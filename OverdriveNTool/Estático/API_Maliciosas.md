# **API Maliciosas**
---

Joder esto va a ser super divertido (>o<), tanto en el archivo Pecheck.txt como en la carpeta API se recogen
todas las llamadas a la API de Windows obtenidas con la herramienta Pecheck, aquí voy a indicar cuales de esas
son de uso común por los desarrolladores de malware y una breve descripción de que hacen, pero esto no quiere decir que estén siendo usadas con fines maliciosos. **¿EMPESAMOS? >:)**

[Conclusiones al final]

---

| File Name | Hash SHA-256 |
| --------- | ------------ |
| OverdriveNTool.exe |ad1c82b1ba7df42a977f0c18275e368174187977882e82b1deec6d33c55357a3 |

---

**[ advapi32.dll.AdjustTokenPrivileges ]**

- Se utiliza para permitir o bloquear determinados privilegios específicos de acceso. Las muestras de malware
que se inyectan en proceso suelen llamar a esta función para obtener permisos adicionales.

**[ gdi32.dll.BitBlt ]**

- Realiza una transferencia bit-block del color correspondiente a un rectángulo de píxeles del dispositivo fuente especificado.
Utilizada para copiar datos gráficos de un dispositivo a otro. Hay muestras de spyware que utilizan esta función para realizar
capturas de pantalla. Esta función suele ser añadida por el compilador como parte del codigo de la librería.

**[ user32.dll.CallNextHookEx ]**

- Utilizada por código que está hookeándose en un evento establecido por SetWindowsHookEx. Llama al siguiente hook en la cadena.
Analiza la funcion que la llama para determinar el propósito del hook establecido por SetWindowsHookEx.

**[ Crypt32.dll.CertOpenSystemStore ]**

- Utilizada para acceder a los certificados almacenados en el sistema local.

**[ ole32.dll.CoCreateInstance ]**

- Crea un objeto COM. Los objetos COM permiten una gran cantidad de opciones. El identificador de clase CLSID indica que el
fichero contiene código que implementa el objeto COM.

**[ kernel32.dll.CreateFile ]**

- Crea un nuevo fichero o abre uno existente.

**[ kernel32.dll.CreateMutex ]**

- Crea un objeto de exclusión mutua (mutex) que puede ser utilizado por el malware para asegurar que solo una única instancia del 
malware se está ejecutando en un momento dado. Es frecuente que el nombre del mutex esté hardcodeado en el malware, lo que puede
ser usado como IOC (Indicador de compromiso).

**[ kernel32.dll.CreateProcess ]**

- Crea y lanza un nuevo proceso.

**[ kernel32.dll.DeviceIoControl ]**

- Envía un mensaje de control del espacio usuario al driver del dispositivo. Suele ser usada por los malware dev por ser un modo
fácil y flexible de pasar información entre el espacio usuario y el espacio del kernel. Para entender mejor esto debemos entender
que Windows en este caso, separa en memoria una parte para su uso del kernel y otra para el usuario, estas no deben mezclarse.

**[ kernel32.dll.FindFirstFile/indNextFile ]**

- Utilizada para buscar a través de un directorio y listar el sistema de ficheros.

**[ kernel32.dll.FindResource ]**

- Utilizada para encontrar un recurso en un ejecutable o librería cargada. En ocasiones, el malware emplea recursos para
almacenar cadenas, información de configuración u otros ficheros maliciosos. Como hemos detectado esta función debemos comprobar
la sección .rsrc en la cabecera PE del malware, esto lo podremos ver con IDA Pro, Ghidra, PEStudio o PeiD... ya lo veremos más
adelante. (;

![ima](https://github.com/5kidRo0t/Malware_Analysis/assets/137389975/fa1cf48c-0e90-4e24-933d-b5d4dad3ef4a)

**[ user32.dll.FindWindow ]**

- Busca una ventana abierta en el escritorio. En ocasiones, esta función se utiliza como técnica anti-debuggin para detectar
la presencia de un debugger, de hecho podemos encontrar la función IsDebuggerPresent en la carpeta API/kernel32.txt y Pecheck.txt
esto es un claro indicativo de que tenemos presentes técnicas anti-debugging que dificultan el análisis.

**[ user32.dll.GetDC ]**

- Devuelve un handle al contexto de un dispositivo (DC, Device Context) para una ventana o toda la pantalla. Las variantes de 
spyware que capturan pantallas suelen utilizar esta función.

**[ user32.dll.GetForegroundWindow ]**

- Devuelve un handle a la ventana que se encuentra en primer plano del escritorio. Utilizada habitualmente por los keyloggers
para determinar qué ventana está introduciendo el usuario las pulsaciones del teclado.

**[ user32.dll.GetKeyState ]**

- Utilizada por keyloggers para obtener el estado de una tecla concreta del teclado.

**[ kernel32.dll.GetModuleFileName ]**

- Devuelve el nombre de fichero de un módulo que está cargado en el proceso actual. El malware puede emplear esta función
para modificar o copiar ficheros en el proceso actualmente en ejecución.

**[ kernel32.dll.GetModuleHandle ]**

-  Utilizada para obtener un handle a un módulo ya cargado. El malware puede utilizar esta función para localizar y modificar
código de un módulo cargado o buscar una buena ubicación donde inyectar código.

**[ kernel32.dll.GetProcAddress ]**

- Recupera la dirección de una función de una librería cargada en memoria. Utilizada para importar funciones de otras 
librerías además de funciones importadas en la cabecera del fichero PE.

**[ kernel32.dll.GetSystemDefaultUILanguage ]**

- Recupera el idioma establecido por defecto en la configuración del sistema. Habitualmente usado por malware que afecta 
únicamente a sistemas de determinadas regiones, o para customizar las pantallas y los nombres de fichero.

**[ kernel32.dll.GetTickCount ]**

- Recupera el número de milisegundos desde que el sistema se inició (hasta un total de 49,7 días). Esta función puede ser
utilizada para capturar información del reloj del sistema y empleada como técnica anti-debugging. Suele ser añadida por el
compilador y se incluye en muchos ejecutables, por lo tanto no es un buen indicador de que el fichero sea malicioso, pero lo que llevamos visto pues... (/>.<)/

**[ kernel32.dll.GetVersionEx ]**

- Devuelve información de que versión de Mocosoft Windows se está ejecutando. Puede ser empleada para obtener información del
sistema o para seleccionar entre diferentes offsets de estructuras no documentadas que han cambiado entre diferentes versiones
de Mocosoft Windows.

**[ kernel32.dll.GetWindowsDirectory ]**

- Devuelve la ruta del directorio del sistema operativo (Ej. C:\Windows). Esta función puede ser utilizada por el malware
para determinar en qué directorio instalar programas maliciosos adicionales.

**[ kernel32.dll.IsDebuggerPresent ]**

- Esta es bastante obvia, lo que hace es comprobar si el proceso actual está siendo depurado, es usado como técnica 
anti-debugging y está presente en muchos ejecutables, es normal que los desarrolladores quieran proteger su software por lo 
tanto esta y otras técnicas son de uso común en software legítimo.

**[ kernel32.dll.IsWow64Process ]**

- Utilizada por un proceso de 32 bits para determinar si se está ejecutando en un sistema operativo de 64 bits.

**[ kernel32.dll.LoadLibrary ]**

- Carga una librería en un proceso que pudiera no haberse cargado cuando el programa comenzó. Importada por casi todos los 
programas Win32.

**[ kernel32.dll.LoadResource ]**

- Carga un recurso de un fichero PE en memoria. El malware en ocasiones utiliza recursos para almacenar cadenas, información
de configuración u otros ficheros maliciosos.

**[ user32.dll.MapVirtualKey ]**

-  Mapea un código de tecla virtual en el valor de un carácter o un código de escaneo. También puede mapear un código de escaneo
en una tecla virtual. Utilizada habitualmente por keyloggers.

**[ ole32.dll.OleInitialize ]**

- Utilizada para inicializar la librería COM. Los programas que utilizan objetos COM deben llamar a esta función antes de llamar
a cualquier función COM.

**[ kernel32.dll.OpenMutex ]**

- Abre un handle a un mutex, lo que puede ser utilizado por el malware para asegurar que solo una única instancia de dicho
malware se encuentra en ejecución en ese momento en el sistema.

**[ kernel32.dll.OpenProcess ]**

- Abre un handle a otro proceso en ejecución en el sistema. Este handle puede ser utilizado para leer y escribir en la memoria
del otro proceso o para inyectar código dentro del otro proceso.

**[ kernel32.dll.OutputDebugString ]**

- Devuelve una cadena a un depurador si se le ha incorporado uno. Usado como anti-debugging.

**[ kernel32.dll.QueryPerformanceCounter ]**

- Utilizada para recuperar el valor del contador de rendimiento basado en hardware. Puede ser usada para recopilar información
del reloj del sistema como parte de una técnica anti-debugging.

**[ advapi32.dll.RegOpenKeyEx ]**

- Abre un handle a una clave de registro para su lectura y edición. Las claves de registro son en ocasiones escritas por el
malware para lograr persistencia en el sistema.

**[ kernel32.dll.ResumeThread ]**

- Resume un hilo previamente suspendido. Se usa como parte de diferentes técnicas de inyección.

**[ kernel32.dll.SetFileTime ]**

- Modifica los MAC times de un fichero. Esto puede ser usado por el malware para ocultar su actividad.

**[ user32.dll.SetWindowsHookEx ]**

- Establece una función hook que pueda ser llamada siempre que se llame a un determinado evento. Frecuentemente usada por 
keyloggers y spyware, esta función también permite fácilmente cargar una librería dentro de todos los procesos GUI del sistema.

**[ shell32.dll.ShellExecute ]**

- Utilizada para ejecutar otro programa.

**[ kernel32.dll.VirtualAlloc ]**

- Rutina para asignación de memoria que permite asignar memoria en un proceso remoto. Puede ser usada para inyectar código.

**[ kernel32.dll.VirtualProtect ]**

- Cambia la protección de una región de memoria. El malware puede emplear esta función para cambiar una sección de solo lectura de la memoria de un ejecutable.

**[ kernel32.dll.WideCharToMultiByte ]**

- Utilizada para convertir una cadena Unicode en una cadena ASCII.

---

# Conclusión:

- Si esto no es un spyware entonces es un puto milagro, si habéis leído todas las funciones aquí presentes podemos ver claramente un comportamiento típico de un spyware, es raro que usen **[winhttp.dll]** que es lo que parece usarse para el envío de información entre la víctima y el atacante, digo es raro porque generalmente se usa **[wininet.dll]** debido a que ofrece un espectro más amplio en un contexto comunicativo. 


No he explicado aquí ninguna función dentro de winhttp para no extenderme más y porque realmente es innecesario, con que sepamos que las funciones que ya hemos visto y detectado en el primer análisis estático del ejecutable en su conjunto muestran un claro comportamiento de un spyware y que **winhttp** es usado para el envío de información es más que suficiente, además que sepamos que **winhttp** está presente es un adelantamiento a que cuando hagamos el análisis dinámico del comportamiento en red debemos centrarnos en el protocolo http. Me sorprende gratamente que la persona que me indicó este contenido para su análisis **--digo persona, si estás leyendo y quieres que te mencione aquí tú dimelo, gracias por esto (;--** pues me mencionó que esto podía ser un *Keylogger* o *Spyware*, yo me decanto por *spyware*, obviamente porque muchas funciones que usa, un *keylogger* no las necesita para nada.


Con esto podríamos decir que hemos finalizado casi el análisis estático porque las funciones usadas por una aplicación arrojan muchísima información, iré subiendo más cositas sobre el análisis estático porque aún nos queda ver los **.bin** pero ya no creo que vaya a ser tan explicativo, mas que nada porque por ejemplo los strings, pues joder son cadenas de texto que se han obtenido de la muestra por lo tanto no tengo nada que explicar ahí. *Arigatooo (~-~')*
