typedef unsigned char   undefined;

typedef unsigned long long    GUID;
typedef unsigned int    ImageBaseOffset32;
typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned long long    qword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef short    wchar_t;
typedef unsigned short    word;
typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion;

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct {
    dword OffsetToDirectory;
    dword DataIsDirectory;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion {
    dword OffsetToData;
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;
};

typedef unsigned short    wchar16;
typedef ushort WORD;

typedef uchar BYTE;

typedef int BOOL;

typedef ulong DWORD;

typedef BYTE * PBYTE;

typedef struct IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

struct IMAGE_DATA_DIRECTORY {
    ImageBaseOffset32 VirtualAddress;
    dword Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
    word Magic;
    byte MajorLinkerVersion;
    byte MinorLinkerVersion;
    dword SizeOfCode;
    dword SizeOfInitializedData;
    dword SizeOfUninitializedData;
    ImageBaseOffset32 AddressOfEntryPoint;
    ImageBaseOffset32 BaseOfCode;
    ImageBaseOffset32 BaseOfData;
    pointer32 ImageBase;
    dword SectionAlignment;
    dword FileAlignment;
    word MajorOperatingSystemVersion;
    word MinorOperatingSystemVersion;
    word MajorImageVersion;
    word MinorImageVersion;
    word MajorSubsystemVersion;
    word MinorSubsystemVersion;
    dword Win32VersionValue;
    dword SizeOfImage;
    dword SizeOfHeaders;
    dword CheckSum;
    word Subsystem;
    word DllCharacteristics;
    dword SizeOfStackReserve;
    dword SizeOfStackCommit;
    dword SizeOfHeapReserve;
    dword SizeOfHeapCommit;
    dword LoaderFlags;
    dword NumberOfRvaAndSizes;
    struct IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef struct Var Var, *PVar;

struct Var {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct {
    dword NameOffset;
    dword NameIsString;
};

typedef struct IMAGE_FILE_HEADER IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

struct IMAGE_FILE_HEADER {
    word Machine; // 332
    word NumberOfSections;
    dword TimeDateStamp;
    dword PointerToSymbolTable;
    dword NumberOfSymbols;
    word SizeOfOptionalHeader;
    word Characteristics;
};

typedef struct IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

struct IMAGE_NT_HEADERS32 {
    char Signature[4];
    struct IMAGE_FILE_HEADER FileHeader;
    struct IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

typedef struct StringFileInfo StringFileInfo, *PStringFileInfo;

struct StringFileInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion;

union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion {
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;
    dword Name;
    word Id;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion NameUnion;
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion DirectoryUnion;
};

typedef struct StringTable StringTable, *PStringTable;

struct StringTable {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_SECTION_HEADER IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef union Misc Misc, *PMisc;

typedef enum SectionFlags {
    IMAGE_SCN_TYPE_NO_PAD=8,
    IMAGE_SCN_RESERVED_0001=16,
    IMAGE_SCN_CNT_CODE=32,
    IMAGE_SCN_CNT_INITIALIZED_DATA=64,
    IMAGE_SCN_CNT_UNINITIALIZED_DATA=128,
    IMAGE_SCN_LNK_OTHER=256,
    IMAGE_SCN_LNK_INFO=512,
    IMAGE_SCN_RESERVED_0040=1024,
    IMAGE_SCN_LNK_REMOVE=2048,
    IMAGE_SCN_LNK_COMDAT=4096,
    IMAGE_SCN_GPREL=32768,
    IMAGE_SCN_MEM_16BIT=131072,
    IMAGE_SCN_MEM_PURGEABLE=131072,
    IMAGE_SCN_MEM_LOCKED=262144,
    IMAGE_SCN_MEM_PRELOAD=524288,
    IMAGE_SCN_ALIGN_1BYTES=1048576,
    IMAGE_SCN_ALIGN_2BYTES=2097152,
    IMAGE_SCN_ALIGN_4BYTES=3145728,
    IMAGE_SCN_ALIGN_8BYTES=4194304,
    IMAGE_SCN_ALIGN_16BYTES=5242880,
    IMAGE_SCN_ALIGN_32BYTES=6291456,
    IMAGE_SCN_ALIGN_64BYTES=7340032,
    IMAGE_SCN_ALIGN_128BYTES=8388608,
    IMAGE_SCN_ALIGN_256BYTES=9437184,
    IMAGE_SCN_ALIGN_512BYTES=10485760,
    IMAGE_SCN_ALIGN_1024BYTES=11534336,
    IMAGE_SCN_ALIGN_2048BYTES=12582912,
    IMAGE_SCN_ALIGN_4096BYTES=13631488,
    IMAGE_SCN_ALIGN_8192BYTES=14680064,
    IMAGE_SCN_LNK_NRELOC_OVFL=16777216,
    IMAGE_SCN_MEM_DISCARDABLE=33554432,
    IMAGE_SCN_MEM_NOT_CACHED=67108864,
    IMAGE_SCN_MEM_NOT_PAGED=134217728,
    IMAGE_SCN_MEM_SHARED=268435456,
    IMAGE_SCN_MEM_EXECUTE=536870912,
    IMAGE_SCN_MEM_READ=1073741824,
    IMAGE_SCN_MEM_WRITE=2147483648
} SectionFlags;

union Misc {
    dword PhysicalAddress;
    dword VirtualSize;
};

struct IMAGE_SECTION_HEADER {
    char Name[8];
    union Misc Misc;
    ImageBaseOffset32 VirtualAddress;
    dword SizeOfRawData;
    dword PointerToRawData;
    dword PointerToRelocations;
    dword PointerToLinenumbers;
    word NumberOfRelocations;
    word NumberOfLinenumbers;
    enum SectionFlags Characteristics;
};

typedef struct VS_VERSION_INFO VS_VERSION_INFO, *PVS_VERSION_INFO;

struct VS_VERSION_INFO {
    word StructLength;
    word ValueLength;
    word StructType;
    wchar16 Info[16];
    byte Padding[2];
    dword Signature;
    word StructVersion[2];
    word FileVersion[4];
    word ProductVersion[4];
    dword FileFlagsMask[2];
    dword FileFlags;
    dword FileOS;
    dword FileType;
    dword FileSubtype;
    dword FileTimestamp;
};

typedef struct IMAGE_RESOURCE_DATA_ENTRY IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

struct IMAGE_RESOURCE_DATA_ENTRY {
    dword OffsetToData;
    dword Size;
    dword CodePage;
    dword Reserved;
};

typedef struct IMAGE_COR20_HEADER IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

typedef struct CLI_METADATA_DIRECTORY CLI_METADATA_DIRECTORY, *PCLI_METADATA_DIRECTORY;

typedef enum COR20_Flags {
    COMIMAGE_FLAGS_ILONLY=1,
    COMIMAGE_FLAGS_32BITREQUIRED=2,
    COMIMAGE_FLAGS_IL_LIBRARY=4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED=8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT=16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA=65536
} COR20_Flags;

typedef struct IMAGE_DATA_DIRECTORY.conflict IMAGE_DATA_DIRECTORY.conflict, *PIMAGE_DATA_DIRECTORY.conflict;

struct CLI_METADATA_DIRECTORY {
    dword VirtualAddress;
    dword Size;
};

struct IMAGE_DATA_DIRECTORY.conflict {
    dword VirtualAddress;
    dword Size;
};

struct IMAGE_COR20_HEADER {
    dword cb; // Size of the structure
    word MajorRuntimeVersion; // Version of CLR Runtime
    word MinorRuntimeVersion;
    struct CLI_METADATA_DIRECTORY MetaData; // RVA and size of MetaData
    enum COR20_Flags Flags;
    dword EntryPointToken; // This is a metadata token if not a valid RVA
    struct IMAGE_DATA_DIRECTORY.conflict Resources;
    struct IMAGE_DATA_DIRECTORY.conflict StrongNameSignature;
    struct IMAGE_DATA_DIRECTORY.conflict CodeManagerTable; // Should be 0
    struct IMAGE_DATA_DIRECTORY.conflict VTableFixups;
    struct IMAGE_DATA_DIRECTORY.conflict ExportAddressTableJumps; // Should be 0
    struct IMAGE_DATA_DIRECTORY.conflict ManagedNativeHeader; // 0 unless this is a native image
};

typedef struct VarFileInfo VarFileInfo, *PVarFileInfo;

struct VarFileInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_RESOURCE_DIRECTORY IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

struct IMAGE_RESOURCE_DIRECTORY {
    dword Characteristics;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    word NumberOfNamedEntries;
    word NumberOfIdEntries;
};

typedef struct StringInfo StringInfo, *PStringInfo;

struct StringInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct CLI_METADATA_HEADER CLI_METADATA_HEADER, *PCLI_METADATA_HEADER;

typedef struct CLI_Stream_Header_#~ CLI_Stream_Header_#~, *PCLI_Stream_Header_#~;

typedef struct CLI_Stream_Header_#Strings CLI_Stream_Header_#Strings, *PCLI_Stream_Header_#Strings;

typedef struct CLI_Stream_Header_#US CLI_Stream_Header_#US, *PCLI_Stream_Header_#US;

typedef struct CLI_Stream_Header_#GUID CLI_Stream_Header_#GUID, *PCLI_Stream_Header_#GUID;

typedef struct CLI_Stream_Header_#Blob CLI_Stream_Header_#Blob, *PCLI_Stream_Header_#Blob;

struct CLI_Stream_Header_#Blob {
    dword offset;
    dword size;
    char name[8];
};

struct CLI_Stream_Header_#GUID {
    dword offset;
    dword size;
    char name[8];
};

struct CLI_Stream_Header_#~ {
    dword offset;
    dword size;
    char name[4];
};

struct CLI_Stream_Header_#US {
    dword offset;
    dword size;
    char name[4];
};

struct CLI_Stream_Header_#Strings {
    dword offset;
    dword size;
    char name[12];
};

struct CLI_METADATA_HEADER {
    dword Signature; // must be 0x424a5342
    word MajorVersion;
    word MinorVersion;
    dword Reserved; // should be 0
    dword VersionLength;
    char Version[12];
    word Flags; // should be 0
    word StreamsCount; // number of stream headers to follow
    struct CLI_Stream_Header_#~ #~;
    struct CLI_Stream_Header_#Strings #Strings;
    struct CLI_Stream_Header_#US #US;
    struct CLI_Stream_Header_#GUID #GUID;
    struct CLI_Stream_Header_#Blob #Blob;
};

typedef struct ELEMENT_TYPE_MVAR_2818646 ELEMENT_TYPE_MVAR_2818646, *PELEMENT_TYPE_MVAR_2818646;

typedef enum TypeCode {
    ELEMENT_TYPE_END=0,
    ELEMENT_TYPE_VOID=1,
    ELEMENT_TYPE_BOOLEAN=2,
    ELEMENT_TYPE_CHAR=3,
    ELEMENT_TYPE_I1=4,
    ELEMENT_TYPE_U1=5,
    ELEMENT_TYPE_I2=6,
    ELEMENT_TYPE_U2=7,
    ELEMENT_TYPE_I4=8,
    ELEMENT_TYPE_U4=9,
    ELEMENT_TYPE_I8=10,
    ELEMENT_TYPE_U8=11,
    ELEMENT_TYPE_R4=12,
    ELEMENT_TYPE_R8=13,
    ELEMENT_TYPE_STRING=14,
    ELEMENT_TYPE_PTR=15,
    ELEMENT_TYPE_BYREF=16,
    ELEMENT_TYPE_VALUETYPE=17,
    ELEMENT_TYPE_CLASS=18,
    ELEMENT_TYPE_VAR=19,
    ELEMENT_TYPE_ARRAY=20,
    ELEMENT_TYPE_GENERICINST=21,
    ELEMENT_TYPE_TYPEDBYREF=22,
    ELEMENT_TYPE_I=24,
    ELEMENT_TYPE_U=25,
    ELEMENT_TYPE_FNPTR=27,
    ELEMENT_TYPE_OBJECT=28,
    ELEMENT_TYPE_SZARRAY=29,
    ELEMENT_TYPE_MVAR=30,
    ELEMENT_TYPE_CMOD_REQD=31,
    ELEMENT_TYPE_CMOD_OPT=32,
    ELEMENT_TYPE_INTERNAL=33,
    ELEMENT_TYPE_MAX=34,
    ELEMENT_TYPE_MODIFIER=64,
    ELEMENT_TYPE_SENTINEL=65,
    ELEMENT_TYPE_PINNED=69
} TypeCode;

struct ELEMENT_TYPE_MVAR_2818646 {
    enum TypeCode ELEMENT_TYPE_MVAR;
    byte number;
};

typedef struct ELEMENT_TYPE_MVAR_2818648 ELEMENT_TYPE_MVAR_2818648, *PELEMENT_TYPE_MVAR_2818648;

struct ELEMENT_TYPE_MVAR_2818648 {
    enum TypeCode ELEMENT_TYPE_MVAR;
    byte number;
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@345a5c5] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@345a5c5], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@345a5c5];

typedef struct ELEMENT_TYPE_MVAR_2818480 ELEMENT_TYPE_MVAR_2818480, *PELEMENT_TYPE_MVAR_2818480;

struct ELEMENT_TYPE_MVAR_2818480 {
    enum TypeCode ELEMENT_TYPE_MVAR;
    byte number;
};

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@345a5c5] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    byte Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    struct ELEMENT_TYPE_MVAR_2818480 Type; // Generic Type
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@39356338] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@39356338], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@39356338];

typedef struct ELEMENT_TYPE_VAR_2819424 ELEMENT_TYPE_VAR_2819424, *PELEMENT_TYPE_VAR_2819424;

struct ELEMENT_TYPE_VAR_2819424 {
    enum TypeCode ELEMENT_TYPE_VAR;
    byte number;
};

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@39356338] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    word Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    struct ELEMENT_TYPE_VAR_2819424 Type; // Generic Type
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@25a0b410, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@3eca0102] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@25a0b410, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@3eca0102], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@25a0b410, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@3eca0102];

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@25a0b410, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@3eca0102] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    word Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    enum TypeCode Type; // Generic Type
    enum TypeCode Type; // Generic Type
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57f9890f, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@53b4e966] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57f9890f, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@53b4e966], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57f9890f, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@53b4e966];

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57f9890f, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@53b4e966] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    word Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    enum TypeCode Type; // Generic Type
    enum TypeCode Type; // Generic Type
};

typedef struct ELEMENT_TYPE_MVAR_2819468 ELEMENT_TYPE_MVAR_2819468, *PELEMENT_TYPE_MVAR_2819468;

struct ELEMENT_TYPE_MVAR_2819468 {
    enum TypeCode ELEMENT_TYPE_MVAR;
    byte number;
};

typedef struct ELEMENT_TYPE_MVAR_2819470 ELEMENT_TYPE_MVAR_2819470, *PELEMENT_TYPE_MVAR_2819470;

struct ELEMENT_TYPE_MVAR_2819470 {
    enum TypeCode ELEMENT_TYPE_MVAR;
    byte number;
};

typedef struct ValueType.conflict ValueType.conflict, *PValueType.conflict;

struct ValueType.conflict {
    enum TypeCode ValueType; // ValueType
    byte TypeDefOrRefEncoded; // TypeRef: Row 0x8
};

typedef struct ELEMENT_TYPE_VAR_2819414 ELEMENT_TYPE_VAR_2819414, *PELEMENT_TYPE_VAR_2819414;

struct ELEMENT_TYPE_VAR_2819414 {
    enum TypeCode ELEMENT_TYPE_VAR;
    byte number;
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@16d98edb, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1589564] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@16d98edb, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1589564], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@16d98edb, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1589564];

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@16d98edb, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1589564] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    word Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    enum TypeCode Type; // Generic Type
    enum TypeCode Type; // Generic Type
};

typedef struct ELEMENT_TYPE_VAR_2819701 ELEMENT_TYPE_VAR_2819701, *PELEMENT_TYPE_VAR_2819701;

struct ELEMENT_TYPE_VAR_2819701 {
    enum TypeCode ELEMENT_TYPE_VAR;
    byte number;
};

typedef struct SzArray SzArray, *PSzArray;

typedef struct Class Class, *PClass;

struct Class {
    enum TypeCode Class; // Class
    byte Type; // TypeDefOrRefOrSpecEncoded
};

struct SzArray {
    enum TypeCode TypeCode; // SzArray
    struct Class Type; // type or void
};

typedef struct SzArray.conflict SzArray.conflict, *PSzArray.conflict;

struct SzArray.conflict {
    enum TypeCode TypeCode; // SzArray
    enum TypeCode Type; // type or void
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@351edfb4] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@351edfb4], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@351edfb4];

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@351edfb4] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    word Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    enum TypeCode Type; // Generic Type
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@1e2bf101] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@1e2bf101], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@1e2bf101];

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@1e2bf101] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    byte Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    struct ELEMENT_TYPE_MVAR_2819468 Type; // Generic Type
};

typedef struct ELEMENT_TYPE_VAR_2819436 ELEMENT_TYPE_VAR_2819436, *PELEMENT_TYPE_VAR_2819436;

struct ELEMENT_TYPE_VAR_2819436 {
    enum TypeCode ELEMENT_TYPE_VAR;
    byte number;
};

typedef struct ELEMENT_TYPE_VAR_2819832 ELEMENT_TYPE_VAR_2819832, *PELEMENT_TYPE_VAR_2819832;

struct ELEMENT_TYPE_VAR_2819832 {
    enum TypeCode ELEMENT_TYPE_VAR;
    byte number;
};

typedef struct Class.conflict Class.conflict, *PClass.conflict;

struct Class.conflict {
    enum TypeCode Class; // Class
    word Type; // TypeDefOrRefOrSpecEncoded
};

typedef struct ValueType.conflict19 ValueType.conflict19, *PValueType.conflict19;

struct ValueType.conflict19 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x5a
};

typedef struct ValueType.conflict18 ValueType.conflict18, *PValueType.conflict18;

struct ValueType.conflict18 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x56
};

typedef struct ValueType.conflict15 ValueType.conflict15, *PValueType.conflict15;

struct ValueType.conflict15 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x4c
};

typedef struct ValueType.conflict14 ValueType.conflict14, *PValueType.conflict14;

struct ValueType.conflict14 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x49
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1e91580b, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@529aa229] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1e91580b, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@529aa229], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1e91580b, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@529aa229];

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1e91580b, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@529aa229] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    word Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    enum TypeCode Type; // Generic Type
    enum TypeCode Type; // Generic Type
};

typedef struct ValueType.conflict17 ValueType.conflict17, *PValueType.conflict17;

struct ValueType.conflict17 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x50
};

typedef struct ValueType.conflict16 ValueType.conflict16, *PValueType.conflict16;

struct ValueType.conflict16 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x4e
};

typedef struct ValueType.conflict7 ValueType.conflict7, *PValueType.conflict7;

struct ValueType.conflict7 {
    enum TypeCode ValueType; // ValueType
    byte TypeDefOrRefEncoded; // TypeRef: Row 0x1b
};

typedef struct ValueType.conflict11 ValueType.conflict11, *PValueType.conflict11;

struct ValueType.conflict11 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x2c
};

typedef struct ValueType.conflict8 ValueType.conflict8, *PValueType.conflict8;

struct ValueType.conflict8 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x23
};

typedef struct ValueType.conflict10 ValueType.conflict10, *PValueType.conflict10;

struct ValueType.conflict10 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x27
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@7138774e] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@7138774e], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@7138774e];

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@7138774e] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    word Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    enum TypeCode Type; // Generic Type
};

typedef struct ValueType.conflict5 ValueType.conflict5, *PValueType.conflict5;

struct ValueType.conflict5 {
    enum TypeCode ValueType; // ValueType
    byte TypeDefOrRefEncoded; // TypeRef: Row 0x19
};

typedef struct ValueType.conflict13 ValueType.conflict13, *PValueType.conflict13;

struct ValueType.conflict13 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x3a
};

typedef struct ValueType.conflict6 ValueType.conflict6, *PValueType.conflict6;

struct ValueType.conflict6 {
    enum TypeCode ValueType; // ValueType
    byte TypeDefOrRefEncoded; // TypeRef: Row 0x1a
};

typedef struct ValueType.conflict12 ValueType.conflict12, *PValueType.conflict12;

struct ValueType.conflict12 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x2f
};

typedef struct ValueType.conflict9 ValueType.conflict9, *PValueType.conflict9;

struct ValueType.conflict9 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x26
};

typedef struct ValueType.conflict3 ValueType.conflict3, *PValueType.conflict3;

struct ValueType.conflict3 {
    enum TypeCode ValueType; // ValueType
    byte TypeDefOrRefEncoded; // TypeRef: Row 0xc
};

typedef struct ValueType ValueType, *PValueType;

struct ValueType {
    enum TypeCode ValueType; // ValueType
    byte TypeDefOrRefEncoded; // TypeDef: Row 0x7
};

typedef struct ValueType.conflict4 ValueType.conflict4, *PValueType.conflict4;

struct ValueType.conflict4 {
    enum TypeCode ValueType; // ValueType
    byte TypeDefOrRefEncoded; // TypeRef: Row 0xe
};

typedef struct ValueType.conflict1 ValueType.conflict1, *PValueType.conflict1;

struct ValueType.conflict1 {
    enum TypeCode ValueType; // ValueType
    byte TypeDefOrRefEncoded; // TypeRef: Row 0x9
};

typedef struct ValueType.conflict2 ValueType.conflict2, *PValueType.conflict2;

struct ValueType.conflict2 {
    enum TypeCode ValueType; // ValueType
    byte TypeDefOrRefEncoded; // TypeRef: Row 0xa
};

typedef struct ELEMENT_TYPE_VAR_2819855 ELEMENT_TYPE_VAR_2819855, *PELEMENT_TYPE_VAR_2819855;

struct ELEMENT_TYPE_VAR_2819855 {
    enum TypeCode ELEMENT_TYPE_VAR;
    byte number;
};

typedef struct ELEMENT_TYPE_VAR_2819698 ELEMENT_TYPE_VAR_2819698, *PELEMENT_TYPE_VAR_2819698;

struct ELEMENT_TYPE_VAR_2819698 {
    enum TypeCode ELEMENT_TYPE_VAR;
    byte number;
};

typedef struct ELEMENT_TYPE_VAR_2819853 ELEMENT_TYPE_VAR_2819853, *PELEMENT_TYPE_VAR_2819853;

struct ELEMENT_TYPE_VAR_2819853 {
    enum TypeCode ELEMENT_TYPE_VAR;
    byte number;
};

typedef struct ValueType.conflict22 ValueType.conflict22, *PValueType.conflict22;

struct ValueType.conflict22 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x70
};

typedef struct ValueType.conflict21 ValueType.conflict21, *PValueType.conflict21;

struct ValueType.conflict21 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x6d
};

typedef struct ValueType.conflict24 ValueType.conflict24, *PValueType.conflict24;

struct ValueType.conflict24 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x79
};

typedef struct ValueType.conflict23 ValueType.conflict23, *PValueType.conflict23;

struct ValueType.conflict23 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x73
};

typedef struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57cbb605] GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57cbb605], *PGenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57cbb605];

struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57cbb605] {
    enum TypeCode GenericInst; // GenericInst
    enum TypeCode ClassOrValueType; // Class or ValueType
    word Type; // TypeDefOrRefOrSpecEncoded
    byte GenArgCount; // Number of generics to follow
    enum TypeCode Type; // Generic Type
};

typedef struct ValueType.conflict20 ValueType.conflict20, *PValueType.conflict20;

struct ValueType.conflict20 {
    enum TypeCode ValueType; // ValueType
    word TypeDefOrRefEncoded; // TypeRef: Row 0x61
};

typedef struct SzArray.conflict1 SzArray.conflict1, *PSzArray.conflict1;

struct SzArray.conflict1 {
    enum TypeCode TypeCode; // SzArray
    struct Class.conflict Type; // type or void
};

typedef struct Blob_ConstantSig_435 Blob_ConstantSig_435, *PBlob_ConstantSig_435;

typedef struct ConstantSig_435 ConstantSig_435, *PConstantSig_435;

struct ConstantSig_435 {
    dword ELEMENT_TYPE_I4;
};

struct Blob_ConstantSig_435 {
    byte Size; // coded integer - blob size
    struct ConstantSig_435 ConstantSig; // Data stored in a constant
};

typedef struct Blob_Generic_423 Blob_Generic_423, *PBlob_Generic_423;

struct Blob_Generic_423 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_662 Blob_Generic_662, *PBlob_Generic_662;

struct Blob_Generic_662 {
    byte Size; // coded integer - blob size
    byte Generic[31]; // Undefined blob contents
};

typedef struct Blob_Generic_1352 Blob_Generic_1352, *PBlob_Generic_1352;

struct Blob_Generic_1352 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1115 Blob_Generic_1115, *PBlob_Generic_1115;

struct Blob_Generic_1115 {
    byte Size; // coded integer - blob size
    byte Generic[9]; // Undefined blob contents
};

typedef struct Blob_Generic_1358 Blob_Generic_1358, *PBlob_Generic_1358;

struct Blob_Generic_1358 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct CustomAttrib_1628 CustomAttrib_1628, *PCustomAttrib_1628;

struct CustomAttrib_1628 {
    word PROLOG; // Magic (0x0001)
    word NumNamed; // Number of NamedArgs to follow
    byte FieldOrProp; // PROPERTY
    byte FieldOrPropType; // ELEMENT_TYPE_BOOLEAN
    byte PackedLen;
    char FieldOrPropName[23];
};

typedef struct Blob_Generic_429 Blob_Generic_429, *PBlob_Generic_429;

struct Blob_Generic_429 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_FieldSig_32 Blob_FieldSig_32, *PBlob_FieldSig_32;

typedef struct FieldSig_32 FieldSig_32, *PFieldSig_32;

typedef struct Type_2818334 Type_2818334, *PType_2818334;

struct Type_2818334 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct FieldSig_32 {
    byte FIELD; // Magic (0x06)
    struct Type_2818334 ELEMENT_TYPE_I4;
};

struct Blob_FieldSig_32 {
    byte Size; // coded integer - blob size
    struct FieldSig_32 FieldSig; // Type information for Field
};

typedef struct Blob_ConstantSig_440 Blob_ConstantSig_440, *PBlob_ConstantSig_440;

typedef struct ConstantSig_440 ConstantSig_440, *PConstantSig_440;

struct ConstantSig_440 {
    dword ELEMENT_TYPE_I4;
};

struct Blob_ConstantSig_440 {
    byte Size; // coded integer - blob size
    struct ConstantSig_440 ConstantSig; // Data stored in a constant
};

typedef struct Blob_ConstantSig_445 Blob_ConstantSig_445, *PBlob_ConstantSig_445;

typedef struct ConstantSig_445 ConstantSig_445, *PConstantSig_445;

struct ConstantSig_445 {
    dword ELEMENT_TYPE_I4;
};

struct Blob_ConstantSig_445 {
    byte Size; // coded integer - blob size
    struct ConstantSig_445 ConstantSig; // Data stored in a constant
};

typedef struct Blob_CustomAttrib_1726 Blob_CustomAttrib_1726, *PBlob_CustomAttrib_1726;

typedef struct CustomAttrib_1726 CustomAttrib_1726, *PCustomAttrib_1726;

struct CustomAttrib_1726 {
    word PROLOG; // Magic (0x0001)
    byte FixedArg_0; // Elem (ELEMENT_TYPE_BOOLEAN)
    word NumNamed; // Number of NamedArgs to follow
};

struct Blob_CustomAttrib_1726 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_1726 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_Generic_412 Blob_Generic_412, *PBlob_Generic_412;

struct Blob_Generic_412 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_1363 Blob_Generic_1363, *PBlob_Generic_1363;

struct Blob_Generic_1363 {
    byte Size; // coded integer - blob size
    byte Generic[9]; // Undefined blob contents
};

typedef struct Blob_Generic_10 Blob_Generic_10, *PBlob_Generic_10;

struct Blob_Generic_10 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_416 Blob_Generic_416, *PBlob_Generic_416;

struct Blob_Generic_416 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_657 Blob_Generic_657, *PBlob_Generic_657;

struct Blob_Generic_657 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_1125 Blob_Generic_1125, *PBlob_Generic_1125;

struct Blob_Generic_1125 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct CustomAttrib_1619 CustomAttrib_1619, *PCustomAttrib_1619;

struct CustomAttrib_1619 {
    word PROLOG; // Magic (0x0001)
    dword FixedArg_0; // Elem (ELEMENT_TYPE_I4)
    word NumNamed; // Number of NamedArgs to follow
};

typedef struct Blob_Generic_19 Blob_Generic_19, *PBlob_Generic_19;

struct Blob_Generic_19 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1196 Blob_MethodRefSig_1196, *PBlob_MethodRefSig_1196;

typedef struct MethodRefSig_1196 MethodRefSig_1196, *PMethodRefSig_1196;

typedef struct Type_2819499 Type_2819499, *PType_2819499;

typedef struct Type_2819500 Type_2819500, *PType_2819500;

struct Type_2819500 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819499 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct MethodRefSig_1196 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819499 RetType;
    struct Type_2819500 Param0;
};

struct Blob_MethodRefSig_1196 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1196 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_FieldSig_40 Blob_FieldSig_40, *PBlob_FieldSig_40;

typedef struct FieldSig_40 FieldSig_40, *PFieldSig_40;

typedef struct Type_2818342 Type_2818342, *PType_2818342;

struct Type_2818342 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct FieldSig_40 {
    byte FIELD; // Magic (0x06)
    struct Type_2818342 ELEMENT_TYPE_CLASS;
};

struct Blob_FieldSig_40 {
    byte Size; // coded integer - blob size
    struct FieldSig_40 FieldSig; // Type information for Field
};

typedef struct Blob_FieldSig_44 Blob_FieldSig_44, *PBlob_FieldSig_44;

typedef struct FieldSig_44 FieldSig_44, *PFieldSig_44;

typedef struct Type_2818346 Type_2818346, *PType_2818346;

struct Type_2818346 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct FieldSig_44 {
    byte FIELD; // Magic (0x06)
    struct Type_2818346 ELEMENT_TYPE_CLASS;
};

struct Blob_FieldSig_44 {
    byte Size; // coded integer - blob size
    struct FieldSig_44 FieldSig; // Type information for Field
};

typedef struct Blob_Generic_1373 Blob_Generic_1373, *PBlob_Generic_1373;

struct Blob_Generic_1373 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_1132 Blob_Generic_1132, *PBlob_Generic_1132;

struct Blob_Generic_1132 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_1137 Blob_Generic_1137, *PBlob_Generic_1137;

struct Blob_Generic_1137 {
    byte Size; // coded integer - blob size
    byte Generic[9]; // Undefined blob contents
};

typedef struct Blob_Generic_402 Blob_Generic_402, *PBlob_Generic_402;

struct Blob_Generic_402 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_1378 Blob_Generic_1378, *PBlob_Generic_1378;

struct Blob_Generic_1378 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_407 Blob_Generic_407, *PBlob_Generic_407;

struct Blob_Generic_407 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_649 Blob_Generic_649, *PBlob_Generic_649;

struct Blob_Generic_649 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1184 Blob_MethodRefSig_1184, *PBlob_MethodRefSig_1184;

typedef struct MethodRefSig_1184 MethodRefSig_1184, *PMethodRefSig_1184;

typedef struct Type_2819487 Type_2819487, *PType_2819487;

typedef struct Type_2819488 Type_2819488, *PType_2819488;

typedef struct Type_2819489 Type_2819489, *PType_2819489;

struct Type_2819489 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819488 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819487 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct MethodRefSig_1184 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819487 RetType;
    struct Type_2819488 Param0;
    struct Type_2819489 Param1;
};

struct Blob_MethodRefSig_1184 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1184 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_LocalVarSig_547 Blob_LocalVarSig_547, *PBlob_LocalVarSig_547;

typedef struct LocalVarSig_547 LocalVarSig_547, *PLocalVarSig_547;

typedef struct Type_2818850 Type_2818850, *PType_2818850;

typedef struct Type_2818852 Type_2818852, *PType_2818852;

typedef struct Type_2818855 Type_2818855, *PType_2818855;

typedef struct Type_2818858 Type_2818858, *PType_2818858;

typedef struct Type_2818861 Type_2818861, *PType_2818861;

typedef struct Type_2818864 Type_2818864, *PType_2818864;

typedef struct Type_2818867 Type_2818867, *PType_2818867;

typedef struct Type_2818869 Type_2818869, *PType_2818869;

typedef struct Type_2818870 Type_2818870, *PType_2818870;

struct Type_2818869 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818870 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818850 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818864 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818867 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818858 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818861 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818855 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818852 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct LocalVarSig_547 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2818850 Type;
    struct Type_2818852 Type;
    struct Type_2818855 Type;
    struct Type_2818858 Type;
    struct Type_2818861 Type;
    struct Type_2818864 Type;
    struct Type_2818867 Type;
    struct Type_2818869 Type;
    struct Type_2818870 Type;
};

struct Blob_LocalVarSig_547 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_547 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_CustomAttrib_1705 Blob_CustomAttrib_1705, *PBlob_CustomAttrib_1705;

typedef struct CustomAttrib_1705 CustomAttrib_1705, *PCustomAttrib_1705;

struct CustomAttrib_1705 {
    word PROLOG; // Magic (0x0001)
    byte PackedLen;
    char FixedArg_0[15];
    word NumNamed; // Number of NamedArgs to follow
};

struct Blob_CustomAttrib_1705 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_1705 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_Generic_630 Blob_Generic_630, *PBlob_Generic_630;

struct Blob_Generic_630 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1385 Blob_Generic_1385, *PBlob_Generic_1385;

struct Blob_Generic_1385 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_Generic_636 Blob_Generic_636, *PBlob_Generic_636;

struct Blob_Generic_636 {
    byte Size; // coded integer - blob size
    byte Generic[12]; // Undefined blob contents
};

typedef struct Blob_Generic_1147 Blob_Generic_1147, *PBlob_Generic_1147;

struct Blob_Generic_1147 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_40 Blob_Generic_40, *PBlob_Generic_40;

struct Blob_Generic_40 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_221 Blob_Generic_221, *PBlob_Generic_221;

struct Blob_Generic_221 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_463 Blob_Generic_463, *PBlob_Generic_463;

struct Blob_Generic_463 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_1393 Blob_Generic_1393, *PBlob_Generic_1393;

struct Blob_Generic_1393 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_293 Blob_MethodRefSig_293, *PBlob_MethodRefSig_293;

typedef struct MethodRefSig_293 MethodRefSig_293, *PMethodRefSig_293;

typedef struct Type_2818596 Type_2818596, *PType_2818596;

struct Type_2818596 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct MethodRefSig_293 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818596 RetType;
};

struct Blob_MethodRefSig_293 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_293 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1153 Blob_Generic_1153, *PBlob_Generic_1153;

struct Blob_Generic_1153 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_48 Blob_Generic_48, *PBlob_Generic_48;

struct Blob_Generic_48 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1158 Blob_MethodRefSig_1158, *PBlob_MethodRefSig_1158;

typedef struct MethodRefSig_1158 MethodRefSig_1158, *PMethodRefSig_1158;

typedef struct Type_2819462 Type_2819462, *PType_2819462;

typedef struct Type_2819463 Type_2819463, *PType_2819463;

typedef struct Type_2819469 Type_2819469, *PType_2819469;

struct Type_2819462 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct Type_2819469 {
    struct ELEMENT_TYPE_MVAR_2819470 ELEMENT_TYPE_MVAR;
};

struct Type_2819463 {
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@1e2bf101] ELEMENT_TYPE_GENERICINST;
};

struct MethodRefSig_1158 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte GenParamCount; // Number of generic paramameters for the method
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819462 RetType;
    struct Type_2819463 Param0;
    struct Type_2819469 Param1;
};

struct Blob_MethodRefSig_1158 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1158 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_227 Blob_Generic_227, *PBlob_Generic_227;

struct Blob_Generic_227 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_1093 Blob_LocalVarSig_1093, *PBlob_LocalVarSig_1093;

typedef struct LocalVarSig_1093 LocalVarSig_1093, *PLocalVarSig_1093;

typedef struct Type_2819396 Type_2819396, *PType_2819396;

struct Type_2819396 {
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@7138774e] ELEMENT_TYPE_GENERICINST;
};

struct LocalVarSig_1093 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819396 Type;
};

struct Blob_LocalVarSig_1093 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1093 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_44 Blob_Generic_44, *PBlob_Generic_44;

struct Blob_Generic_44 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_1158 Blob_Generic_1158, *PBlob_Generic_1158;

struct Blob_Generic_1158 {
    byte Size; // coded integer - blob size
    byte Generic[12]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_297 Blob_MethodRefSig_297, *PBlob_MethodRefSig_297;

typedef struct MethodRefSig_297 MethodRefSig_297, *PMethodRefSig_297;

typedef struct Type_2818600 Type_2818600, *PType_2818600;

struct Type_2818600 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_297 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818600 RetType;
};

struct Blob_MethodRefSig_297 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_297 MethodRefSig; // Type info for imported method return and params
};

typedef struct CustomAttrib_1666 CustomAttrib_1666, *PCustomAttrib_1666;

struct CustomAttrib_1666 {
    word PROLOG; // Magic (0x0001)
    byte PackedLen;
    char FixedArg_0[7];
    word NumNamed; // Number of NamedArgs to follow
};

typedef struct Blob_Generic_694 Blob_Generic_694, *PBlob_Generic_694;

struct Blob_Generic_694 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_450 Blob_Generic_450, *PBlob_Generic_450;

struct Blob_Generic_450 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_1089 Blob_LocalVarSig_1089, *PBlob_LocalVarSig_1089;

typedef struct LocalVarSig_1089 LocalVarSig_1089, *PLocalVarSig_1089;

typedef struct Type_2819392 Type_2819392, *PType_2819392;

struct Type_2819392 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct LocalVarSig_1089 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819392 Type;
};

struct Blob_LocalVarSig_1089 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1089 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_57 Blob_Generic_57, *PBlob_Generic_57;

struct Blob_Generic_57 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_53 Blob_Generic_53, *PBlob_Generic_53;

struct Blob_Generic_53 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_459 Blob_Generic_459, *PBlob_Generic_459;

struct Blob_Generic_459 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1147 Blob_MethodRefSig_1147, *PBlob_MethodRefSig_1147;

typedef struct MethodRefSig_1147 MethodRefSig_1147, *PMethodRefSig_1147;

typedef struct Type_2819450 Type_2819450, *PType_2819450;

typedef struct Type_2819452 Type_2819452, *PType_2819452;

struct Type_2819450 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2819452 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_1147 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819450 RetType;
    struct Type_2819452 Param0;
};

struct Blob_MethodRefSig_1147 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1147 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_215 Blob_Generic_215, *PBlob_Generic_215;

struct Blob_Generic_215 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1153 Blob_MethodRefSig_1153, *PBlob_MethodRefSig_1153;

typedef struct MethodRefSig_1153 MethodRefSig_1153, *PMethodRefSig_1153;

typedef struct Type_2819456 Type_2819456, *PType_2819456;

typedef struct Type_2819457 Type_2819457, *PType_2819457;

struct Type_2819457 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819456 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_1153 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819456 RetType;
    struct Type_2819457 Param0;
};

struct Blob_MethodRefSig_1153 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1153 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_287 Blob_MethodRefSig_287, *PBlob_MethodRefSig_287;

typedef struct MethodRefSig_287 MethodRefSig_287, *PMethodRefSig_287;

typedef struct Type_2818590 Type_2818590, *PType_2818590;

struct Type_2818590 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_287 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818590 RetType;
};

struct Blob_MethodRefSig_287 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_287 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1393 Blob_MethodRefSig_1393, *PBlob_MethodRefSig_1393;

typedef struct MethodRefSig_1393 MethodRefSig_1393, *PMethodRefSig_1393;

typedef struct Type_2819696 Type_2819696, *PType_2819696;

typedef struct Type_2819697 Type_2819697, *PType_2819697;

typedef struct Type_2819699 Type_2819699, *PType_2819699;

struct Type_2819699 {
    enum TypeCode ELEMENT_TYPE_BYREF; // By Reference
    struct ELEMENT_TYPE_VAR_2819701 ELEMENT_TYPE_VAR;
};

struct Type_2819697 {
    struct ELEMENT_TYPE_VAR_2819698 ELEMENT_TYPE_VAR;
};

struct Type_2819696 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct MethodRefSig_1393 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819696 RetType;
    struct Type_2819697 Param0;
    struct Type_2819699 Param1;
};

struct Blob_MethodRefSig_1393 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1393 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_440 Blob_Generic_440, *PBlob_Generic_440;

struct Blob_Generic_440 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_1171 Blob_Generic_1171, *PBlob_Generic_1171;

struct Blob_Generic_1171 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_1079 Blob_LocalVarSig_1079, *PBlob_LocalVarSig_1079;

typedef struct LocalVarSig_1079 LocalVarSig_1079, *PLocalVarSig_1079;

typedef struct Type_2819382 Type_2819382, *PType_2819382;

struct Type_2819382 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct LocalVarSig_1079 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819382 Type;
};

struct Blob_LocalVarSig_1079 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1079 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_445 Blob_Generic_445, *PBlob_Generic_445;

struct Blob_Generic_445 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_272 Blob_MethodRefSig_272, *PBlob_MethodRefSig_272;

typedef struct MethodRefSig_272 MethodRefSig_272, *PMethodRefSig_272;

typedef struct Type_2818575 Type_2818575, *PType_2818575;

typedef struct Type_2818576 Type_2818576, *PType_2818576;

struct Type_2818575 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818576 {
    struct ValueType.conflict10 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_272 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818575 RetType;
    struct Type_2818576 Param0;
};

struct Blob_MethodRefSig_272 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_272 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1175 Blob_Generic_1175, *PBlob_Generic_1175;

struct Blob_Generic_1175 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_279 Blob_MethodRefSig_279, *PBlob_MethodRefSig_279;

typedef struct MethodRefSig_279 MethodRefSig_279, *PMethodRefSig_279;

typedef struct Type_2818582 Type_2818582, *PType_2818582;

typedef struct Type_2818583 Type_2818583, *PType_2818583;

typedef struct Type_2818584 Type_2818584, *PType_2818584;

typedef struct Type_2818585 Type_2818585, *PType_2818585;

typedef struct Type_2818586 Type_2818586, *PType_2818586;

struct Type_2818583 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818585 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818582 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818586 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818584 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_279 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818582 RetType;
    struct Type_2818583 Param0;
    struct Type_2818584 Param1;
    struct Type_2818585 Param2;
    struct Type_2818586 Param3;
};

struct Blob_MethodRefSig_279 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_279 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_209 Blob_Generic_209, *PBlob_Generic_209;

struct Blob_Generic_209 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_28 Blob_Generic_28, *PBlob_Generic_28;

struct Blob_Generic_28 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_1065 Blob_LocalVarSig_1065, *PBlob_LocalVarSig_1065;

typedef struct LocalVarSig_1065 LocalVarSig_1065, *PLocalVarSig_1065;

typedef struct Type_2819368 Type_2819368, *PType_2819368;

struct Type_2819368 {
    enum TypeCode ELEMENT_TYPE_CHAR;
};

struct LocalVarSig_1065 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819368 Type;
};

struct Blob_LocalVarSig_1065 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1065 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_1184 Blob_Generic_1184, *PBlob_Generic_1184;

struct Blob_Generic_1184 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_35 Blob_Generic_35, *PBlob_Generic_35;

struct Blob_Generic_35 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_32 Blob_Generic_32, *PBlob_Generic_32;

struct Blob_Generic_32 {
    byte Size; // coded integer - blob size
    byte Generic[2]; // Undefined blob contents
};

typedef struct Blob_Generic_435 Blob_Generic_435, *PBlob_Generic_435;

struct Blob_Generic_435 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1373 Blob_MethodRefSig_1373, *PBlob_MethodRefSig_1373;

typedef struct MethodRefSig_1373 MethodRefSig_1373, *PMethodRefSig_1373;

typedef struct Type_2819676 Type_2819676, *PType_2819676;

typedef struct Type_2819677 Type_2819677, *PType_2819677;

struct Type_2819677 {
    enum TypeCode ELEMENT_TYPE_I8;
};

struct Type_2819676 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_1373 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819676 RetType;
    struct Type_2819677 Param0;
};

struct Blob_MethodRefSig_1373 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1373 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1132 Blob_MethodRefSig_1132, *PBlob_MethodRefSig_1132;

typedef struct MethodRefSig_1132 MethodRefSig_1132, *PMethodRefSig_1132;

typedef struct Type_2819435 Type_2819435, *PType_2819435;

struct Type_2819435 {
    struct ELEMENT_TYPE_VAR_2819436 ELEMENT_TYPE_VAR;
};

struct MethodRefSig_1132 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819435 RetType;
};

struct Blob_MethodRefSig_1132 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1132 MethodRefSig; // Type info for imported method return and params
};

typedef struct CustomAttrib_1679 CustomAttrib_1679, *PCustomAttrib_1679;

struct CustomAttrib_1679 {
    word PROLOG; // Magic (0x0001)
    byte PackedLen;
    char FixedArg_0[14];
    word NumNamed; // Number of NamedArgs to follow
};

typedef struct Blob_MethodRefSig_263 Blob_MethodRefSig_263, *PBlob_MethodRefSig_263;

typedef struct MethodRefSig_263 MethodRefSig_263, *PMethodRefSig_263;

typedef struct Type_2818566 Type_2818566, *PType_2818566;

typedef struct Type_2818567 Type_2818567, *PType_2818567;

typedef struct Type_2818568 Type_2818568, *PType_2818568;

typedef struct Type_2818569 Type_2818569, *PType_2818569;

struct Type_2818566 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818568 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct Type_2818567 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818569 {
    struct ValueType.conflict9 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_263 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818566 RetType;
    struct Type_2818567 Param0;
    struct Type_2818568 Param1;
    struct Type_2818569 Param2;
};

struct Blob_MethodRefSig_263 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_263 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_FieldSig_407 Blob_FieldSig_407, *PBlob_FieldSig_407;

typedef struct FieldSig_407 FieldSig_407, *PFieldSig_407;

typedef struct Type_2818709 Type_2818709, *PType_2818709;

struct Type_2818709 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct FieldSig_407 {
    byte FIELD; // Magic (0x06)
    struct Type_2818709 ELEMENT_TYPE_CLASS;
};

struct Blob_FieldSig_407 {
    byte Size; // coded integer - blob size
    struct FieldSig_407 FieldSig; // Type information for Field
};

typedef struct Blob_Generic_1512 Blob_Generic_1512, *PBlob_Generic_1512;

struct Blob_Generic_1512 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1115 Blob_MethodRefSig_1115, *PBlob_MethodRefSig_1115;

typedef struct MethodRefSig_1115 MethodRefSig_1115, *PMethodRefSig_1115;

typedef struct Type_2819418 Type_2819418, *PType_2819418;

struct Type_2819418 {
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@39356338] ELEMENT_TYPE_GENERICINST;
};

struct MethodRefSig_1115 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819418 RetType;
};

struct Blob_MethodRefSig_1115 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1115 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_820 Blob_Generic_820, *PBlob_Generic_820;

struct Blob_Generic_820 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1358 Blob_MethodRefSig_1358, *PBlob_MethodRefSig_1358;

typedef struct MethodRefSig_1358 MethodRefSig_1358, *PMethodRefSig_1358;

typedef struct Type_2819661 Type_2819661, *PType_2819661;

typedef struct Type_2819662 Type_2819662, *PType_2819662;

struct Type_2819661 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct Type_2819662 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_1358 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819661 RetType;
    struct Type_2819662 Param0;
};

struct Blob_MethodRefSig_1358 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1358 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1363 Blob_MethodRefSig_1363, *PBlob_MethodRefSig_1363;

typedef struct MethodRefSig_1363 MethodRefSig_1363, *PMethodRefSig_1363;

typedef struct Type_2819666 Type_2819666, *PType_2819666;

typedef struct Type_2819667 Type_2819667, *PType_2819667;

typedef struct Type_2819670 Type_2819670, *PType_2819670;

struct Type_2819666 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2819670 {
    struct ValueType.conflict22 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2819667 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_1363 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819666 RetType;
    struct Type_2819667 Param0;
    struct Type_2819670 Param1;
};

struct Blob_MethodRefSig_1363 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1363 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_824 Blob_Generic_824, *PBlob_Generic_824;

struct Blob_Generic_824 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_1519 Blob_Generic_1519, *PBlob_Generic_1519;

struct Blob_Generic_1519 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_Generic_829 Blob_Generic_829, *PBlob_Generic_829;

struct Blob_Generic_829 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodDefSig_28 Blob_MethodDefSig_28, *PBlob_MethodDefSig_28;

typedef struct MethodDefSig_28 MethodDefSig_28, *PMethodDefSig_28;

typedef struct Type_2818331 Type_2818331, *PType_2818331;

struct Type_2818331 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodDefSig_28 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte Count; // Number of parameter types to follow RetType
    struct Type_2818331 RetType;
};

struct Blob_MethodDefSig_28 {
    byte Size; // coded integer - blob size
    struct MethodDefSig_28 MethodDefSig; // Type info for method return and params
};

typedef struct Blob_MethodRefSig_916 Blob_MethodRefSig_916, *PBlob_MethodRefSig_916;

typedef struct MethodRefSig_916 MethodRefSig_916, *PMethodRefSig_916;

typedef struct Type_2819219 Type_2819219, *PType_2819219;

typedef struct Type_2819222 Type_2819222, *PType_2819222;

struct Type_2819222 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819219 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_916 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819219 RetType;
    struct Type_2819222 Param0;
};

struct Blob_MethodRefSig_916 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_916 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1109 Blob_MethodRefSig_1109, *PBlob_MethodRefSig_1109;

typedef struct MethodRefSig_1109 MethodRefSig_1109, *PMethodRefSig_1109;

typedef struct Type_2819412 Type_2819412, *PType_2819412;

typedef struct Type_2819413 Type_2819413, *PType_2819413;

struct Type_2819413 {
    struct ELEMENT_TYPE_VAR_2819414 ELEMENT_TYPE_VAR;
};

struct Type_2819412 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_1109 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819412 RetType;
    struct Type_2819413 Param0;
};

struct Blob_MethodRefSig_1109 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1109 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1527 Blob_Generic_1527, *PBlob_Generic_1527;

struct Blob_Generic_1527 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1352 Blob_MethodRefSig_1352, *PBlob_MethodRefSig_1352;

typedef struct MethodRefSig_1352 MethodRefSig_1352, *PMethodRefSig_1352;

typedef struct Type_2819655 Type_2819655, *PType_2819655;

struct Type_2819655 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_1352 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819655 RetType;
};

struct Blob_MethodRefSig_1352 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1352 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_814 Blob_Generic_814, *PBlob_Generic_814;

struct Blob_Generic_814 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_708 Blob_LocalVarSig_708, *PBlob_LocalVarSig_708;

typedef struct LocalVarSig_708 LocalVarSig_708, *PLocalVarSig_708;

typedef struct Type_2819011 Type_2819011, *PType_2819011;

typedef struct Type_2819014 Type_2819014, *PType_2819014;

struct Type_2819014 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2819011 {
    struct SzArray ELEMENT_TYPE_SZARRAY;
};

struct LocalVarSig_708 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819011 Type;
    struct Type_2819014 Type;
};

struct Blob_LocalVarSig_708 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_708 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_MethodRefSig_1579 Blob_MethodRefSig_1579, *PBlob_MethodRefSig_1579;

typedef struct MethodRefSig_1579 MethodRefSig_1579, *PMethodRefSig_1579;

typedef struct Type_2819882 Type_2819882, *PType_2819882;

typedef struct Type_2819883 Type_2819883, *PType_2819883;

struct Type_2819882 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2819883 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_1579 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819882 RetType;
    struct Type_2819883 Param0;
};

struct Blob_MethodRefSig_1579 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1579 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1533 Blob_Generic_1533, *PBlob_Generic_1533;

struct Blob_Generic_1533 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_CustomAttrib_1774 Blob_CustomAttrib_1774, *PBlob_CustomAttrib_1774;

typedef struct CustomAttrib_1774 CustomAttrib_1774, *PCustomAttrib_1774;

struct CustomAttrib_1774 {
    word PROLOG; // Magic (0x0001)
    byte PackedLen;
    char FixedArg_0[9];
    word NumNamed; // Number of NamedArgs to follow
};

struct Blob_CustomAttrib_1774 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_1774 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_Generic_1774 Blob_Generic_1774, *PBlob_Generic_1774;

struct Blob_Generic_1774 {
    byte Size; // coded integer - blob size
    byte Generic[14]; // Undefined blob contents
};

typedef struct Blob_Generic_805 Blob_Generic_805, *PBlob_Generic_805;

struct Blob_Generic_805 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_1538 Blob_Generic_1538, *PBlob_Generic_1538;

struct Blob_Generic_1538 {
    byte Size; // coded integer - blob size
    byte Generic[9]; // Undefined blob contents
};

typedef struct Blob_CustomAttrib_1789 Blob_CustomAttrib_1789, *PBlob_CustomAttrib_1789;

typedef struct CustomAttrib_1789 CustomAttrib_1789, *PCustomAttrib_1789;

struct CustomAttrib_1789 {
    word PROLOG; // Magic (0x0001)
    byte PackedLen;
    char FixedArg_0[5];
    word NumNamed; // Number of NamedArgs to follow
};

struct Blob_CustomAttrib_1789 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_1789 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_Generic_1303 Blob_Generic_1303, *PBlob_Generic_1303;

struct Blob_Generic_1303 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1548 Blob_Generic_1548, *PBlob_Generic_1548;

struct Blob_Generic_1548 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1572 Blob_MethodRefSig_1572, *PBlob_MethodRefSig_1572;

typedef struct MethodRefSig_1572 MethodRefSig_1572, *PMethodRefSig_1572;

typedef struct Type_2819875 Type_2819875, *PType_2819875;

typedef struct Type_2819876 Type_2819876, *PType_2819876;

typedef struct Type_2819878 Type_2819878, *PType_2819878;

struct Type_2819876 {
    enum TypeCode ELEMENT_TYPE_BYREF; // By Reference
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2819875 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2819878 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct MethodRefSig_1572 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819875 RetType;
    struct Type_2819876 Param0;
    struct Type_2819878 Param1;
};

struct Blob_MethodRefSig_1572 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1572 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1789 Blob_Generic_1789, *PBlob_Generic_1789;

struct Blob_Generic_1789 {
    byte Size; // coded integer - blob size
    byte Generic[10]; // Undefined blob contents
};

typedef struct Blob_Generic_1309 Blob_Generic_1309, *PBlob_Generic_1309;

struct Blob_Generic_1309 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_1556 Blob_Generic_1556, *PBlob_Generic_1556;

struct Blob_Generic_1556 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodDefSig_62 Blob_MethodDefSig_62, *PBlob_MethodDefSig_62;

typedef struct MethodDefSig_62 MethodDefSig_62, *PMethodDefSig_62;

typedef struct Type_2818365 Type_2818365, *PType_2818365;

struct Type_2818365 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodDefSig_62 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte Count; // Number of parameter types to follow RetType
    struct Type_2818365 RetType;
};

struct Blob_MethodDefSig_62 {
    byte Size; // coded integer - blob size
    struct MethodDefSig_62 MethodDefSig; // Type info for method return and params
};

typedef struct Blob_Generic_622 Blob_Generic_622, *PBlob_Generic_622;

struct Blob_Generic_622 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1556 Blob_MethodRefSig_1556, *PBlob_MethodRefSig_1556;

typedef struct MethodRefSig_1556 MethodRefSig_1556, *PMethodRefSig_1556;

typedef struct Type_2819859 Type_2819859, *PType_2819859;

struct Type_2819859 {
    struct ValueType.conflict23 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_1556 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819859 RetType;
};

struct Blob_MethodRefSig_1556 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1556 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1318 Blob_Generic_1318, *PBlob_Generic_1318;

struct Blob_Generic_1318 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodDefSig_66 Blob_MethodDefSig_66, *PBlob_MethodDefSig_66;

typedef struct MethodDefSig_66 MethodDefSig_66, *PMethodDefSig_66;

typedef struct Type_2818369 Type_2818369, *PType_2818369;

typedef struct Type_2818370 Type_2818370, *PType_2818370;

typedef struct Type_2818371 Type_2818371, *PType_2818371;

struct Type_2818371 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct Type_2818370 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct Type_2818369 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodDefSig_66 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte Count; // Number of parameter types to follow RetType
    struct Type_2818369 RetType;
    struct Type_2818370 Param0;
    struct Type_2818371 Param1;
};

struct Blob_MethodDefSig_66 {
    byte Size; // coded integer - blob size
    struct MethodDefSig_66 MethodDefSig; // Type info for method return and params
};

typedef struct Blob_MethodSpecSig_181 Blob_MethodSpecSig_181, *PBlob_MethodSpecSig_181;

typedef struct MethodSpecSig_181 MethodSpecSig_181, *PMethodSpecSig_181;

struct MethodSpecSig_181 {
    byte GENRICINST; // Magic (0x0a)
    byte GenArgCount; // Number of types to follow
    struct Class Type0;
};

struct Blob_MethodSpecSig_181 {
    byte Size; // coded integer - blob size
    struct MethodSpecSig_181 MethodSpecSig; // Specifies a generic method with GenArgCount types
};

typedef struct Blob_LocalVarSig_527 Blob_LocalVarSig_527, *PBlob_LocalVarSig_527;

typedef struct LocalVarSig_527 LocalVarSig_527, *PLocalVarSig_527;

typedef struct Type_2818830 Type_2818830, *PType_2818830;

typedef struct Type_2818832 Type_2818832, *PType_2818832;

typedef struct Type_2818835 Type_2818835, *PType_2818835;

struct Type_2818832 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818830 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818835 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct LocalVarSig_527 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2818830 Type;
    struct Type_2818832 Type;
    struct Type_2818835 Type;
};

struct Blob_LocalVarSig_527 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_527 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_MethodRefSig_1309 Blob_MethodRefSig_1309, *PBlob_MethodRefSig_1309;

typedef struct MethodRefSig_1309 MethodRefSig_1309, *PMethodRefSig_1309;

typedef struct Type_2819612 Type_2819612, *PType_2819612;

typedef struct Type_2819615 Type_2819615, *PType_2819615;

struct Type_2819615 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819612 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_1309 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819612 RetType;
    struct Type_2819615 Param0;
};

struct Blob_MethodRefSig_1309 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1309 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1562 Blob_Generic_1562, *PBlob_Generic_1562;

struct Blob_Generic_1562 {
    byte Size; // coded integer - blob size
    byte Generic[9]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1548 Blob_MethodRefSig_1548, *PBlob_MethodRefSig_1548;

typedef struct MethodRefSig_1548 MethodRefSig_1548, *PMethodRefSig_1548;

typedef struct Type_2819851 Type_2819851, *PType_2819851;

typedef struct Type_2819852 Type_2819852, *PType_2819852;

typedef struct Type_2819854 Type_2819854, *PType_2819854;

struct Type_2819854 {
    struct ELEMENT_TYPE_VAR_2819855 ELEMENT_TYPE_VAR;
};

struct Type_2819852 {
    struct ELEMENT_TYPE_VAR_2819853 ELEMENT_TYPE_VAR;
};

struct Type_2819851 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_1548 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819851 RetType;
    struct Type_2819852 Param0;
    struct Type_2819854 Param1;
};

struct Blob_MethodRefSig_1548 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1548 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1324 Blob_Generic_1324, *PBlob_Generic_1324;

struct Blob_Generic_1324 {
    byte Size; // coded integer - blob size
    byte Generic[9]; // Undefined blob contents
};

typedef struct Blob_MethodDefSig_73 Blob_MethodDefSig_73, *PBlob_MethodDefSig_73;

typedef struct MethodDefSig_73 MethodDefSig_73, *PMethodDefSig_73;

typedef struct Type_2818376 Type_2818376, *PType_2818376;

typedef struct Type_2818377 Type_2818377, *PType_2818377;

struct Type_2818376 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818377 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct MethodDefSig_73 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte Count; // Number of parameter types to follow RetType
    struct Type_2818376 RetType;
    struct Type_2818377 Param0;
};

struct Blob_MethodDefSig_73 {
    byte Size; // coded integer - blob size
    struct MethodDefSig_73 MethodDefSig; // Type info for method return and params
};

typedef struct Blob_MethodRefSig_1303 Blob_MethodRefSig_1303, *PBlob_MethodRefSig_1303;

typedef struct MethodRefSig_1303 MethodRefSig_1303, *PMethodRefSig_1303;

typedef struct Type_2819606 Type_2819606, *PType_2819606;

struct Type_2819606 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_1303 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819606 RetType;
};

struct Blob_MethodRefSig_1303 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1303 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_615 Blob_Generic_615, *PBlob_Generic_615;

struct Blob_Generic_615 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_CustomAttrib_805 Blob_CustomAttrib_805, *PBlob_CustomAttrib_805;

typedef struct CustomAttrib_805 CustomAttrib_805, *PCustomAttrib_805;

struct CustomAttrib_805 {
    word PROLOG; // Magic (0x0001)
    dword FixedArg_0; // Elem (ELEMENT_TYPE_VALUETYPE)
    word NumNamed; // Number of NamedArgs to follow
};

struct Blob_CustomAttrib_805 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_805 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_Generic_841 Blob_Generic_841, *PBlob_Generic_841;

struct Blob_Generic_841 {
    byte Size; // coded integer - blob size
    byte Generic[65]; // Undefined blob contents
};

typedef struct Blob_Generic_1572 Blob_Generic_1572, *PBlob_Generic_1572;

struct Blob_Generic_1572 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1538 Blob_MethodRefSig_1538, *PBlob_MethodRefSig_1538;

typedef struct MethodRefSig_1538 MethodRefSig_1538, *PMethodRefSig_1538;

typedef struct Type_2819841 Type_2819841, *PType_2819841;

typedef struct Type_2819842 Type_2819842, *PType_2819842;

typedef struct Type_2819845 Type_2819845, *PType_2819845;

struct Type_2819845 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819842 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819841 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct MethodRefSig_1538 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819841 RetType;
    struct Type_2819842 Param0;
    struct Type_2819845 Param1;
};

struct Blob_MethodRefSig_1538 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1538 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1533 Blob_MethodRefSig_1533, *PBlob_MethodRefSig_1533;

typedef struct MethodRefSig_1533 MethodRefSig_1533, *PMethodRefSig_1533;

typedef struct Type_2819836 Type_2819836, *PType_2819836;

typedef struct Type_2819837 Type_2819837, *PType_2819837;

struct Type_2819836 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2819837 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct MethodRefSig_1533 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819836 RetType;
    struct Type_2819837 Param0;
};

struct Blob_MethodRefSig_1533 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1533 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_600 Blob_Generic_600, *PBlob_Generic_600;

struct Blob_Generic_600 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_1334 Blob_Generic_1334, *PBlob_Generic_1334;

struct Blob_Generic_1334 {
    byte Size; // coded integer - blob size
    byte Generic[17]; // Undefined blob contents
};

typedef struct Blob_CustomAttrib_1732 Blob_CustomAttrib_1732, *PBlob_CustomAttrib_1732;

typedef struct CustomAttrib_1732 CustomAttrib_1732, *PCustomAttrib_1732;

struct CustomAttrib_1732 {
    word PROLOG; // Magic (0x0001)
    byte PackedLen;
    char FixedArg_0[36];
    word NumNamed; // Number of NamedArgs to follow
};

struct Blob_CustomAttrib_1732 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_1732 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_Generic_1579 Blob_Generic_1579, *PBlob_Generic_1579;

struct Blob_Generic_1579 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodDefSig_48 Blob_MethodDefSig_48, *PBlob_MethodDefSig_48;

typedef struct MethodDefSig_48 MethodDefSig_48, *PMethodDefSig_48;

typedef struct Type_2818351 Type_2818351, *PType_2818351;

struct Type_2818351 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct MethodDefSig_48 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte Count; // Number of parameter types to follow RetType
    struct Type_2818351 RetType;
};

struct Blob_MethodDefSig_48 {
    byte Size; // coded integer - blob size
    struct MethodDefSig_48 MethodDefSig; // Type info for method return and params
};

typedef struct Blob_Generic_609 Blob_Generic_609, *PBlob_Generic_609;

struct Blob_Generic_609 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1527 Blob_MethodRefSig_1527, *PBlob_MethodRefSig_1527;

typedef struct MethodRefSig_1527 MethodRefSig_1527, *PMethodRefSig_1527;

typedef struct Type_2819830 Type_2819830, *PType_2819830;

typedef struct Type_2819831 Type_2819831, *PType_2819831;

struct Type_2819831 {
    struct ELEMENT_TYPE_VAR_2819832 ELEMENT_TYPE_VAR;
};

struct Type_2819830 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct MethodRefSig_1527 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819830 RetType;
    struct Type_2819831 Param0;
};

struct Blob_MethodRefSig_1527 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1527 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1589 Blob_Generic_1589, *PBlob_Generic_1589;

struct Blob_Generic_1589 {
    byte Size; // coded integer - blob size
    byte Generic[14]; // Undefined blob contents
};

typedef struct Blob_Generic_1102 Blob_Generic_1102, *PBlob_Generic_1102;

struct Blob_Generic_1102 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_1586 Blob_Generic_1586, *PBlob_Generic_1586;

struct Blob_Generic_1586 {
    byte Size; // coded integer - blob size
    byte Generic[2]; // Undefined blob contents
};

typedef struct Blob_Generic_1109 Blob_Generic_1109, *PBlob_Generic_1109;

struct Blob_Generic_1109 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_835 Blob_Generic_835, *PBlob_Generic_835;

struct Blob_Generic_835 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_1334 Blob_LocalVarSig_1334, *PBlob_LocalVarSig_1334;

typedef struct LocalVarSig_1334 LocalVarSig_1334, *PLocalVarSig_1334;

typedef struct Type_2819637 Type_2819637, *PType_2819637;

typedef struct Type_2819640 Type_2819640, *PType_2819640;

typedef struct Type_2819643 Type_2819643, *PType_2819643;

typedef struct Type_2819646 Type_2819646, *PType_2819646;

typedef struct Type_2819649 Type_2819649, *PType_2819649;

struct Type_2819637 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819646 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819640 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819649 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819643 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct LocalVarSig_1334 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819637 Type;
    struct Type_2819640 Type;
    struct Type_2819643 Type;
    struct Type_2819646 Type;
    struct Type_2819649 Type;
};

struct Blob_LocalVarSig_1334 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1334 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_MethodRefSig_657 Blob_MethodRefSig_657, *PBlob_MethodRefSig_657;

typedef struct MethodRefSig_657 MethodRefSig_657, *PMethodRefSig_657;

typedef struct Type_2818960 Type_2818960, *PType_2818960;

typedef struct Type_2818961 Type_2818961, *PType_2818961;

struct Type_2818961 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818960 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_657 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818960 RetType;
    struct Type_2818961 Param0;
};

struct Blob_MethodRefSig_657 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_657 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_416 Blob_MethodRefSig_416, *PBlob_MethodRefSig_416;

typedef struct MethodRefSig_416 MethodRefSig_416, *PMethodRefSig_416;

typedef struct Type_2818719 Type_2818719, *PType_2818719;

typedef struct Type_2818720 Type_2818720, *PType_2818720;

struct Type_2818720 {
    struct ValueType.conflict13 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818719 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_416 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818719 RetType;
    struct Type_2818720 Param0;
};

struct Blob_MethodRefSig_416 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_416 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodSpecSig_367 Blob_MethodSpecSig_367, *PBlob_MethodSpecSig_367;

typedef struct MethodSpecSig_367 MethodSpecSig_367, *PMethodSpecSig_367;

struct MethodSpecSig_367 {
    byte GENRICINST; // Magic (0x0a)
    byte GenArgCount; // Number of types to follow
    struct Class.conflict Type0;
};

struct Blob_MethodSpecSig_367 {
    byte Size; // coded integer - blob size
    struct MethodSpecSig_367 MethodSpecSig; // Specifies a generic method with GenArgCount types
};

typedef struct Blob_MethodSpecSig_1171 Blob_MethodSpecSig_1171, *PBlob_MethodSpecSig_1171;

typedef struct MethodSpecSig_1171 MethodSpecSig_1171, *PMethodSpecSig_1171;

struct MethodSpecSig_1171 {
    byte GENRICINST; // Magic (0x0a)
    byte GenArgCount; // Number of types to follow
    enum TypeCode Type0;
};

struct Blob_MethodSpecSig_1171 {
    byte Size; // coded integer - blob size
    struct MethodSpecSig_1171 MethodSpecSig; // Specifies a generic method with GenArgCount types
};

typedef struct Blob_MethodRefSig_649 Blob_MethodRefSig_649, *PBlob_MethodRefSig_649;

typedef struct MethodRefSig_649 MethodRefSig_649, *PMethodRefSig_649;

typedef struct Type_2818952 Type_2818952, *PType_2818952;

typedef struct Type_2818953 Type_2818953, *PType_2818953;

typedef struct Type_2818955 Type_2818955, *PType_2818955;

typedef struct Type_2818956 Type_2818956, *PType_2818956;

struct Type_2818955 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818953 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818952 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818956 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct MethodRefSig_649 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818952 RetType;
    struct Type_2818953 Param0;
    struct Type_2818955 Param1;
    struct Type_2818956 Param2;
};

struct Blob_MethodRefSig_649 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_649 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_402 Blob_MethodRefSig_402, *PBlob_MethodRefSig_402;

typedef struct MethodRefSig_402 MethodRefSig_402, *PMethodRefSig_402;

typedef struct Type_2818705 Type_2818705, *PType_2818705;

typedef struct Type_2818706 Type_2818706, *PType_2818706;

struct Type_2818705 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818706 {
    enum TypeCode ELEMENT_TYPE_R8;
};

struct MethodRefSig_402 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818705 RetType;
    struct Type_2818706 Param0;
};

struct Blob_MethodRefSig_402 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_402 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_630 Blob_MethodRefSig_630, *PBlob_MethodRefSig_630;

typedef struct MethodRefSig_630 MethodRefSig_630, *PMethodRefSig_630;

typedef struct Type_2818933 Type_2818933, *PType_2818933;

struct Type_2818933 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_630 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818933 RetType;
};

struct Blob_MethodRefSig_630 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_630 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_636 Blob_MethodRefSig_636, *PBlob_MethodRefSig_636;

typedef struct MethodRefSig_636 MethodRefSig_636, *PMethodRefSig_636;

typedef struct Type_2818939 Type_2818939, *PType_2818939;

typedef struct Type_2818940 Type_2818940, *PType_2818940;

typedef struct Type_2818943 Type_2818943, *PType_2818943;

typedef struct Type_2818946 Type_2818946, *PType_2818946;

struct Type_2818943 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818940 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818946 {
    struct ValueType.conflict17 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818939 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_636 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818939 RetType;
    struct Type_2818940 Param0;
    struct Type_2818943 Param1;
    struct Type_2818946 Param2;
};

struct Blob_MethodRefSig_636 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_636 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_LocalVarSig_1318 Blob_LocalVarSig_1318, *PBlob_LocalVarSig_1318;

typedef struct LocalVarSig_1318 LocalVarSig_1318, *PLocalVarSig_1318;

typedef struct Type_2819621 Type_2819621, *PType_2819621;

typedef struct Type_2819623 Type_2819623, *PType_2819623;

struct Type_2819621 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2819623 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct LocalVarSig_1318 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819621 Type;
    struct Type_2819623 Type;
};

struct Blob_LocalVarSig_1318 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1318 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_MethodSpecSig_349 Blob_MethodSpecSig_349, *PBlob_MethodSpecSig_349;

typedef struct MethodSpecSig_349 MethodSpecSig_349, *PMethodSpecSig_349;

struct MethodSpecSig_349 {
    byte GENRICINST; // Magic (0x0a)
    byte GenArgCount; // Number of types to follow
    struct Class Type0;
};

struct Blob_MethodSpecSig_349 {
    byte Size; // coded integer - blob size
    struct MethodSpecSig_349 MethodSpecSig; // Specifies a generic method with GenArgCount types
};

typedef struct Blob_Generic_1705 Blob_Generic_1705, *PBlob_Generic_1705;

struct Blob_Generic_1705 {
    byte Size; // coded integer - blob size
    byte Generic[20]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_622 Blob_MethodRefSig_622, *PBlob_MethodRefSig_622;

typedef struct MethodRefSig_622 MethodRefSig_622, *PMethodRefSig_622;

typedef struct Type_2818925 Type_2818925, *PType_2818925;

typedef struct Type_2818926 Type_2818926, *PType_2818926;

typedef struct Type_2818928 Type_2818928, *PType_2818928;

typedef struct Type_2818929 Type_2818929, *PType_2818929;

struct Type_2818925 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818928 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818926 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818929 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct MethodRefSig_622 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818925 RetType;
    struct Type_2818926 Param0;
    struct Type_2818928 Param1;
    struct Type_2818929 Param2;
};

struct Blob_MethodRefSig_622 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_622 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_PropertySig_925 Blob_PropertySig_925, *PBlob_PropertySig_925;

typedef struct PropertySig_925 PropertySig_925, *PPropertySig_925;

typedef struct Type_2819228 Type_2819228, *PType_2819228;

struct Type_2819228 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct PropertySig_925 {
    byte PROPERTY; // Magic (0x08) optionalled OR'd with HASTHIS (0x20)
    byte Count; // Number of params to follow RetType
    struct Type_2819228 RetType; // Return type
};

struct Blob_PropertySig_925 {
    byte Size; // coded integer - blob size
    struct PropertySig_925 PropertySig; // Contains signature for properties. Gives params for getters/setters.
};

typedef struct Blob_MethodRefSig_609 Blob_MethodRefSig_609, *PBlob_MethodRefSig_609;

typedef struct MethodRefSig_609 MethodRefSig_609, *PMethodRefSig_609;

typedef struct Type_2818912 Type_2818912, *PType_2818912;

typedef struct Type_2818914 Type_2818914, *PType_2818914;

struct Type_2818912 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818914 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct MethodRefSig_609 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818912 RetType;
    struct Type_2818914 Param0;
};

struct Blob_MethodRefSig_609 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_609 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_907 Blob_Generic_907, *PBlob_Generic_907;

struct Blob_Generic_907 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_615 Blob_MethodRefSig_615, *PBlob_MethodRefSig_615;

typedef struct MethodRefSig_615 MethodRefSig_615, *PMethodRefSig_615;

typedef struct Type_2818918 Type_2818918, *PType_2818918;

typedef struct Type_2818919 Type_2818919, *PType_2818919;

struct Type_2818918 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818919 {
    struct ValueType.conflict16 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_615 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818918 RetType;
    struct Type_2818919 Param0;
};

struct Blob_MethodRefSig_615 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_615 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_TypeSpec_783 Blob_TypeSpec_783, *PBlob_TypeSpec_783;

struct Blob_TypeSpec_783 {
    byte Size; // coded integer - blob size
    struct SzArray.conflict TypeSpec; // Describes a type.
};

typedef struct Blob_Generic_1726 Blob_Generic_1726, *PBlob_Generic_1726;

struct Blob_Generic_1726 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_600 Blob_MethodRefSig_600, *PBlob_MethodRefSig_600;

typedef struct MethodRefSig_600 MethodRefSig_600, *PMethodRefSig_600;

typedef struct Type_2818903 Type_2818903, *PType_2818903;

typedef struct Type_2818904 Type_2818904, *PType_2818904;

typedef struct Type_2818906 Type_2818906, *PType_2818906;

typedef struct Type_2818908 Type_2818908, *PType_2818908;

struct Type_2818903 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818906 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818904 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818908 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct MethodRefSig_600 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818903 RetType;
    struct Type_2818904 Param0;
    struct Type_2818906 Param1;
    struct Type_2818908 Param2;
};

struct Blob_MethodRefSig_600 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_600 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1732 Blob_Generic_1732, *PBlob_Generic_1732;

struct Blob_Generic_1732 {
    byte Size; // coded integer - blob size
    byte Generic[41]; // Undefined blob contents
};

typedef struct Blob_ConstantSig_1589 Blob_ConstantSig_1589, *PBlob_ConstantSig_1589;

typedef struct ConstantSig_1589 ConstantSig_1589, *PConstantSig_1589;

struct ConstantSig_1589 {
    wchar16 ELEMENT_TYPE_STRING[7];
};

struct Blob_ConstantSig_1589 {
    byte Size; // coded integer - blob size
    struct ConstantSig_1589 ConstantSig; // Data stored in a constant
};

typedef struct Blob_MethodRefSig_835 Blob_MethodRefSig_835, *PBlob_MethodRefSig_835;

typedef struct MethodRefSig_835 MethodRefSig_835, *PMethodRefSig_835;

typedef struct Type_2819138 Type_2819138, *PType_2819138;

typedef struct Type_2819139 Type_2819139, *PType_2819139;

typedef struct Type_2819140 Type_2819140, *PType_2819140;

struct Type_2819139 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819140 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819138 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_835 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819138 RetType;
    struct Type_2819139 Param0;
    struct Type_2819140 Param1;
};

struct Blob_MethodRefSig_835 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_835 MethodRefSig; // Type info for imported method return and params
};

typedef struct CustomAttrib_841 CustomAttrib_841, *PCustomAttrib_841;

struct CustomAttrib_841 {
    word PROLOG; // Magic (0x0001)
    byte PackedLen;
    char FixedArg_0[51];
    byte PackedLen;
    char FixedArg_1[8];
    word NumNamed; // Number of NamedArgs to follow
};

typedef struct Blob_LocalVarSig_1175 Blob_LocalVarSig_1175, *PBlob_LocalVarSig_1175;

typedef struct LocalVarSig_1175 LocalVarSig_1175, *PLocalVarSig_1175;

typedef struct Type_2819478 Type_2819478, *PType_2819478;

typedef struct Type_2819481 Type_2819481, *PType_2819481;

typedef struct Type_2819482 Type_2819482, *PType_2819482;

struct Type_2819478 {
    struct SzArray ELEMENT_TYPE_SZARRAY;
};

struct Type_2819482 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct Type_2819481 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct LocalVarSig_1175 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819478 Type;
    struct Type_2819481 Type;
    struct Type_2819482 Type;
};

struct Blob_LocalVarSig_1175 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1175 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_1074 Blob_Generic_1074, *PBlob_Generic_1074;

struct Blob_Generic_1074 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_263 Blob_Generic_263, *PBlob_Generic_263;

struct Blob_Generic_263 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_1079 Blob_Generic_1079, *PBlob_Generic_1079;

struct Blob_Generic_1079 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_250 Blob_MethodRefSig_250, *PBlob_MethodRefSig_250;

typedef struct MethodRefSig_250 MethodRefSig_250, *PMethodRefSig_250;

typedef struct Type_2818553 Type_2818553, *PType_2818553;

typedef struct Type_2818556 Type_2818556, *PType_2818556;

struct Type_2818553 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818556 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_250 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818553 RetType;
    struct Type_2818556 Param0;
};

struct Blob_MethodRefSig_250 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_250 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_257 Blob_MethodRefSig_257, *PBlob_MethodRefSig_257;

typedef struct MethodRefSig_257 MethodRefSig_257, *PMethodRefSig_257;

typedef struct Type_2818560 Type_2818560, *PType_2818560;

typedef struct Type_2818561 Type_2818561, *PType_2818561;

typedef struct Type_2818562 Type_2818562, *PType_2818562;

struct Type_2818561 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818560 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818562 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct MethodRefSig_257 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818560 RetType;
    struct Type_2818561 Param0;
    struct Type_2818562 Param1;
};

struct Blob_MethodRefSig_257 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_257 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_493 Blob_MethodRefSig_493, *PBlob_MethodRefSig_493;

typedef struct MethodRefSig_493 MethodRefSig_493, *PMethodRefSig_493;

typedef struct Type_2818796 Type_2818796, *PType_2818796;

typedef struct Type_2818799 Type_2818799, *PType_2818799;

typedef struct Type_2818800 Type_2818800, *PType_2818800;

struct Type_2818796 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818800 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct Type_2818799 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_493 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818796 RetType;
    struct Type_2818799 Param0;
    struct Type_2818800 Param1;
};

struct Blob_MethodRefSig_493 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_493 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_250 Blob_Generic_250, *PBlob_Generic_250;

struct Blob_Generic_250 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_1083 Blob_Generic_1083, *PBlob_Generic_1083;

struct Blob_Generic_1083 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_493 Blob_Generic_493, *PBlob_Generic_493;

struct Blob_Generic_493 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_Generic_1089 Blob_Generic_1089, *PBlob_Generic_1089;

struct Blob_Generic_1089 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_257 Blob_Generic_257, *PBlob_Generic_257;

struct Blob_Generic_257 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_FieldSig_1586 Blob_FieldSig_1586, *PBlob_FieldSig_1586;

typedef struct FieldSig_1586 FieldSig_1586, *PFieldSig_1586;

typedef struct Type_2819888 Type_2819888, *PType_2819888;

struct Type_2819888 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct FieldSig_1586 {
    byte FIELD; // Magic (0x06)
    struct Type_2819888 ELEMENT_TYPE_STRING;
};

struct Blob_FieldSig_1586 {
    byte Size; // coded integer - blob size
    struct FieldSig_1586 FieldSig; // Type information for Field
};

typedef struct Blob_MethodRefSig_485 Blob_MethodRefSig_485, *PBlob_MethodRefSig_485;

typedef struct MethodRefSig_485 MethodRefSig_485, *PMethodRefSig_485;

typedef struct Type_2818788 Type_2818788, *PType_2818788;

typedef struct Type_2818789 Type_2818789, *PType_2818789;

typedef struct Type_2818790 Type_2818790, *PType_2818790;

struct Type_2818789 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818788 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818790 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_485 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818788 RetType;
    struct Type_2818789 Param0;
    struct Type_2818790 Param1;
};

struct Blob_MethodRefSig_485 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_485 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1093 Blob_Generic_1093, *PBlob_Generic_1093;

struct Blob_Generic_1093 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_485 Blob_Generic_485, *PBlob_Generic_485;

struct Blob_Generic_485 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_470 Blob_MethodRefSig_470, *PBlob_MethodRefSig_470;

typedef struct MethodRefSig_470 MethodRefSig_470, *PMethodRefSig_470;

typedef struct Type_2818773 Type_2818773, *PType_2818773;

typedef struct Type_2818776 Type_2818776, *PType_2818776;

struct Type_2818773 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818776 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_470 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818773 RetType;
    struct Type_2818776 Param0;
};

struct Blob_MethodRefSig_470 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_470 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_245 Blob_Generic_245, *PBlob_Generic_245;

struct Blob_Generic_245 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_234 Blob_MethodRefSig_234, *PBlob_MethodRefSig_234;

typedef struct MethodRefSig_234 MethodRefSig_234, *PMethodRefSig_234;

typedef struct Type_2818537 Type_2818537, *PType_2818537;

struct Type_2818537 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_234 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818537 RetType;
};

struct Blob_MethodRefSig_234 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_234 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_479 Blob_MethodRefSig_479, *PBlob_MethodRefSig_479;

typedef struct MethodRefSig_479 MethodRefSig_479, *PMethodRefSig_479;

typedef struct Type_2818782 Type_2818782, *PType_2818782;

struct Type_2818782 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_479 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818782 RetType;
};

struct Blob_MethodRefSig_479 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_479 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_238 Blob_MethodRefSig_238, *PBlob_MethodRefSig_238;

typedef struct MethodRefSig_238 MethodRefSig_238, *PMethodRefSig_238;

typedef struct Type_2818541 Type_2818541, *PType_2818541;

typedef struct Type_2818542 Type_2818542, *PType_2818542;

struct Type_2818542 {
    struct ValueType.conflict8 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818541 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_238 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818541 RetType;
    struct Type_2818542 Param0;
};

struct Blob_MethodRefSig_238 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_238 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_470 Blob_Generic_470, *PBlob_Generic_470;

struct Blob_Generic_470 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_234 Blob_Generic_234, *PBlob_Generic_234;

struct Blob_Generic_234 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_238 Blob_Generic_238, *PBlob_Generic_238;

struct Blob_Generic_238 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_479 Blob_Generic_479, *PBlob_Generic_479;

struct Blob_Generic_479 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_153 Blob_LocalVarSig_153, *PBlob_LocalVarSig_153;

typedef struct LocalVarSig_153 LocalVarSig_153, *PLocalVarSig_153;

typedef struct Type_2818456 Type_2818456, *PType_2818456;

typedef struct Type_2818457 Type_2818457, *PType_2818457;

typedef struct Type_2818459 Type_2818459, *PType_2818459;

typedef struct Type_2818461 Type_2818461, *PType_2818461;

struct Type_2818459 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct Type_2818456 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818461 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct Type_2818457 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct LocalVarSig_153 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2818456 Type;
    struct Type_2818457 Type;
    struct Type_2818459 Type;
    struct Type_2818461 Type;
};

struct Blob_LocalVarSig_153 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_153 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_MethodRefSig_221 Blob_MethodRefSig_221, *PBlob_MethodRefSig_221;

typedef struct MethodRefSig_221 MethodRefSig_221, *PMethodRefSig_221;

typedef struct Type_2818524 Type_2818524, *PType_2818524;

typedef struct Type_2818525 Type_2818525, *PType_2818525;

typedef struct Type_2818526 Type_2818526, *PType_2818526;

struct Type_2818526 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818525 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818524 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_221 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818524 RetType;
    struct Type_2818525 Param0;
    struct Type_2818526 Param1;
};

struct Blob_MethodRefSig_221 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_221 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_463 Blob_MethodRefSig_463, *PBlob_MethodRefSig_463;

typedef struct MethodRefSig_463 MethodRefSig_463, *PMethodRefSig_463;

typedef struct Type_2818766 Type_2818766, *PType_2818766;

typedef struct Type_2818769 Type_2818769, *PType_2818769;

struct Type_2818766 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818769 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_463 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818766 RetType;
    struct Type_2818769 Param0;
};

struct Blob_MethodRefSig_463 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_463 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_227 Blob_MethodRefSig_227, *PBlob_MethodRefSig_227;

typedef struct MethodRefSig_227 MethodRefSig_227, *PMethodRefSig_227;

typedef struct Type_2818530 Type_2818530, *PType_2818530;

typedef struct Type_2818531 Type_2818531, *PType_2818531;

typedef struct Type_2818532 Type_2818532, *PType_2818532;

struct Type_2818532 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818531 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818530 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_227 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818530 RetType;
    struct Type_2818531 Param0;
    struct Type_2818532 Param1;
};

struct Blob_MethodRefSig_227 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_227 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_LocalVarSig_1137 Blob_LocalVarSig_1137, *PBlob_LocalVarSig_1137;

typedef struct LocalVarSig_1137 LocalVarSig_1137, *PLocalVarSig_1137;

typedef struct Type_2819440 Type_2819440, *PType_2819440;

typedef struct Type_2819442 Type_2819442, *PType_2819442;

typedef struct Type_2819444 Type_2819444, *PType_2819444;

typedef struct Type_2819445 Type_2819445, *PType_2819445;

typedef struct Type_2819446 Type_2819446, *PType_2819446;

struct Type_2819446 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819445 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819444 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2819442 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2819440 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct LocalVarSig_1137 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819440 Type;
    struct Type_2819442 Type;
    struct Type_2819444 Type;
    struct Type_2819445 Type;
    struct Type_2819446 Type;
};

struct Blob_LocalVarSig_1137 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1137 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_MethodRefSig_459 Blob_MethodRefSig_459, *PBlob_MethodRefSig_459;

typedef struct MethodRefSig_459 MethodRefSig_459, *PMethodRefSig_459;

typedef struct Type_2818762 Type_2818762, *PType_2818762;

struct Type_2818762 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_459 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818762 RetType;
};

struct Blob_MethodRefSig_459 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_459 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_215 Blob_MethodRefSig_215, *PBlob_MethodRefSig_215;

typedef struct MethodRefSig_215 MethodRefSig_215, *PMethodRefSig_215;

typedef struct Type_2818518 Type_2818518, *PType_2818518;

typedef struct Type_2818519 Type_2818519, *PType_2818519;

typedef struct Type_2818520 Type_2818520, *PType_2818520;

struct Type_2818520 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818518 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818519 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_215 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818518 RetType;
    struct Type_2818519 Param0;
    struct Type_2818520 Param1;
};

struct Blob_MethodRefSig_215 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_215 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_293 Blob_Generic_293, *PBlob_Generic_293;

struct Blob_Generic_293 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_ConstantSig_522 Blob_ConstantSig_522, *PBlob_ConstantSig_522;

typedef struct ConstantSig_522 ConstantSig_522, *PConstantSig_522;

struct ConstantSig_522 {
    dword ELEMENT_TYPE_I4;
};

struct Blob_ConstantSig_522 {
    byte Size; // coded integer - blob size
    struct ConstantSig_522 ConstantSig; // Data stored in a constant
};

typedef struct Blob_Generic_297 Blob_Generic_297, *PBlob_Generic_297;

struct Blob_Generic_297 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_209 Blob_MethodRefSig_209, *PBlob_MethodRefSig_209;

typedef struct MethodRefSig_209 MethodRefSig_209, *PMethodRefSig_209;

typedef struct Type_2818512 Type_2818512, *PType_2818512;

typedef struct Type_2818514 Type_2818514, *PType_2818514;

struct Type_2818514 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818512 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_209 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818512 RetType;
    struct Type_2818514 Param0;
};

struct Blob_MethodRefSig_209 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_209 MethodRefSig; // Type info for imported method return and params
};

typedef struct CustomAttrib_435 CustomAttrib_435, *PCustomAttrib_435;

struct CustomAttrib_435 {
    word PROLOG; // Magic (0x0001)
    word NumNamed; // Number of NamedArgs to follow
};

typedef struct Blob_Generic_287 Blob_Generic_287, *PBlob_Generic_287;

struct Blob_Generic_287 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_272 Blob_Generic_272, *PBlob_Generic_272;

struct Blob_Generic_272 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_279 Blob_Generic_279, *PBlob_Generic_279;

struct Blob_Generic_279 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_423 Blob_MethodRefSig_423, *PBlob_MethodRefSig_423;

typedef struct MethodRefSig_423 MethodRefSig_423, *PMethodRefSig_423;

typedef struct Type_2818726 Type_2818726, *PType_2818726;

typedef struct Type_2818727 Type_2818727, *PType_2818727;

struct Type_2818727 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct Type_2818726 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_423 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818726 RetType;
    struct Type_2818727 Param0;
};

struct Blob_MethodRefSig_423 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_423 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_ConstantSig_35 Blob_ConstantSig_35, *PBlob_ConstantSig_35;

typedef struct ConstantSig_35 ConstantSig_35, *PConstantSig_35;

struct ConstantSig_35 {
    dword ELEMENT_TYPE_I4;
};

struct Blob_ConstantSig_35 {
    byte Size; // coded integer - blob size
    struct ConstantSig_35 ConstantSig; // Data stored in a constant
};

typedef struct Blob_Generic_302 Blob_Generic_302, *PBlob_Generic_302;

struct Blob_Generic_302 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_786 Blob_Generic_786, *PBlob_Generic_786;

struct Blob_Generic_786 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1233 Blob_Generic_1233, *PBlob_Generic_1233;

struct Blob_Generic_1233 {
    byte Size; // coded integer - blob size
    byte Generic[2]; // Undefined blob contents
};

typedef struct Blob_Generic_1475 Blob_Generic_1475, *PBlob_Generic_1475;

struct Blob_Generic_1475 {
    byte Size; // coded integer - blob size
    byte Generic[22]; // Undefined blob contents
};

typedef struct Blob_Generic_542 Blob_Generic_542, *PBlob_Generic_542;

struct Blob_Generic_542 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_783 Blob_Generic_783, *PBlob_Generic_783;

struct Blob_Generic_783 {
    byte Size; // coded integer - blob size
    byte Generic[2]; // Undefined blob contents
};

typedef struct Blob_Generic_1236 Blob_Generic_1236, *PBlob_Generic_1236;

struct Blob_Generic_1236 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_547 Blob_Generic_547, *PBlob_Generic_547;

struct Blob_Generic_547 {
    byte Size; // coded integer - blob size
    byte Generic[25]; // Undefined blob contents
};

typedef struct Blob_Generic_308 Blob_Generic_308, *PBlob_Generic_308;

struct Blob_Generic_308 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1083 Blob_MethodRefSig_1083, *PBlob_MethodRefSig_1083;

typedef struct MethodRefSig_1083 MethodRefSig_1083, *PMethodRefSig_1083;

typedef struct Type_2819386 Type_2819386, *PType_2819386;

struct Type_2819386 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_1083 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819386 RetType;
};

struct Blob_MethodRefSig_1083 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1083 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_775 Blob_Generic_775, *PBlob_Generic_775;

struct Blob_Generic_775 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1069 Blob_MethodRefSig_1069, *PBlob_MethodRefSig_1069;

typedef struct MethodRefSig_1069 MethodRefSig_1069, *PMethodRefSig_1069;

typedef struct Type_2819372 Type_2819372, *PType_2819372;

typedef struct Type_2819373 Type_2819373, *PType_2819373;

struct Type_2819372 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2819373 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct MethodRefSig_1069 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819372 RetType;
    struct Type_2819373 Param0;
};

struct Blob_MethodRefSig_1069 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1069 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_536 Blob_Generic_536, *PBlob_Generic_536;

struct Blob_Generic_536 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1245 Blob_Generic_1245, *PBlob_Generic_1245;

struct Blob_Generic_1245 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_450 Blob_LocalVarSig_450, *PBlob_LocalVarSig_450;

typedef struct LocalVarSig_450 LocalVarSig_450, *PLocalVarSig_450;

typedef struct Type_2818753 Type_2818753, *PType_2818753;

typedef struct Type_2818754 Type_2818754, *PType_2818754;

typedef struct Type_2818755 Type_2818755, *PType_2818755;

typedef struct Type_2818758 Type_2818758, *PType_2818758;

struct Type_2818753 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818755 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818758 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818754 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct LocalVarSig_450 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2818753 Type;
    struct Type_2818754 Type;
    struct Type_2818755 Type;
    struct Type_2818758 Type;
};

struct Blob_LocalVarSig_450 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_450 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_MethodRefSig_1074 Blob_MethodRefSig_1074, *PBlob_MethodRefSig_1074;

typedef struct MethodRefSig_1074 MethodRefSig_1074, *PMethodRefSig_1074;

typedef struct Type_2819377 Type_2819377, *PType_2819377;

typedef struct Type_2819378 Type_2819378, *PType_2819378;

struct Type_2819378 {
    enum TypeCode ELEMENT_TYPE_CHAR;
};

struct Type_2819377 {
    enum TypeCode ELEMENT_TYPE_CHAR;
};

struct MethodRefSig_1074 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819377 RetType;
    struct Type_2819378 Param0;
};

struct Blob_MethodRefSig_1074 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1074 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_PropertySig_148 Blob_PropertySig_148, *PBlob_PropertySig_148;

typedef struct PropertySig_148 PropertySig_148, *PPropertySig_148;

typedef struct Type_2818451 Type_2818451, *PType_2818451;

struct Type_2818451 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct PropertySig_148 {
    byte PROPERTY; // Magic (0x08) optionalled OR'd with HASTHIS (0x20)
    byte Count; // Number of params to follow RetType
    struct Type_2818451 RetType; // Return type
};

struct Blob_PropertySig_148 {
    byte Size; // coded integer - blob size
    struct PropertySig_148 PropertySig; // Contains signature for properties. Gives params for getters/setters.
};

typedef struct Blob_Generic_760 Blob_Generic_760, *PBlob_Generic_760;

struct Blob_Generic_760 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_522 Blob_Generic_522, *PBlob_Generic_522;

struct Blob_Generic_522 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_1254 Blob_Generic_1254, *PBlob_Generic_1254;

struct Blob_Generic_1254 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_FieldSig_907 Blob_FieldSig_907, *PBlob_FieldSig_907;

typedef struct FieldSig_907 FieldSig_907, *PFieldSig_907;

typedef struct Type_2819209 Type_2819209, *PType_2819209;

struct Type_2819209 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct FieldSig_907 {
    byte FIELD; // Magic (0x06)
    struct Type_2819209 ELEMENT_TYPE_CLASS;
};

struct Blob_FieldSig_907 {
    byte Size; // coded integer - blob size
    struct FieldSig_907 FieldSig; // Type information for Field
};

typedef struct Blob_Generic_767 Blob_Generic_767, *PBlob_Generic_767;

struct Blob_Generic_767 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_191 Blob_MethodRefSig_191, *PBlob_MethodRefSig_191;

typedef struct MethodRefSig_191 MethodRefSig_191, *PMethodRefSig_191;

typedef struct Type_2818494 Type_2818494, *PType_2818494;

typedef struct Type_2818495 Type_2818495, *PType_2818495;

typedef struct Type_2818496 Type_2818496, *PType_2818496;

typedef struct Type_2818497 Type_2818497, *PType_2818497;

struct Type_2818494 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct Type_2818496 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818495 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818497 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct MethodRefSig_191 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818494 RetType;
    struct Type_2818495 Param0;
    struct Type_2818496 Param1;
    struct Type_2818497 Param2;
};

struct Blob_MethodRefSig_191 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_191 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1059 Blob_MethodRefSig_1059, *PBlob_MethodRefSig_1059;

typedef struct MethodRefSig_1059 MethodRefSig_1059, *PMethodRefSig_1059;

typedef struct Type_2819362 Type_2819362, *PType_2819362;

typedef struct Type_2819363 Type_2819363, *PType_2819363;

struct Type_2819362 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2819363 {
    struct ValueType.conflict ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_1059 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819362 RetType;
    struct Type_2819363 Param0;
};

struct Blob_MethodRefSig_1059 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1059 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1498 Blob_Generic_1498, *PBlob_Generic_1498;

struct Blob_Generic_1498 {
    byte Size; // coded integer - blob size
    byte Generic[13]; // Undefined blob contents
};

typedef struct Blob_Generic_527 Blob_Generic_527, *PBlob_Generic_527;

struct Blob_Generic_527 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_198 Blob_MethodRefSig_198, *PBlob_MethodRefSig_198;

typedef struct MethodRefSig_198 MethodRefSig_198, *PMethodRefSig_198;

typedef struct Type_2818501 Type_2818501, *PType_2818501;

typedef struct Type_2818503 Type_2818503, *PType_2818503;

typedef struct Type_2818504 Type_2818504, *PType_2818504;

typedef struct Type_2818505 Type_2818505, *PType_2818505;

typedef struct Type_2818507 Type_2818507, *PType_2818507;

struct Type_2818504 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818503 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818501 {
    struct ValueType.conflict5 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818507 {
    struct ValueType.conflict7 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818505 {
    struct ValueType.conflict6 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_198 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818501 RetType;
    struct Type_2818503 Param0;
    struct Type_2818504 Param1;
    struct Type_2818505 Param2;
    struct Type_2818507 Param3;
};

struct Blob_MethodRefSig_198 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_198 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_LocalVarSig_662 Blob_LocalVarSig_662, *PBlob_LocalVarSig_662;

typedef struct LocalVarSig_662 LocalVarSig_662, *PLocalVarSig_662;

typedef struct Type_2818965 Type_2818965, *PType_2818965;

typedef struct Type_2818967 Type_2818967, *PType_2818967;

typedef struct Type_2818970 Type_2818970, *PType_2818970;

typedef struct Type_2818973 Type_2818973, *PType_2818973;

typedef struct Type_2818976 Type_2818976, *PType_2818976;

typedef struct Type_2818979 Type_2818979, *PType_2818979;

typedef struct Type_2818982 Type_2818982, *PType_2818982;

typedef struct Type_2818983 Type_2818983, *PType_2818983;

typedef struct Type_2818985 Type_2818985, *PType_2818985;

typedef struct Type_2818988 Type_2818988, *PType_2818988;

typedef struct Type_2818991 Type_2818991, *PType_2818991;

struct Type_2818988 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818965 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818976 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818985 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818973 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818983 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818991 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818967 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818970 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818979 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2818982 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct LocalVarSig_662 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2818965 Type;
    struct Type_2818967 Type;
    struct Type_2818970 Type;
    struct Type_2818973 Type;
    struct Type_2818976 Type;
    struct Type_2818979 Type;
    struct Type_2818982 Type;
    struct Type_2818983 Type;
    struct Type_2818985 Type;
    struct Type_2818988 Type;
    struct Type_2818991 Type;
};

struct Blob_LocalVarSig_662 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_662 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_1261 Blob_Generic_1261, *PBlob_Generic_1261;

struct Blob_Generic_1261 {
    byte Size; // coded integer - blob size
    byte Generic[13]; // Undefined blob contents
};

typedef struct Blob_Generic_1020 Blob_Generic_1020, *PBlob_Generic_1020;

struct Blob_Generic_1020 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_510 Blob_Generic_510, *PBlob_Generic_510;

struct Blob_Generic_510 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_Generic_1024 Blob_Generic_1024, *PBlob_Generic_1024;

struct Blob_Generic_1024 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_754 Blob_Generic_754, *PBlob_Generic_754;

struct Blob_Generic_754 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_518 Blob_Generic_518, *PBlob_Generic_518;

struct Blob_Generic_518 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_1029 Blob_Generic_1029, *PBlob_Generic_1029;

struct Blob_Generic_1029 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1294 Blob_MethodRefSig_1294, *PBlob_MethodRefSig_1294;

typedef struct MethodRefSig_1294 MethodRefSig_1294, *PMethodRefSig_1294;

typedef struct Type_2819597 Type_2819597, *PType_2819597;

typedef struct Type_2819598 Type_2819598, *PType_2819598;

typedef struct Type_2819599 Type_2819599, *PType_2819599;

typedef struct Type_2819600 Type_2819600, *PType_2819600;

struct Type_2819600 {
    struct ValueType.conflict21 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2819599 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819598 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819597 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct MethodRefSig_1294 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819597 RetType;
    struct Type_2819598 Param0;
    struct Type_2819599 Param1;
    struct Type_2819600 Param2;
};

struct Blob_MethodRefSig_1294 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1294 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_186 Blob_MethodRefSig_186, *PBlob_MethodRefSig_186;

typedef struct MethodRefSig_186 MethodRefSig_186, *PMethodRefSig_186;

typedef struct Type_2818489 Type_2818489, *PType_2818489;

typedef struct Type_2818490 Type_2818490, *PType_2818490;

struct Type_2818490 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818489 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_186 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818489 RetType;
    struct Type_2818490 Param0;
};

struct Blob_MethodRefSig_186 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_186 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1053 Blob_MethodRefSig_1053, *PBlob_MethodRefSig_1053;

typedef struct MethodRefSig_1053 MethodRefSig_1053, *PMethodRefSig_1053;

typedef struct Type_2819356 Type_2819356, *PType_2819356;

struct Type_2819356 {
    struct ValueType.conflict20 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_1053 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819356 RetType;
};

struct Blob_MethodRefSig_1053 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1053 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_341 Blob_Generic_341, *PBlob_Generic_341;

struct Blob_Generic_341 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_Generic_581 Blob_Generic_581, *PBlob_Generic_581;

struct Blob_Generic_581 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_587 Blob_Generic_587, *PBlob_Generic_587;

struct Blob_Generic_587 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1035 Blob_Generic_1035, *PBlob_Generic_1035;

struct Blob_Generic_1035 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_170 Blob_MethodRefSig_170, *PBlob_MethodRefSig_170;

typedef struct MethodRefSig_170 MethodRefSig_170, *PMethodRefSig_170;

typedef struct Type_2818474 Type_2818474, *PType_2818474;

typedef struct Type_2818475 Type_2818475, *PType_2818475;

struct Type_2818474 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818475 {
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypeVarOrMvar@345a5c5] ELEMENT_TYPE_GENERICINST;
};

struct MethodRefSig_170 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte GenParamCount; // Number of generic paramameters for the method
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818474 RetType;
    struct Type_2818475 Param0;
};

struct Blob_MethodRefSig_170 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_170 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_101 Blob_Generic_101, *PBlob_Generic_101;

struct Blob_Generic_101 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1275 Blob_Generic_1275, *PBlob_Generic_1275;

struct Blob_Generic_1275 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_107 Blob_Generic_107, *PBlob_Generic_107;

struct Blob_Generic_107 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_349 Blob_Generic_349, *PBlob_Generic_349;

struct Blob_Generic_349 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1288 Blob_MethodRefSig_1288, *PBlob_MethodRefSig_1288;

typedef struct MethodRefSig_1288 MethodRefSig_1288, *PMethodRefSig_1288;

typedef struct Type_2819591 Type_2819591, *PType_2819591;

struct Type_2819591 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_1288 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819591 RetType;
};

struct Blob_MethodRefSig_1288 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1288 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1281 Blob_MethodRefSig_1281, *PBlob_MethodRefSig_1281;

typedef struct MethodRefSig_1281 MethodRefSig_1281, *PMethodRefSig_1281;

typedef struct Type_2819584 Type_2819584, *PType_2819584;

struct Type_2819584 {
    struct SzArray.conflict1 ELEMENT_TYPE_SZARRAY;
};

struct MethodRefSig_1281 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819584 RetType;
};

struct Blob_MethodRefSig_1281 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1281 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1041 Blob_MethodRefSig_1041, *PBlob_MethodRefSig_1041;

typedef struct MethodRefSig_1041 MethodRefSig_1041, *PMethodRefSig_1041;

typedef struct Type_2819344 Type_2819344, *PType_2819344;

struct Type_2819344 {
    enum TypeCode ELEMENT_TYPE_I;
};

struct MethodRefSig_1041 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819344 RetType;
};

struct Blob_MethodRefSig_1041 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1041 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_573 Blob_Generic_573, *PBlob_Generic_573;

struct Blob_Generic_573 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_Generic_1041 Blob_Generic_1041, *PBlob_Generic_1041;

struct Blob_Generic_1041 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_1281 Blob_Generic_1281, *PBlob_Generic_1281;

struct Blob_Generic_1281 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_335 Blob_Generic_335, *PBlob_Generic_335;

struct Blob_Generic_335 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1045 Blob_Generic_1045, *PBlob_Generic_1045;

struct Blob_Generic_1045 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_Generic_1288 Blob_Generic_1288, *PBlob_Generic_1288;

struct Blob_Generic_1288 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1275 Blob_MethodRefSig_1275, *PBlob_MethodRefSig_1275;

typedef struct MethodRefSig_1275 MethodRefSig_1275, *PMethodRefSig_1275;

typedef struct Type_2819578 Type_2819578, *PType_2819578;

struct Type_2819578 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_1275 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819578 RetType;
};

struct Blob_MethodRefSig_1275 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1275 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_TypeSpec_1125 Blob_TypeSpec_1125, *PBlob_TypeSpec_1125;

struct Blob_TypeSpec_1125 {
    byte Size; // coded integer - blob size
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@351edfb4] TypeSpec; // Describes a type.
};

typedef struct Blob_MethodRefSig_1035 Blob_MethodRefSig_1035, *PBlob_MethodRefSig_1035;

typedef struct MethodRefSig_1035 MethodRefSig_1035, *PMethodRefSig_1035;

typedef struct Type_2819338 Type_2819338, *PType_2819338;

struct Type_2819338 {
    struct SzArray ELEMENT_TYPE_SZARRAY;
};

struct MethodRefSig_1035 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819338 RetType;
};

struct Blob_MethodRefSig_1035 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1035 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_163 Blob_MethodRefSig_163, *PBlob_MethodRefSig_163;

typedef struct MethodRefSig_163 MethodRefSig_163, *PMethodRefSig_163;

typedef struct Type_2818466 Type_2818466, *PType_2818466;

typedef struct Type_2818469 Type_2818469, *PType_2818469;

struct Type_2818466 {
    struct SzArray ELEMENT_TYPE_SZARRAY;
};

struct Type_2818469 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_163 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818466 RetType;
    struct Type_2818469 Param0;
};

struct Blob_MethodRefSig_163 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_163 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1294 Blob_Generic_1294, *PBlob_Generic_1294;

struct Blob_Generic_1294 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_1053 Blob_Generic_1053, *PBlob_Generic_1053;

struct Blob_Generic_1053 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_1190 Blob_LocalVarSig_1190, *PBlob_LocalVarSig_1190;

typedef struct LocalVarSig_1190 LocalVarSig_1190, *PLocalVarSig_1190;

typedef struct Type_2819493 Type_2819493, *PType_2819493;

typedef struct Type_2819495 Type_2819495, *PType_2819495;

struct Type_2819495 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2819493 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct LocalVarSig_1190 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819493 Type;
    struct Type_2819495 Type;
};

struct Blob_LocalVarSig_1190 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1190 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_321 Blob_Generic_321, *PBlob_Generic_321;

struct Blob_Generic_321 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_328 Blob_Generic_328, *PBlob_Generic_328;

struct Blob_Generic_328 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_1059 Blob_Generic_1059, *PBlob_Generic_1059;

struct Blob_Generic_1059 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_395 Blob_MethodRefSig_395, *PBlob_MethodRefSig_395;

typedef struct MethodRefSig_395 MethodRefSig_395, *PMethodRefSig_395;

typedef struct Type_2818698 Type_2818698, *PType_2818698;

typedef struct Type_2818699 Type_2818699, *PType_2818699;

struct Type_2818698 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818699 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_395 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818698 RetType;
    struct Type_2818699 Param0;
};

struct Blob_MethodRefSig_395 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_395 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_792 Blob_Generic_792, *PBlob_Generic_792;

struct Blob_Generic_792 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1065 Blob_Generic_1065, *PBlob_Generic_1065;

struct Blob_Generic_1065 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_315 Blob_Generic_315, *PBlob_Generic_315;

struct Blob_Generic_315 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1069 Blob_Generic_1069, *PBlob_Generic_1069;

struct Blob_Generic_1069 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_798 Blob_Generic_798, *PBlob_Generic_798;

struct Blob_Generic_798 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_388 Blob_MethodRefSig_388, *PBlob_MethodRefSig_388;

typedef struct MethodRefSig_388 MethodRefSig_388, *PMethodRefSig_388;

typedef struct Type_2818691 Type_2818691, *PType_2818691;

typedef struct Type_2818693 Type_2818693, *PType_2818693;

typedef struct Type_2818694 Type_2818694, *PType_2818694;

struct Type_2818693 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818691 {
    struct ValueType.conflict5 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818694 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_388 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818691 RetType;
    struct Type_2818693 Param0;
    struct Type_2818694 Param1;
};

struct Blob_MethodRefSig_388 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_388 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_142 Blob_MethodRefSig_142, *PBlob_MethodRefSig_142;

typedef struct MethodRefSig_142 MethodRefSig_142, *PMethodRefSig_142;

typedef struct Type_2818445 Type_2818445, *PType_2818445;

typedef struct Type_2818446 Type_2818446, *PType_2818446;

struct Type_2818445 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818446 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_142 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818445 RetType;
    struct Type_2818446 Param0;
};

struct Blob_MethodRefSig_142 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_142 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_TypeSpec_1385 Blob_TypeSpec_1385, *PBlob_TypeSpec_1385;

struct Blob_TypeSpec_1385 {
    byte Size; // coded integer - blob size
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@25a0b410, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@3eca0102] TypeSpec; // Describes a type.
};

typedef struct Blob_CustomAttrib_1679 Blob_CustomAttrib_1679, *PBlob_CustomAttrib_1679;

struct Blob_CustomAttrib_1679 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_1679 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_PropertySig_792 Blob_PropertySig_792, *PBlob_PropertySig_792;

typedef struct PropertySig_792 PropertySig_792, *PPropertySig_792;

typedef struct Type_2819095 Type_2819095, *PType_2819095;

struct Type_2819095 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct PropertySig_792 {
    byte PROPERTY; // Magic (0x08) optionalled OR'd with HASTHIS (0x20)
    byte Count; // Number of params to follow RetType
    struct Type_2819095 RetType; // Return type
};

struct Blob_PropertySig_792 {
    byte Size; // coded integer - blob size
    struct PropertySig_792 PropertySig; // Contains signature for properties. Gives params for getters/setters.
};

typedef struct Blob_Generic_701 Blob_Generic_701, *PBlob_Generic_701;

struct Blob_Generic_701 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_1878 Blob_Generic_1878, *PBlob_Generic_1878;

struct Blob_Generic_1878 {
    word Size; // coded integer - blob size
    byte Generic[158]; // Undefined blob contents
};

typedef struct Blob_Generic_708 Blob_Generic_708, *PBlob_Generic_708;

struct Blob_Generic_708 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_1402 Blob_Generic_1402, *PBlob_Generic_1402;

struct Blob_Generic_1402 {
    byte Size; // coded integer - blob size
    byte Generic[13]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1467 Blob_MethodRefSig_1467, *PBlob_MethodRefSig_1467;

typedef struct MethodRefSig_1467 MethodRefSig_1467, *PMethodRefSig_1467;

typedef struct Type_2819770 Type_2819770, *PType_2819770;

typedef struct Type_2819773 Type_2819773, *PType_2819773;

struct Type_2819770 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819773 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct MethodRefSig_1467 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819770 RetType;
    struct Type_2819773 Param0;
};

struct Blob_MethodRefSig_1467 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1467 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_930 Blob_Generic_930, *PBlob_Generic_930;

struct Blob_Generic_930 {
    byte Size; // coded integer - blob size
    byte Generic[89]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1215 Blob_MethodRefSig_1215, *PBlob_MethodRefSig_1215;

typedef struct MethodRefSig_1215 MethodRefSig_1215, *PMethodRefSig_1215;

typedef struct Type_2819518 Type_2819518, *PType_2819518;

typedef struct Type_2819520 Type_2819520, *PType_2819520;

typedef struct Type_2819521 Type_2819521, *PType_2819521;

typedef struct Type_2819522 Type_2819522, *PType_2819522;

struct Type_2819522 {
    struct ValueType.conflict6 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2819521 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819518 {
    struct ValueType.conflict5 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2819520 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_1215 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819518 RetType;
    struct Type_2819520 Param0;
    struct Type_2819521 Param1;
    struct Type_2819522 Param2;
};

struct Blob_MethodRefSig_1215 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1215 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1457 Blob_MethodRefSig_1457, *PBlob_MethodRefSig_1457;

typedef struct MethodRefSig_1457 MethodRefSig_1457, *PMethodRefSig_1457;

typedef struct Type_2819760 Type_2819760, *PType_2819760;

typedef struct Type_2819763 Type_2819763, *PType_2819763;

typedef struct Type_2819765 Type_2819765, *PType_2819765;

struct Type_2819765 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2819763 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2819760 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_1457 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819760 RetType;
    struct Type_2819763 Param0;
    struct Type_2819765 Param1;
};

struct Blob_MethodRefSig_1457 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1457 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1416 Blob_Generic_1416, *PBlob_Generic_1416;

struct Blob_Generic_1416 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_925 Blob_Generic_925, *PBlob_Generic_925;

struct Blob_Generic_925 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_1659 Blob_Generic_1659, *PBlob_Generic_1659;

struct Blob_Generic_1659 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_FieldSig_518 Blob_FieldSig_518, *PBlob_FieldSig_518;

typedef struct FieldSig_518 FieldSig_518, *PFieldSig_518;

typedef struct Type_2818820 Type_2818820, *PType_2818820;

struct Type_2818820 {
    struct ValueType ELEMENT_TYPE_VALUETYPE;
};

struct FieldSig_518 {
    byte FIELD; // Magic (0x06)
    struct Type_2818820 ELEMENT_TYPE_VALUETYPE;
};

struct Blob_FieldSig_518 {
    byte Size; // coded integer - blob size
    struct FieldSig_518 FieldSig; // Type information for Field
};

typedef struct Blob_Generic_911 Blob_Generic_911, *PBlob_Generic_911;

struct Blob_Generic_911 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1201 Blob_MethodRefSig_1201, *PBlob_MethodRefSig_1201;

typedef struct MethodRefSig_1201 MethodRefSig_1201, *PMethodRefSig_1201;

typedef struct Type_2819504 Type_2819504, *PType_2819504;

typedef struct Type_2819506 Type_2819506, *PType_2819506;

struct Type_2819506 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819504 {
    struct ValueType.conflict5 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_1201 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819504 RetType;
    struct Type_2819506 Param0;
};

struct Blob_MethodRefSig_1201 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1201 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1666 Blob_Generic_1666, *PBlob_Generic_1666;

struct Blob_Generic_1666 {
    byte Size; // coded integer - blob size
    byte Generic[12]; // Undefined blob contents
};

typedef struct Blob_Generic_1421 Blob_Generic_1421, *PBlob_Generic_1421;

struct Blob_Generic_1421 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_CustomAttrib_1666 Blob_CustomAttrib_1666, *PBlob_CustomAttrib_1666;

struct Blob_CustomAttrib_1666 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_1666 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_MethodRefSig_1450 Blob_MethodRefSig_1450, *PBlob_MethodRefSig_1450;

typedef struct MethodRefSig_1450 MethodRefSig_1450, *PMethodRefSig_1450;

typedef struct Type_2819753 Type_2819753, *PType_2819753;

typedef struct Type_2819754 Type_2819754, *PType_2819754;

typedef struct Type_2819755 Type_2819755, *PType_2819755;

typedef struct Type_2819756 Type_2819756, *PType_2819756;

struct Type_2819756 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct Type_2819755 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct Type_2819754 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819753 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_1450 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819753 RetType;
    struct Type_2819754 Param0;
    struct Type_2819755 Param1;
    struct Type_2819756 Param2;
};

struct Blob_MethodRefSig_1450 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1450 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1425 Blob_Generic_1425, *PBlob_Generic_1425;

struct Blob_Generic_1425 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_TypeSpec_1102 Blob_TypeSpec_1102, *PBlob_TypeSpec_1102;

struct Blob_TypeSpec_1102 {
    byte Size; // coded integer - blob size
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57cbb605] TypeSpec; // Describes a type.
};

typedef struct Blob_Generic_916 Blob_Generic_916, *PBlob_Generic_916;

struct Blob_Generic_916 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_740 Blob_Generic_740, *PBlob_Generic_740;

struct Blob_Generic_740 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_TypeSpec_1519 Blob_TypeSpec_1519, *PBlob_TypeSpec_1519;

struct Blob_TypeSpec_1519 {
    byte Size; // coded integer - blob size
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@16d98edb, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1589564] TypeSpec; // Describes a type.
};

typedef struct Blob_Generic_501 Blob_Generic_501, *PBlob_Generic_501;

struct Blob_Generic_501 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_1433 Blob_Generic_1433, *PBlob_Generic_1433;

struct Blob_Generic_1433 {
    byte Size; // coded integer - blob size
    byte Generic[16]; // Undefined blob contents
};

typedef struct Blob_ConstantSig_1604 Blob_ConstantSig_1604, *PBlob_ConstantSig_1604;

typedef struct ConstantSig_1604 ConstantSig_1604, *PConstantSig_1604;

struct ConstantSig_1604 {
    wchar16 ELEMENT_TYPE_STRING[7];
};

struct Blob_ConstantSig_1604 {
    byte Size; // coded integer - blob size
    struct ConstantSig_1604 ConstantSig; // Data stored in a constant
};

typedef struct Blob_Generic_748 Blob_Generic_748, *PBlob_Generic_748;

struct Blob_Generic_748 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1679 Blob_Generic_1679, *PBlob_Generic_1679;

struct Blob_Generic_1679 {
    byte Size; // coded integer - blob size
    byte Generic[19]; // Undefined blob contents
};

typedef struct Blob_FieldSig_720 Blob_FieldSig_720, *PBlob_FieldSig_720;

typedef struct FieldSig_720 FieldSig_720, *PFieldSig_720;

typedef struct Type_2819022 Type_2819022, *PType_2819022;

struct Type_2819022 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct FieldSig_720 {
    byte FIELD; // Magic (0x06)
    struct Type_2819022 ELEMENT_TYPE_CLASS;
};

struct Blob_FieldSig_720 {
    byte Size; // coded integer - blob size
    struct FieldSig_720 FieldSig; // Type information for Field
};

typedef struct Blob_MethodRefSig_1421 Blob_MethodRefSig_1421, *PBlob_MethodRefSig_1421;

typedef struct MethodRefSig_1421 MethodRefSig_1421, *PMethodRefSig_1421;

typedef struct Type_2819724 Type_2819724, *PType_2819724;

struct Type_2819724 {
    enum TypeCode ELEMENT_TYPE_I8;
};

struct MethodRefSig_1421 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819724 RetType;
};

struct Blob_MethodRefSig_1421 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1421 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_734 Blob_Generic_734, *PBlob_Generic_734;

struct Blob_Generic_734 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1201 Blob_Generic_1201, *PBlob_Generic_1201;

struct Blob_Generic_1201 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1207 Blob_Generic_1207, *PBlob_Generic_1207;

struct Blob_Generic_1207 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_CustomAttrib_1619 Blob_CustomAttrib_1619, *PBlob_CustomAttrib_1619;

struct Blob_CustomAttrib_1619 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_1619 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_Generic_720 Blob_Generic_720, *PBlob_Generic_720;

struct Blob_Generic_720 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_1450 Blob_Generic_1450, *PBlob_Generic_1450;

struct Blob_Generic_1450 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_1659 Blob_MethodRefSig_1659, *PBlob_MethodRefSig_1659;

typedef struct MethodRefSig_1659 MethodRefSig_1659, *PMethodRefSig_1659;

typedef struct Type_2819962 Type_2819962, *PType_2819962;

typedef struct Type_2819963 Type_2819963, *PType_2819963;

struct Type_2819963 {
    struct ValueType.conflict24 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2819962 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_1659 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819962 RetType;
    struct Type_2819963 Param0;
};

struct Blob_MethodRefSig_1659 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1659 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1215 Blob_Generic_1215, *PBlob_Generic_1215;

struct Blob_Generic_1215 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_1457 Blob_Generic_1457, *PBlob_Generic_1457;

struct Blob_Generic_1457 {
    byte Size; // coded integer - blob size
    byte Generic[9]; // Undefined blob contents
};

typedef struct Blob_Generic_1699 Blob_Generic_1699, *PBlob_Generic_1699;

struct Blob_Generic_1699 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_725 Blob_Generic_725, *PBlob_Generic_725;

struct Blob_Generic_725 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_FieldSig_715 Blob_FieldSig_715, *PBlob_FieldSig_715;

typedef struct FieldSig_715 FieldSig_715, *PFieldSig_715;

typedef struct Type_2819017 Type_2819017, *PType_2819017;

struct Type_2819017 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct FieldSig_715 {
    byte FIELD; // Magic (0x06)
    struct Type_2819017 ELEMENT_TYPE_CLASS;
};

struct Blob_FieldSig_715 {
    byte Size; // coded integer - blob size
    struct FieldSig_715 FieldSig; // Type information for Field
};

typedef struct Blob_CustomAttrib_1628 Blob_CustomAttrib_1628, *PBlob_CustomAttrib_1628;

struct Blob_CustomAttrib_1628 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_1628 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_Generic_1467 Blob_Generic_1467, *PBlob_Generic_1467;

struct Blob_Generic_1467 {
    byte Size; // coded integer - blob size
    byte Generic[7]; // Undefined blob contents
};

typedef struct Blob_Generic_1224 Blob_Generic_1224, *PBlob_Generic_1224;

struct Blob_Generic_1224 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_715 Blob_Generic_715, *PBlob_Generic_715;

struct Blob_Generic_715 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_78 Blob_MethodRefSig_78, *PBlob_MethodRefSig_78;

typedef struct MethodRefSig_78 MethodRefSig_78, *PMethodRefSig_78;

typedef struct Type_2818381 Type_2818381, *PType_2818381;

typedef struct Type_2818382 Type_2818382, *PType_2818382;

typedef struct Type_2818383 Type_2818383, *PType_2818383;

struct Type_2818383 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818382 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2818381 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_78 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818381 RetType;
    struct Type_2818382 Param0;
    struct Type_2818383 Param1;
};

struct Blob_MethodRefSig_78 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_78 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_73 Blob_MethodRefSig_73, *PBlob_MethodRefSig_73;

typedef struct MethodRefSig_73 MethodRefSig_73, *PMethodRefSig_73;

struct MethodRefSig_73 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818376 RetType;
    struct Type_2818377 Param0;
};

struct Blob_MethodRefSig_73 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_73 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_1512 Blob_MethodRefSig_1512, *PBlob_MethodRefSig_1512;

typedef struct MethodRefSig_1512 MethodRefSig_1512, *PMethodRefSig_1512;

typedef struct Type_2819815 Type_2819815, *PType_2819815;

typedef struct Type_2819816 Type_2819816, *PType_2819816;

typedef struct Type_2819817 Type_2819817, *PType_2819817;

struct Type_2819815 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2819817 {
    enum TypeCode ELEMENT_TYPE_BYREF; // By Reference
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct Type_2819816 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct MethodRefSig_1512 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819815 RetType;
    struct Type_2819816 Param0;
    struct Type_2819817 Param1;
};

struct Blob_MethodRefSig_1512 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_1512 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_775 Blob_MethodRefSig_775, *PBlob_MethodRefSig_775;

typedef struct MethodRefSig_775 MethodRefSig_775, *PMethodRefSig_775;

typedef struct Type_2819078 Type_2819078, *PType_2819078;

typedef struct Type_2819079 Type_2819079, *PType_2819079;

typedef struct Type_2819080 Type_2819080, *PType_2819080;

struct Type_2819079 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819078 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct Type_2819080 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_775 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819078 RetType;
    struct Type_2819079 Param0;
    struct Type_2819080 Param1;
};

struct Blob_MethodRefSig_775 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_775 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_FieldSig_245 Blob_FieldSig_245, *PBlob_FieldSig_245;

typedef struct FieldSig_245 FieldSig_245, *PFieldSig_245;

typedef struct Type_2818547 Type_2818547, *PType_2818547;

struct Type_2818547 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct FieldSig_245 {
    byte FIELD; // Magic (0x06)
    struct Type_2818547 ELEMENT_TYPE_CLASS;
};

struct Blob_FieldSig_245 {
    byte Size; // coded integer - blob size
    struct FieldSig_245 FieldSig; // Type information for Field
};

typedef struct Blob_MethodRefSig_536 Blob_MethodRefSig_536, *PBlob_MethodRefSig_536;

typedef struct MethodRefSig_536 MethodRefSig_536, *PMethodRefSig_536;

typedef struct Type_2818839 Type_2818839, *PType_2818839;

typedef struct Type_2818840 Type_2818840, *PType_2818840;

struct Type_2818840 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2818839 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_536 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818839 RetType;
    struct Type_2818840 Param0;
};

struct Blob_MethodRefSig_536 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_536 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_62 Blob_MethodRefSig_62, *PBlob_MethodRefSig_62;

typedef struct MethodRefSig_62 MethodRefSig_62, *PMethodRefSig_62;

struct MethodRefSig_62 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818365 RetType;
};

struct Blob_MethodRefSig_62 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_62 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1800 Blob_Generic_1800, *PBlob_Generic_1800;

struct Blob_Generic_1800 {
    byte Size; // coded integer - blob size
    byte Generic[77]; // Undefined blob contents
};

typedef struct Blob_PropertySig_829 Blob_PropertySig_829, *PBlob_PropertySig_829;

typedef struct PropertySig_829 PropertySig_829, *PPropertySig_829;

typedef struct Type_2819132 Type_2819132, *PType_2819132;

struct Type_2819132 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct PropertySig_829 {
    byte PROPERTY; // Magic (0x08) optionalled OR'd with HASTHIS (0x20)
    byte Count; // Number of params to follow RetType
    struct Type_2819132 RetType; // Return type
};

struct Blob_PropertySig_829 {
    byte Size; // coded integer - blob size
    struct PropertySig_829 PropertySig; // Contains signature for properties. Gives params for getters/setters.
};

typedef struct Blob_PropertySig_820 Blob_PropertySig_820, *PBlob_PropertySig_820;

typedef struct PropertySig_820 PropertySig_820, *PPropertySig_820;

typedef struct Type_2819123 Type_2819123, *PType_2819123;

struct Type_2819123 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct PropertySig_820 {
    byte PROPERTY; // Magic (0x08) optionalled OR'd with HASTHIS (0x20)
    byte Count; // Number of params to follow RetType
    struct Type_2819123 RetType; // Return type
};

struct Blob_PropertySig_820 {
    byte Size; // coded integer - blob size
    struct PropertySig_820 PropertySig; // Contains signature for properties. Gives params for getters/setters.
};

typedef struct Blob_CustomAttrib_841 Blob_CustomAttrib_841, *PBlob_CustomAttrib_841;

struct Blob_CustomAttrib_841 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_841 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_MethodRefSig_767 Blob_MethodRefSig_767, *PBlob_MethodRefSig_767;

typedef struct MethodRefSig_767 MethodRefSig_767, *PMethodRefSig_767;

typedef struct Type_2819070 Type_2819070, *PType_2819070;

typedef struct Type_2819071 Type_2819071, *PType_2819071;

typedef struct Type_2819072 Type_2819072, *PType_2819072;

struct Type_2819071 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819070 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819072 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_767 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819070 RetType;
    struct Type_2819071 Param0;
    struct Type_2819072 Param1;
};

struct Blob_MethodRefSig_767 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_767 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_PropertySig_824 Blob_PropertySig_824, *PBlob_PropertySig_824;

typedef struct PropertySig_824 PropertySig_824, *PPropertySig_824;

typedef struct Type_2819127 Type_2819127, *PType_2819127;

struct Type_2819127 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct PropertySig_824 {
    byte PROPERTY; // Magic (0x08) optionalled OR'd with HASTHIS (0x20)
    byte Count; // Number of params to follow RetType
    struct Type_2819127 RetType; // Return type
};

struct Blob_PropertySig_824 {
    byte Size; // coded integer - blob size
    struct PropertySig_824 PropertySig; // Contains signature for properties. Gives params for getters/setters.
};

typedef struct Blob_MethodRefSig_57 Blob_MethodRefSig_57, *PBlob_MethodRefSig_57;

typedef struct MethodRefSig_57 MethodRefSig_57, *PMethodRefSig_57;

typedef struct Type_2818360 Type_2818360, *PType_2818360;

typedef struct Type_2818361 Type_2818361, *PType_2818361;

struct Type_2818360 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818361 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct MethodRefSig_57 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818360 RetType;
    struct Type_2818361 Param0;
};

struct Blob_MethodRefSig_57 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_57 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_53 Blob_MethodRefSig_53, *PBlob_MethodRefSig_53;

typedef struct MethodRefSig_53 MethodRefSig_53, *PMethodRefSig_53;

typedef struct Type_2818356 Type_2818356, *PType_2818356;

struct Type_2818356 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct MethodRefSig_53 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818356 RetType;
};

struct Blob_MethodRefSig_53 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_53 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_LocalVarSig_1433 Blob_LocalVarSig_1433, *PBlob_LocalVarSig_1433;

typedef struct LocalVarSig_1433 LocalVarSig_1433, *PLocalVarSig_1433;

typedef struct Type_2819736 Type_2819736, *PType_2819736;

typedef struct Type_2819737 Type_2819737, *PType_2819737;

typedef struct Type_2819739 Type_2819739, *PType_2819739;

typedef struct Type_2819742 Type_2819742, *PType_2819742;

typedef struct Type_2819745 Type_2819745, *PType_2819745;

typedef struct Type_2819748 Type_2819748, *PType_2819748;

struct Type_2819736 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819745 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819737 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2819742 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819748 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2819739 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct LocalVarSig_1433 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819736 Type;
    struct Type_2819737 Type;
    struct Type_2819739 Type;
    struct Type_2819742 Type;
    struct Type_2819745 Type;
    struct Type_2819748 Type;
};

struct Blob_LocalVarSig_1433 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1433 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_MethodRefSig_48 Blob_MethodRefSig_48, *PBlob_MethodRefSig_48;

typedef struct MethodRefSig_48 MethodRefSig_48, *PMethodRefSig_48;

struct MethodRefSig_48 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818351 RetType;
};

struct Blob_MethodRefSig_48 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_48 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_PropertySig_814 Blob_PropertySig_814, *PBlob_PropertySig_814;

typedef struct PropertySig_814 PropertySig_814, *PPropertySig_814;

typedef struct Type_2819117 Type_2819117, *PType_2819117;

struct Type_2819117 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct PropertySig_814 {
    byte PROPERTY; // Magic (0x08) optionalled OR'd with HASTHIS (0x20)
    byte Count; // Number of params to follow RetType
    struct Type_2819117 RetType; // Return type
};

struct Blob_PropertySig_814 {
    byte Size; // coded integer - blob size
    struct PropertySig_814 PropertySig; // Contains signature for properties. Gives params for getters/setters.
};

typedef struct Blob_Generic_198 Blob_Generic_198, *PBlob_Generic_198;

struct Blob_Generic_198 {
    byte Size; // coded integer - blob size
    byte Generic[10]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_740 Blob_MethodRefSig_740, *PBlob_MethodRefSig_740;

typedef struct MethodRefSig_740 MethodRefSig_740, *PMethodRefSig_740;

typedef struct Type_2819043 Type_2819043, *PType_2819043;

typedef struct Type_2819044 Type_2819044, *PType_2819044;

typedef struct Type_2819045 Type_2819045, *PType_2819045;

struct Type_2819044 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819043 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2819045 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_740 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819043 RetType;
    struct Type_2819044 Param0;
    struct Type_2819045 Param1;
};

struct Blob_MethodRefSig_740 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_740 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_1 Blob_Generic_1, *PBlob_Generic_1;

struct Blob_Generic_1 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_28 Blob_MethodRefSig_28, *PBlob_MethodRefSig_28;

typedef struct MethodRefSig_28 MethodRefSig_28, *PMethodRefSig_28;

struct MethodRefSig_28 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818331 RetType;
};

struct Blob_MethodRefSig_28 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_28 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_734 Blob_MethodRefSig_734, *PBlob_MethodRefSig_734;

typedef struct MethodRefSig_734 MethodRefSig_734, *PMethodRefSig_734;

typedef struct Type_2819037 Type_2819037, *PType_2819037;

struct Type_2819037 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_734 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819037 RetType;
};

struct Blob_MethodRefSig_734 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_734 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_LocalVarSig_1416 Blob_LocalVarSig_1416, *PBlob_LocalVarSig_1416;

typedef struct LocalVarSig_1416 LocalVarSig_1416, *PLocalVarSig_1416;

typedef struct Type_2819719 Type_2819719, *PType_2819719;

struct Type_2819719 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct LocalVarSig_1416 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819719 Type;
};

struct Blob_LocalVarSig_1416 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1416 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_1604 Blob_Generic_1604, *PBlob_Generic_1604;

struct Blob_Generic_1604 {
    byte Size; // coded integer - blob size
    byte Generic[14]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_725 Blob_MethodRefSig_725, *PBlob_MethodRefSig_725;

typedef struct MethodRefSig_725 MethodRefSig_725, *PMethodRefSig_725;

typedef struct Type_2819028 Type_2819028, *PType_2819028;

typedef struct Type_2819031 Type_2819031, *PType_2819031;

struct Type_2819028 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819031 {
    struct ValueType.conflict18 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_725 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819028 RetType;
    struct Type_2819031 Param0;
};

struct Blob_MethodRefSig_725 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_725 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_FieldSig_1020 Blob_FieldSig_1020, *PBlob_FieldSig_1020;

typedef struct FieldSig_1020 FieldSig_1020, *PFieldSig_1020;

typedef struct Type_2819322 Type_2819322, *PType_2819322;

struct Type_2819322 {
    struct ValueType.conflict ELEMENT_TYPE_VALUETYPE;
};

struct FieldSig_1020 {
    byte FIELD; // Magic (0x06)
    struct Type_2819322 ELEMENT_TYPE_VALUETYPE;
};

struct Blob_FieldSig_1020 {
    byte Size; // coded integer - blob size
    struct FieldSig_1020 FieldSig; // Type information for Field
};

typedef struct Blob_FieldSig_1024 Blob_FieldSig_1024, *PBlob_FieldSig_1024;

typedef struct FieldSig_1024 FieldSig_1024, *PFieldSig_1024;

typedef struct Type_2819326 Type_2819326, *PType_2819326;

struct Type_2819326 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct FieldSig_1024 {
    byte FIELD; // Magic (0x06)
    struct Type_2819326 ELEMENT_TYPE_CLASS;
};

struct Blob_FieldSig_1024 {
    byte Size; // coded integer - blob size
    struct FieldSig_1024 FieldSig; // Type information for Field
};

typedef struct Blob_Generic_1619 Blob_Generic_1619, *PBlob_Generic_1619;

struct Blob_Generic_1619 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_FieldSig_1245 Blob_FieldSig_1245, *PBlob_FieldSig_1245;

typedef struct FieldSig_1245 FieldSig_1245, *PFieldSig_1245;

typedef struct Type_2819547 Type_2819547, *PType_2819547;

struct Type_2819547 {
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@57f9890f, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@53b4e966] ELEMENT_TYPE_GENERICINST;
};

struct FieldSig_1245 {
    byte FIELD; // Magic (0x06)
    struct Type_2819547 ELEMENT_TYPE_GENERICINST;
};

struct Blob_FieldSig_1245 {
    byte Size; // coded integer - blob size
    struct FieldSig_1245 FieldSig; // Type information for Field
};

typedef struct Blob_Generic_1628 Blob_Generic_1628, *PBlob_Generic_1628;

struct Blob_Generic_1628 {
    byte Size; // coded integer - blob size
    byte Generic[30]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_701 Blob_MethodRefSig_701, *PBlob_MethodRefSig_701;

typedef struct MethodRefSig_701 MethodRefSig_701, *PMethodRefSig_701;

typedef struct Type_2819004 Type_2819004, *PType_2819004;

typedef struct Type_2819006 Type_2819006, *PType_2819006;

typedef struct Type_2819007 Type_2819007, *PType_2819007;

struct Type_2819007 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819006 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2819004 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_701 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819004 RetType;
    struct Type_2819006 Param0;
    struct Type_2819007 Param1;
};

struct Blob_MethodRefSig_701 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_701 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_84 Blob_Generic_84, *PBlob_Generic_84;

struct Blob_Generic_84 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1190 Blob_Generic_1190, *PBlob_Generic_1190;

struct Blob_Generic_1190 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_1196 Blob_Generic_1196, *PBlob_Generic_1196;

struct Blob_Generic_1196 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_142 Blob_Generic_142, *PBlob_Generic_142;

struct Blob_Generic_142 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_148 Blob_Generic_148, *PBlob_Generic_148;

struct Blob_Generic_148 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_388 Blob_Generic_388, *PBlob_Generic_388;

struct Blob_Generic_388 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_136 Blob_MethodRefSig_136, *PBlob_MethodRefSig_136;

typedef struct MethodRefSig_136 MethodRefSig_136, *PMethodRefSig_136;

typedef struct Type_2818439 Type_2818439, *PType_2818439;

typedef struct Type_2818440 Type_2818440, *PType_2818440;

typedef struct Type_2818441 Type_2818441, *PType_2818441;

struct Type_2818439 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818441 {
    enum TypeCode ELEMENT_TYPE_I;
};

struct Type_2818440 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct MethodRefSig_136 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818439 RetType;
    struct Type_2818440 Param0;
    struct Type_2818441 Param1;
};

struct Blob_MethodRefSig_136 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_136 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_379 Blob_MethodRefSig_379, *PBlob_MethodRefSig_379;

typedef struct MethodRefSig_379 MethodRefSig_379, *PMethodRefSig_379;

typedef struct Type_2818682 Type_2818682, *PType_2818682;

typedef struct Type_2818685 Type_2818685, *PType_2818685;

typedef struct Type_2818686 Type_2818686, *PType_2818686;

struct Type_2818686 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct Type_2818685 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818682 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_379 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818682 RetType;
    struct Type_2818685 Param0;
    struct Type_2818686 Param1;
};

struct Blob_MethodRefSig_379 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_379 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_FieldSig_1236 Blob_FieldSig_1236, *PBlob_FieldSig_1236;

typedef struct FieldSig_1236 FieldSig_1236, *PFieldSig_1236;

typedef struct Type_2819538 Type_2819538, *PType_2819538;

struct Type_2819538 {
    struct GenericInstType[ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@1e91580b, ghidra.app.util.bin.format.pe.cli.blobs.CliAbstractSig$CliTypePrimitive@529aa229] ELEMENT_TYPE_GENERICINST;
};

struct FieldSig_1236 {
    byte FIELD; // Magic (0x06)
    struct Type_2819538 ELEMENT_TYPE_GENERICINST;
};

struct Blob_FieldSig_1236 {
    byte Size; // coded integer - blob size
    struct FieldSig_1236 FieldSig; // Type information for Field
};

typedef struct Blob_MethodRefSig_130 Blob_MethodRefSig_130, *PBlob_MethodRefSig_130;

typedef struct MethodRefSig_130 MethodRefSig_130, *PMethodRefSig_130;

typedef struct Type_2818433 Type_2818433, *PType_2818433;

typedef struct Type_2818434 Type_2818434, *PType_2818434;

struct Type_2818433 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818434 {
    struct ValueType.conflict4 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_130 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818433 RetType;
    struct Type_2818434 Param0;
};

struct Blob_MethodRefSig_130 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_130 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_373 Blob_MethodRefSig_373, *PBlob_MethodRefSig_373;

typedef struct MethodRefSig_373 MethodRefSig_373, *PMethodRefSig_373;

typedef struct Type_2818676 Type_2818676, *PType_2818676;

struct Type_2818676 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_373 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818676 RetType;
};

struct Blob_MethodRefSig_373 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_373 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_CustomAttrib_435 Blob_CustomAttrib_435, *PBlob_CustomAttrib_435;

struct Blob_CustomAttrib_435 {
    byte Size; // coded integer - blob size
    struct CustomAttrib_435 CustomAttrib; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
};

typedef struct Blob_FieldSig_1233 Blob_FieldSig_1233, *PBlob_FieldSig_1233;

typedef struct FieldSig_1233 FieldSig_1233, *PFieldSig_1233;

typedef struct Type_2819535 Type_2819535, *PType_2819535;

struct Type_2819535 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct FieldSig_1233 {
    byte FIELD; // Magic (0x06)
    struct Type_2819535 ELEMENT_TYPE_OBJECT;
};

struct Blob_FieldSig_1233 {
    byte Size; // coded integer - blob size
    struct FieldSig_1233 FieldSig; // Type information for Field
};

typedef struct Blob_Generic_95 Blob_Generic_95, *PBlob_Generic_95;

struct Blob_Generic_95 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_90 Blob_Generic_90, *PBlob_Generic_90;

struct Blob_Generic_90 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_373 Blob_Generic_373, *PBlob_Generic_373;

struct Blob_Generic_373 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_130 Blob_Generic_130, *PBlob_Generic_130;

struct Blob_Generic_130 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_1045 Blob_LocalVarSig_1045, *PBlob_LocalVarSig_1045;

typedef struct LocalVarSig_1045 LocalVarSig_1045, *PLocalVarSig_1045;

typedef struct Type_2819348 Type_2819348, *PType_2819348;

typedef struct Type_2819349 Type_2819349, *PType_2819349;

typedef struct Type_2819350 Type_2819350, *PType_2819350;

struct Type_2819349 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2819348 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct Type_2819350 {
    struct ValueType.conflict20 ELEMENT_TYPE_VALUETYPE;
};

struct LocalVarSig_1045 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819348 Type;
    struct Type_2819349 Type;
    struct Type_2819350 Type;
};

struct Blob_LocalVarSig_1045 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1045 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_379 Blob_Generic_379, *PBlob_Generic_379;

struct Blob_Generic_379 {
    byte Size; // coded integer - blob size
    byte Generic[8]; // Undefined blob contents
};

typedef struct Blob_Generic_136 Blob_Generic_136, *PBlob_Generic_136;

struct Blob_Generic_136 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_360 Blob_MethodRefSig_360, *PBlob_MethodRefSig_360;

typedef struct MethodRefSig_360 MethodRefSig_360, *PMethodRefSig_360;

typedef struct Type_2818663 Type_2818663, *PType_2818663;

typedef struct Type_2818664 Type_2818664, *PType_2818664;

typedef struct Type_2818665 Type_2818665, *PType_2818665;

typedef struct Type_2818666 Type_2818666, *PType_2818666;

struct Type_2818663 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818665 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818664 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818666 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct MethodRefSig_360 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818663 RetType;
    struct Type_2818664 Param0;
    struct Type_2818665 Param1;
    struct Type_2818666 Param2;
};

struct Blob_MethodRefSig_360 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_360 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_124 Blob_MethodRefSig_124, *PBlob_MethodRefSig_124;

typedef struct MethodRefSig_124 MethodRefSig_124, *PMethodRefSig_124;

typedef struct Type_2818427 Type_2818427, *PType_2818427;

typedef struct Type_2818428 Type_2818428, *PType_2818428;

struct Type_2818427 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818428 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_124 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818427 RetType;
    struct Type_2818428 Param0;
};

struct Blob_MethodRefSig_124 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_124 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_360 Blob_Generic_360, *PBlob_Generic_360;

struct Blob_Generic_360 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_62 Blob_Generic_62, *PBlob_Generic_62;

struct Blob_Generic_62 {
    byte Size; // coded integer - blob size
    byte Generic[3]; // Undefined blob contents
};

typedef struct Blob_Generic_367 Blob_Generic_367, *PBlob_Generic_367;

struct Blob_Generic_367 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_124 Blob_Generic_124, *PBlob_Generic_124;

struct Blob_Generic_124 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_66 Blob_Generic_66, *PBlob_Generic_66;

struct Blob_Generic_66 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_354 Blob_MethodRefSig_354, *PBlob_MethodRefSig_354;

typedef struct MethodRefSig_354 MethodRefSig_354, *PMethodRefSig_354;

typedef struct Type_2818657 Type_2818657, *PType_2818657;

struct Type_2818657 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_354 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818657 RetType;
};

struct Blob_MethodRefSig_354 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_354 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_113 Blob_MethodRefSig_113, *PBlob_MethodRefSig_113;

typedef struct MethodRefSig_113 MethodRefSig_113, *PMethodRefSig_113;

typedef struct Type_2818416 Type_2818416, *PType_2818416;

typedef struct Type_2818417 Type_2818417, *PType_2818417;

struct Type_2818416 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818417 {
    struct ValueType.conflict3 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_113 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818416 RetType;
    struct Type_2818417 Param0;
};

struct Blob_MethodRefSig_113 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_113 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_593 Blob_MethodRefSig_593, *PBlob_MethodRefSig_593;

typedef struct MethodRefSig_593 MethodRefSig_593, *PMethodRefSig_593;

typedef struct Type_2818896 Type_2818896, *PType_2818896;

typedef struct Type_2818897 Type_2818897, *PType_2818897;

struct Type_2818896 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818897 {
    struct ValueType.conflict15 ELEMENT_TYPE_VALUETYPE;
};

struct MethodRefSig_593 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818896 RetType;
    struct Type_2818897 Param0;
};

struct Blob_MethodRefSig_593 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_593 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_119 Blob_MethodRefSig_119, *PBlob_MethodRefSig_119;

typedef struct MethodRefSig_119 MethodRefSig_119, *PMethodRefSig_119;

typedef struct Type_2818422 Type_2818422, *PType_2818422;

struct Type_2818422 {
    struct Class ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_119 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818422 RetType;
};

struct Blob_MethodRefSig_119 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_119 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_73 Blob_Generic_73, *PBlob_Generic_73;

struct Blob_Generic_73 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_1261 Blob_LocalVarSig_1261, *PBlob_LocalVarSig_1261;

typedef struct LocalVarSig_1261 LocalVarSig_1261, *PLocalVarSig_1261;

typedef struct Type_2819564 Type_2819564, *PType_2819564;

typedef struct Type_2819568 Type_2819568, *PType_2819568;

typedef struct Type_2819569 Type_2819569, *PType_2819569;

typedef struct Type_2819572 Type_2819572, *PType_2819572;

struct Type_2819569 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819564 {
    struct SzArray.conflict1 ELEMENT_TYPE_SZARRAY;
};

struct Type_2819572 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819568 {
    enum TypeCode ELEMENT_TYPE_I4;
};

struct LocalVarSig_1261 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819564 Type;
    struct Type_2819568 Type;
    struct Type_2819569 Type;
    struct Type_2819572 Type;
};

struct Blob_LocalVarSig_1261 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1261 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_593 Blob_Generic_593, *PBlob_Generic_593;

struct Blob_Generic_593 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_113 Blob_Generic_113, *PBlob_Generic_113;

struct Blob_Generic_113 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_354 Blob_Generic_354, *PBlob_Generic_354;

struct Blob_Generic_354 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_Generic_119 Blob_Generic_119, *PBlob_Generic_119;

struct Blob_Generic_119 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_Generic_78 Blob_Generic_78, *PBlob_Generic_78;

struct Blob_Generic_78 {
    byte Size; // coded integer - blob size
    byte Generic[5]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_587 Blob_MethodRefSig_587, *PBlob_MethodRefSig_587;

typedef struct MethodRefSig_587 MethodRefSig_587, *PMethodRefSig_587;

typedef struct Type_2818890 Type_2818890, *PType_2818890;

typedef struct Type_2818892 Type_2818892, *PType_2818892;

struct Type_2818892 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818890 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct MethodRefSig_587 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818890 RetType;
    struct Type_2818892 Param0;
};

struct Blob_MethodRefSig_587 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_587 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_101 Blob_MethodRefSig_101, *PBlob_MethodRefSig_101;

typedef struct MethodRefSig_101 MethodRefSig_101, *PMethodRefSig_101;

typedef struct Type_2818404 Type_2818404, *PType_2818404;

typedef struct Type_2818405 Type_2818405, *PType_2818405;

typedef struct Type_2818406 Type_2818406, *PType_2818406;

struct Type_2818405 {
    enum TypeCode ELEMENT_TYPE_R4;
};

struct Type_2818404 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct Type_2818406 {
    enum TypeCode ELEMENT_TYPE_R4;
};

struct MethodRefSig_101 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818404 RetType;
    struct Type_2818405 Param0;
    struct Type_2818406 Param1;
};

struct Blob_MethodRefSig_101 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_101 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_341 Blob_MethodRefSig_341, *PBlob_MethodRefSig_341;

typedef struct MethodRefSig_341 MethodRefSig_341, *PMethodRefSig_341;

typedef struct Type_2818645 Type_2818645, *PType_2818645;

typedef struct Type_2818647 Type_2818647, *PType_2818647;

struct Type_2818647 {
    struct ELEMENT_TYPE_MVAR_2818648 ELEMENT_TYPE_MVAR;
};

struct Type_2818645 {
    struct ELEMENT_TYPE_MVAR_2818646 ELEMENT_TYPE_MVAR;
};

struct MethodRefSig_341 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte GenParamCount; // Number of generic paramameters for the method
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818645 RetType;
    struct Type_2818647 Param0;
};

struct Blob_MethodRefSig_341 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_341 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_581 Blob_MethodRefSig_581, *PBlob_MethodRefSig_581;

typedef struct MethodRefSig_581 MethodRefSig_581, *PMethodRefSig_581;

typedef struct Type_2818884 Type_2818884, *PType_2818884;

struct Type_2818884 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_581 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818884 RetType;
};

struct Blob_MethodRefSig_581 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_581 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_107 Blob_MethodRefSig_107, *PBlob_MethodRefSig_107;

typedef struct MethodRefSig_107 MethodRefSig_107, *PMethodRefSig_107;

typedef struct Type_2818410 Type_2818410, *PType_2818410;

typedef struct Type_2818411 Type_2818411, *PType_2818411;

struct Type_2818411 {
    struct ValueType.conflict2 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818410 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_107 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818410 RetType;
    struct Type_2818411 Param0;
};

struct Blob_MethodRefSig_107 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_107 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_181 Blob_Generic_181, *PBlob_Generic_181;

struct Blob_Generic_181 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_LocalVarSig_1498 Blob_LocalVarSig_1498, *PBlob_LocalVarSig_1498;

typedef struct LocalVarSig_1498 LocalVarSig_1498, *PLocalVarSig_1498;

typedef struct Type_2819801 Type_2819801, *PType_2819801;

typedef struct Type_2819804 Type_2819804, *PType_2819804;

typedef struct Type_2819807 Type_2819807, *PType_2819807;

typedef struct Type_2819808 Type_2819808, *PType_2819808;

typedef struct Type_2819809 Type_2819809, *PType_2819809;

struct Type_2819801 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819807 {
    enum TypeCode ELEMENT_TYPE_OBJECT;
};

struct Type_2819809 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819804 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct Type_2819808 {
    enum TypeCode ELEMENT_TYPE_BOOLEAN;
};

struct LocalVarSig_1498 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819801 Type;
    struct Type_2819804 Type;
    struct Type_2819807 Type;
    struct Type_2819808 Type;
    struct Type_2819809 Type;
};

struct Blob_LocalVarSig_1498 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1498 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_Generic_186 Blob_Generic_186, *PBlob_Generic_186;

struct Blob_Generic_186 {
    byte Size; // coded integer - blob size
    byte Generic[4]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_335 Blob_MethodRefSig_335, *PBlob_MethodRefSig_335;

typedef struct MethodRefSig_335 MethodRefSig_335, *PMethodRefSig_335;

typedef struct Type_2818638 Type_2818638, *PType_2818638;

struct Type_2818638 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_335 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818638 RetType;
};

struct Blob_MethodRefSig_335 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_335 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_573 Blob_MethodRefSig_573, *PBlob_MethodRefSig_573;

typedef struct MethodRefSig_573 MethodRefSig_573, *PMethodRefSig_573;

typedef struct Type_2818876 Type_2818876, *PType_2818876;

typedef struct Type_2818877 Type_2818877, *PType_2818877;

typedef struct Type_2818878 Type_2818878, *PType_2818878;

struct Type_2818878 {
    struct ValueType.conflict14 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818877 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818876 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_573 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818876 RetType;
    struct Type_2818877 Param0;
    struct Type_2818878 Param1;
};

struct Blob_MethodRefSig_573 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_573 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_191 Blob_Generic_191, *PBlob_Generic_191;

struct Blob_Generic_191 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_Generic_170 Blob_Generic_170, *PBlob_Generic_170;

struct Blob_Generic_170 {
    byte Size; // coded integer - blob size
    byte Generic[10]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_321 Blob_MethodRefSig_321, *PBlob_MethodRefSig_321;

typedef struct MethodRefSig_321 MethodRefSig_321, *PMethodRefSig_321;

typedef struct Type_2818624 Type_2818624, *PType_2818624;

typedef struct Type_2818627 Type_2818627, *PType_2818627;

struct Type_2818624 {
    struct ValueType.conflict12 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818627 {
    enum TypeCode ELEMENT_TYPE_R8;
};

struct MethodRefSig_321 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818624 RetType;
    struct Type_2818627 Param0;
};

struct Blob_MethodRefSig_321 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_321 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_328 Blob_MethodRefSig_328, *PBlob_MethodRefSig_328;

typedef struct MethodRefSig_328 MethodRefSig_328, *PMethodRefSig_328;

typedef struct Type_2818631 Type_2818631, *PType_2818631;

typedef struct Type_2818632 Type_2818632, *PType_2818632;

struct Type_2818632 {
    struct ValueType.conflict12 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818631 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_328 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818631 RetType;
    struct Type_2818632 Param0;
};

struct Blob_MethodRefSig_328 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_328 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_95 Blob_MethodRefSig_95, *PBlob_MethodRefSig_95;

typedef struct MethodRefSig_95 MethodRefSig_95, *PMethodRefSig_95;

typedef struct Type_2818398 Type_2818398, *PType_2818398;

typedef struct Type_2818399 Type_2818399, *PType_2818399;

struct Type_2818399 {
    struct ValueType.conflict1 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818398 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_95 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818398 RetType;
    struct Type_2818399 Param0;
};

struct Blob_MethodRefSig_95 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_95 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_163 Blob_Generic_163, *PBlob_Generic_163;

struct Blob_Generic_163 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_90 Blob_MethodRefSig_90, *PBlob_MethodRefSig_90;

typedef struct MethodRefSig_90 MethodRefSig_90, *PMethodRefSig_90;

typedef struct Type_2818393 Type_2818393, *PType_2818393;

typedef struct Type_2818394 Type_2818394, *PType_2818394;

struct Type_2818394 {
    enum TypeCode ELEMENT_TYPE_STRING;
};

struct Type_2818393 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_90 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818393 RetType;
    struct Type_2818394 Param0;
};

struct Blob_MethodRefSig_90 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_90 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_798 Blob_MethodRefSig_798, *PBlob_MethodRefSig_798;

typedef struct MethodRefSig_798 MethodRefSig_798, *PMethodRefSig_798;

typedef struct Type_2819101 Type_2819101, *PType_2819101;

typedef struct Type_2819102 Type_2819102, *PType_2819102;

struct Type_2819102 {
    struct ValueType.conflict19 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2819101 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_798 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2819101 RetType;
    struct Type_2819102 Param0;
};

struct Blob_MethodRefSig_798 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_798 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_315 Blob_MethodRefSig_315, *PBlob_MethodRefSig_315;

typedef struct MethodRefSig_315 MethodRefSig_315, *PMethodRefSig_315;

typedef struct Type_2818618 Type_2818618, *PType_2818618;

struct Type_2818618 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_315 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818618 RetType;
};

struct Blob_MethodRefSig_315 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_315 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_LocalVarSig_1224 Blob_LocalVarSig_1224, *PBlob_LocalVarSig_1224;

typedef struct LocalVarSig_1224 LocalVarSig_1224, *PLocalVarSig_1224;

typedef struct Type_2819527 Type_2819527, *PType_2819527;

typedef struct Type_2819529 Type_2819529, *PType_2819529;

typedef struct Type_2819531 Type_2819531, *PType_2819531;

struct Type_2819527 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2819531 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct Type_2819529 {
    struct SzArray.conflict ELEMENT_TYPE_SZARRAY;
};

struct LocalVarSig_1224 {
    byte LOCAL_SIG; // Magic (0x07)
    byte Count; // Number of types to follow
    struct Type_2819527 Type;
    struct Type_2819529 Type;
    struct Type_2819531 Type;
};

struct Blob_LocalVarSig_1224 {
    byte Size; // coded integer - blob size
    struct LocalVarSig_1224 LocalVarSig; // Contains signature for function locals
};

typedef struct Blob_MethodRefSig_84 Blob_MethodRefSig_84, *PBlob_MethodRefSig_84;

typedef struct MethodRefSig_84 MethodRefSig_84, *PMethodRefSig_84;

typedef struct Type_2818387 Type_2818387, *PType_2818387;

typedef struct Type_2818388 Type_2818388, *PType_2818388;

struct Type_2818388 {
    struct ValueType.conflict ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818387 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_84 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818387 RetType;
    struct Type_2818388 Param0;
};

struct Blob_MethodRefSig_84 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_84 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_Generic_153 Blob_Generic_153, *PBlob_Generic_153;

struct Blob_Generic_153 {
    byte Size; // coded integer - blob size
    byte Generic[9]; // Undefined blob contents
};

typedef struct Blob_Generic_395 Blob_Generic_395, *PBlob_Generic_395;

struct Blob_Generic_395 {
    byte Size; // coded integer - blob size
    byte Generic[6]; // Undefined blob contents
};

typedef struct Blob_MethodRefSig_302 Blob_MethodRefSig_302, *PBlob_MethodRefSig_302;

typedef struct MethodRefSig_302 MethodRefSig_302, *PMethodRefSig_302;

typedef struct Type_2818605 Type_2818605, *PType_2818605;

struct Type_2818605 {
    struct Class.conflict ELEMENT_TYPE_CLASS;
};

struct MethodRefSig_302 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818605 RetType;
};

struct Blob_MethodRefSig_302 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_302 MethodRefSig; // Type info for imported method return and params
};

typedef struct Blob_MethodRefSig_308 Blob_MethodRefSig_308, *PBlob_MethodRefSig_308;

typedef struct MethodRefSig_308 MethodRefSig_308, *PMethodRefSig_308;

typedef struct Type_2818611 Type_2818611, *PType_2818611;

typedef struct Type_2818612 Type_2818612, *PType_2818612;

struct Type_2818612 {
    struct ValueType.conflict11 ELEMENT_TYPE_VALUETYPE;
};

struct Type_2818611 {
    enum TypeCode ELEMENT_TYPE_VOID;
};

struct MethodRefSig_308 {
    byte Flags; // ORed VARARG/GENERIC/HASTHIS/EXPLICITTHIS
    byte ParamCount; // Number of parameter types to follow RetType
    struct Type_2818611 RetType;
    struct Type_2818612 Param0;
};

struct Blob_MethodRefSig_308 {
    byte Size; // coded integer - blob size
    struct MethodRefSig_308 MethodRefSig; // Type info for imported method return and params
};

typedef struct ParamRow ParamRow, *PParamRow;

typedef enum ParamAttributes {
    In=1,
    Out=2,
    Optional=16,
    HasDefault=4096,
    HasFieldMarshal=8192,
    Unused=53216
} ParamAttributes;

struct ParamRow {
    enum ParamAttributes Flags; // bitmask of type ParamAttributes
    word Sequence; // constant
    word Name; // index into String heap
};

typedef struct AssemblyRef Row AssemblyRef Row, *PAssemblyRef Row;

typedef enum AssemblyFlags {
    PublicKey=1,
    Retargetable=256,
    DisableJITcompileOptimizer=16384,
    EnableJITcompileTracking=32768
} AssemblyFlags;

struct AssemblyRef Row {
    word MajorVersion;
    word MinorVersion;
    word BuildNumber;
    word RevisionNumber;
    enum AssemblyFlags Flags; // Bitmask of type AssemblyFlags
    word PublicKeyOrToken; // Public Key or token identifying the author of the assembly.
    word Name; // index into String heap
    word Culture; // index into String heap
    word HashValue; // index into Blob heap
};

typedef struct ManifestResource Row ManifestResource Row, *PManifestResource Row;

typedef enum ManifestResourceAttributes {
    Public=1,
    Private=2
} ManifestResourceAttributes;

struct ManifestResource Row {
    dword Offset;
    enum ManifestResourceAttributes Flags; // Bitmask of type ManifestResourceAttributes
    word Name; // index into String heap
    word Implementation; // Implementation coded index
};

typedef struct ImplMap Row ImplMap Row, *PImplMap Row;

typedef enum PInvokeAttributes {
    CharSetNotSpec=0,
    NoMangle=1,
    CharSetAnsi=2,
    CharSetUnicode=4,
    CharSetAuto=6,
    SupportsLastError=64,
    CallConvPlatformapi=256,
    CallConvCdecl=512,
    CallConvStdcall=768,
    CallConvThiscall=1024,
    CallConvFastcall=1280
} PInvokeAttributes;

struct ImplMap Row {
    enum PInvokeAttributes MappingFlags; // Bitmask of type PInvokeAttributes
    word MemberForwarded; // MemberForwarded Coded Index
    word ImportName; // index into String heap
    word ImportScope; // Index into ModuleRef table
};

typedef struct MethodSpec Row MethodSpec Row, *PMethodSpec Row;

struct MethodSpec Row {
    word Method; // MethodDefOrRef coded index
    word Instantiation; // index into Blob heap, signature of this instantiation
};

typedef struct Property Row Property Row, *PProperty Row;

typedef enum PropertyAttributes {
    SpecialName=512,
    RTSpecialName=1024,
    HasDefault=4096,
    Unused=59903
} PropertyAttributes;

struct Property Row {
    enum PropertyAttributes Flags; // Bitmask of type PropertyAttributes
    word Name;
    word Type; // Blob index to the signature, not a TypeDef/TypeRef
};

typedef struct MethodSemantics Row MethodSemantics Row, *PMethodSemantics Row;

typedef enum MethodSemanticsAttributes {
    Setter=1,
    Getter=2,
    Other=4,
    AddOn=8,
    RemoveOn=16,
    Fire=32
} MethodSemanticsAttributes;

struct MethodSemantics Row {
    enum MethodSemanticsAttributes Semantics; // Bitmask of type MethodSemanticsAttributes
    word Method; // index into MethodDef table
    word Association; // HasSemantics coded index into Event or Property
};

typedef struct Field Row Field Row, *PField Row;

typedef enum FieldAttributes {
    Access_CompilerControlled=0,
    Access_Private=1,
    Access_FamANDAssem=2,
    Access_Assembly=3,
    Access_Family=4,
    Access_FamORAssem=5,
    Access_Public=6,
    Static=16,
    InitOnly=32,
    Literal=64,
    NotSerialized=128,
    HasFieldRVA=256,
    SpecialName=512,
    RTSpecialName=1024,
    HasFieldMarshal=4096,
    PInvokeImpl=8192,
    HasDefault=32768
} FieldAttributes;

struct Field Row {
    enum FieldAttributes Flags; // see CorFieldAttr
    word Name; // index into String heap
    word Signature; // index into Blob heap
};

typedef struct MethodDef Row MethodDef Row, *PMethodDef Row;

typedef enum MethodImplAttributes {
    CodeType_IL=0,
    CodeType_Native=1,
    CodeType_OPTIL=2,
    CodeType_Runtime=3,
    Unmanaged=4,
    NoInlining=8,
    ForwardRef=16,
    Synchronized=32,
    NoOptimization=64,
    PreserveSig=128,
    InternalCall=4096,
    MaxMethodImplVal=65535
} MethodImplAttributes;

typedef enum MethodAttributes {
    MAccess_CompilerControlled=0,
    MAccess_Private=1,
    MAccess_FamANDAssem=2,
    MAccess_Assem=3,
    MAccess_Family=4,
    MAccess_FamORAssem=5,
    MAccess_Public=6,
    UnmanagedExport=8,
    Static=16,
    Final=32,
    Virtual=64,
    HideBySig=128,
    VtableLayout_NewSlot=256,
    Strict=512,
    Abstract=1024,
    SpecialName=2048,
    RTSpecialName=4096,
    PInvokeImpl=8192,
    HasSecurity=16384,
    RequireSecObject=32768
} MethodAttributes;

struct MethodDef Row {
    dword RVA;
    enum MethodImplAttributes ImplFlags; // Bitmask of type MethodImplAttributes
    enum MethodAttributes Flags; // Bitmask of type MethodAttribute
    word Name; // index into String heap
    word Signature; // index into Blob heap
    word ParamList; // index into Param table
};

typedef struct TypeSpec Row TypeSpec Row, *PTypeSpec Row;

struct TypeSpec Row {
    word Signature; // index into Blob heap
};

typedef struct NestedClass Row NestedClass Row, *PNestedClass Row;

struct NestedClass Row {
    word NestedClass; // TypeDef index
    word EnclosingClass; // TypeDef index
};

typedef struct MemberRef Row MemberRef Row, *PMemberRef Row;

struct MemberRef Row {
    word Class; // index-MemberRefParent coded
    word Name; // index into String heap
    word Signature; // index into Blob heap
};

typedef struct TypeDef Row TypeDef Row, *PTypeDef Row;

typedef enum TypeAttributes {
    Visibility_NotPublic=0,
    Visibility_Public=1,
    Visibility_NestedPublic=2,
    Visibility_NestedPrivate=3,
    Visibility_NestedFamily=4,
    Visibility_NestedAssembly=5,
    Visibility_NestedFamANDAssem=6,
    Visibility_NestedFamORAssem=7,
    SequentialLayout=8,
    ExplicitLayout=16,
    Interface=32,
    Abstract=128,
    Sealed=256,
    SpecialName=1024,
    RTSpecialName=2048,
    Import=4096,
    Serializable=8192,
    UnicodeClass=65536,
    AutoClass=131072,
    CustomFormatClass=196608,
    HasSecurity=262144,
    BeforeFieldInit=1048576,
    IsTypeForwarder=2097152,
    CustomStringFormatMask=12582912
} TypeAttributes;

struct TypeDef Row {
    enum TypeAttributes Flags; // see CorTypeAttr
    word TypeName; // index into String heap
    word TypeNamespace; // index into String heap
    word Extends; // index: coded TypeDefOrRef
    word FieldList; // index into Field table
    word MethodList; // index into MethodDef table
};

typedef struct ModuleRef Row ModuleRef Row, *PModuleRef Row;

struct ModuleRef Row {
    word Name; // index into String heap
};

typedef struct StandAloneSig Row StandAloneSig Row, *PStandAloneSig Row;

struct StandAloneSig Row {
    word Signature;
};

typedef struct TypeRef Row TypeRef Row, *PTypeRef Row;

struct TypeRef Row {
    word ResolutionScope;
    word TypeName;
    word TypeNamespace;
};

typedef struct Constant Row Constant Row, *PConstant Row;

struct Constant Row {
    enum TypeCode Type; // if Class, indicates nullref
    byte Reserved; // should be 0
    word Parent; // index - coded HasConstant
    word Value; // index into Blob heap
};

typedef struct PropertyMap Row PropertyMap Row, *PPropertyMap Row;

struct PropertyMap Row {
    word Parent;
    word options; // Index into Property table. Points to contiguous run of Properties until next ref from PropertyMap or end of table.
};

typedef struct CustomAttribute Row CustomAttribute Row, *PCustomAttribute Row;

struct CustomAttribute Row {
    word Parent;
    word Type;
    word Value;
};

typedef struct DeclSecurity Row DeclSecurity Row, *PDeclSecurity Row;

struct DeclSecurity Row {
    word Action; // Points to a System.Security.SecurityAction as described in ISO23271 IV
    word Parent;
    word PermissionSet;
};

typedef struct MethodImpl Row MethodImpl Row, *PMethodImpl Row;

struct MethodImpl Row {
    word Class; // index into TypeDef
    word MethodBody; // MethodDefOrRef coded index
    word MethodDeclaration; // MethodDefOrRef coded index
};

typedef struct Assembly Table Assembly Table, *PAssembly Table;

typedef enum AssemblyHash {
    None=0,
    Reserved (MD5)=32771,
    SHA1=32772
} AssemblyHash;

struct Assembly Table {
    enum AssemblyHash HashAlg; // Type of hash present
    word MajorVersion;
    word MinorVersion;
    word BuildNumber;
    word RevisionNumber;
    enum AssemblyFlags Flags; // Bitmask of type AssemblyFlags
    word PublicKey; // index into Blob heap
    word Name; // index into String heap
    word Culture; // index into String heap
};

typedef struct Module Row Module Row, *PModule Row;

struct Module Row {
    word Generation; // reserved, shall be 0
    word Name; // index into String heap
    word MvId; // used to distinguish between versions of same module
    word EncId; // reserved, shall be 0
    word EncBaseId; // reserved, shall be 0
};

typedef struct #US #US, *P#US;

struct #US {
    byte Reserved; // Always 0
    byte Next string size;
    wchar16 [1][6];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [f][91];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [c8][11];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [e0][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [f0][35];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [138][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [144][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [162][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [16e][18];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [194][19];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1bc][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1da][11];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1f2][19];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [21a][11];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [232][9];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [246][17];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26a][9];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27e][13];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [29a][10];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2b0][12];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2ca][17];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2ee][15];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [30e][9];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [322][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [340][12];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [35a][19];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [384][19];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [3ac][57];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [420][18];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [446][15];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [466][15];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [486][70];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [515][59];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [58d][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [5ab][1];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [5af][53];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [61b][16];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [63d][1];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [641][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [653][24];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [685][21];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [6b1][57];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [725][9];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [739][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [757][12];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [771][85];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [81e][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [830][28];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [86a][85];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [917][86];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [9c6][82];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [a6d][85];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [b1a][86];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [bc9][86];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [c78][85];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [d25][90];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [ddc][101];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [ea9][99];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [f72][86];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [1021][85];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [10ce][86];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [117d][83];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [1226][84];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [12d1][83];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [137a][85];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [1427][86];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [14d6][93];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [1593][91];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [164c][84];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [16f7][85];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [17a4][87];
    byte Extra byte; // 0x01 if string contains non-ASCII
    word Next string size;
    wchar16 [1855][81];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [18fa][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1918][21];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1944][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1950][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [195a][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1964][11];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [197c][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1986][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1996][2];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [199c][6];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [19aa][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [19bc][6];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [19ca][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [19dc][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [19ec][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [19f8][19];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1a20][11];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1a38][1];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1a3c][32];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1a7e][13];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1a9a][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1aac][10];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1ac2][16];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1ae4][25];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1b18][25];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1b4c][12];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1b66][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1b72][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1b7e][10];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1b94][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1ba4][12];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1bbe][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1bce][12];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1be8][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1bf8][10];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1c0e][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1c1e][11];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1c36][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1c46][11];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1c5e][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1c6e][9];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1c82][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1c92][15];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1cb2][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1cc2][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1ccc][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1cdc][13];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1cf8][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1d0a][13];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1d26][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1d38][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1d4a][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1d5c][10];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1d72][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1d84][16];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1da6][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1db8][16];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1dda][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1dec][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1dfc][60];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1e76][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1e88][18];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1eae][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1ec0][18];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1ee6][15];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1f06][13];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1f22][21];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1f4e][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1f6c][13];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1f88][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1f9a][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1faa][30];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [1fe8][31];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2028][28];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2062][6];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2070][10];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2086][12];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [20a0][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [20aa][12];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [20c4][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [20ce][12];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [20e8][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2106][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2116][13];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2132][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2144][9];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2158][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2176][53];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [21e2][37];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [222e][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [223a][36];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2284][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [228e][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [229a][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [22a4][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [22ae][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [22b8][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [22c2][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [22cc][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [22d6][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [22e0][6];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [22ee][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [22f6][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2300][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [230a][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2314][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [231e][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2328][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2332][2];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2338][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2342][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [234a][2];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2350][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [235a][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2364][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [236c][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2378][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2382][6];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2390][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2398][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23a0][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23aa][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23b4][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23c0][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23c8][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23d2][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23dc][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23e6][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23f0][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [23fa][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2404][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [240e][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2418][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2422][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [242e][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2438][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2444][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2454][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [245e][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2468][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2472][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [247e][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [248a][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2496][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24a2][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24ac][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24b8][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24c2][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24cc][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24d4][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24de][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24e6][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24f0][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [24fa][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2504][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [250e][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2516][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2520][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [252a][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2534][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2540][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [254c][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2558][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2564][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2570][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [257a][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2584][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [258e][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2598][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [25a2][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [25ac][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [25b6][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [25c0][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [25cc][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [25d8][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [25e4][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [25f0][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [25fc][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2606][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2612][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [261c][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2626][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2630][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [263a][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2644][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2650][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [265c][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2668][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2674][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2680][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [268c][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2698][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26a4][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26b0][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26ba][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26c4][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26ce][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26d8][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26e2][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26ec][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [26f6][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2700][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [270a][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2712][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [271c][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2726][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2730][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [273a][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2746][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2750][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [275a][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2764][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [276e][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2778][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2782][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [278c][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2798][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27a2][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27ac][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27b6][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27c0][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27ca][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27d4][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27e4][5];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27f0][4];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [27fa][20];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2824][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2836][19];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [285e][19];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2886][19];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [28ae][14];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [28cc][15];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [28ec][17];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2910][15];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2930][24];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2962][30];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [29a0][35];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [29e8][35];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2a30][24];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2a62][38];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2ab0][22];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2ade][26];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2b14][27];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2b4c][34];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2b92][26];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2bc8][29];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2c04][38];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2c52][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2c64][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2c74][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2c7c][8];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2c8e][3];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2c96][6];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2ca4][29];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2ce0][31];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2d20][11];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2d38][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2d48][7];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2d58][30];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2d96][29];
    byte Extra byte; // 0x01 if string contains non-ASCII
    byte Next string size;
    wchar16 [2dd2][52];
    byte Extra byte; // 0x01 if string contains non-ASCII
};

typedef struct #GUID #GUID, *P#GUID;

struct #GUID {
    GUID [0];
};

typedef struct #Strings #Strings, *P#Strings;

struct #Strings {
    char [0][1];
    char [1][9];
    char [a][9];
    char [13][14];
    char [21][7];
    char [28][7];
    char [2f][8];
    char [37][9];
    char [40][16];
    char [50][6];
    char [56][13];
    char [63][8];
    char [6b][9];
    char [74][8];
    char [7c][9];
    char [85][8];
    char [8d][9];
    char [96][8];
    char [9e][9];
    char [a7][8];
    char [af][9];
    char [b8][8];
    char [c0][9];
    char [c9][8];
    char [d1][8];
    char [d9][9];
    char [e2][7];
    char [e9][11];
    char [f4][22];
    char [10a][19];
    char [11d][6];
    char [123][12];
    char [12f][18];
    char [141][10];
    char [14b][21];
    char [160][7];
    char [167][6];
    char [16d][6];
    char [173][27];
    char [18e][30];
    char [1ac][31];
    char [1cb][33];
    char [1ec][36];
    char [210][30];
    char [22e][24];
    char [246][33];
    char [267][24];
    char [27f][32];
    char [29f][8];
    char [2a7][13];
    char [2b4][8];
    char [2bc][9];
    char [2c5][9];
    char [2ce][27];
    char [2e9][8];
    char [2f1][9];
    char [2fa][18];
    char [30c][15];
    char [31b][11];
    char [326][16];
    char [336][9];
    char [33f][17];
    char [350][21];
    char [365][4];
    char [369][16];
    char [379][11];
    char [384][10];
    char [38e][12];
    char [39a][6];
    char [3a0][9];
    char [3a9][31];
    char [3c8][53];
    char [3fd][13];
    char [40a][5];
    char [40f][9];
    char [418][18];
    char [42a][12];
    char [436][15];
    char [445][9];
    char [44e][12];
    char [45a][16];
    char [46a][12];
    char [476][7];
    char [47d][9];
    char [486][18];
    char [498][9];
    char [4a1][12];
    char [4ad][17];
    char [4be][16];
    char [4ce][11];
    char [4d9][12];
    char [4e5][12];
    char [4f1][9];
    char [4fa][10];
    char [504][11];
    char [50f][12];
    char [51b][18];
    char [52d][18];
    char [53f][21];
    char [554][10];
    char [55e][10];
    char [568][11];
    char [573][8];
    char [57b][20];
    char [58f][15];
    char [59e][15];
    char [5ad][6];
    char [5b3][9];
    char [5bc][9];
    char [5c5][13];
    char [5d2][10];
    char [5dc][12];
    char [5e8][8];
    char [5f0][19];
    char [603][22];
    char [619][9];
    char [622][10];
    char [62c][8];
    char [634][13];
    char [641][5];
    char [646][19];
    char [659][12];
    char [665][12];
    char [671][12];
    char [67d][16];
    char [68d][8];
    char [695][11];
    char [6a0][24];
    char [6b8][6];
    char [6be][8];
    char [6c6][17];
    char [6d7][21];
    char [6ec][7];
    char [6f3][6];
    char [6f9][17];
    char [70a][14];
    char [718][19];
    char [72b][18];
    char [73d][18];
    char [74f][19];
    char [762][27];
    char [77d][14];
    char [78b][23];
    char [7a2][26];
    char [7bc][29];
    char [7d9][34];
    char [7fb][20];
    char [80f][25];
    char [828][20];
    char [83c][23];
    char [853][27];
    char [86e][25];
    char [887][29];
    char [8a4][31];
    char [8c3][29];
    char [8e0][32];
    char [900][25];
    char [919][27];
    char [934][25];
    char [94d][30];
    char [96b][20];
    char [97f][5];
    char [984][12];
    char [990][9];
    char [999][6];
    char [99f][5];
    char [9a4][12];
    char [9b0][20];
    char [9c4][30];
    char [9e2][35];
    char [a05][28];
    char [a21][12];
    char [a2d][36];
    char [a51][17];
    char [a62][9];
    char [a6b][14];
    char [a79][14];
    char [a87][13];
    char [a94][15];
    char [aa3][12];
    char [aaf][12];
    char [abb][9];
    char [ac4][17];
    char [ad5][12];
    char [ae1][9];
    char [aea][23];
    char [b01][17];
    char [b12][26];
    char [b2c][16];
    char [b3c][10];
    char [b46][10];
    char [b50][15];
    char [b5f][9];
    char [b68][13];
    char [b75][16];
    char [b85][63];
    char [bc4][32];
    char [be4][7];
    char [beb][19];
    char [bfe][12];
    char [c0a][14];
    char [c18][5];
    char [c1d][10];
    char [c27][11];
    char [c32][9];
    char [c3b][9];
    char [c44][4];
    char [c48][4];
    char [c4c][35];
    char [c6f][33];
    char [c90][15];
    char [c9f][15];
    char [cae][14];
    char [cbc][15];
    char [ccb][14];
    char [cd9][15];
    char [ce8][14];
    char [cf6][15];
    char [d05][14];
    char [d13][15];
    char [d22][14];
    char [d30][15];
    char [d3f][14];
    char [d4d][15];
    char [d5c][14];
    char [d6a][14];
    char [d78][14];
    char [d86][10];
    char [d90][14];
    char [d9e][8];
    char [da6][13];
    char [db3][14];
    char [dc1][14];
    char [dcf][13];
    char [ddc][6];
    char [de2][22];
    char [df8][13];
    char [e05][13];
    char [e12][8];
    char [e1a][11];
    char [e25][31];
    char [e44][33];
    char [e65][15];
    char [e74][5];
    char [e79][17];
    char [e8a][11];
    char [e95][11];
    char [ea0][26];
    char [eba][11];
    char [ec5][14];
    char [ed3][11];
    char [ede][13];
    char [eeb][13];
    char [ef8][7];
    char [eff][7];
    char [f06][9];
    char [f0f][9];
    char [f18][7];
    char [f1f][19];
    char [f32][7];
    char [f39][8];
    char [f41][5];
    char [f46][17];
    char [f57][5];
    char [f5c][12];
    char [f68][9];
    char [f71][18];
    char [f83][5];
    char [f88][10];
    char [f92][18];
    char [fa4][11];
    char [faf][13];
    char [fbc][15];
    char [fcb][23];
    char [fe2][9];
    char [feb][13];
    char [ff8][12];
    char [1004][22];
    char [101a][12];
    char [1026][13];
    char [1033][16];
    char [1043][18];
    char [1055][12];
    char [1061][21];
    char [1076][21];
    char [108b][11];
    char [1096][11];
    char [10a1][8];
    char [10a9][18];
    char [10bb][18];
    char [10cd][17];
    char [10de][18];
    char [10f0][23];
    char [1107][13];
    char [1114][18];
    char [1126][18];
    char [1138][15];
    char [1147][23];
    char [115e][11];
    char [1169][13];
    char [1176][17];
    char [1187][7];
    char [118e][18];
    char [11a0][10];
    char [11aa][9];
    char [11b3][7];
    char [11ba][16];
    char [11ca][15];
    char [11d9][21];
    char [11ee][14];
    char [11fc][17];
    char [120d][14];
    char [121b][7];
    char [1222][10];
    char [122c][9];
    char [1235][6];
    char [123b][5];
    char [1240][8];
    char [1248][12];
    char [1254][18];
    char [1266][5];
    char [126b][15];
    char [127a][25];
    char [1293][11];
    char [129e][14];
    char [12ac][15];
    char [12bb][7];
    char [12c2][20];
    char [12d6][13];
    char [12e3][17];
    char [12f4][16];
    char [1304][20];
    char [1318][24];
    char [1330][30];
    char [134e][11];
    char [1359][10];
    char [1363][14];
    char [1371][12];
    char [137d][6];
    char [1383][8];
    char [138b][28];
    char [13a7][7];
    char [13ae][14];
    char [13bc][22];
    char [13d2][6];
    char [13d8][7];
    char [13df][8];
    char [13e7][16];
    char [13f7][16];
    char [1407][35];
    char [142a][3];
    char [142d][19];
    char [1440][8];
    char [1448][17];
    char [1459][13];
    char [1466][15];
    char [1475][13];
    char [1482][31];
    char [14a1][32];
    char [14c1][17];
    char [14d2][26];
    char [14ec][29];
    char [1509][30];
    char [1527][34];
    char [1549][39];
    char [1570][15];
    char [157f][14];
    char [158d][15];
    char [159c][19];
    char [15af][17];
    char [15c0][9];
    char [15c9][10];
    char [15d3][19];
    char [15e6][14];
    char [15f4][12];
    char [1600][14];
    char [160e][13];
    char [161b][8];
    char [1623][15];
    char [1632][15];
    char [1641][12];
    char [164d][19];
    char [1660][14];
    char [166e][9];
    char [1677][10];
    char [1681][18];
    char [1693][9];
    char [169c][17];
    char [16ad][5];
    char [16b2][7];
    char [16b9][14];
    char [16c7][13];
    char [16d4][17];
    char [16e5][21];
    char [16fa][9];
    char [1703][14];
    char [1711][24];
    char [1729][12];
    char [1735][18];
    char [1747][13];
    char [1754][7];
    char [175b][12];
    char [1767][13];
    char [1774][11];
    char [177f][9];
    char [1788][7];
    char [178f][7];
    char [1796][9];
    char [179f][37];
    char [17c4][29];
    char [17e1][7];
    char [17e8][12];
    char [17f4][10];
    char [17fe][11];
    char [1809][4];
    char [180d][11];
    char [1818][9];
    char [1821][5];
    char [1826][19];
    char [1839][12];
    char [1845][13];
    char [1852][17];
    char [1863][10];
    char [186d][12];
    char [1879][20];
    char [188d][12];
    char [1899][6];
    char [189f][6];
    char [18a5][12];
    char [18b1][12];
    char [18bd][19];
    char [18d0][12];
    char [18dc][18];
    char [18ee][12];
    char [18fa][12];
    char [1906][14];
    char [1914][13];
    char [1921][14];
    char [192f][9];
    char [1938][12];
    char [1944][9];
    char [194d][13];
    char [195a][17];
    char [196b][14];
    char [1979][5];
    char [197e][13];
    char [198b][19];
    char [199e][5];
    char [19a3][13];
    char [19b0][11];
    char [19bb][16];
    char [19cb][16];
    char [19db][5];
    char [19e0][16];
    char [19f0][8];
    char [19f8][13];
    char [1a05][11];
    char [1a10][12];
    char [1a1c][12];
    char [1a28][29];
    char [1a45][13];
    char [1a52][16];
    char [1a62][21];
    char [1a77][21];
    char [1a8c][5];
    char [1a91][16];
    char [1aa1][9];
    char [1aaa][12];
    char [1ab6][12];
    char [1ac2][14];
    char [1ad0][16];
    char [1ae0][14];
    char [1aee][1];
    char [1aef][1];
};

typedef struct #~ #~, *P#~;

struct #~ {
    dword Reserved; // Always 0
    byte MajorVersion;
    byte MinorVersion;
    byte HeapSizes; // Bit vector for heap sizes
    byte Reserved; // Always 1
    qword Valid; // Bit vector of present tables
    qword Sorted; // Bit vector of sorted tables
    dword Rows[23]; // # of rows for each corresponding present table
    struct Module Row Module; // CLI Metadata Table: Module
    struct TypeRef Row TypeRef[134]; // CLI Metadata Table: TypeRef
    struct TypeDef Row TypeDef[17]; // CLI Metadata Table: TypeDef
    struct Field Row Field[45]; // CLI Metadata Table: Field
    struct MethodDef Row MethodDef[108]; // CLI Metadata Table: MethodDef
    struct ParamRow Param[78]; // CLI Metadata Table: Param
    struct MemberRef Row MemberRef[229]; // CLI Metadata Table: MemberRef
    struct Constant Row Constant[9]; // CLI Metadata Table: Constant
    struct CustomAttribute Row CustomAttribute[25]; // CLI Metadata Table: CustomAttribute
    struct DeclSecurity Row DeclSecurity[1]; // CLI Metadata Table: DeclSecurity
    struct StandAloneSig Row StandAloneSig[21]; // CLI Metadata Table: StandAloneSig
    struct PropertyMap Row PropertyMap[3]; // CLI Metadata Table: PropertyMap
    struct Property Row Property[17]; // CLI Metadata Table: Property
    struct MethodSemantics Row MethodSemantics[18]; // CLI Metadata Table: MethodSemantics
    struct MethodImpl Row MethodImpl[1]; // CLI Metadata Table: MethodImpl
    struct ModuleRef Row ModuleRef[2]; // CLI Metadata Table: ModuleRef
    struct TypeSpec Row TypeSpec[5]; // CLI Metadata Table: TypeSpec
    struct ImplMap Row ImplMap[13]; // CLI Metadata Table: ImplMap
    struct Assembly Table Assembly; // CLI Metadata Table: Assembly
    struct AssemblyRef Row AssemblyRef[6]; // CLI Metadata Table: AssemblyRef
    struct ManifestResource Row ManifestResource[19]; // CLI Metadata Table: ManifestResource
    struct NestedClass Row NestedClass[1]; // CLI Metadata Table: NestedClass
    struct MethodSpec Row MethodSpec[4]; // CLI Metadata Table: MethodSpec
};

typedef struct #Blob #Blob, *P#Blob;

struct #Blob {
    byte Reserved; // Always 0
    struct Blob_Generic_1 [1];
    struct Blob_Generic_10 [a];
    struct Blob_Generic_19 [13];
    struct Blob_MethodRefSig_28 MethodRefSig_28; // Type info for imported method return and params
    struct Blob_FieldSig_32 FieldSig_32; // Type information for Field
    struct Blob_ConstantSig_35 ConstantSig_35; // Data stored in a constant
    struct Blob_FieldSig_40 FieldSig_40; // Type information for Field
    struct Blob_FieldSig_44 FieldSig_44; // Type information for Field
    struct Blob_MethodRefSig_48 MethodRefSig_48; // Type info for imported method return and params
    struct Blob_MethodRefSig_53 MethodRefSig_53; // Type info for imported method return and params
    struct Blob_MethodRefSig_57 MethodRefSig_57; // Type info for imported method return and params
    struct Blob_MethodRefSig_62 MethodRefSig_62; // Type info for imported method return and params
    struct Blob_MethodDefSig_66 MethodDefSig_66; // Type info for method return and params
    struct Blob_MethodRefSig_73 MethodRefSig_73; // Type info for imported method return and params
    struct Blob_MethodRefSig_78 MethodRefSig_78; // Type info for imported method return and params
    struct Blob_MethodRefSig_84 MethodRefSig_84; // Type info for imported method return and params
    struct Blob_MethodRefSig_90 MethodRefSig_90; // Type info for imported method return and params
    struct Blob_MethodRefSig_95 MethodRefSig_95; // Type info for imported method return and params
    struct Blob_MethodRefSig_101 MethodRefSig_101; // Type info for imported method return and params
    struct Blob_MethodRefSig_107 MethodRefSig_107; // Type info for imported method return and params
    struct Blob_MethodRefSig_113 MethodRefSig_113; // Type info for imported method return and params
    struct Blob_MethodRefSig_119 MethodRefSig_119; // Type info for imported method return and params
    struct Blob_MethodRefSig_124 MethodRefSig_124; // Type info for imported method return and params
    struct Blob_MethodRefSig_130 MethodRefSig_130; // Type info for imported method return and params
    struct Blob_MethodRefSig_136 MethodRefSig_136; // Type info for imported method return and params
    struct Blob_MethodRefSig_142 MethodRefSig_142; // Type info for imported method return and params
    struct Blob_PropertySig_148 PropertySig_148; // Contains signature for properties. Gives params for getters/setters.
    struct Blob_LocalVarSig_153 LocalVarSig_153; // Contains signature for function locals
    struct Blob_MethodRefSig_163 MethodRefSig_163; // Type info for imported method return and params
    struct Blob_MethodRefSig_170 MethodRefSig_170; // Type info for imported method return and params
    struct Blob_MethodSpecSig_181 MethodSpecSig_181; // Specifies a generic method with GenArgCount types
    struct Blob_MethodRefSig_186 MethodRefSig_186; // Type info for imported method return and params
    struct Blob_MethodRefSig_191 MethodRefSig_191; // Type info for imported method return and params
    struct Blob_MethodRefSig_198 MethodRefSig_198; // Type info for imported method return and params
    struct Blob_MethodRefSig_209 MethodRefSig_209; // Type info for imported method return and params
    struct Blob_MethodRefSig_215 MethodRefSig_215; // Type info for imported method return and params
    struct Blob_MethodRefSig_221 MethodRefSig_221; // Type info for imported method return and params
    struct Blob_MethodRefSig_227 MethodRefSig_227; // Type info for imported method return and params
    struct Blob_MethodRefSig_234 MethodRefSig_234; // Type info for imported method return and params
    struct Blob_MethodRefSig_238 MethodRefSig_238; // Type info for imported method return and params
    struct Blob_FieldSig_245 FieldSig_245; // Type information for Field
    struct Blob_MethodRefSig_250 MethodRefSig_250; // Type info for imported method return and params
    struct Blob_MethodRefSig_257 MethodRefSig_257; // Type info for imported method return and params
    struct Blob_MethodRefSig_263 MethodRefSig_263; // Type info for imported method return and params
    struct Blob_MethodRefSig_272 MethodRefSig_272; // Type info for imported method return and params
    struct Blob_MethodRefSig_279 MethodRefSig_279; // Type info for imported method return and params
    struct Blob_MethodRefSig_287 MethodRefSig_287; // Type info for imported method return and params
    struct Blob_MethodRefSig_293 MethodRefSig_293; // Type info for imported method return and params
    struct Blob_MethodRefSig_297 MethodRefSig_297; // Type info for imported method return and params
    struct Blob_MethodRefSig_302 MethodRefSig_302; // Type info for imported method return and params
    struct Blob_MethodRefSig_308 MethodRefSig_308; // Type info for imported method return and params
    struct Blob_MethodRefSig_315 MethodRefSig_315; // Type info for imported method return and params
    struct Blob_MethodRefSig_321 MethodRefSig_321; // Type info for imported method return and params
    struct Blob_MethodRefSig_328 MethodRefSig_328; // Type info for imported method return and params
    struct Blob_MethodRefSig_335 MethodRefSig_335; // Type info for imported method return and params
    struct Blob_MethodRefSig_341 MethodRefSig_341; // Type info for imported method return and params
    struct Blob_MethodSpecSig_349 MethodSpecSig_349; // Specifies a generic method with GenArgCount types
    struct Blob_MethodRefSig_354 MethodRefSig_354; // Type info for imported method return and params
    struct Blob_MethodRefSig_360 MethodRefSig_360; // Type info for imported method return and params
    struct Blob_MethodSpecSig_367 MethodSpecSig_367; // Specifies a generic method with GenArgCount types
    struct Blob_MethodRefSig_373 MethodRefSig_373; // Type info for imported method return and params
    struct Blob_MethodRefSig_379 MethodRefSig_379; // Type info for imported method return and params
    struct Blob_MethodRefSig_388 MethodRefSig_388; // Type info for imported method return and params
    struct Blob_MethodRefSig_395 MethodRefSig_395; // Type info for imported method return and params
    struct Blob_MethodRefSig_402 MethodRefSig_402; // Type info for imported method return and params
    struct Blob_FieldSig_407 FieldSig_407; // Type information for Field
    struct Blob_Generic_412 [19c];
    struct Blob_MethodRefSig_416 MethodRefSig_416; // Type info for imported method return and params
    struct Blob_MethodRefSig_423 MethodRefSig_423; // Type info for imported method return and params
    struct Blob_Generic_429 [1ad];
    struct Blob_CustomAttrib_435 CustomAttrib_435; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_ConstantSig_440 ConstantSig_440; // Data stored in a constant
    struct Blob_ConstantSig_445 ConstantSig_445; // Data stored in a constant
    struct Blob_LocalVarSig_450 LocalVarSig_450; // Contains signature for function locals
    struct Blob_MethodRefSig_459 MethodRefSig_459; // Type info for imported method return and params
    struct Blob_MethodRefSig_463 MethodRefSig_463; // Type info for imported method return and params
    struct Blob_MethodRefSig_470 MethodRefSig_470; // Type info for imported method return and params
    struct Blob_MethodRefSig_479 MethodRefSig_479; // Type info for imported method return and params
    struct Blob_MethodRefSig_485 MethodRefSig_485; // Type info for imported method return and params
    struct Blob_MethodRefSig_493 MethodRefSig_493; // Type info for imported method return and params
    struct Blob_Generic_501 [1f5];
    struct Blob_Generic_510 [1fe];
    struct Blob_FieldSig_518 FieldSig_518; // Type information for Field
    struct Blob_ConstantSig_522 ConstantSig_522; // Data stored in a constant
    struct Blob_LocalVarSig_527 LocalVarSig_527; // Contains signature for function locals
    struct Blob_MethodRefSig_536 MethodRefSig_536; // Type info for imported method return and params
    struct Blob_Generic_542 [21e];
    struct Blob_LocalVarSig_547 LocalVarSig_547; // Contains signature for function locals
    struct Blob_MethodRefSig_573 MethodRefSig_573; // Type info for imported method return and params
    struct Blob_MethodRefSig_581 MethodRefSig_581; // Type info for imported method return and params
    struct Blob_MethodRefSig_587 MethodRefSig_587; // Type info for imported method return and params
    struct Blob_MethodRefSig_593 MethodRefSig_593; // Type info for imported method return and params
    struct Blob_MethodRefSig_600 MethodRefSig_600; // Type info for imported method return and params
    struct Blob_MethodRefSig_609 MethodRefSig_609; // Type info for imported method return and params
    struct Blob_MethodRefSig_615 MethodRefSig_615; // Type info for imported method return and params
    struct Blob_MethodRefSig_622 MethodRefSig_622; // Type info for imported method return and params
    struct Blob_MethodRefSig_630 MethodRefSig_630; // Type info for imported method return and params
    struct Blob_MethodRefSig_636 MethodRefSig_636; // Type info for imported method return and params
    struct Blob_MethodRefSig_649 MethodRefSig_649; // Type info for imported method return and params
    struct Blob_MethodRefSig_657 MethodRefSig_657; // Type info for imported method return and params
    struct Blob_LocalVarSig_662 LocalVarSig_662; // Contains signature for function locals
    struct Blob_Generic_694 [2b6];
    struct Blob_MethodRefSig_701 MethodRefSig_701; // Type info for imported method return and params
    struct Blob_LocalVarSig_708 LocalVarSig_708; // Contains signature for function locals
    struct Blob_FieldSig_715 FieldSig_715; // Type information for Field
    struct Blob_FieldSig_720 FieldSig_720; // Type information for Field
    struct Blob_MethodRefSig_725 MethodRefSig_725; // Type info for imported method return and params
    struct Blob_MethodRefSig_734 MethodRefSig_734; // Type info for imported method return and params
    struct Blob_MethodRefSig_740 MethodRefSig_740; // Type info for imported method return and params
    struct Blob_Generic_748 [2ec];
    struct Blob_Generic_754 [2f2];
    struct Blob_Generic_760 [2f8];
    struct Blob_MethodRefSig_767 MethodRefSig_767; // Type info for imported method return and params
    struct Blob_MethodRefSig_775 MethodRefSig_775; // Type info for imported method return and params
    struct Blob_TypeSpec_783 TypeSpec_783; // Describes a type.
    struct Blob_Generic_786 [312];
    struct Blob_PropertySig_792 PropertySig_792; // Contains signature for properties. Gives params for getters/setters.
    struct Blob_MethodRefSig_798 MethodRefSig_798; // Type info for imported method return and params
    struct Blob_CustomAttrib_805 CustomAttrib_805; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_PropertySig_814 PropertySig_814; // Contains signature for properties. Gives params for getters/setters.
    struct Blob_PropertySig_820 PropertySig_820; // Contains signature for properties. Gives params for getters/setters.
    struct Blob_PropertySig_824 PropertySig_824; // Contains signature for properties. Gives params for getters/setters.
    struct Blob_PropertySig_829 PropertySig_829; // Contains signature for properties. Gives params for getters/setters.
    struct Blob_MethodRefSig_835 MethodRefSig_835; // Type info for imported method return and params
    struct Blob_CustomAttrib_841 CustomAttrib_841; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_FieldSig_907 FieldSig_907; // Type information for Field
    struct Blob_Generic_911 [38f];
    struct Blob_MethodRefSig_916 MethodRefSig_916; // Type info for imported method return and params
    struct Blob_PropertySig_925 PropertySig_925; // Contains signature for properties. Gives params for getters/setters.
    struct Blob_Generic_930 [3a2];
    struct Blob_FieldSig_1020 FieldSig_1020; // Type information for Field
    struct Blob_FieldSig_1024 FieldSig_1024; // Type information for Field
    struct Blob_Generic_1029 [405];
    struct Blob_MethodRefSig_1035 MethodRefSig_1035; // Type info for imported method return and params
    struct Blob_MethodRefSig_1041 MethodRefSig_1041; // Type info for imported method return and params
    struct Blob_LocalVarSig_1045 LocalVarSig_1045; // Contains signature for function locals
    struct Blob_MethodRefSig_1053 MethodRefSig_1053; // Type info for imported method return and params
    struct Blob_MethodRefSig_1059 MethodRefSig_1059; // Type info for imported method return and params
    struct Blob_LocalVarSig_1065 LocalVarSig_1065; // Contains signature for function locals
    struct Blob_MethodRefSig_1069 MethodRefSig_1069; // Type info for imported method return and params
    struct Blob_MethodRefSig_1074 MethodRefSig_1074; // Type info for imported method return and params
    struct Blob_LocalVarSig_1079 LocalVarSig_1079; // Contains signature for function locals
    struct Blob_MethodRefSig_1083 MethodRefSig_1083; // Type info for imported method return and params
    struct Blob_LocalVarSig_1089 LocalVarSig_1089; // Contains signature for function locals
    struct Blob_LocalVarSig_1093 LocalVarSig_1093; // Contains signature for function locals
    struct Blob_TypeSpec_1102 TypeSpec_1102; // Describes a type.
    struct Blob_MethodRefSig_1109 MethodRefSig_1109; // Type info for imported method return and params
    struct Blob_MethodRefSig_1115 MethodRefSig_1115; // Type info for imported method return and params
    struct Blob_TypeSpec_1125 TypeSpec_1125; // Describes a type.
    struct Blob_MethodRefSig_1132 MethodRefSig_1132; // Type info for imported method return and params
    struct Blob_LocalVarSig_1137 LocalVarSig_1137; // Contains signature for function locals
    struct Blob_MethodRefSig_1147 MethodRefSig_1147; // Type info for imported method return and params
    struct Blob_MethodRefSig_1153 MethodRefSig_1153; // Type info for imported method return and params
    struct Blob_MethodRefSig_1158 MethodRefSig_1158; // Type info for imported method return and params
    struct Blob_MethodSpecSig_1171 MethodSpecSig_1171; // Specifies a generic method with GenArgCount types
    struct Blob_LocalVarSig_1175 LocalVarSig_1175; // Contains signature for function locals
    struct Blob_MethodRefSig_1184 MethodRefSig_1184; // Type info for imported method return and params
    struct Blob_LocalVarSig_1190 LocalVarSig_1190; // Contains signature for function locals
    struct Blob_MethodRefSig_1196 MethodRefSig_1196; // Type info for imported method return and params
    struct Blob_MethodRefSig_1201 MethodRefSig_1201; // Type info for imported method return and params
    struct Blob_Generic_1207 [4b7];
    struct Blob_MethodRefSig_1215 MethodRefSig_1215; // Type info for imported method return and params
    struct Blob_LocalVarSig_1224 LocalVarSig_1224; // Contains signature for function locals
    struct Blob_FieldSig_1233 FieldSig_1233; // Type information for Field
    struct Blob_FieldSig_1236 FieldSig_1236; // Type information for Field
    struct Blob_FieldSig_1245 FieldSig_1245; // Type information for Field
    struct Blob_Generic_1254 [4e6];
    struct Blob_LocalVarSig_1261 LocalVarSig_1261; // Contains signature for function locals
    struct Blob_MethodRefSig_1275 MethodRefSig_1275; // Type info for imported method return and params
    struct Blob_MethodRefSig_1281 MethodRefSig_1281; // Type info for imported method return and params
    struct Blob_MethodRefSig_1288 MethodRefSig_1288; // Type info for imported method return and params
    struct Blob_MethodRefSig_1294 MethodRefSig_1294; // Type info for imported method return and params
    struct Blob_MethodRefSig_1303 MethodRefSig_1303; // Type info for imported method return and params
    struct Blob_MethodRefSig_1309 MethodRefSig_1309; // Type info for imported method return and params
    struct Blob_LocalVarSig_1318 LocalVarSig_1318; // Contains signature for function locals
    struct Blob_Generic_1324 [52c];
    struct Blob_LocalVarSig_1334 LocalVarSig_1334; // Contains signature for function locals
    struct Blob_MethodRefSig_1352 MethodRefSig_1352; // Type info for imported method return and params
    struct Blob_MethodRefSig_1358 MethodRefSig_1358; // Type info for imported method return and params
    struct Blob_MethodRefSig_1363 MethodRefSig_1363; // Type info for imported method return and params
    struct Blob_MethodRefSig_1373 MethodRefSig_1373; // Type info for imported method return and params
    struct Blob_Generic_1378 [562];
    struct Blob_TypeSpec_1385 TypeSpec_1385; // Describes a type.
    struct Blob_MethodRefSig_1393 MethodRefSig_1393; // Type info for imported method return and params
    struct Blob_Generic_1402 [57a];
    struct Blob_LocalVarSig_1416 LocalVarSig_1416; // Contains signature for function locals
    struct Blob_MethodRefSig_1421 MethodRefSig_1421; // Type info for imported method return and params
    struct Blob_Generic_1425 [591];
    struct Blob_LocalVarSig_1433 LocalVarSig_1433; // Contains signature for function locals
    struct Blob_MethodRefSig_1450 MethodRefSig_1450; // Type info for imported method return and params
    struct Blob_MethodRefSig_1457 MethodRefSig_1457; // Type info for imported method return and params
    struct Blob_MethodRefSig_1467 MethodRefSig_1467; // Type info for imported method return and params
    struct Blob_Generic_1475 [5c3];
    struct Blob_LocalVarSig_1498 LocalVarSig_1498; // Contains signature for function locals
    struct Blob_MethodRefSig_1512 MethodRefSig_1512; // Type info for imported method return and params
    struct Blob_TypeSpec_1519 TypeSpec_1519; // Describes a type.
    struct Blob_MethodRefSig_1527 MethodRefSig_1527; // Type info for imported method return and params
    struct Blob_MethodRefSig_1533 MethodRefSig_1533; // Type info for imported method return and params
    struct Blob_MethodRefSig_1538 MethodRefSig_1538; // Type info for imported method return and params
    struct Blob_MethodRefSig_1548 MethodRefSig_1548; // Type info for imported method return and params
    struct Blob_MethodRefSig_1556 MethodRefSig_1556; // Type info for imported method return and params
    struct Blob_Generic_1562 [61a];
    struct Blob_MethodRefSig_1572 MethodRefSig_1572; // Type info for imported method return and params
    struct Blob_MethodRefSig_1579 MethodRefSig_1579; // Type info for imported method return and params
    struct Blob_FieldSig_1586 FieldSig_1586; // Type information for Field
    struct Blob_ConstantSig_1589 ConstantSig_1589; // Data stored in a constant
    struct Blob_ConstantSig_1604 ConstantSig_1604; // Data stored in a constant
    struct Blob_CustomAttrib_1619 CustomAttrib_1619; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_CustomAttrib_1628 CustomAttrib_1628; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_MethodRefSig_1659 MethodRefSig_1659; // Type info for imported method return and params
    struct Blob_CustomAttrib_1666 CustomAttrib_1666; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_CustomAttrib_1679 CustomAttrib_1679; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_Generic_1699 [6a3];
    struct Blob_CustomAttrib_1705 CustomAttrib_1705; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_CustomAttrib_1726 CustomAttrib_1726; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_CustomAttrib_1732 CustomAttrib_1732; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_CustomAttrib_1774 CustomAttrib_1774; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_CustomAttrib_1789 CustomAttrib_1789; // A CustomAttrib blob stores values of fixed or named parameters supplied when instantiating a custom attribute
    struct Blob_Generic_1800 [708];
    struct Blob_Generic_1878 [756];
};

typedef struct MethodDefHdr_Fat MethodDefHdr_Fat, *PMethodDefHdr_Fat;

struct MethodDefHdr_Fat {
    word Size+Flags; // L.S. Bits 0:3 Size of hdr in bytes, Bits 4:15 Flags
    word MaxStack; // Maximum number of items on the operand stack
    dword CodeSize; // Size of actual method body in bytes
    dword LocalVarSigTok; // Signature for the local variables of the method. 0 means no locals. References standalone signature in Metadata tables, which references #Blob heap.
};

typedef struct MethodDefHdr_Tiny MethodDefHdr_Tiny, *PMethodDefHdr_Tiny;

struct MethodDefHdr_Tiny {
    byte Size+Flags; // L.S. Bits 0:1 Flags, Bits 2:7 Size of method in Bytes
};

typedef struct _iobuf _iobuf, *P_iobuf;

struct _iobuf {
    char * _ptr;
    int _cnt;
    char * _base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char * _tmpfname;
};

typedef struct _iobuf FILE;

typedef struct _IMAGE_SECTION_HEADER _IMAGE_SECTION_HEADER, *P_IMAGE_SECTION_HEADER;

typedef struct _IMAGE_SECTION_HEADER * PIMAGE_SECTION_HEADER;

typedef union _union_226 _union_226, *P_union_226;

union _union_226 {
    DWORD PhysicalAddress;
    DWORD VirtualSize;
};

struct _IMAGE_SECTION_HEADER {
    BYTE Name[8];
    union _union_226 Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
};

typedef uint uintptr_t;

typedef struct IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

struct IMAGE_DOS_HEADER {
    char e_magic[2]; // Magic number
    word e_cblp; // Bytes of last page
    word e_cp; // Pages in file
    word e_crlc; // Relocations
    word e_cparhdr; // Size of header in paragraphs
    word e_minalloc; // Minimum extra paragraphs needed
    word e_maxalloc; // Maximum extra paragraphs needed
    word e_ss; // Initial (relative) SS value
    word e_sp; // Initial SP value
    word e_csum; // Checksum
    word e_ip; // Initial IP value
    word e_cs; // Initial (relative) CS value
    word e_lfarlc; // File address of relocation table
    word e_ovno; // Overlay number
    word e_res[4][4]; // Reserved words
    word e_oemid; // OEM identifier (for e_oeminfo)
    word e_oeminfo; // OEM information; e_oemid specific
    word e_res2[10][10]; // Reserved words
    dword e_lfanew; // File address of new exe header
    byte e_program[64]; // Actual DOS program
};

typedef struct <lambda_2b24c74d71094a6cd0cb82e44167d71b> <lambda_2b24c74d71094a6cd0cb82e44167d71b>, *P<lambda_2b24c74d71094a6cd0cb82e44167d71b>;

struct <lambda_2b24c74d71094a6cd0cb82e44167d71b> { // PlaceHolder Structure
};

typedef struct <lambda_3e16ef9562a7dcce91392c22ab16ea36> <lambda_3e16ef9562a7dcce91392c22ab16ea36>, *P<lambda_3e16ef9562a7dcce91392c22ab16ea36>;

struct <lambda_3e16ef9562a7dcce91392c22ab16ea36> { // PlaceHolder Structure
};

typedef struct <lambda_628dfdc04ba53c8bfc02c9951375f3f5> <lambda_628dfdc04ba53c8bfc02c9951375f3f5>, *P<lambda_628dfdc04ba53c8bfc02c9951375f3f5>;

struct <lambda_628dfdc04ba53c8bfc02c9951375f3f5> { // PlaceHolder Structure
};

typedef struct <lambda_2cc53f568c5a2bb6f192f930a45d44ea> <lambda_2cc53f568c5a2bb6f192f930a45d44ea>, *P<lambda_2cc53f568c5a2bb6f192f930a45d44ea>;

struct <lambda_2cc53f568c5a2bb6f192f930a45d44ea> { // PlaceHolder Structure
};

typedef struct <lambda_c2ffc0b7726aa6be21d5f0026187e748> <lambda_c2ffc0b7726aa6be21d5f0026187e748>, *P<lambda_c2ffc0b7726aa6be21d5f0026187e748>;

struct <lambda_c2ffc0b7726aa6be21d5f0026187e748> { // PlaceHolder Structure
};

typedef struct <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104> <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>, *P<lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>;

struct <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104> { // PlaceHolder Structure
};

typedef struct <lambda_9e9de3de5fa147e2223d7db92bc10aa6> <lambda_9e9de3de5fa147e2223d7db92bc10aa6>, *P<lambda_9e9de3de5fa147e2223d7db92bc10aa6>;

struct <lambda_9e9de3de5fa147e2223d7db92bc10aa6> { // PlaceHolder Structure
};

typedef struct __crt_signal_action_t __crt_signal_action_t, *P__crt_signal_action_t;

struct __crt_signal_action_t { // PlaceHolder Structure
};

typedef struct __crt_locale_data __crt_locale_data, *P__crt_locale_data;

struct __crt_locale_data { // PlaceHolder Structure
};

typedef struct <lambda_fb385d3da700c9147fc39e65dd577a8c> <lambda_fb385d3da700c9147fc39e65dd577a8c>, *P<lambda_fb385d3da700c9147fc39e65dd577a8c>;

struct <lambda_fb385d3da700c9147fc39e65dd577a8c> { // PlaceHolder Structure
};

typedef struct <lambda_5056f36f92c185fae794536d1ce2027b> <lambda_5056f36f92c185fae794536d1ce2027b>, *P<lambda_5056f36f92c185fae794536d1ce2027b>;

struct <lambda_5056f36f92c185fae794536d1ce2027b> { // PlaceHolder Structure
};

typedef struct <lambda_218ce3db14220d0be481dae8ef3383b6> <lambda_218ce3db14220d0be481dae8ef3383b6>, *P<lambda_218ce3db14220d0be481dae8ef3383b6>;

struct <lambda_218ce3db14220d0be481dae8ef3383b6> { // PlaceHolder Structure
};

typedef struct <lambda_a7e850c220f1c8d1e6efeecdedd162c6> <lambda_a7e850c220f1c8d1e6efeecdedd162c6>, *P<lambda_a7e850c220f1c8d1e6efeecdedd162c6>;

struct <lambda_a7e850c220f1c8d1e6efeecdedd162c6> { // PlaceHolder Structure
};

typedef struct <lambda_ab61a845afdef5b7c387490eaf3616ee> <lambda_ab61a845afdef5b7c387490eaf3616ee>, *P<lambda_ab61a845afdef5b7c387490eaf3616ee>;

struct <lambda_ab61a845afdef5b7c387490eaf3616ee> { // PlaceHolder Structure
};

typedef struct <lambda_207f2d024fc103971653565357d6cd41> <lambda_207f2d024fc103971653565357d6cd41>, *P<lambda_207f2d024fc103971653565357d6cd41>;

struct <lambda_207f2d024fc103971653565357d6cd41> { // PlaceHolder Structure
};

typedef struct <lambda_f03950bc5685219e0bcd2087efbe011e> <lambda_f03950bc5685219e0bcd2087efbe011e>, *P<lambda_f03950bc5685219e0bcd2087efbe011e>;

struct <lambda_f03950bc5685219e0bcd2087efbe011e> { // PlaceHolder Structure
};

typedef struct <lambda_03b1d95aef87969028cfba75ccab2455> <lambda_03b1d95aef87969028cfba75ccab2455>, *P<lambda_03b1d95aef87969028cfba75ccab2455>;

struct <lambda_03b1d95aef87969028cfba75ccab2455> { // PlaceHolder Structure
};

typedef struct <lambda_ae742caa10f662c28703da3d2ea5e57e> <lambda_ae742caa10f662c28703da3d2ea5e57e>, *P<lambda_ae742caa10f662c28703da3d2ea5e57e>;

struct <lambda_ae742caa10f662c28703da3d2ea5e57e> { // PlaceHolder Structure
};

typedef struct <lambda_ceb1ee4838e85a9d631eb091e2fbe199> <lambda_ceb1ee4838e85a9d631eb091e2fbe199>, *P<lambda_ceb1ee4838e85a9d631eb091e2fbe199>;

struct <lambda_ceb1ee4838e85a9d631eb091e2fbe199> { // PlaceHolder Structure
};

typedef enum _crt_exit_cleanup_mode {
} _crt_exit_cleanup_mode;

typedef struct <lambda_6dbb1268764f43b569ce7b67e331d33a> <lambda_6dbb1268764f43b569ce7b67e331d33a>, *P<lambda_6dbb1268764f43b569ce7b67e331d33a>;

struct <lambda_6dbb1268764f43b569ce7b67e331d33a> { // PlaceHolder Structure
};

typedef struct <lambda_6affb1475c98b40b75cdec977db92e3c> <lambda_6affb1475c98b40b75cdec977db92e3c>, *P<lambda_6affb1475c98b40b75cdec977db92e3c>;

struct <lambda_6affb1475c98b40b75cdec977db92e3c> { // PlaceHolder Structure
};

typedef struct __crt_seh_guarded_call<void> __crt_seh_guarded_call<void>, *P__crt_seh_guarded_call<void>;

struct __crt_seh_guarded_call<void> { // PlaceHolder Structure
};

typedef struct <lambda_38edbb1296d33220d7e4dd0ed76b244a> <lambda_38edbb1296d33220d7e4dd0ed76b244a>, *P<lambda_38edbb1296d33220d7e4dd0ed76b244a>;

struct <lambda_38edbb1296d33220d7e4dd0ed76b244a> { // PlaceHolder Structure
};

typedef struct <lambda_39ca0ed439415581b5b15c265174cece> <lambda_39ca0ed439415581b5b15c265174cece>, *P<lambda_39ca0ed439415581b5b15c265174cece>;

struct <lambda_39ca0ed439415581b5b15c265174cece> { // PlaceHolder Structure
};

typedef struct HINSTANCE__ HINSTANCE__, *PHINSTANCE__;

struct HINSTANCE__ { // PlaceHolder Structure
};

typedef struct <lambda_15ade71b0218206bbe3333a0c9b79046> <lambda_15ade71b0218206bbe3333a0c9b79046>, *P<lambda_15ade71b0218206bbe3333a0c9b79046>;

struct <lambda_15ade71b0218206bbe3333a0c9b79046> { // PlaceHolder Structure
};

typedef struct <lambda_38ce7e780aa69e748d6df282ebc68efe> <lambda_38ce7e780aa69e748d6df282ebc68efe>, *P<lambda_38ce7e780aa69e748d6df282ebc68efe>;

struct <lambda_38ce7e780aa69e748d6df282ebc68efe> { // PlaceHolder Structure
};

typedef struct <lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518> <lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518>, *P<lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518>;

struct <lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518> { // PlaceHolder Structure
};

typedef struct <lambda_2866be3712abc81a800a822484c830d8> <lambda_2866be3712abc81a800a822484c830d8>, *P<lambda_2866be3712abc81a800a822484c830d8>;

struct <lambda_2866be3712abc81a800a822484c830d8> { // PlaceHolder Structure
};

typedef struct <lambda_44731a7d0e6d81c3e6aa82d741081786> <lambda_44731a7d0e6d81c3e6aa82d741081786>, *P<lambda_44731a7d0e6d81c3e6aa82d741081786>;

struct <lambda_44731a7d0e6d81c3e6aa82d741081786> { // PlaceHolder Structure
};

typedef struct <lambda_4b292cb8dd18144e164572427af410ab> <lambda_4b292cb8dd18144e164572427af410ab>, *P<lambda_4b292cb8dd18144e164572427af410ab>;

struct <lambda_4b292cb8dd18144e164572427af410ab> { // PlaceHolder Structure
};

typedef struct __crt_stdio_stream __crt_stdio_stream, *P__crt_stdio_stream;

struct __crt_stdio_stream { // PlaceHolder Structure
};

typedef struct <lambda_69a2805e680e0e292e8ba93315fe43a8> <lambda_69a2805e680e0e292e8ba93315fe43a8>, *P<lambda_69a2805e680e0e292e8ba93315fe43a8>;

struct <lambda_69a2805e680e0e292e8ba93315fe43a8> { // PlaceHolder Structure
};

typedef struct __crt_multibyte_data __crt_multibyte_data, *P__crt_multibyte_data;

struct __crt_multibyte_data { // PlaceHolder Structure
};

typedef struct void_(__cdecl**)(int) void_(__cdecl**)(int), *Pvoid_(__cdecl**)(int);

struct void_(__cdecl**)(int) { // PlaceHolder Structure
};

typedef struct __crt_seh_guarded_call<int> __crt_seh_guarded_call<int>, *P__crt_seh_guarded_call<int>;

struct __crt_seh_guarded_call<int> { // PlaceHolder Structure
};

typedef struct <lambda_800076c951b434888f4765a74a194fcc> <lambda_800076c951b434888f4765a74a194fcc>, *P<lambda_800076c951b434888f4765a74a194fcc>;

struct <lambda_800076c951b434888f4765a74a194fcc> { // PlaceHolder Structure
};

typedef struct <lambda_da44e0f8b0f19ba52fefafb335991732> <lambda_da44e0f8b0f19ba52fefafb335991732>, *P<lambda_da44e0f8b0f19ba52fefafb335991732>;

struct <lambda_da44e0f8b0f19ba52fefafb335991732> { // PlaceHolder Structure
};

typedef struct <lambda_5ce1d447e08cb34b2473517608e21441> <lambda_5ce1d447e08cb34b2473517608e21441>, *P<lambda_5ce1d447e08cb34b2473517608e21441>;

struct <lambda_5ce1d447e08cb34b2473517608e21441> { // PlaceHolder Structure
};

typedef struct <lambda_af42a3ee9806e9a7305d451646e05244> <lambda_af42a3ee9806e9a7305d451646e05244>, *P<lambda_af42a3ee9806e9a7305d451646e05244>;

struct <lambda_af42a3ee9806e9a7305d451646e05244> { // PlaceHolder Structure
};

typedef struct __acrt_ptd __acrt_ptd, *P__acrt_ptd;

struct __acrt_ptd { // PlaceHolder Structure
};

typedef struct <lambda_03fcd07e894ec930e3f35da366ca99d6> <lambda_03fcd07e894ec930e3f35da366ca99d6>, *P<lambda_03fcd07e894ec930e3f35da366ca99d6>;

struct <lambda_03fcd07e894ec930e3f35da366ca99d6> { // PlaceHolder Structure
};

typedef struct <lambda_6e4b09c48022b2350581041d5f6b0c4c> <lambda_6e4b09c48022b2350581041d5f6b0c4c>, *P<lambda_6e4b09c48022b2350581041d5f6b0c4c>;

struct <lambda_6e4b09c48022b2350581041d5f6b0c4c> { // PlaceHolder Structure
};

typedef struct <lambda_8ca6da459f0f6780f1cff60fdc3d00e5> <lambda_8ca6da459f0f6780f1cff60fdc3d00e5>, *P<lambda_8ca6da459f0f6780f1cff60fdc3d00e5>;

struct <lambda_8ca6da459f0f6780f1cff60fdc3d00e5> { // PlaceHolder Structure
};

typedef struct <lambda_e25ca0880e6ef98be67edffd8c599615> <lambda_e25ca0880e6ef98be67edffd8c599615>, *P<lambda_e25ca0880e6ef98be67edffd8c599615>;

struct <lambda_e25ca0880e6ef98be67edffd8c599615> { // PlaceHolder Structure
};

typedef struct __crt_seh_guarded_call<void_(__cdecl*)(int)> __crt_seh_guarded_call<void_(__cdecl*)(int)>, *P__crt_seh_guarded_call<void_(__cdecl*)(int)>;

struct __crt_seh_guarded_call<void_(__cdecl*)(int)> { // PlaceHolder Structure
};

typedef struct <lambda_57dc472bd5c9d5f3b2cbca59b8a843ae> <lambda_57dc472bd5c9d5f3b2cbca59b8a843ae>, *P<lambda_57dc472bd5c9d5f3b2cbca59b8a843ae>;

struct <lambda_57dc472bd5c9d5f3b2cbca59b8a843ae> { // PlaceHolder Structure
};

typedef struct <lambda_eee62cb4a147bfbb98180ad682ce6e17> <lambda_eee62cb4a147bfbb98180ad682ce6e17>, *P<lambda_eee62cb4a147bfbb98180ad682ce6e17>;

struct <lambda_eee62cb4a147bfbb98180ad682ce6e17> { // PlaceHolder Structure
};

typedef struct <lambda_cd08b5d6af4937fe54fc07d0c9bf6b37> <lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>, *P<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>;

struct <lambda_cd08b5d6af4937fe54fc07d0c9bf6b37> { // PlaceHolder Structure
};

typedef struct <lambda_e5124f882df8998aaf41531e079ba474> <lambda_e5124f882df8998aaf41531e079ba474>, *P<lambda_e5124f882df8998aaf41531e079ba474>;

struct <lambda_e5124f882df8998aaf41531e079ba474> { // PlaceHolder Structure
};

typedef struct <lambda_4e60a939b0d047cfe11ddc22648dfba9> <lambda_4e60a939b0d047cfe11ddc22648dfba9>, *P<lambda_4e60a939b0d047cfe11ddc22648dfba9>;

struct <lambda_4e60a939b0d047cfe11ddc22648dfba9> { // PlaceHolder Structure
};

typedef struct <lambda_cbab9ec6f41b0180b23cc171c22676b0> <lambda_cbab9ec6f41b0180b23cc171c22676b0>, *P<lambda_cbab9ec6f41b0180b23cc171c22676b0>;

struct <lambda_cbab9ec6f41b0180b23cc171c22676b0> { // PlaceHolder Structure
};

typedef struct <lambda_46720907175c18b6c9d2717bc0d2d362> <lambda_46720907175c18b6c9d2717bc0d2d362>, *P<lambda_46720907175c18b6c9d2717bc0d2d362>;

struct <lambda_46720907175c18b6c9d2717bc0d2d362> { // PlaceHolder Structure
};

typedef struct <lambda_22bdf7517842c4b3e53723af5aa32b9e> <lambda_22bdf7517842c4b3e53723af5aa32b9e>, *P<lambda_22bdf7517842c4b3e53723af5aa32b9e>;

struct <lambda_22bdf7517842c4b3e53723af5aa32b9e> { // PlaceHolder Structure
};

typedef enum _crt_exit_return_mode {
} _crt_exit_return_mode;

typedef struct <lambda_9048902d66e8d99359bc9897bbb930a8> <lambda_9048902d66e8d99359bc9897bbb930a8>, *P<lambda_9048902d66e8d99359bc9897bbb930a8>;

struct <lambda_9048902d66e8d99359bc9897bbb930a8> { // PlaceHolder Structure
};

typedef struct __crt_locale_pointers __crt_locale_pointers, *P__crt_locale_pointers;

struct __crt_locale_pointers { // PlaceHolder Structure
};

typedef struct __crt_seh_guarded_call<bool> __crt_seh_guarded_call<bool>, *P__crt_seh_guarded_call<bool>;

struct __crt_seh_guarded_call<bool> { // PlaceHolder Structure
};


// WARNING! conflicting data type names: /Demangler/wchar_t - /wchar_t

typedef struct <lambda_608742c3c92a14382c1684fc64f96c88> <lambda_608742c3c92a14382c1684fc64f96c88>, *P<lambda_608742c3c92a14382c1684fc64f96c88>;

struct <lambda_608742c3c92a14382c1684fc64f96c88> { // PlaceHolder Structure
};

typedef struct exception exception, *Pexception;

struct exception { // PlaceHolder Structure
};

typedef enum module_id {
} module_id;

typedef enum function_id {
} function_id;

typedef ulong ULONG_PTR;

typedef ULONG_PTR DWORD_PTR;

typedef int (* _onexit_t)(void);

typedef uint size_t;

typedef struct lconv lconv, *Plconv;

struct lconv {
    char * decimal_point;
    char * thousands_sep;
    char * grouping;
    char * int_curr_symbol;
    char * currency_symbol;
    char * mon_decimal_point;
    char * mon_thousands_sep;
    char * mon_grouping;
    char * positive_sign;
    char * negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    wchar_t * _W_decimal_point;
    wchar_t * _W_thousands_sep;
    wchar_t * _W_int_curr_symbol;
    wchar_t * _W_currency_symbol;
    wchar_t * _W_mon_decimal_point;
    wchar_t * _W_mon_thousands_sep;
    wchar_t * _W_positive_sign;
    wchar_t * _W_negative_sign;
};

typedef struct threadlocaleinfostruct threadlocaleinfostruct, *Pthreadlocaleinfostruct;

typedef struct threadlocaleinfostruct * pthreadlocinfo;

typedef struct localerefcount localerefcount, *Plocalerefcount;

typedef struct localerefcount locrefcount;

typedef struct __lc_time_data __lc_time_data, *P__lc_time_data;

struct __lc_time_data {
    char * wday_abbr[7];
    char * wday[7];
    char * month_abbr[12];
    char * month[12];
    char * ampm[2];
    char * ww_sdatefmt;
    char * ww_ldatefmt;
    char * ww_timefmt;
    int ww_caltype;
    int refcount;
    wchar_t * _W_wday_abbr[7];
    wchar_t * _W_wday[7];
    wchar_t * _W_month_abbr[12];
    wchar_t * _W_month[12];
    wchar_t * _W_ampm[2];
    wchar_t * _W_ww_sdatefmt;
    wchar_t * _W_ww_ldatefmt;
    wchar_t * _W_ww_timefmt;
    wchar_t * _W_ww_locale_name;
};

struct localerefcount {
    char * locale;
    wchar_t * wlocale;
    int * refcount;
    int * wrefcount;
};

struct threadlocaleinfostruct {
    int refcount;
    uint lc_codepage;
    uint lc_collate_cp;
    uint lc_time_cp;
    locrefcount lc_category[6];
    int lc_clike;
    int mb_cur_max;
    int * lconv_intl_refcount;
    int * lconv_num_refcount;
    int * lconv_mon_refcount;
    struct lconv * lconv;
    int * ctype1_refcount;
    ushort * ctype1;
    ushort * pctype;
    uchar * pclmap;
    uchar * pcumap;
    struct __lc_time_data * lc_time_curr;
    wchar_t * locale_name[6];
};

typedef longlong __time64_t;

typedef size_t rsize_t;

typedef int errno_t;

typedef struct localeinfo_struct localeinfo_struct, *Plocaleinfo_struct;

typedef struct threadmbcinfostruct threadmbcinfostruct, *Pthreadmbcinfostruct;

typedef struct threadmbcinfostruct * pthreadmbcinfo;

struct threadmbcinfostruct {
    int refcount;
    int mbcodepage;
    int ismbcodepage;
    ushort mbulinfo[6];
    uchar mbctype[257];
    uchar mbcasemap[256];
    wchar_t * mblocalename;
};

struct localeinfo_struct {
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
};

typedef int intptr_t;

typedef struct localeinfo_struct * _locale_t;




// Library Function - Single Match
//  @__security_check_cookie@4
// 
// Library: Visual Studio 2015 Release

void __fastcall ___security_check_cookie_4(int param_1)

{
  if (param_1 == 0x74c08447) {
    return;
  }
  ___report_gsfailure();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___raise_securityfailure
// 
// Library: Visual Studio 2015 Release

void ___raise_securityfailure(undefined4 param_1)

{
  undefined4 uVar1;
  
  (*(code *)0xfffffffe)(0);
  (*(code *)0xfc45c759)(param_1);
  uVar1 = (*_FUN_0040e018)(0xc0000409);
  (*pcRam0040e01c)(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___report_gsfailure
// 
// Library: Visual Studio 2015 Release

void __cdecl ___report_gsfailure(void)

{
  code *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 uVar5;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte bVar6;
  byte bVar7;
  byte in_AF;
  byte bVar8;
  byte bVar9;
  byte in_TF;
  byte in_IF;
  byte bVar10;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined8 uVar11;
  undefined4 unaff_retaddr;
  
  uVar11 = FUN_0041731c(0x17);
  uVar4 = (uint)uVar11;
  bVar6 = 0;
  bVar10 = 0;
  bVar9 = (int)uVar4 < 0;
  bVar8 = uVar4 == 0;
  bVar7 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;
  uVar5 = extraout_ECX;
  uVar2 = unaff_retaddr;
  uVar3 = unaff_EBP;
  if (!(bool)bVar8) {
    pcVar1 = (code *)swi(0x29);
    uVar11 = (*pcVar1)();
    uVar5 = extraout_ECX_00;
    uVar2 = unaff_retaddr;
    uVar3 = unaff_EBP;
  }
                    // WARNING: Read-only address (ram,0x00414880) is written
  uRam00414884 = uVar3;
  uRam00414888 = uVar2;
                    // WARNING: Read-only address (ram,0x0041487c) is written
                    // WARNING: Read-only address (ram,0x00414878) is written
                    // WARNING: Read-only address (ram,0x00414874) is written
                    // WARNING: Read-only address (ram,0x00414870) is written
                    // WARNING: Read-only address (ram,0x0041486c) is written
                    // WARNING: Read-only address (ram,0x00414898) is written
                    // WARNING: Read-only address (ram,0x0041488c) is written
                    // WARNING: Read-only address (ram,0x00414868) is written
                    // WARNING: Read-only address (ram,0x00414864) is written
                    // WARNING: Read-only address (ram,0x00414860) is written
                    // WARNING: Read-only address (ram,0x0041485c) is written
  uRam00414890 = (uint)(in_NT & 1) * 0x4000 | (uint)(bVar10 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200
                 | (uint)(in_TF & 1) * 0x100 | (uint)(bVar9 & 1) * 0x80 | (uint)(bVar8 & 1) * 0x40 |
                 (uint)(in_AF & 1) * 0x10 | (uint)(bVar7 & 1) * 4 | (uint)(bVar6 & 1) |
                 (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 |
                 (uint)(in_VIF & 1) * 0x80000 | (uint)(in_AC & 1) * 0x40000;
                    // WARNING: Read-only address (ram,0x00414890) is written
                    // WARNING: Read-only address (ram,0x00414884) is written
                    // WARNING: Read-only address (ram,0x00414888) is written
  puRam00414894 = &stack0x00000004;
                    // WARNING: Read-only address (ram,0x00414894) is written
  write_double_translated_unicode_nolock = 0x10001;
                    // WARNING: Read-only address (ram,0x0041478c) is written
  uRam0041478c = 0x1aebc032;
                    // WARNING: Read-only address (ram,0x00414780) is written
  uRam00414780 = 0xc0000409;
                    // WARNING: Read-only address (ram,0x00414784) is written
  uRam00414784 = 1;
                    // WARNING: Read-only address (ram,0x00414790) is written
  uRam00414790 = 1;
                    // WARNING: Read-only address (ram,0x00414794) is written
  uRam00414794 = 2;
  uRam0041485c = in_GS;
  uRam00414860 = in_FS;
  uRam00414864 = in_ES;
  uRam00414868 = in_DS;
  uRam0041486c = unaff_EDI;
  uRam00414870 = unaff_ESI;
  uRam00414874 = unaff_EBX;
  uRam0041487c = uVar5;
  uRam0041488c = in_CS;
  uRam00414898 = in_SS;
  ___raise_securityfailure(0x40e170);
  uRam00414878 = (undefined4)((ulonglong)uVar11 >> 0x20);
  uRam00414880 = (undefined4)uVar11;
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  int (__cdecl*__cdecl __crt_fast_encode_pointer<int (__cdecl*)(void)>(int
// (__cdecl*const)(void)))(void)
//  void (__cdecl** __cdecl __crt_fast_encode_pointer<void (__cdecl**)(void)>(void (__cdecl**
// const)(void)))(void)
// 
// Library: Visual Studio 2015 Release

uint __crt_fast_encode_pointer__(uint param_1)

{
  return (param_1 >> 0x19 | param_1 << 7) ^ 0x74c08447;
}



// Library Function - Single Match
//  struct _IMAGE_SECTION_HEADER * __cdecl find_pe_section(unsigned char * const,unsigned int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

_IMAGE_SECTION_HEADER * __cdecl find_pe_section(uchar *param_1,uint param_2)

{
  int iVar1;
  _IMAGE_SECTION_HEADER *p_Var2;
  _IMAGE_SECTION_HEADER *p_Var3;
  
  iVar1 = *(int *)(param_1 + 0x3c);
  p_Var2 = (_IMAGE_SECTION_HEADER *)
           (param_1 + (uint)*(ushort *)(param_1 + iVar1 + 0x14) + iVar1 + 0x18);
  p_Var3 = p_Var2 + *(ushort *)(param_1 + iVar1 + 6);
  while( true ) {
    if (p_Var2 == p_Var3) {
      return (_IMAGE_SECTION_HEADER *)0x0;
    }
    if ((p_Var2->VirtualAddress <= param_2) && (param_2 < p_Var2->Misc + p_Var2->VirtualAddress))
    break;
    p_Var2 = p_Var2 + 1;
  }
  return p_Var2;
}



// Library Function - Single Match
//  ___scrt_initialize_crt
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined ___scrt_initialize_crt(int param_1)

{
  char cVar1;
  
  if (param_1 == 0) {
                    // WARNING: Read-only address (ram,0x00414abd) is written
    uRam00414abd = 1;
  }
  FUN_0040be14();
  cVar1 = ___vcrt_initialize();
  if (cVar1 != '\0') {
    cVar1 = ___acrt_initialize();
    if (cVar1 != '\0') {
      return 1;
    }
    ___vcrt_uninitialize(0);
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x0040b8d0)
// WARNING: Removing unreachable block (ram,0x0040b8d8)
// WARNING: Removing unreachable block (ram,0x0040b95c)
// WARNING: Removing unreachable block (ram,0x0040b8dd)
// WARNING: Removing unreachable block (ram,0x0040b8e6)
// WARNING: Removing unreachable block (ram,0x0040b90c)
// WARNING: Removing unreachable block (ram,0x0040b8ea)
// WARNING: Removing unreachable block (ram,0x0040b8f9)
// WARNING: Removing unreachable block (ram,0x0040b94e)
// WARNING: Removing unreachable block (ram,0x0040b908)
// WARNING: Removing unreachable block (ram,0x0040b957)

undefined4 FUN_0040b8ba(void)

{
  return 1;
}



// Library Function - Single Match
//  ___scrt_release_startup_lock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int ___scrt_release_startup_lock(char param_1)

{
  int iVar1;
  
  iVar1 = ___scrt_is_ucrt_dll_in_use();
  if ((iVar1 != 0) && (param_1 == '\0')) {
                    // WARNING: Read-only address (ram,0x00414aa0) is written
    iVar1 = 0x48b5653;
    uRam00414aa0 = 0;
  }
  return iVar1;
}



// Library Function - Single Match
//  ___scrt_uninitialize_crt
// 
// Library: Visual Studio 2017 Release

undefined ___scrt_uninitialize_crt(undefined4 param_1,char param_2)

{
  if (param_2 == '\0') {
    ___acrt_uninitialize(param_1);
    ___vcrt_uninitialize(param_1);
  }
  return 1;
}



// WARNING: Removing unreachable block (ram,0x0040ba50)
// Library Function - Single Match
//  __onexit
// 
// Library: Visual Studio 2017 Release

_onexit_t __cdecl __onexit(_onexit_t _Func)

{
  int iVar1;
  
  iVar1 = __register_onexit_function(0x414aa4,_Func);
  return (_onexit_t)(~-(uint)(iVar1 != 0) & (uint)_Func);
}



// Library Function - Single Match
//  _atexit
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int __cdecl _atexit(void *param_1)

{
  _onexit_t p_Var1;
  
  p_Var1 = __onexit((_onexit_t)param_1);
  return (p_Var1 != (_onexit_t)0x0) - 1;
}



uint FUN_0040ba83(void)

{
  uint uVar1;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  uint local_8;
  
  local_10 = 0;
  local_c = 0;
  (*(code *)&LAB_0040e167_1)(&local_10);
  local_8 = local_c ^ local_10;
  uVar1 = (*(code *)0x685959ff)();
  local_8 = local_8 ^ uVar1;
  uVar1 = (*(code *)0xfffe86e8)();
  local_8 = local_8 ^ uVar1;
  (*(code *)&LAB_0040e14e_2)(&local_18);
  return local_14 ^ local_18 ^ local_8 ^ (uint)&local_8;
}



void FUN_0040bb9c(void)

{
  code *pcVar1;
  int iVar2;
  int iVar3;
  undefined4 local_328 [39];
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 *local_c;
  undefined4 *local_8;
  
  iVar2 = FUN_0041731c();
  if (iVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  FUN_0040bd49();
  _memset(local_328,0,0x2cc);
  local_328[0] = 0x10001;
  _memset(&local_5c,0,0x50);
  local_5c = 0x40000015;
  local_58 = 1;
  iVar2 = (*(code *)0xfe75e800)();
  local_c = &local_5c;
  local_8 = local_328;
  (*(code *)0xfffffffe)();
  iVar3 = (*(code *)0xfc45c759)();
  if ((iVar3 == 0) && (iVar2 != 1)) {
    FUN_0040bd49();
  }
  return;
}



// Library Function - Single Match
//  ___scrt_is_managed_app
// 
// Library: Visual Studio 2015 Release

uint ___scrt_is_managed_app(void)

{
  int *piVar1;
  int *piVar2;
  
  piVar1 = (int *)(*(code *)0x3904468b)(0);
  piVar2 = piVar1;
  if ((((piVar1 != (int *)0x0) && (piVar2 = (int *)0x5a4d, *(short *)piVar1 == 0x5a4d)) &&
      (piVar2 = (int *)(piVar1[0xf] + (int)piVar1), *piVar2 == 0x4550)) &&
     ((*(short *)(piVar2 + 6) == 0x10b && (0xe < (uint)piVar2[0x1d])))) {
    return (uint)piVar2 & 0xffffff00 | (uint)(piVar2[0x3a] != 0);
  }
  return (uint)piVar2 & 0xffffff00;
}



// Library Function - Single Match
//  ___scrt_unhandled_exception_filter@4
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 ___scrt_unhandled_exception_filter_4(int **param_1)

{
  int *piVar1;
  int iVar2;
  code *pcVar3;
  undefined4 uVar4;
  
  piVar1 = *param_1;
  if (((*piVar1 == -0x1f928c9d) && (piVar1[4] == 3)) &&
     ((iVar2 = piVar1[5], iVar2 == 0x19930520 ||
      (((iVar2 == 0x19930521 || (iVar2 == 0x19930522)) || (iVar2 == 0x1994000)))))) {
    _terminate();
    pcVar3 = (code *)swi(3);
    uVar4 = (*pcVar3)();
    return uVar4;
  }
  return 0;
}



void FUN_0040bd49(void)

{
  uRam00414ad8 = 0;
                    // WARNING: Read-only address (ram,0x00414ad8) is written
  return;
}



void FUN_0040bda7(void)

{
                    // WARNING: Treating indirect jump as call
  (*(code *)0xff0875ff)();
  return;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// Library Function - Single Match
//  __SEH_prolog4
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __SEH_prolog4(undefined4 param_1,int param_2)

{
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  param_2 = -param_2;
  *(undefined4 *)((int)auStack28 + param_2 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + param_2 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + param_2 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + param_2 + 4) = (uint)&stack0x00000008 ^ 0x74c08447;
  *(undefined4 *)((int)auStack28 + param_2) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __SEH_epilog4
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __SEH_epilog4(void)

{
  undefined4 *unaff_EBP;
  undefined4 *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  *in_FS_OFFSET = unaff_EBP[-4];
  *unaff_EBP = unaff_retaddr;
  return;
}



// WARNING: Removing unreachable block (ram,0x0040be90)
// WARNING: Removing unreachable block (ram,0x0040be55)
// WARNING: Removing unreachable block (ram,0x0040bf08)

undefined4 FUN_0040be14(void)

{
  int *piVar1;
  uint *puVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint in_XCR0;
  
                    // WARNING: Read-only address (ram,0x00414adc) is written
  uRam00414adc = 0;
                    // WARNING: Read-only address (ram,0x00414010) is written
  uRam00414010 = 0xc0844707;
  iVar3 = FUN_0041731c(10);
  if (iVar3 != 0) {
                    // WARNING: Read-only address (ram,0x00414010) is written
    uRam00414010 = 0xc0844707;
                    // WARNING: Read-only address (ram,0x00414adc) is written
    uRam00414adc = 1;
    piVar1 = (int *)cpuid_basic_info(0);
    puVar2 = (uint *)cpuid_Version_info(1);
    uVar5 = puVar2[3];
    if (((piVar1[1] ^ 0x756e6547U | piVar1[3] ^ 0x6c65746eU | piVar1[2] ^ 0x49656e69U) == 0) &&
       (((((uVar4 = *puVar2 & 0xfff3ff0, uVar4 == 0x106c0 || (uVar4 == 0x20660)) ||
          (uVar4 == 0x20670)) || ((uVar4 == 0x30650 || (uVar4 == 0x30660)))) || (uVar4 == 0x30670)))
       ) {
                    // WARNING: Read-only address (ram,0x00414ae0) is written
      uRam00414ae0 = 0xfff95085;
    }
    if (*piVar1 < 7) {
      uVar4 = 0;
    }
    else {
      iVar3 = cpuid_Extended_Feature_Enumeration_info(7);
      uVar4 = *(uint *)(iVar3 + 4);
      if ((uVar4 & 0x200) != 0) {
                    // WARNING: Read-only address (ram,0x00414ae0) is written
        uRam00414ae0 = 0xfff95087;
      }
    }
    if ((uVar5 & 0x100000) != 0) {
                    // WARNING: Read-only address (ram,0x00414010) is written
      uRam00414010 = 0xc0844707;
                    // WARNING: Read-only address (ram,0x00414adc) is written
      uRam00414adc = 2;
      if ((((uVar5 & 0x8000000) != 0) && ((uVar5 & 0x10000000) != 0)) && ((in_XCR0 & 6) == 6)) {
                    // WARNING: Read-only address (ram,0x00414adc) is written
        uRam00414adc = 3;
                    // WARNING: Read-only address (ram,0x00414010) is written
        uRam00414010 = 0xc084470f;
        if ((uVar4 & 0x20) != 0) {
                    // WARNING: Read-only address (ram,0x00414adc) is written
          uRam00414adc = 5;
                    // WARNING: Read-only address (ram,0x00414010) is written
          uRam00414010 = 0xc084472f;
        }
      }
    }
  }
  return 0;
}



// Library Function - Single Match
//  ___scrt_is_ucrt_dll_in_use
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 ___scrt_is_ucrt_dll_in_use(void)

{
  return 1;
}



// Library Function - Single Match
//  _ValidateLocalCookies
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void _ValidateLocalCookies(int *param_1)

{
  if (*param_1 != -2) {
    ___security_check_cookie_4();
  }
  ___security_check_cookie_4();
  return;
}



undefined4 FUN_0040bff9(int *param_1,int param_2,undefined4 param_3)

{
  int iVar1;
  code *pcVar2;
  int iVar3;
  BOOL BVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  int *local_20;
  undefined4 local_1c;
  int local_18;
  int local_14;
  undefined4 local_10;
  uint local_c;
  char local_5;
  
  local_5 = '\0';
  iVar6 = param_2 + 0x10;
  local_c = *(uint *)(param_2 + 8) ^ 0x74c08447;
  local_10 = 1;
  local_14 = iVar6;
  _ValidateLocalCookies(local_c,iVar6);
  ___except_validate_context_record(param_3);
  iVar7 = *(int *)(param_2 + 0xc);
  if ((*(byte *)(param_1 + 1) & 0x66) == 0) {
    local_20 = param_1;
    local_1c = param_3;
    *(int ***)(param_2 + -4) = &local_20;
    if (iVar7 == -2) {
      return local_10;
    }
    do {
      iVar3 = iVar7 * 3 + 4;
      iVar1 = *(int *)(local_c + iVar3 * 4);
      local_18 = local_c + iVar3 * 4;
      if (*(int *)(local_18 + 4) != 0) {
        iVar3 = __EH4_CallFilterFunc_8();
        local_5 = '\x01';
        if (iVar3 < 0) {
          local_10 = 0;
          goto LAB_0040c111;
        }
        if (0 < iVar3) {
          if ((*param_1 == -0x1f928c9d) && (BVar4 = __IsNonwritableInCurrentImage(""), BVar4 != 0))
          {
            FUN_0040bda7(param_1,1);
            (*(code *)0x166a0000)();
            iVar6 = local_14;
          }
          FUN_0040c43d();
          if (*(int *)(param_2 + 0xc) != iVar7) {
            __EH4_LocalUnwind_16(iVar6,0x414000);
          }
          *(int *)(param_2 + 0xc) = iVar1;
          _ValidateLocalCookies(local_c,iVar6);
          __EH4_TransferToHandler_8();
          pcVar2 = (code *)swi(3);
          uVar5 = (*pcVar2)();
          return uVar5;
        }
      }
      iVar7 = iVar1;
    } while (iVar1 != -2);
    if (local_5 == '\0') {
      return local_10;
    }
  }
  else {
    if (iVar7 == -2) {
      return local_10;
    }
    __EH4_LocalUnwind_16(iVar6,0x414000);
  }
LAB_0040c111:
  _ValidateLocalCookies(local_c,iVar6);
  return local_10;
}



// Library Function - Single Match
//  ___vcrt_initialize
// 
// Library: Visual Studio 2015 Release

undefined ___vcrt_initialize(void)

{
  char cVar1;
  
  ___vcrt_initialize_pure_virtual_call_handler();
  ___vcrt_initialize_winapi_thunks();
  cVar1 = ___vcrt_initialize_locks();
  if (cVar1 != '\0') {
    cVar1 = FUN_0040c4e9();
    if (cVar1 != '\0') {
      return 1;
    }
    ___vcrt_uninitialize_locks();
  }
  return 0;
}



// Library Function - Single Match
//  ___vcrt_uninitialize
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined ___vcrt_uninitialize(char param_1)

{
  if (param_1 == '\0') {
    ___vcrt_uninitialize_ptd();
    ___vcrt_uninitialize_locks();
    ___vcrt_uninitialize_winapi_thunks(0);
  }
  return 1;
}



// WARNING: Removing unreachable block (ram,0x0040c1e5)
// WARNING: Removing unreachable block (ram,0x0040c1e7)
// Library Function - Single Match
//  _memset
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void * __cdecl _memset(void *_Dst,int _Val,size_t _Size)

{
  uint uVar1;
  int iVar2;
  int *piVar3;
  
  if (_Size != 0) {
    iVar2 = (_Val & 0xffU) * 0x1010101;
    if (0x20 < (int)_Size) {
      piVar3 = (int *)_Dst;
      if (0x7f < (int)_Size) {
        *(int *)_Dst = iVar2;
        *(int *)((int)_Dst + 4) = iVar2;
        *(int *)((int)_Dst + 8) = iVar2;
        *(int *)((int)_Dst + 0xc) = iVar2;
        piVar3 = (int *)((int)_Dst + 0x10U & 0xfffffff0);
        _Size = (int)_Dst + (_Size - (int)piVar3);
        if (0x80 < (int)_Size) {
          do {
            *piVar3 = iVar2;
            piVar3[1] = iVar2;
            piVar3[2] = iVar2;
            piVar3[3] = iVar2;
            piVar3[4] = iVar2;
            piVar3[5] = iVar2;
            piVar3[6] = iVar2;
            piVar3[7] = iVar2;
            piVar3[8] = iVar2;
            piVar3[9] = iVar2;
            piVar3[10] = iVar2;
            piVar3[0xb] = iVar2;
            piVar3[0xc] = iVar2;
            piVar3[0xd] = iVar2;
            piVar3[0xe] = iVar2;
            piVar3[0xf] = iVar2;
            piVar3[0x10] = iVar2;
            piVar3[0x11] = iVar2;
            piVar3[0x12] = iVar2;
            piVar3[0x13] = iVar2;
            piVar3[0x14] = iVar2;
            piVar3[0x15] = iVar2;
            piVar3[0x16] = iVar2;
            piVar3[0x17] = iVar2;
            piVar3[0x18] = iVar2;
            piVar3[0x19] = iVar2;
            piVar3[0x1a] = iVar2;
            piVar3[0x1b] = iVar2;
            piVar3[0x1c] = iVar2;
            piVar3[0x1d] = iVar2;
            piVar3[0x1e] = iVar2;
            piVar3[0x1f] = iVar2;
            piVar3 = piVar3 + 0x20;
            _Size = _Size - 0x80;
          } while ((_Size & 0xffffff00) != 0);
        }
      }
      if (0x1f < _Size) {
        do {
          *piVar3 = iVar2;
          piVar3[1] = iVar2;
          piVar3[2] = iVar2;
          piVar3[3] = iVar2;
          piVar3[4] = iVar2;
          piVar3[5] = iVar2;
          piVar3[6] = iVar2;
          piVar3[7] = iVar2;
          piVar3 = piVar3 + 8;
          _Size = _Size - 0x20;
        } while (0x1f < _Size);
        if ((_Size & 0x1f) == 0) {
          return _Dst;
        }
      }
      piVar3 = (int *)((int)piVar3 + (_Size - 0x20));
      *piVar3 = iVar2;
      piVar3[1] = iVar2;
      piVar3[2] = iVar2;
      piVar3[3] = iVar2;
      piVar3[4] = iVar2;
      piVar3[5] = iVar2;
      piVar3[6] = iVar2;
      piVar3[7] = iVar2;
      return _Dst;
    }
    uVar1 = _Size & 3;
    piVar3 = (int *)_Dst;
    while (uVar1 != 0) {
      *(char *)piVar3 = (char)iVar2;
      piVar3 = (int *)((int)piVar3 + 1);
      _Size = _Size - 1;
      uVar1 = _Size & 3;
    }
    if ((_Size & 4) != 0) {
      *piVar3 = iVar2;
      piVar3 = piVar3 + 1;
      _Size = _Size - 4;
    }
    for (; (_Size & 0xfffffff8) != 0; _Size = _Size - 8) {
      *piVar3 = iVar2;
      piVar3[1] = iVar2;
      piVar3 = piVar3 + 2;
    }
  }
  return _Dst;
}



// Library Function - Single Match
//  __local_unwind4
// 
// Library: Visual Studio

void __local_unwind4(uint *param_1,int param_2,uint param_3)

{
  undefined4 *puVar1;
  uint uVar2;
  undefined4 *in_FS_OFFSET;
  undefined4 uStack40;
  undefined4 uStack36;
  uint local_20;
  uint uStack28;
  int iStack24;
  uint *puStack20;
  
  puStack20 = param_1;
  iStack24 = param_2;
  uStack28 = param_3;
  uStack36 = 0x401f40;
  uStack40 = *in_FS_OFFSET;
  local_20 = (uint)&uStack40 ^ 0x74c08447;
  *in_FS_OFFSET = &uStack40;
  while( true ) {
    uVar2 = *(uint *)(param_2 + 0xc);
    if ((uVar2 == 0xfffffffe) || ((param_3 != 0xfffffffe && (uVar2 <= param_3)))) break;
    puVar1 = (undefined4 *)((*(uint *)(param_2 + 8) ^ *param_1) + 0x10 + uVar2 * 0xc);
    *(undefined4 *)(param_2 + 0xc) = *puVar1;
    if (puVar1[1] == 0) {
      __NLG_Notify(0x101);
      FUN_0040c9c4();
    }
  }
  *in_FS_OFFSET = uStack40;
  return;
}



// Library Function - Single Match
//  @_EH4_CallFilterFunc@8
// 
// Library: Visual Studio

void __fastcall __EH4_CallFilterFunc_8(code *param_1)

{
  (*param_1)();
  return;
}



// Library Function - Single Match
//  @_EH4_TransferToHandler@8
// 
// Library: Visual Studio

void __fastcall __EH4_TransferToHandler_8(code *UNRECOVERED_JUMPTABLE)

{
  __NLG_Notify(1);
                    // WARNING: Could not recover jumptable at 0x0040c438. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)();
  return;
}



void __fastcall FUN_0040c43d(undefined4 param_1,undefined4 param_2)

{
  (*(code *)0xc60d7518)(param_1,0x401ff9,param_2,0);
  return;
}



// Library Function - Single Match
//  @_EH4_LocalUnwind@16
// 
// Library: Visual Studio

void __fastcall
__EH4_LocalUnwind_16
          (undefined4 param_1_00,undefined4 param_2_00,undefined4 param_1,undefined4 param_2)

{
  __local_unwind4(param_2,param_1_00,param_2_00);
  return;
}



// Library Function - Single Match
//  ___except_validate_context_record
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___except_validate_context_record(int param_1)

{
  uint *puVar1;
  uint uVar2;
  code *pcVar3;
  int in_FS_OFFSET;
  
  uVar2 = *(uint *)(param_1 + 0xc4);
  if ((uVar2 < *(uint *)(*(int *)(in_FS_OFFSET + 0x18) + 8)) ||
     (puVar1 = (uint *)(*(int *)(in_FS_OFFSET + 0x18) + 4), *puVar1 <= uVar2 && uVar2 != *puVar1)) {
    pcVar3 = (code *)swi(0x29);
    (*pcVar3)();
  }
  return;
}



// Library Function - Single Match
//  ___except_validate_jump_buffer
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___except_validate_jump_buffer(int param_1)

{
  uint *puVar1;
  uint uVar2;
  code *pcVar3;
  int in_FS_OFFSET;
  
  uVar2 = *(uint *)(param_1 + 0x10);
  if ((uVar2 < *(uint *)(*(int *)(in_FS_OFFSET + 0x18) + 8)) ||
     (puVar1 = (uint *)(*(int *)(in_FS_OFFSET + 0x18) + 4), *puVar1 <= uVar2 && uVar2 != *puVar1)) {
    pcVar3 = (code *)swi(0x29);
    (*pcVar3)();
  }
  return;
}



void FUN_0040c4cd(void *param_1)

{
  if ((param_1 != (void *)0x0) && (param_1 != (void *)0x414ae4)) {
    FID_conflict__free(param_1);
  }
  return;
}



undefined4 FUN_0040c4e9(void)

{
  int iVar1;
  
  iRam00414020 = ___vcrt_FlsAlloc(0x402074);
                    // WARNING: Read-only address (ram,0x00414020) is written
  if (iRam00414020 != -1) {
    iVar1 = ___vcrt_FlsSetValue(iRam00414020,0x414ae4);
    if (iVar1 != 0) {
      return 1;
    }
    ___vcrt_FlsFree(0x558bd285);
                    // WARNING: Read-only address (ram,0x00414020) is written
    iRam00414020 = -1;
  }
  return 0;
}



// Library Function - Single Match
//  ___vcrt_uninitialize_ptd
// 
// Library: Visual Studio 2015 Release

undefined4 ___vcrt_uninitialize_ptd(void)

{
  ___vcrt_FlsFree(0x558bd285);
                    // WARNING: Read-only address (ram,0x00414020) is written
  uRam00414020 = 0xffffffff;
  return 1;
}



// Library Function - Single Match
//  ___vcrt_initialize_locks
// 
// Library: Visual Studio 2015 Release

undefined4 ___vcrt_initialize_locks(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  
  iVar3 = 0x414b0c;
  uVar2 = 0;
  do {
    iVar1 = ___vcrt_InitializeCriticalSectionEx(iVar3,4000,0);
    if (iVar1 == 0) {
      ___vcrt_uninitialize_locks();
      return 0;
    }
                    // WARNING: Read-only address (ram,0x00414b24) is written
    uRam00414b24 = 0x685350c2;
    uVar2 = uVar2 + 0x18;
    iVar3 = iVar3 + 0x18;
  } while (uVar2 < 0x18);
                    // WARNING: Read-only address (ram,0x00414b24) is written
  uRam00414b24 = 0x685350c2;
  return 1;
}



// Library Function - Single Match
//  ___vcrt_uninitialize_locks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 ___vcrt_uninitialize_locks(void)

{
  int iVar1;
  int iVar2;
  
  iVar1 = 0x685350c1;
  iVar2 = -0x37ef22f4;
  do {
    (*(code *)0x458bc300)(iVar2);
                    // WARNING: Read-only address (ram,0x00414b24) is written
    uRam00414b24 = 0x685350c0;
    iVar2 = iVar2 + -0x18;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  uRam00414b24 = 0x685350c0;
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  struct HINSTANCE__ * __cdecl try_get_first_available_module(enum `anonymous
// namespace'::module_id const * const,enum `anonymous namespace'::module_id const * const)
// 
// Library: Visual Studio 2017 Release

HINSTANCE__ * __cdecl try_get_first_available_module(module_id *param_1,module_id *param_2)

{
  HINSTANCE__ **ppHVar1;
  wchar_t *_Str1;
  HINSTANCE__ *pHVar2;
  HINSTANCE__ *pHVar3;
  int iVar4;
  
  do {
    if (param_1 == param_2) {
      return (HINSTANCE__ *)0x0;
    }
    ppHVar1 = (HINSTANCE__ **)(*param_1 * 4 + 0x414b28);
    pHVar3 = *ppHVar1;
    if (pHVar3 == (HINSTANCE__ *)0x0) {
      _Str1 = *(wchar_t **)(*param_1 * 4 + 0x40e178);
      pHVar3 = (HINSTANCE__ *)(*FUN_0040e073)(_Str1,0,0x800);
      if (pHVar3 == (HINSTANCE__ *)0x0) {
        iVar4 = (*(code *)0x414cb805)();
        if (((iVar4 == 0x57) &&
            (iVar4 = _wcsncmp(_Str1,
                              L"崀诃嗿\xec8bjj痿\xe808﹢\xffff쒃崌诃嗿\xec8b䖋㴈䀀",7),
            iVar4 != 0)) &&
           (iVar4 = _wcsncmp(_Str1,L"﹢\xffff쒃崌诃嗿\xec8b䖋㴈䀀",7), iVar4 != 0)) {
          pHVar3 = (HINSTANCE__ *)(*FUN_0040e073)(_Str1,0,0);
        }
        else {
          pHVar3 = (HINSTANCE__ *)0x0;
        }
        if (pHVar3 == (HINSTANCE__ *)0x0) {
          *ppHVar1 = (HINSTANCE__ *)0xffffffff;
          goto LAB_0040c662;
        }
      }
      pHVar2 = *ppHVar1;
      *ppHVar1 = pHVar3;
      if (pHVar2 != (HINSTANCE__ *)0x0) {
        (*(code *)0x8bcc0000)(pHVar3);
      }
LAB_0040c65e:
      if (pHVar3 != (HINSTANCE__ *)0x0) {
        return pHVar3;
      }
    }
    else if (pHVar3 != (HINSTANCE__ *)0xffffffff) goto LAB_0040c65e;
LAB_0040c662:
    param_1 = param_1 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_0040c67b(int param_1,undefined4 param_2,module_id *param_3,module_id *param_4)

{
  uint *puVar1;
  HINSTANCE__ *pHVar2;
  uint uVar3;
  
  puVar1 = (uint *)(param_1 * 4 + 0x414b34);
  uVar3 = (*puVar1 ^ 0x74c08447) >> 7 | (*puVar1 ^ 0x74c08447) << 0x19;
  if (uVar3 != 0xffffffff) {
    if (uVar3 != 0) {
      return uVar3;
    }
    pHVar2 = try_get_first_available_module(param_3,param_4);
    if ((pHVar2 != (HINSTANCE__ *)0x0) && (uVar3 = (*FUN_0040e073)(pHVar2,param_2), uVar3 != 0)) {
      *puVar1 = (uVar3 >> 0x19 | uVar3 << 7) ^ 0x74c08447;
      return uVar3;
    }
    *puVar1 = 0x8b3f7bb8;
  }
  return 0;
}



// Library Function - Single Match
//  ___vcrt_FlsAlloc
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsAlloc(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_0040c67b(0,0x40e238,0x40e230,0x40e238);
  if (pcVar1 != (code *)0x0) {
    FUN_0040bda7(param_1);
    (*pcVar1)();
    return;
  }
                    // WARNING: Treating indirect jump as call
  (*(code *)0xde830)();
  return;
}



// Library Function - Single Match
//  ___vcrt_FlsFree
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsFree(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_0040c67b(1,0x40e24c,0x40e244,0x40e24c);
  if (pcVar1 == (code *)0x0) {
    (*(code *)0x8b9e8e8)(param_1);
  }
  else {
    FUN_0040bda7();
    (*pcVar1)();
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_FlsSetValue
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsSetValue(undefined4 param_1,undefined4 param_2)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_0040c67b(3,&DAT_0040e268,0x40e260,&DAT_0040e268);
  if (pcVar1 == (code *)0x0) {
    (*(code *)0x658bc304)(param_1,param_2);
  }
  else {
    FUN_0040bda7();
    (*pcVar1)();
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_InitializeCriticalSectionEx
// 
// Library: Visual Studio 2015 Release

void ___vcrt_InitializeCriticalSectionEx(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_0040c67b(4,&LAB_0040e27c,&DAT_0040e274,&LAB_0040e27c);
  if (pcVar1 == (code *)0x0) {
    (*(code *)0xff008bec)(param_1,param_2);
  }
  else {
    FUN_0040bda7(param_1,param_2,param_3);
    (*pcVar1)();
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_initialize_winapi_thunks
// 
// Library: Visual Studio 2015 Release

void ___vcrt_initialize_winapi_thunks(void)

{
  undefined4 *puVar1;
  int iVar2;
  
  puVar1 = (undefined4 *)0x414b34;
  iVar2 = 0;
  do {
    iVar2 = iVar2 + 1;
    *puVar1 = 0x74c08447;
    puVar1 = puVar1 + 1;
  } while (iVar2 != 5);
  return;
}



// Library Function - Single Match
//  ___vcrt_uninitialize_winapi_thunks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___vcrt_uninitialize_winapi_thunks(char param_1)

{
  int *piVar1;
  
  if (param_1 == '\0') {
    piVar1 = (int *)0x414b28;
    do {
      if (*piVar1 != 0) {
        if (*piVar1 != -1) {
          (*(code *)0x8bcc0000)(*piVar1);
        }
        *piVar1 = 0;
      }
      piVar1 = piVar1 + 1;
    } while (piVar1 != (int *)0x414b34);
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_initialize_pure_virtual_call_handler
// 
// Library: Visual Studio 2015 Release

void ___vcrt_initialize_pure_virtual_call_handler(void)

{
  uRam00414b48 = 0x74c08447;
                    // WARNING: Read-only address (ram,0x00414b48) is written
  return;
}



// Library Function - Single Match
//  __global_unwind2
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __global_unwind2(undefined4 param_1)

{
  (*(code *)0xc60d7518)(param_1,0x402449,0,0,&stack0xfffffffc);
  return;
}



// Library Function - Single Match
//  __local_unwind2
// 
// Library: Visual Studio

void __local_unwind2(int param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  undefined4 *in_FS_OFFSET;
  undefined4 local_20;
  undefined4 uStack28;
  undefined4 local_18;
  int iStack20;
  
  iStack20 = param_1;
  uStack28 = 0x402451;
  local_20 = *in_FS_OFFSET;
  uVar2 = (uint)&local_20 ^ 0x74c08447;
  *in_FS_OFFSET = &local_20;
  while( true ) {
    uVar1 = *(uint *)(param_1 + 0xc);
    if ((uVar1 == 0xffffffff) || ((param_2 != 0xffffffff && (uVar1 <= param_2)))) break;
    local_18 = *(undefined4 *)(*(int *)(param_1 + 8) + uVar1 * 0xc);
    *(undefined4 *)(param_1 + 0xc) = local_18;
    if (*(int *)(*(int *)(param_1 + 8) + 4 + uVar1 * 0xc) == 0) {
      __NLG_Notify(0x101);
      FUN_0040c9c4(uVar2);
    }
  }
  *in_FS_OFFSET = local_20;
  return;
}



// Library Function - Single Match
//  __NLG_Notify1
// 
// Library: Visual Studio

undefined4 __fastcall __NLG_Notify1(undefined4 param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
                    // WARNING: Read-only address (ram,0x00414038) is written
                    // WARNING: Read-only address (ram,0x00414034) is written
                    // WARNING: Read-only address (ram,0x0041403c) is written
  uRam00414034 = in_EAX;
  uRam00414038 = param_1;
  uRam0041403c = unaff_EBP;
  return in_EAX;
}



// Library Function - Single Match
//  __NLG_Notify
// 
// Library: Visual Studio

void __NLG_Notify(ulong param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  uRam00414034 = in_EAX;
  uRam00414038 = param_1;
  uRam0041403c = unaff_EBP;
                    // WARNING: Read-only address (ram,0x00414038) is written
                    // WARNING: Read-only address (ram,0x00414034) is written
                    // WARNING: Read-only address (ram,0x0041403c) is written
  return;
}



void FUN_0040c9c4(void)

{
  code *in_EAX;
  
  (*in_EAX)();
  return;
}



// WARNING: Control flow encountered bad instruction data
// WARNING: Removing unreachable block (ram,0x0040ca17)
// WARNING: Removing unreachable block (ram,0x0040ca19)
// WARNING: Removing unreachable block (ram,0x0040ca08)
// WARNING: Removing unreachable block (ram,0x0040cc9a)
// WARNING: Removing unreachable block (ram,0x0040cca2)
// WARNING: Removing unreachable block (ram,0x0040cca9)
// WARNING: Removing unreachable block (ram,0x0040ccb6)
// WARNING: Removing unreachable block (ram,0x0040ccbf)
// WARNING: Removing unreachable block (ram,0x0040ccce)
// WARNING: Removing unreachable block (ram,0x0040ccd0)
// WARNING: Removing unreachable block (ram,0x081e7225)
// WARNING: Switch with 1 destination removed at 0x0040cc1e
// WARNING: Exceeded maximum restarts with more pending

undefined8 FUN_0040c9c9(undefined8 *param_1,undefined8 *param_2,uint param_3)

{
  undefined auVar1 [32];
  undefined auVar2 [32];
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  undefined4 uVar19;
  undefined4 uVar20;
  undefined4 uVar21;
  undefined4 uVar22;
  undefined4 uVar23;
  undefined4 uVar24;
  undefined4 uVar25;
  undefined4 uVar26;
  undefined4 uVar27;
  undefined4 uVar28;
  undefined4 uVar29;
  undefined4 uVar30;
  int iVar31;
  uint uVar32;
  uint uVar33;
  int iVar34;
  undefined8 *puVar35;
  undefined4 *puVar36;
  undefined4 *puVar37;
  undefined8 *puVar38;
  undefined4 *puVar39;
  undefined4 *puVar40;
  undefined4 uVar41;
  undefined4 uVar42;
  undefined4 uVar43;
  undefined8 uVar44;
  
  if ((param_2 < param_1) && (param_1 < (undefined8 *)(param_3 + (int)param_2))) {
    puVar37 = (undefined4 *)((int)param_2 + param_3);
    puVar40 = (undefined4 *)((int)param_1 + param_3);
    uVar33 = param_3;
    if (0x1f < param_3) {
      while (puVar36 = puVar37, puVar39 = puVar40, ((uint)puVar40 & 0xf) != 0) {
        puVar37 = (undefined4 *)((int)puVar37 + -1);
        puVar40 = (undefined4 *)((int)puVar40 + -1);
        *(undefined *)puVar40 = *(undefined *)puVar37;
        uVar33 = uVar33 - 1;
      }
      do {
        puVar37 = puVar36;
        puVar40 = puVar39;
        if (uVar33 < 0x80) break;
        puVar37 = puVar36 + -0x20;
        puVar40 = puVar39 + -0x20;
        uVar41 = puVar36[-0x1f];
        uVar42 = puVar36[-0x1e];
        uVar43 = puVar36[-0x1d];
        uVar3 = puVar36[-0x1c];
        uVar4 = puVar36[-0x1b];
        uVar5 = puVar36[-0x1a];
        uVar6 = puVar36[-0x19];
        uVar7 = puVar36[-0x18];
        uVar8 = puVar36[-0x17];
        uVar9 = puVar36[-0x16];
        uVar10 = puVar36[-0x15];
        uVar11 = puVar36[-0x14];
        uVar12 = puVar36[-0x13];
        uVar13 = puVar36[-0x12];
        uVar14 = puVar36[-0x11];
        uVar15 = puVar36[-0x10];
        uVar16 = puVar36[-0xf];
        uVar17 = puVar36[-0xe];
        uVar18 = puVar36[-0xd];
        uVar19 = puVar36[-0xc];
        uVar20 = puVar36[-0xb];
        uVar21 = puVar36[-10];
        uVar22 = puVar36[-9];
        uVar23 = puVar36[-8];
        uVar24 = puVar36[-7];
        uVar25 = puVar36[-6];
        uVar26 = puVar36[-5];
        uVar27 = puVar36[-4];
        uVar28 = puVar36[-3];
        uVar29 = puVar36[-2];
        uVar30 = puVar36[-1];
        *puVar40 = *puVar37;
        puVar39[-0x1f] = uVar41;
        puVar39[-0x1e] = uVar42;
        puVar39[-0x1d] = uVar43;
        puVar39[-0x1c] = uVar3;
        puVar39[-0x1b] = uVar4;
        puVar39[-0x1a] = uVar5;
        puVar39[-0x19] = uVar6;
        puVar39[-0x18] = uVar7;
        puVar39[-0x17] = uVar8;
        puVar39[-0x16] = uVar9;
        puVar39[-0x15] = uVar10;
        puVar39[-0x14] = uVar11;
        puVar39[-0x13] = uVar12;
        puVar39[-0x12] = uVar13;
        puVar39[-0x11] = uVar14;
        puVar39[-0x10] = uVar15;
        puVar39[-0xf] = uVar16;
        puVar39[-0xe] = uVar17;
        puVar39[-0xd] = uVar18;
        puVar39[-0xc] = uVar19;
        puVar39[-0xb] = uVar20;
        puVar39[-10] = uVar21;
        puVar39[-9] = uVar22;
        puVar39[-8] = uVar23;
        puVar39[-7] = uVar24;
        puVar39[-6] = uVar25;
        puVar39[-5] = uVar26;
        puVar39[-4] = uVar27;
        puVar39[-3] = uVar28;
        puVar39[-2] = uVar29;
        puVar39[-1] = uVar30;
        uVar33 = uVar33 - 0x80;
        puVar36 = puVar37;
        puVar39 = puVar40;
      } while ((uVar33 & 0xffffff80) != 0);
      puVar36 = puVar37;
      puVar39 = puVar40;
      if (0x1f < uVar33) {
        do {
          puVar37 = puVar36 + -8;
          puVar40 = puVar39 + -8;
          uVar41 = puVar36[-7];
          uVar42 = puVar36[-6];
          uVar43 = puVar36[-5];
          uVar3 = puVar36[-4];
          uVar4 = puVar36[-3];
          uVar5 = puVar36[-2];
          uVar6 = puVar36[-1];
          *puVar40 = *puVar37;
          puVar39[-7] = uVar41;
          puVar39[-6] = uVar42;
          puVar39[-5] = uVar43;
          puVar39[-4] = uVar3;
          puVar39[-3] = uVar4;
          puVar39[-2] = uVar5;
          puVar39[-1] = uVar6;
          uVar33 = uVar33 - 0x20;
          puVar36 = puVar37;
          puVar39 = puVar40;
        } while ((uVar33 & 0xffffffe0) != 0);
      }
    }
    for (; (uVar33 & 0xfffffffc) != 0; uVar33 = uVar33 - 4) {
      puVar40 = puVar40 + -1;
      puVar37 = puVar37 + -1;
      *puVar40 = *puVar37;
    }
    for (; uVar33 != 0; uVar33 = uVar33 - 1) {
      puVar40 = (undefined4 *)((int)puVar40 + -1);
      puVar37 = (undefined4 *)((int)puVar37 + -1);
      *(undefined *)puVar40 = *(undefined *)puVar37;
    }
    return CONCAT44(param_3,param_1);
  }
  uVar33 = param_3;
  puVar38 = param_1;
  if (0x1f < param_3) {
    if (0x7f < param_3) {
      if ((((uint)param_1 ^ (uint)param_2) & 0xf) != 0) {
        if (((uint)param_1 & 3) == 0) {
          if (((uint)param_2 & 3) == 0) {
            if (((uint)param_1 >> 2 & 1) != 0) {
              uVar41 = *(undefined4 *)param_2;
              param_3 = param_3 - 4;
              param_2 = (undefined8 *)((int)param_2 + 4);
              *(undefined4 *)param_1 = uVar41;
              param_1 = (undefined8 *)((int)param_1 + 4);
            }
            if (((uint)param_1 >> 3 & 1) != 0) {
              uVar44 = *param_2;
              param_3 = param_3 - 8;
              param_2 = param_2 + 1;
              *param_1 = uVar44;
              param_1 = param_1 + 1;
            }
            if (((uint)param_2 & 7) == 0) {
              puVar38 = param_2 + -1;
              uVar41 = *(undefined4 *)param_2;
              uVar42 = *(undefined4 *)((int)param_2 + 4);
              do {
                puVar35 = puVar38;
                uVar4 = *(undefined4 *)(puVar35 + 4);
                uVar5 = *(undefined4 *)((int)puVar35 + 0x24);
                param_3 = param_3 - 0x30;
                auVar1 = *(undefined (*) [32])(puVar35 + 2);
                uVar43 = *(undefined4 *)(puVar35 + 7);
                uVar3 = *(undefined4 *)((int)puVar35 + 0x3c);
                auVar2 = *(undefined (*) [32])(puVar35 + 4);
                *(undefined4 *)(param_1 + 1) = uVar41;
                *(undefined4 *)((int)param_1 + 0xc) = uVar42;
                *(undefined4 *)(param_1 + 2) = uVar4;
                *(undefined4 *)((int)param_1 + 0x14) = uVar5;
                *(undefined (*) [16])(param_1 + 2) = SUB3216(auVar1 >> 0x40,0);
                *(undefined (*) [16])(param_1 + 4) = SUB3216(auVar2 >> 0x40,0);
                param_1 = param_1 + 6;
                puVar38 = puVar35 + 6;
                uVar41 = uVar43;
                uVar42 = uVar3;
              } while (0x2f < (int)param_3);
              puVar35 = puVar35 + 7;
            }
            else if (((uint)param_2 >> 3 & 1) == 0) {
              iVar31 = (int)param_2 + -4;
              uVar41 = *(undefined4 *)param_2;
              uVar42 = *(undefined4 *)((int)param_2 + 4);
              uVar43 = *(undefined4 *)(param_2 + 1);
              do {
                iVar34 = iVar31;
                uVar6 = *(undefined4 *)(iVar34 + 0x20);
                param_3 = param_3 - 0x30;
                auVar1 = *(undefined (*) [32])(iVar34 + 0x10);
                uVar3 = *(undefined4 *)(iVar34 + 0x34);
                uVar4 = *(undefined4 *)(iVar34 + 0x38);
                uVar5 = *(undefined4 *)(iVar34 + 0x3c);
                auVar2 = *(undefined (*) [32])(iVar34 + 0x20);
                *(undefined4 *)((int)param_1 + 4) = uVar41;
                *(undefined4 *)(param_1 + 1) = uVar42;
                *(undefined4 *)((int)param_1 + 0xc) = uVar43;
                *(undefined4 *)(param_1 + 2) = uVar6;
                *(undefined (*) [16])(param_1 + 2) = SUB3216(auVar1 >> 0x20,0);
                *(undefined (*) [16])(param_1 + 4) = SUB3216(auVar2 >> 0x20,0);
                param_1 = param_1 + 6;
                iVar31 = iVar34 + 0x30;
                uVar41 = uVar3;
                uVar42 = uVar4;
                uVar43 = uVar5;
              } while (0x2f < (int)param_3);
              puVar35 = (undefined8 *)(iVar34 + 0x34);
            }
            else {
              iVar31 = (int)param_2 + -0xc;
              uVar41 = *(undefined4 *)param_2;
              do {
                iVar34 = iVar31;
                uVar43 = *(undefined4 *)(iVar34 + 0x20);
                uVar3 = *(undefined4 *)(iVar34 + 0x24);
                uVar4 = *(undefined4 *)(iVar34 + 0x28);
                param_3 = param_3 - 0x30;
                auVar1 = *(undefined (*) [32])(iVar34 + 0x10);
                uVar42 = *(undefined4 *)(iVar34 + 0x3c);
                auVar2 = *(undefined (*) [32])(iVar34 + 0x20);
                *(undefined4 *)((int)param_1 + 0xc) = uVar41;
                *(undefined4 *)(param_1 + 2) = uVar43;
                *(undefined4 *)((int)param_1 + 0x14) = uVar3;
                *(undefined4 *)(param_1 + 3) = uVar4;
                *(undefined (*) [16])(param_1 + 2) = SUB3216(auVar1 >> 0x60,0);
                *(undefined (*) [16])(param_1 + 4) = SUB3216(auVar2 >> 0x60,0);
                param_1 = param_1 + 6;
                iVar31 = iVar34 + 0x30;
                uVar41 = uVar42;
              } while (0x2f < (int)param_3);
              puVar35 = (undefined8 *)(iVar34 + 0x3c);
            }
            for (; 0xf < (int)param_3; param_3 = param_3 - 0x10) {
              uVar41 = *(undefined4 *)puVar35;
              uVar42 = *(undefined4 *)((int)puVar35 + 4);
              uVar43 = *(undefined4 *)(puVar35 + 1);
              uVar3 = *(undefined4 *)((int)puVar35 + 0xc);
              puVar35 = puVar35 + 2;
              *(undefined4 *)param_1 = uVar41;
              *(undefined4 *)((int)param_1 + 4) = uVar42;
              *(undefined4 *)(param_1 + 1) = uVar43;
              *(undefined4 *)((int)param_1 + 0xc) = uVar3;
              param_1 = param_1 + 2;
            }
            if ((param_3 >> 2 & 1) != 0) {
              uVar41 = *(undefined4 *)puVar35;
              param_3 = param_3 - 4;
              puVar35 = (undefined8 *)((int)puVar35 + 4);
              *(undefined4 *)param_1 = uVar41;
              param_1 = (undefined8 *)((int)param_1 + 4);
            }
            if ((param_3 >> 3 & 1) != 0) {
              param_3 = param_3 - 8;
              *param_1 = *puVar35;
            }
                    // WARNING: Could not recover jumptable at 0x0040cbee. Too many branches
                    // WARNING: Treating indirect jump as call
            uVar44 = (**(code **)(param_3 * 4 + 0x4027d4))();
            return uVar44;
          }
        }
        else {
          uVar33 = (uint)param_1 & 3;
          while (uVar33 != 0) {
            *(undefined *)puVar38 = *(undefined *)param_2;
            param_3 = param_3 - 1;
            param_2 = (undefined8 *)((int)param_2 + 1);
            puVar38 = (undefined8 *)((int)puVar38 + 1);
            uVar33 = (uint)puVar38 & 3;
          }
        }
        uVar33 = param_3;
        if (0x1f < param_3) {
          for (param_3 = param_3 >> 2; param_3 != 0; param_3 = param_3 - 1) {
            *(undefined4 *)puVar38 = *(undefined4 *)param_2;
            param_2 = (undefined8 *)((int)param_2 + 4);
            puVar38 = (undefined8 *)((int)puVar38 + 4);
          }
                    // WARNING: Bad instruction - Truncating control flow here
          halt_baddata();
        }
        goto LAB_0040cec4;
      }
      if (((uint)param_2 & 0xf) != 0) {
        uVar32 = 0x10 - ((uint)param_2 & 0xf);
        param_3 = param_3 - uVar32;
        for (uVar33 = uVar32 & 3; uVar33 != 0; uVar33 = uVar33 - 1) {
          *(undefined *)puVar38 = *(undefined *)param_2;
          param_2 = (undefined8 *)((int)param_2 + 1);
          puVar38 = (undefined8 *)((int)puVar38 + 1);
        }
        for (uVar32 = uVar32 >> 2; uVar32 != 0; uVar32 = uVar32 - 1) {
          *(undefined4 *)puVar38 = *(undefined4 *)param_2;
          param_2 = (undefined8 *)((int)param_2 + 4);
          puVar38 = (undefined8 *)((int)puVar38 + 4);
        }
      }
      uVar32 = param_3 & 0x7f;
      for (uVar33 = param_3 >> 7; param_3 = uVar32, uVar33 != 0; uVar33 = uVar33 - 1) {
        uVar41 = *(undefined4 *)((int)param_2 + 4);
        uVar42 = *(undefined4 *)(param_2 + 1);
        uVar43 = *(undefined4 *)((int)param_2 + 0xc);
        uVar3 = *(undefined4 *)(param_2 + 2);
        uVar4 = *(undefined4 *)((int)param_2 + 0x14);
        uVar5 = *(undefined4 *)(param_2 + 3);
        uVar6 = *(undefined4 *)((int)param_2 + 0x1c);
        uVar7 = *(undefined4 *)(param_2 + 4);
        uVar8 = *(undefined4 *)((int)param_2 + 0x24);
        uVar9 = *(undefined4 *)(param_2 + 5);
        uVar10 = *(undefined4 *)((int)param_2 + 0x2c);
        uVar11 = *(undefined4 *)(param_2 + 6);
        uVar12 = *(undefined4 *)((int)param_2 + 0x34);
        uVar13 = *(undefined4 *)(param_2 + 7);
        uVar14 = *(undefined4 *)((int)param_2 + 0x3c);
        *(undefined4 *)puVar38 = *(undefined4 *)param_2;
        *(undefined4 *)((int)puVar38 + 4) = uVar41;
        *(undefined4 *)(puVar38 + 1) = uVar42;
        *(undefined4 *)((int)puVar38 + 0xc) = uVar43;
        *(undefined4 *)(puVar38 + 2) = uVar3;
        *(undefined4 *)((int)puVar38 + 0x14) = uVar4;
        *(undefined4 *)(puVar38 + 3) = uVar5;
        *(undefined4 *)((int)puVar38 + 0x1c) = uVar6;
        *(undefined4 *)(puVar38 + 4) = uVar7;
        *(undefined4 *)((int)puVar38 + 0x24) = uVar8;
        *(undefined4 *)(puVar38 + 5) = uVar9;
        *(undefined4 *)((int)puVar38 + 0x2c) = uVar10;
        *(undefined4 *)(puVar38 + 6) = uVar11;
        *(undefined4 *)((int)puVar38 + 0x34) = uVar12;
        *(undefined4 *)(puVar38 + 7) = uVar13;
        *(undefined4 *)((int)puVar38 + 0x3c) = uVar14;
        uVar41 = *(undefined4 *)((int)param_2 + 0x44);
        uVar42 = *(undefined4 *)(param_2 + 9);
        uVar43 = *(undefined4 *)((int)param_2 + 0x4c);
        uVar3 = *(undefined4 *)(param_2 + 10);
        uVar4 = *(undefined4 *)((int)param_2 + 0x54);
        uVar5 = *(undefined4 *)(param_2 + 0xb);
        uVar6 = *(undefined4 *)((int)param_2 + 0x5c);
        uVar7 = *(undefined4 *)(param_2 + 0xc);
        uVar8 = *(undefined4 *)((int)param_2 + 100);
        uVar9 = *(undefined4 *)(param_2 + 0xd);
        uVar10 = *(undefined4 *)((int)param_2 + 0x6c);
        uVar11 = *(undefined4 *)(param_2 + 0xe);
        uVar12 = *(undefined4 *)((int)param_2 + 0x74);
        uVar13 = *(undefined4 *)(param_2 + 0xf);
        uVar14 = *(undefined4 *)((int)param_2 + 0x7c);
        *(undefined4 *)(puVar38 + 8) = *(undefined4 *)(param_2 + 8);
        *(undefined4 *)((int)puVar38 + 0x44) = uVar41;
        *(undefined4 *)(puVar38 + 9) = uVar42;
        *(undefined4 *)((int)puVar38 + 0x4c) = uVar43;
        *(undefined4 *)(puVar38 + 10) = uVar3;
        *(undefined4 *)((int)puVar38 + 0x54) = uVar4;
        *(undefined4 *)(puVar38 + 0xb) = uVar5;
        *(undefined4 *)((int)puVar38 + 0x5c) = uVar6;
        *(undefined4 *)(puVar38 + 0xc) = uVar7;
        *(undefined4 *)((int)puVar38 + 100) = uVar8;
        *(undefined4 *)(puVar38 + 0xd) = uVar9;
        *(undefined4 *)((int)puVar38 + 0x6c) = uVar10;
        *(undefined4 *)(puVar38 + 0xe) = uVar11;
        *(undefined4 *)((int)puVar38 + 0x74) = uVar12;
        *(undefined4 *)(puVar38 + 0xf) = uVar13;
        *(undefined4 *)((int)puVar38 + 0x7c) = uVar14;
        param_2 = param_2 + 0x10;
        puVar38 = puVar38 + 0x10;
      }
    }
    if (param_3 == 0) goto LAB_0040cef9;
    for (uVar33 = param_3 >> 5; uVar33 != 0; uVar33 = uVar33 - 1) {
      uVar41 = *(undefined4 *)((int)param_2 + 4);
      uVar42 = *(undefined4 *)(param_2 + 1);
      uVar43 = *(undefined4 *)((int)param_2 + 0xc);
      uVar3 = *(undefined4 *)(param_2 + 2);
      uVar4 = *(undefined4 *)((int)param_2 + 0x14);
      uVar5 = *(undefined4 *)(param_2 + 3);
      uVar6 = *(undefined4 *)((int)param_2 + 0x1c);
      *(undefined4 *)puVar38 = *(undefined4 *)param_2;
      *(undefined4 *)((int)puVar38 + 4) = uVar41;
      *(undefined4 *)(puVar38 + 1) = uVar42;
      *(undefined4 *)((int)puVar38 + 0xc) = uVar43;
      *(undefined4 *)(puVar38 + 2) = uVar3;
      *(undefined4 *)((int)puVar38 + 0x14) = uVar4;
      *(undefined4 *)(puVar38 + 3) = uVar5;
      *(undefined4 *)((int)puVar38 + 0x1c) = uVar6;
      param_2 = param_2 + 4;
      puVar38 = puVar38 + 4;
    }
  }
LAB_0040cec4:
  if ((param_3 & 0x1f) != 0) {
    for (uVar32 = (param_3 & 0x1f) >> 2; uVar32 != 0; uVar32 = uVar32 - 1) {
      uVar33 = *(uint *)param_2;
      *(uint *)puVar38 = uVar33;
      puVar38 = (undefined8 *)((int)puVar38 + 4);
      param_2 = (undefined8 *)((int)param_2 + 4);
    }
    for (param_3 = param_3 & 3; param_3 != 0; param_3 = param_3 - 1) {
      *(undefined *)puVar38 = *(undefined *)param_2;
      param_2 = (undefined8 *)((int)param_2 + 1);
      puVar38 = (undefined8 *)((int)puVar38 + 1);
    }
  }
LAB_0040cef9:
  return CONCAT44(uVar33,param_1);
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// Library Function - Single Match
//  __CallSettingFrame@12
// 
// Library: Visual Studio

void __CallSettingFrame_12(undefined4 param_1,undefined4 param_2,int param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)__NLG_Notify1(param_3);
  (*pcVar1)();
  if (param_3 == 0x100) {
    param_3 = 2;
  }
  __NLG_Notify1(param_3);
  return;
}



void FUN_0040d5a2(undefined4 param_1,code *param_2)

{
  (*param_2)();
  return;
}



void FUN_0040d5af(int param_1)

{
  int iVar1;
  code *pcVar2;
  errno_t eVar3;
  int *piVar4;
  undefined4 *puVar5;
  int iVar6;
  char *local_1c;
  char *local_18;
  undefined4 local_14;
  int local_10;
  undefined4 local_c;
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  local_1c = (char *)0x0;
  eVar3 = __dupenv_s(&local_1c,(size_t *)0x0,(char *)0x40ea14);
  if ((eVar3 != 0) && (eVar3 == 0x16)) {
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    pcVar2 = (code *)swi(3);
    (*pcVar2)();
    return;
  }
  if (param_1 == 0) {
    if (local_1c != (char *)0x0) {
      __access_s(local_1c,0);
    }
    goto LAB_0040d688;
  }
  local_18 = local_1c;
  local_14 = 0x40ea24;
  local_10 = param_1;
  local_c = 0;
  if (local_1c != (char *)0x0) {
    piVar4 = (int *)FUN_0040ef03();
    iVar1 = *piVar4;
    puVar5 = (undefined4 *)FUN_0040ef03();
    *puVar5 = 0;
    iVar6 = FUN_0040f699(0,local_18,&local_18,0);
    piVar4 = (int *)FUN_0040ef03();
    if (iVar6 != -1) {
      *piVar4 = iVar1;
      goto LAB_0040d688;
    }
    if ((*piVar4 != 2) && (piVar4 = (int *)FUN_0040ef03(), *piVar4 != 0xd)) goto LAB_0040d688;
    piVar4 = (int *)FUN_0040ef03();
    *piVar4 = iVar1;
  }
  local_18 = (char *)0x40ea1c;
  FUN_0040f943(0,0x40ea1c,&local_18,0);
LAB_0040d688:
  FID_conflict__free(local_1c);
  ___security_check_cookie_4();
  return;
}



void FUN_0040d6af(void)

{
  FUN_0040d5af();
  return;
}



// Library Function - Single Match
//  __seh_filter_exe
// 
// Library: Visual Studio 2015 Release

void __seh_filter_exe(uint param_1,uint *param_2)

{
  uint *puVar1;
  code *pcVar2;
  uint uVar3;
  uint **ppuVar4;
  uint *puVar5;
  uint *puVar6;
  uint *extraout_var;
  uint *puVar7;
  
  uVar3 = (uint)&stack0xfffffffc ^ 0x74c08447;
  ppuVar4 = (uint **)FUN_0040fecb();
  puVar7 = extraout_var;
  if (ppuVar4 != (uint **)0x0) {
    puVar1 = *ppuVar4;
    for (puVar6 = puVar1; puVar6 != puVar1 + 0x24; puVar6 = puVar6 + 3) {
      if (*puVar6 == param_1) goto LAB_0040d6fd;
    }
    puVar6 = (uint *)0x0;
LAB_0040d6fd:
    if ((puVar6 != (uint *)0x0) && (pcVar2 = (code *)puVar6[2], pcVar2 != (code *)0x0)) {
      if (pcVar2 == (code *)0x5) {
        puVar6[2] = 0;
      }
      else if (pcVar2 != (code *)0x1) {
        puVar7 = ppuVar4[1];
        ppuVar4[1] = param_2;
        if (puVar6[1] == 8) {
          for (puVar5 = puVar1 + 9; puVar5 != puVar1 + 0x24; puVar5 = puVar5 + 3) {
            puVar5[2] = 0;
          }
          puVar1 = ppuVar4[2];
          if (*puVar6 < 0xc0000092) {
            if (*puVar6 == 0xc0000091) {
              ppuVar4[2] = (uint *)0x84;
            }
            else if (*puVar6 == 0xc000008d) {
              ppuVar4[2] = (uint *)0x82;
            }
            else if (*puVar6 == 0xc000008e) {
              ppuVar4[2] = (uint *)0x83;
            }
            else if (*puVar6 == 0xc000008f) {
              ppuVar4[2] = (uint *)0x86;
            }
            else if (*puVar6 == 0xc0000090) {
              ppuVar4[2] = (uint *)0x81;
            }
          }
          else if (*puVar6 == 0xc0000092) {
            ppuVar4[2] = (uint *)0x8a;
          }
          else if (*puVar6 == 0xc0000093) {
            ppuVar4[2] = (uint *)0x85;
          }
          else if (*puVar6 == 0xc00002b4) {
            ppuVar4[2] = (uint *)0x8e;
          }
          else if (*puVar6 == 0xc00002b5) {
            ppuVar4[2] = (uint *)0x8d;
          }
          (*(code *)0xff0875ff)(8,ppuVar4[2]);
          (*pcVar2)();
          ppuVar4[2] = puVar1;
        }
        else {
          puVar6[2] = 0;
          (*(code *)0xff0875ff)(puVar6[1]);
          (*pcVar2)();
        }
        ppuVar4[1] = puVar7;
      }
    }
  }
  ___security_check_cookie_4(puVar7,uVar3);
  return;
}



undefined4 FUN_0040d82d(void)

{
  return 0x40e04815;
}



void FUN_0040d833(undefined4 param_1)

{
  uRam00414b8c = param_1;
                    // WARNING: Read-only address (ram,0x00414b8c) is written
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  int (__cdecl*__cdecl __crt_fast_encode_pointer<int (__cdecl*)(void)>(int
// (__cdecl*const)(void)))(void)
//  void (__cdecl** __cdecl __crt_fast_encode_pointer<void (__cdecl**)(void)>(void (__cdecl**
// const)(void)))(void)
// 
// Library: Visual Studio 2015 Release

uint __crt_fast_encode_pointer__(uint param_1)

{
  return (param_1 >> 0x19 | param_1 << 7) ^ 0x74c08447;
}



// Library Function - Single Match
//  ___acrt_has_user_matherr
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 ___acrt_has_user_matherr(void)

{
  return 0x8fff8c01;
}



void FUN_0040d879(undefined4 param_1)

{
  uRam00414b90 = param_1;
                    // WARNING: Read-only address (ram,0x00414b90) is written
  return;
}



// WARNING: Removing unreachable block (ram,0x0040d8b0)
// Library Function - Single Match
//  ___acrt_invoke_user_matherr
// 
// Library: Visual Studio 2015 Release

void ___acrt_invoke_user_matherr(undefined4 param_1)

{
  uint uVar1;
  
  uVar1 = (uint)&stack0xfffffffc ^ 0x74c08447;
  (*(code *)0xff0875ff)(param_1);
  (*(code *)0x8fff8c1a)();
  ___security_check_cookie_4(uVar1);
  return;
}



// Library Function - Single Match
//  ___setusermatherr
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___setusermatherr(undefined4 param_1)

{
  uRam00414b90 = __crt_fast_encode_pointer__(param_1);
                    // WARNING: Read-only address (ram,0x00414b90) is written
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_0040d8e6(int param_1)

{
  int iVar1;
  undefined4 *puVar2;
  undefined *puVar3;
  int *piVar4;
  int *piVar5;
  undefined *local_14;
  undefined4 local_10;
  int *local_c;
  int local_8;
  
  if (param_1 == 0) {
    iVar1 = 0;
  }
  else if ((param_1 == 2) || (param_1 == 1)) {
    ___acrt_initialize_multibyte();
    iVar1 = 0;
    (*common_exit)(0,0x414b98,0x104);
    puVar3 = &DAT_ffffa237;
                    // WARNING: Read-only address (ram,0x00414cd0) is written
    uRam00414cd0 = 0x414b98;
    local_14 = &DAT_ffffa237;
    if (DAT_ffffa237 == '\0') {
      puVar3 = (undefined *)0x414b98;
      local_14 = (undefined *)0x414b98;
    }
    local_8 = 0;
    local_10 = 0;
    FUN_0040da1c(puVar3,0,0,&local_8,&local_10);
    piVar4 = (int *)FUN_0040db90(local_8,local_10,1);
    piVar5 = piVar4;
    if (piVar4 == (int *)0x0) {
      puVar2 = (undefined4 *)FUN_0040ef03();
      iVar1 = 0xc;
      *puVar2 = 0xc;
    }
    else {
      FUN_0040da1c(local_14,piVar4,piVar4 + local_8,&local_8,&local_10);
      if (param_1 == 1) {
        iRam00414cbc = local_8 + -1;
                    // WARNING: Read-only address (ram,0x00414cbc) is written
        piVar5 = (int *)0x0;
                    // WARNING: Read-only address (ram,0x00414cc0) is written
        piRam00414cc0 = piVar4;
      }
      else {
        local_c = (int *)0x0;
        iVar1 = FUN_00410476(piVar4,&local_c);
        piVar4 = local_c;
        if (iVar1 == 0) {
          iRam00414cbc = 0;
          iVar1 = *local_c;
          while (iVar1 != 0) {
            local_c = local_c + 1;
            iRam00414cbc = iRam00414cbc + 1;
            iVar1 = *local_c;
          }
                    // WARNING: Read-only address (ram,0x00414cbc) is written
          local_c = (int *)0x0;
          iVar1 = 0;
                    // WARNING: Read-only address (ram,0x00414cc0) is written
          piRam00414cc0 = piVar4;
        }
        FID_conflict__free(local_c);
        local_c = (int *)0x0;
      }
    }
    FID_conflict__free(piVar5);
  }
  else {
    puVar2 = (undefined4 *)FUN_0040ef03();
    iVar1 = 0x16;
    *puVar2 = 0x16;
    FUN_0040ee46();
  }
  return iVar1;
}



void FUN_0040da1c(char *param_1,char **param_2,char *param_3,int *param_4,int *param_5)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  bool bVar4;
  bool bVar5;
  char *pcVar6;
  char *pcVar7;
  
  *param_5 = 0;
  *param_4 = 1;
  if (param_2 != (char **)0x0) {
    *param_2 = param_3;
    param_2 = param_2 + 1;
  }
  bVar4 = false;
  bVar5 = false;
  do {
    if (*param_1 == '\"') {
      bVar5 = !bVar4;
      cVar1 = '\"';
      pcVar6 = param_1 + 1;
      bVar4 = bVar5;
    }
    else {
      *param_5 = *param_5 + 1;
      if (param_3 != (char *)0x0) {
        *param_3 = *param_1;
        param_3 = param_3 + 1;
      }
      cVar1 = *param_1;
      pcVar6 = param_1 + 1;
      iVar3 = __ismbblead((int)cVar1);
      if (iVar3 != 0) {
        *param_5 = *param_5 + 1;
        if (param_3 != (char *)0x0) {
          *param_3 = *pcVar6;
          param_3 = param_3 + 1;
        }
        pcVar6 = param_1 + 2;
      }
      if (cVar1 == '\0') {
        pcVar6 = pcVar6 + -1;
        goto LAB_0040daac;
      }
    }
    param_1 = pcVar6;
  } while ((bVar5) || ((cVar1 != ' ' && (cVar1 != '\t'))));
  if (param_3 != (char *)0x0) {
    param_3[-1] = '\0';
  }
LAB_0040daac:
  bVar5 = false;
  while (pcVar7 = pcVar6, *pcVar6 != '\0') {
    for (; (cVar1 = *pcVar7, cVar1 == ' ' || (cVar1 == '\t')); pcVar7 = pcVar7 + 1) {
    }
    if (cVar1 == '\0') break;
    if (param_2 != (char **)0x0) {
      *param_2 = param_3;
      param_2 = param_2 + 1;
    }
    *param_4 = *param_4 + 1;
    while( true ) {
      bVar4 = true;
      uVar2 = 0;
      for (; *pcVar7 == '\\'; pcVar7 = pcVar7 + 1) {
        uVar2 = uVar2 + 1;
      }
      pcVar6 = pcVar7;
      if (*pcVar7 == '\"') {
        if (((uVar2 & 1) == 0) && ((!bVar5 || (pcVar6 = pcVar7 + 1, *pcVar6 != '\"')))) {
          bVar4 = false;
          bVar5 = !bVar5;
          pcVar6 = pcVar7;
        }
        uVar2 = uVar2 >> 1;
      }
      while (uVar2 != 0) {
        uVar2 = uVar2 - 1;
        if (param_3 != (char *)0x0) {
          *param_3 = '\\';
          param_3 = param_3 + 1;
        }
        *param_5 = *param_5 + 1;
      }
      cVar1 = *pcVar6;
      if ((cVar1 == '\0') || ((!bVar5 && ((cVar1 == ' ' || (cVar1 == '\t')))))) break;
      if (bVar4) {
        if (param_3 != (char *)0x0) {
          *param_3 = cVar1;
          param_3 = param_3 + 1;
        }
        iVar3 = __ismbblead((int)*pcVar6);
        if (iVar3 != 0) {
          pcVar6 = pcVar6 + 1;
          *param_5 = *param_5 + 1;
          if (param_3 != (char *)0x0) {
            *param_3 = *pcVar6;
            param_3 = param_3 + 1;
          }
        }
        *param_5 = *param_5 + 1;
      }
      pcVar7 = pcVar6 + 1;
    }
    if (param_3 != (char *)0x0) {
      *param_3 = '\0';
      param_3 = param_3 + 1;
    }
    *param_5 = *param_5 + 1;
  }
  if (param_2 != (char **)0x0) {
    *param_2 = (char *)0x0;
  }
  *param_4 = *param_4 + 1;
  return;
}



undefined4 FUN_0040db90(uint param_1,uint param_2,uint param_3)

{
  undefined4 uVar1;
  
  if ((param_1 < 0x3fffffff) && (param_2 < (uint)(0xffffffff / (ulonglong)param_3))) {
    if (param_2 * param_3 < ~(param_1 * 4)) {
      uVar1 = __calloc_base(param_1 * 4 + param_2 * param_3,1);
      FID_conflict__free((void *)0x0);
      return uVar1;
    }
  }
  return 0;
}



void FUN_0040dbdf(void)

{
  FUN_0040d8e6();
  return;
}



// WARNING: Removing unreachable block (ram,0x0040dbf3)
// WARNING: Removing unreachable block (ram,0x0040dbfe)
// WARNING: Removing unreachable block (ram,0x0040dc07)
// WARNING: Removing unreachable block (ram,0x0040dbfb)
// WARNING: Removing unreachable block (ram,0x0040dc10)

undefined * FUN_0040dbea(void)

{
  return &DAT_8b104d8b;
}



// WARNING: Removing unreachable block (ram,0x0040dc22)
// WARNING: Removing unreachable block (ram,0x0040dc39)
// WARNING: Removing unreachable block (ram,0x0040dc49)
// WARNING: Removing unreachable block (ram,0x0040dc44)
// WARNING: Removing unreachable block (ram,0x0040dc55)
// WARNING: Removing unreachable block (ram,0x0040dc34)
// WARNING: Removing unreachable block (ram,0x0040dc5d)
// Library Function - Single Match
//  int __cdecl common_initialize_environment_nolock<char>(void)
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl common_initialize_environment_nolock_char_(void)

{
  return 0;
}



// Library Function - Single Match
//  char * * __cdecl create_environment<char>(char * const)
// 
// Library: Visual Studio 2015 Release

char ** __cdecl create_environment_char_(char *param_1)

{
  code *pcVar1;
  char cVar2;
  char **ppcVar3;
  char *_Dst;
  errno_t eVar4;
  char *pcVar5;
  int iVar6;
  char **local_8;
  
  iVar6 = 0;
  cVar2 = *param_1;
  pcVar5 = param_1;
  while (cVar2 != '\0') {
    if (cVar2 != '=') {
      iVar6 = iVar6 + 1;
    }
    do {
      cVar2 = *pcVar5;
      pcVar5 = pcVar5 + 1;
    } while (cVar2 != '\0');
    cVar2 = *pcVar5;
  }
  ppcVar3 = (char **)__calloc_base(iVar6 + 1,4);
  local_8 = ppcVar3;
  if (ppcVar3 == (char **)0x0) {
LAB_0040dd1a:
    ppcVar3 = (char **)0x0;
  }
  else {
    for (; *param_1 != '\0'; param_1 = param_1 + (int)pcVar5) {
      pcVar5 = param_1;
      do {
        cVar2 = *pcVar5;
        pcVar5 = pcVar5 + 1;
      } while (cVar2 != '\0');
      pcVar5 = pcVar5 + (1 - (int)(param_1 + 1));
      if (*param_1 != '=') {
        _Dst = (char *)__calloc_base(pcVar5,1);
        if (_Dst == (char *)0x0) {
          free_environment_char_(ppcVar3);
          FID_conflict__free((void *)0x0);
          goto LAB_0040dd1a;
        }
        eVar4 = _strcpy_s(_Dst,(rsize_t)pcVar5,param_1);
        if (eVar4 != 0) {
          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          pcVar1 = (code *)swi(3);
          ppcVar3 = (char **)(*pcVar1)();
          return ppcVar3;
        }
        *local_8 = _Dst;
        local_8 = local_8 + 1;
        FID_conflict__free((void *)0x0);
      }
    }
  }
  FID_conflict__free((void *)0x0);
  return ppcVar3;
}



// Library Function - Single Match
//  void __cdecl free_environment<char>(char * * const)
// 
// Library: Visual Studio 2015 Release

void __cdecl free_environment_char_(char **param_1)

{
  char *_Memory;
  char **ppcVar1;
  
  if (param_1 != (char **)0x0) {
    _Memory = *param_1;
    ppcVar1 = param_1;
    while (_Memory != (char *)0x0) {
      FID_conflict__free(_Memory);
      ppcVar1 = ppcVar1 + 1;
      _Memory = *ppcVar1;
    }
    FID_conflict__free(param_1);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0040dd76)
// Library Function - Single Match
//  int __cdecl initialize_environment_by_cloning_nolock<char>(void)
// 
// Library: Visual Studio 2015 Release

int __cdecl initialize_environment_by_cloning_nolock_char_(void)

{
  int iVar1;
  void *_Memory;
  int *piVar2;
  
  piVar2 = (int *)&DAT_45890c45;
  while( true ) {
    if (*piVar2 == 0) {
      return 0;
    }
    iVar1 = (*(code *)0x12750010)(0,0,*piVar2,0xffffffff,0,0,0,0);
    if (iVar1 == 0) break;
    _Memory = (void *)__calloc_base(iVar1,1);
    if ((_Memory == (void *)0x0) ||
       (iVar1 = (*(code *)0x12750010)(0,0,*piVar2,0xffffffff,_Memory,iVar1,0,0), iVar1 == 0)) {
      FID_conflict__free(_Memory);
      return -1;
    }
    FUN_004110fe(_Memory,0);
    FID_conflict__free((void *)0x0);
    piVar2 = piVar2 + 1;
  }
  return -1;
}



// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall __crt_state_management::dual_state_global<char * *>::uninitialize<void
// (__cdecl&)(char * * &)>(void (__cdecl&)(char * * &))
//  public: void __thiscall __crt_state_management::dual_state_global<wchar_t *
// *>::uninitialize<void (__cdecl&)(wchar_t * * &)>(void (__cdecl&)(wchar_t * * &))
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void __thiscall uninitialize__(int param_1_00,code *param_1)

{
  int iVar1;
  uint uVar2;
  
  uVar2 = (uint)&stack0xfffffffc ^ 0x74c08447;
  iVar1 = param_1_00 + 4;
  for (; param_1_00 != iVar1; param_1_00 = param_1_00 + 4) {
    (*(code *)0xff0875ff)(param_1_00);
    (*param_1)();
  }
  ___security_check_cookie_4(uVar2);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  void __cdecl uninitialize_environment_internal<char>(char * * &)
//  void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void uninitialize_environment_internal__(undefined4 *param_1)

{
  if ((char **)*param_1 != (char **)0x8758b56) {
    free_environment_char_((char **)*param_1);
  }
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  void __cdecl uninitialize_environment_internal<char>(char * * &)
//  void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void uninitialize_environment_internal__(undefined4 *param_1)

{
  if ((char **)*param_1 != (char **)0xec4d89f8) {
    free_environment_char_((char **)*param_1);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0040dbf3)
// WARNING: Removing unreachable block (ram,0x0040dbfe)
// WARNING: Removing unreachable block (ram,0x0040dc07)
// WARNING: Removing unreachable block (ram,0x0040dbfb)
// WARNING: Removing unreachable block (ram,0x0040dc10)

undefined * thunk_FUN_0040dbea(void)

{
  return &DAT_8b104d8b;
}



// Library Function - Single Match
//  __initterm
// 
// Library: Visual Studio 2015 Release

void __thiscall __initterm(code *param_1_00,code **param_1,code **param_2)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = (uint)&stack0xfffffffc ^ 0x74c08447;
  uVar3 = 0;
  uVar2 = ~-(uint)(param_2 < param_1) & (uint)((int)param_2 + (3 - (int)param_1)) >> 2;
  if (uVar2 != 0) {
    do {
      param_1_00 = *param_1;
      if (param_1_00 != (code *)0x0) {
        (*(code *)0xff0875ff)();
        (*param_1_00)();
      }
      param_1 = param_1 + 1;
      uVar3 = uVar3 + 1;
    } while (uVar3 != uVar2);
  }
  ___security_check_cookie_4(param_1_00,uVar1);
  return;
}



// Library Function - Single Match
//  __initterm_e
// 
// Library: Visual Studio 2015 Release

void __initterm_e(code **param_1,code **param_2)

{
  code *pcVar1;
  uint uVar2;
  int iVar3;
  
  uVar2 = (uint)&stack0xfffffffc ^ 0x74c08447;
  for (; param_1 != param_2; param_1 = param_1 + 1) {
    pcVar1 = *param_1;
    if (pcVar1 != (code *)0x0) {
      (*(code *)0xff0875ff)();
      iVar3 = (*pcVar1)();
      if (iVar3 != 0) break;
    }
  }
  ___security_check_cookie_4(uVar2);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_03b1d95aef87969028cfba75ccab2455>,class <lambda_6e4b09c48022b2350581041d5f6b0c4c>&,class
// <lambda_22bdf7517842c4b3e53723af5aa32b9e>>(class
// <lambda_03b1d95aef87969028cfba75ccab2455>&&,class
// <lambda_6e4b09c48022b2350581041d5f6b0c4c>&,class <lambda_22bdf7517842c4b3e53723af5aa32b9e>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_03b1d95aef87969028cfba75ccab2455__class__lambda_6e4b09c48022b2350581041d5f6b0c4c___class__lambda_22bdf7517842c4b3e53723af5aa32b9e___
          (__crt_seh_guarded_call_void_ *this,_lambda_03b1d95aef87969028cfba75ccab2455_ *param_1,
          _lambda_6e4b09c48022b2350581041d5f6b0c4c_ *param_2,
          _lambda_22bdf7517842c4b3e53723af5aa32b9e_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  FUN_0040df97();
  FUN_0040df8b();
  return;
}



void FUN_0040df8b(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// WARNING: Removing unreachable block (ram,0x0040dfb2)
// WARNING: Removing unreachable block (ram,0x0040e001)
// WARNING: Removing unreachable block (ram,0x0040e006)
// WARNING: Removing unreachable block (ram,0x0040dfc9)
// WARNING: Removing unreachable block (ram,0x0040dfe7)
// WARNING: Removing unreachable block (ram,0x0040dffa)
// WARNING: Removing unreachable block (ram,0x0040e00b)
// WARNING: Removing unreachable block (ram,0x0040e011)
// WARNING: Removing unreachable block (ram,0x0040e01e)
// WARNING: Removing unreachable block (ram,0x0040e02f)
// WARNING: Removing unreachable block (ram,0x0040e047)

void FUN_0040df97(void)

{
  FUN_00417562();
  return;
}



void FUN_0040e018(void)

{
  int unaff_EBX;
  int **unaff_ESI;
  
  if (**unaff_ESI == unaff_EBX) {
    __initterm(&LAB_0040e14e_2,0x40e160);
  }
  __initterm(0x40e164,&LAB_0040e167_1);
  if (*unaff_ESI[1] == unaff_EBX) {
                    // WARNING: Read-only address (ram,0x00414cb8) is written
    uRam00414cb8 = 1;
    *(undefined *)unaff_ESI[2] = 1;
  }
  FUN_00417562();
  return;
}



bool FUN_0040e073(int param_1)

{
  return param_1 == -0x1f928c9d;
}



// Library Function - Single Match
//  void __cdecl common_exit(int,enum _crt_exit_cleanup_mode,enum _crt_exit_return_mode)
// 
// Library: Visual Studio 2017 Release

void __cdecl common_exit(int param_1,_crt_exit_cleanup_mode param_2,_crt_exit_return_mode param_3)

{
  code *pcVar1;
  char cVar2;
  _crt_exit_cleanup_mode *local_1c;
  _crt_exit_return_mode *local_18;
  undefined *local_14;
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_6;
  undefined local_5;
  
  if (param_3 == 0) {
    cVar2 = ___scrt_is_managed_app();
    if (cVar2 != '\0') {
      try_cor_exit_process(param_1);
    }
  }
  local_1c = &param_2;
  local_5 = 0;
  local_18 = &param_3;
  local_14 = &local_5;
  local_c = 2;
  local_10 = 2;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_03b1d95aef87969028cfba75ccab2455__class__lambda_6e4b09c48022b2350581041d5f6b0c4c___class__lambda_22bdf7517842c4b3e53723af5aa32b9e___
            (&local_6,(_lambda_03b1d95aef87969028cfba75ccab2455_ *)&local_10,
             (_lambda_6e4b09c48022b2350581041d5f6b0c4c_ *)&local_1c,
             (_lambda_22bdf7517842c4b3e53723af5aa32b9e_ *)&local_c);
  if (param_3 != 0) {
    return;
  }
  exit_or_terminate_process(param_1);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl exit_or_terminate_process(unsigned int)
// 
// Library: Visual Studio 2017 Release

void __cdecl exit_or_terminate_process(uint param_1)

{
  code *pcVar1;
  int iVar2;
  undefined4 uVar3;
  int in_FS_OFFSET;
  
  iVar2 = ___acrt_get_process_end_policy();
  if ((iVar2 != 1) && ((*(uint *)(*(int *)(in_FS_OFFSET + 0x30) + 0x68) >> 8 & 1) == 0)) {
    uVar3 = (*_FUN_0040e018)(param_1);
    (*pcRam0040e01c)(uVar3);
  }
  try_cor_exit_process(param_1);
  (*(code *)0xffdc1fe8)(param_1);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl try_cor_exit_process(unsigned int)
// 
// Library: Visual Studio 2015 Release

void __cdecl try_cor_exit_process(uint param_1)

{
  int iVar1;
  code *pcVar2;
  int local_c;
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  local_c = 0;
  iVar1 = (*(code *)0x74c084ff)(0,0x40eac4,&local_c);
  if ((iVar1 != 0) && (pcVar2 = (code *)(*FUN_0040e073)(local_c,0x40eadc), pcVar2 != (code *)0x0)) {
    (*(code *)0xff0875ff)(param_1);
    (*pcVar2)();
  }
  if (local_c != 0) {
    (*(code *)0x8bcc0000)(local_c);
  }
  ___security_check_cookie_4();
  return;
}



void FUN_0040e198(undefined4 param_1)

{
  uRam00414cb4 = param_1;
                    // WARNING: Read-only address (ram,0x00414cb4) is written
  return;
}



// Library Function - Single Match
//  __exit
// 
// Library: Visual Studio 2017 Release

void __exit(int param_1)

{
  common_exit(param_1,2,0);
  return;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// WARNING: Removing unreachable block (ram,0x0040e203)
// Library Function - Single Match
//  __register_thread_local_exe_atexit_callback
// 
// Library: Visual Studio 2015 Release

void __register_thread_local_exe_atexit_callback(void)

{
  code *pcVar1;
  int iVar2;
  
  iVar2 = FUN_0040fd7d();
  pcVar1 = *(code **)(iVar2 + 0xc);
  if (pcVar1 != (code *)0x0) {
    (*(code *)0xff0875ff)();
    (*pcVar1)();
  }
  _abort();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  _exit
// 
// Library: Visual Studio 2017 Release

void __cdecl _exit(int _Code)

{
  common_exit(_Code,0,0);
  return;
}



// Library Function - Single Match
//  __set_fmode
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

errno_t __cdecl __set_fmode(int _Mode)

{
  undefined4 *puVar1;
  
  if (((_Mode != 0x4000) && (_Mode != 0x8000)) && (_Mode != 0x10000)) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
    return 0x16;
  }
                    // WARNING: Read-only address (ram,0x00414e64) is written
  iRam00414e64 = _Mode;
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_e5124f882df8998aaf41531e079ba474>,class <lambda_3e16ef9562a7dcce91392c22ab16ea36>&,class
// <lambda_e25ca0880e6ef98be67edffd8c599615>>(class
// <lambda_e5124f882df8998aaf41531e079ba474>&&,class
// <lambda_3e16ef9562a7dcce91392c22ab16ea36>&,class <lambda_e25ca0880e6ef98be67edffd8c599615>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_e5124f882df8998aaf41531e079ba474__class__lambda_3e16ef9562a7dcce91392c22ab16ea36___class__lambda_e25ca0880e6ef98be67edffd8c599615___
          (__crt_seh_guarded_call_void_ *this,_lambda_e5124f882df8998aaf41531e079ba474_ *param_1,
          _lambda_3e16ef9562a7dcce91392c22ab16ea36_ *param_2,
          _lambda_e25ca0880e6ef98be67edffd8c599615_ *param_3)

{
  int iVar1;
  int *piVar2;
  
  ___acrt_lock(*(undefined4 *)param_1);
  for (piVar2 = (int *)0x41506c; piVar2 != (int *)0x415070; piVar2 = piVar2 + 1) {
    if (*piVar2 != 0x414580) {
      iVar1 = __updatetlocinfoEx_nolock(piVar2,0x414580);
      *piVar2 = iVar1;
    }
  }
  FUN_0040e2e3();
  return;
}



void FUN_0040e2e3(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  ___acrt_set_locale_changed
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_set_locale_changed(void)

{
                    // WARNING: Read-only address (ram,0x00414cd4) is written
  uRam00414cd4 = 1;
  return 0x83ffffa1;
}



// Library Function - Single Match
//  ___acrt_uninitialize_locale
// 
// Library: Visual Studio 2017 Release

void ___acrt_uninitialize_locale(void)

{
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  local_c = 4;
  local_10 = 4;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_e5124f882df8998aaf41531e079ba474__class__lambda_3e16ef9562a7dcce91392c22ab16ea36___class__lambda_e25ca0880e6ef98be67edffd8c599615___
            (&local_5,(_lambda_e5124f882df8998aaf41531e079ba474_ *)&local_10,
             (_lambda_3e16ef9562a7dcce91392c22ab16ea36_ *)&local_5,
             (_lambda_e25ca0880e6ef98be67edffd8c599615_ *)&local_c);
  return;
}



// Library Function - Single Match
//  __configthreadlocale
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __configthreadlocale(int _Flag)

{
  uint uVar1;
  int iVar2;
  undefined4 *puVar3;
  uint uVar4;
  
  iVar2 = FUN_0040fd7d();
  uVar1 = *(uint *)(iVar2 + 0x350);
  if (_Flag == -1) {
                    // WARNING: Read-only address (ram,0x004146a0) is written
    uRam004146a0 = 0xffffffff;
  }
  else if (_Flag != 0) {
    if (_Flag == 1) {
      uVar4 = uVar1 | 2;
    }
    else {
      if (_Flag != 2) {
        puVar3 = (undefined4 *)FUN_0040ef03();
        *puVar3 = 0x16;
        FUN_0040ee46();
        return -1;
      }
      uVar4 = uVar1 & 0xfffffffd;
    }
    *(uint *)(iVar2 + 0x350) = uVar4;
  }
                    // WARNING: Read-only address (ram,0x004146a0) is written
  return ((uVar1 & 2) == 0) + 1;
}



undefined4 FUN_0040e385(void)

{
  return 0xb2e9ffc8;
}



// Library Function - Single Match
//  __set_new_mode
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 __set_new_mode(int param_1)

{
  undefined4 *puVar1;
  
  if ((param_1 != 0) && (param_1 != 1)) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
    return 0xffffffff;
  }
                    // WARNING: Read-only address (ram,0x00414cd8) is written
  iRam00414cd8 = param_1;
  return 0xb2e9ffc8;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_69a2805e680e0e292e8ba93315fe43a8>,class <lambda_f03950bc5685219e0bcd2087efbe011e>&,class
// <lambda_03fcd07e894ec930e3f35da366ca99d6>>(class
// <lambda_69a2805e680e0e292e8ba93315fe43a8>&&,class
// <lambda_f03950bc5685219e0bcd2087efbe011e>&,class <lambda_03fcd07e894ec930e3f35da366ca99d6>&&)
// 
// Library: Visual Studio 2017 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_69a2805e680e0e292e8ba93315fe43a8__class__lambda_f03950bc5685219e0bcd2087efbe011e___class__lambda_03fcd07e894ec930e3f35da366ca99d6___
          (__crt_seh_guarded_call_int_ *this,_lambda_69a2805e680e0e292e8ba93315fe43a8_ *param_1,
          _lambda_f03950bc5685219e0bcd2087efbe011e_ *param_2,
          _lambda_03fcd07e894ec930e3f35da366ca99d6_ *param_3)

{
  int iVar1;
  
  ___acrt_lock(*(undefined4 *)param_1);
  iVar1 = FUN_0040e5a3();
  FUN_0040e405();
  return iVar1;
}



void FUN_0040e405(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_800076c951b434888f4765a74a194fcc>,class <lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class
// <lambda_6dbb1268764f43b569ce7b67e331d33a>>(class
// <lambda_800076c951b434888f4765a74a194fcc>&&,class
// <lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class <lambda_6dbb1268764f43b569ce7b67e331d33a>&&)
// 
// Library: Visual Studio 2015 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_800076c951b434888f4765a74a194fcc__class__lambda_4e60a939b0d047cfe11ddc22648dfba9___class__lambda_6dbb1268764f43b569ce7b67e331d33a___
          (__crt_seh_guarded_call_int_ *this,_lambda_800076c951b434888f4765a74a194fcc_ *param_1,
          _lambda_4e60a939b0d047cfe11ddc22648dfba9_ *param_2,
          _lambda_6dbb1268764f43b569ce7b67e331d33a_ *param_3)

{
  int iVar1;
  
  ___acrt_lock(*(undefined4 *)param_1);
  iVar1 = <lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator__(param_2);
  FUN_0040e456();
  return iVar1;
}



void FUN_0040e456(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  public: int __thiscall <lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator()(void)const 
// 
// Library: Visual Studio 2015 Release

int __thiscall
<lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator__
          (_lambda_4e60a939b0d047cfe11ddc22648dfba9_ *this)

{
  uint *puVar1;
  uint uVar2;
  undefined4 uVar3;
  undefined4 *puVar4;
  uint uVar5;
  undefined4 *puVar6;
  uint uVar7;
  undefined4 *puVar8;
  uint uVar9;
  
  puVar1 = **(uint ***)this;
  if (puVar1 == (uint *)0x0) {
    return -1;
  }
  puVar8 = (undefined4 *)((puVar1[1] ^ 0x74c08447) >> 7 | (puVar1[1] ^ 0x74c08447) << 0x19);
  puVar6 = (undefined4 *)((puVar1[2] ^ 0x74c08447) >> 7 | (puVar1[2] ^ 0x74c08447) << 0x19);
  uVar5 = (*puVar1 ^ 0x74c08447) >> 7 | (*puVar1 ^ 0x74c08447) << 0x19;
  uVar2 = uVar5;
  if (puVar8 != puVar6) goto LAB_0040e55c;
  uVar7 = (int)((int)puVar6 - uVar5) >> 2;
  uVar9 = 0x200;
  if (uVar7 < 0x201) {
    uVar9 = uVar7;
  }
  uVar9 = uVar9 + uVar7;
  if (uVar9 == 0) {
    uVar9 = 0x20;
  }
  if (uVar9 < uVar7) {
LAB_0040e4e3:
    uVar9 = uVar7 + 4;
    uVar2 = FUN_0041234e(uVar5,uVar9,4);
    FID_conflict__free((void *)0x0);
    if (uVar2 == 0) {
      return -1;
    }
  }
  else {
    uVar2 = FUN_0041234e(uVar5,uVar9,4);
    FID_conflict__free((void *)0x0);
    if (uVar2 == 0) goto LAB_0040e4e3;
  }
  puVar8 = (undefined4 *)(uVar2 + uVar7 * 4);
  puVar6 = (undefined4 *)(uVar2 + uVar9 * 4);
  uVar5 = ~-(uint)(puVar6 < puVar8) & (uint)((int)puVar6 + (3 - (int)puVar8)) >> 2;
  if (uVar5 != 0) {
    uVar9 = 0;
    puVar4 = puVar8;
    do {
      uVar9 = uVar9 + 1;
      *puVar4 = 0x74c08447;
      puVar4 = puVar4 + 1;
    } while (uVar9 != uVar5);
  }
LAB_0040e55c:
  uVar3 = __crt_fast_encode_pointer__(**(undefined4 **)(this + 4));
  *puVar8 = uVar3;
  uVar3 = __crt_fast_encode_pointer__(uVar2);
  *(undefined4 *)**(undefined4 **)this = uVar3;
  uVar3 = __crt_fast_encode_pointer__(puVar8 + 1);
  *(undefined4 *)(**(int **)this + 4) = uVar3;
  uVar3 = __crt_fast_encode_pointer__(puVar6);
  *(undefined4 *)(**(int **)this + 8) = uVar3;
  return 0;
}



void __fastcall FUN_0040e5a3(int **param_1)

{
  uint *puVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  uint *_Memory;
  uint *puVar5;
  uint *local_14;
  uint *local_10;
  
  puVar5 = (uint *)**param_1;
  if (puVar5 != (uint *)0x0) {
    _Memory = (uint *)((*puVar5 ^ 0x74c08447) >> 7 | (*puVar5 ^ 0x74c08447) << 0x19);
    puVar5 = (uint *)((puVar5[1] ^ 0x74c08447) >> 7 | (puVar5[1] ^ 0x74c08447) << 0x19);
    if ((_Memory != (uint *)0x0) &&
       (local_14 = puVar5, local_10 = _Memory, _Memory != (uint *)0xffffffff)) {
      while (puVar5 = puVar5 + -1, _Memory <= puVar5) {
        if (*puVar5 != 0x74c08447) {
          uVar3 = *puVar5 ^ 0x74c08447;
          *puVar5 = 0x74c08447;
          (*(code *)0xff0875ff)();
          (*(code *)(uVar3 >> 7 | uVar3 << 0x19))();
          uVar4 = *(uint *)**param_1 ^ 0x74c08447;
          uVar3 = ((uint *)**param_1)[1] ^ 0x74c08447;
          puVar1 = (uint *)(uVar4 >> 7 | uVar4 << 0x19);
          puVar2 = (uint *)(uVar3 >> 7 | uVar3 << 0x19);
          if ((puVar1 != local_10) || (puVar2 != local_14)) {
            _Memory = puVar1;
            puVar5 = puVar2;
            local_14 = puVar2;
            local_10 = puVar1;
          }
        }
      }
      if (_Memory != (uint *)0xffffffff) {
        FID_conflict__free(_Memory);
      }
      *(undefined4 *)**param_1 = 0x74c08447;
      *(undefined4 *)(**param_1 + 4) = 0x74c08447;
      *(undefined4 *)(**param_1 + 8) = 0x74c08447;
    }
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  __crt_atexit
// 
// Library: Visual Studio 2017 Release

void __crt_atexit(undefined4 param_1)

{
  __register_onexit_function(0x414ce0,param_1);
  return;
}



// Library Function - Single Match
//  __execute_onexit_table
// 
// Library: Visual Studio 2017 Release

void __execute_onexit_table(void)

{
  undefined4 local_14;
  undefined *local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  local_10 = &stack0x00000004;
  local_c = 2;
  local_14 = 2;
  __crt_seh_guarded_call<int>::
  operator___class__lambda_69a2805e680e0e292e8ba93315fe43a8__class__lambda_f03950bc5685219e0bcd2087efbe011e___class__lambda_03fcd07e894ec930e3f35da366ca99d6___
            (&local_5,(_lambda_69a2805e680e0e292e8ba93315fe43a8_ *)&local_14,
             (_lambda_f03950bc5685219e0bcd2087efbe011e_ *)&local_10,
             (_lambda_03fcd07e894ec930e3f35da366ca99d6_ *)&local_c);
  return;
}



// Library Function - Single Match
//  __initialize_onexit_table
// 
// Library: Visual Studio 2015 Release

undefined4 __initialize_onexit_table(int *param_1)

{
  undefined4 uVar1;
  
  if (param_1 == (int *)0x0) {
    uVar1 = 0xffffffff;
  }
  else {
    if (*param_1 == param_1[2]) {
      *param_1 = 0x74c08447;
      param_1[1] = 0x74c08447;
      param_1[2] = 0x74c08447;
    }
    uVar1 = 0;
  }
  return uVar1;
}



// Library Function - Single Match
//  __register_onexit_function
// 
// Library: Visual Studio 2017 Release

void __register_onexit_function(void)

{
  undefined *local_18;
  undefined *local_14;
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  local_18 = &stack0x00000004;
  local_14 = &stack0x00000008;
  local_c = 2;
  local_10 = 2;
  __crt_seh_guarded_call<int>::
  operator___class__lambda_800076c951b434888f4765a74a194fcc__class__lambda_4e60a939b0d047cfe11ddc22648dfba9___class__lambda_6dbb1268764f43b569ce7b67e331d33a___
            (&local_5,(_lambda_800076c951b434888f4765a74a194fcc_ *)&local_10,
             (_lambda_4e60a939b0d047cfe11ddc22648dfba9_ *)&local_18,
             (_lambda_6dbb1268764f43b569ce7b67e331d33a_ *)&local_c);
  return;
}



// Library Function - Single Match
//  _uninitialize_allocated_memory
// 
// Library: Visual Studio 2017 Release

undefined _uninitialize_allocated_memory(void)

{
  _lambda_af42a3ee9806e9a7305d451646e05244_ local_5;
  
  <lambda_af42a3ee9806e9a7305d451646e05244>::operator__(&local_5,(__crt_multibyte_data **)0x414d04);
  return 1;
}



// Library Function - Single Match
//  public: void __thiscall <lambda_af42a3ee9806e9a7305d451646e05244>::operator()(struct
// __crt_multibyte_data * &)const 
// 
// Library: Visual Studio 2017 Release

void __thiscall
<lambda_af42a3ee9806e9a7305d451646e05244>::operator__
          (_lambda_af42a3ee9806e9a7305d451646e05244_ *this,__crt_multibyte_data **param_1)

{
  int iVar1;
  
  LOCK();
  iVar1 = *(int *)*param_1 + -1;
  *(int *)*param_1 = iVar1;
  if ((iVar1 == 0) && (*param_1 != (__crt_multibyte_data *)0x414360)) {
    FID_conflict__free(*param_1);
    *param_1 = (__crt_multibyte_data *)0x414360;
  }
  return;
}



// Library Function - Single Match
//  ___acrt_initialize
// 
// Library: Visual Studio 2015 Release

void ___acrt_initialize(void)

{
  ___acrt_execute_initializers(0x40eaf0,0x40eb70);
  return;
}



// Library Function - Single Match
//  ___acrt_uninitialize
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 ___acrt_uninitialize(char param_1)

{
  undefined4 uVar1;
  
  if (param_1 == '\0') {
    uVar1 = FUN_00412464(0x40eaf0,0x40eb70);
    return uVar1;
  }
  __flushall();
  return 1;
}



// Library Function - Single Match
//  __controlfp_s
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

errno_t __cdecl __controlfp_s(uint *_CurrentState,uint _NewValue,uint _Mask)

{
  undefined4 *puVar1;
  uint uVar2;
  errno_t eVar3;
  
  uVar2 = _Mask & 0xfff7ffff;
  if ((_NewValue & uVar2 & 0xfcf0fce0) == 0) {
    if (_CurrentState == (uint *)0x0) {
      FUN_00412cb8(_NewValue,uVar2);
    }
    else {
      uVar2 = FUN_00412cb8(_NewValue,uVar2);
      *_CurrentState = uVar2;
    }
    eVar3 = 0;
  }
  else {
    if (_CurrentState != (uint *)0x0) {
      uVar2 = FUN_00412cb8(0,0);
      *_CurrentState = uVar2;
    }
    puVar1 = (undefined4 *)FUN_0040ef03();
    eVar3 = 0x16;
    *puVar1 = 0x16;
    FUN_0040ee46();
  }
  return eVar3;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// Library Function - Single Match
//  _terminate
// 
// Library: Visual Studio 2015 Release

void _terminate(void)

{
  code *pcVar1;
  int iVar2;
  
  iVar2 = FUN_0040fd7d();
  pcVar1 = *(code **)(iVar2 + 0xc);
  if (pcVar1 != (code *)0x0) {
    (*(code *)0xff0875ff)();
    (*pcVar1)();
  }
  _abort();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  __free_base
//  _free
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

void __cdecl FID_conflict__free(void *_Memory)

{
  int iVar1;
  int *piVar2;
  ulong uVar3;
  
  if (_Memory != (void *)0x0) {
    iVar1 = (*(code *)0xff45c60c)(__strnicmp,0,_Memory);
    if (iVar1 == 0) {
      piVar2 = (int *)FUN_0040ef03();
      uVar3 = (*(code *)0x414cb805)();
      iVar1 = FID_conflict____acrt_errno_from_os_error(uVar3);
      *piVar2 = iVar1;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __malloc_base
// 
// Library: Visual Studio 2015 Release

int __malloc_base(size_t param_1)

{
  int iVar1;
  undefined4 *puVar2;
  
  if (param_1 < 0xffffffe1) {
    if (param_1 == 0) {
      param_1 = 1;
    }
    do {
      iVar1 = (*(code *)0xe8458900)(__strnicmp,0,param_1);
      if (iVar1 != 0) {
        return iVar1;
      }
      iVar1 = FUN_0040e385();
    } while ((iVar1 != 0) && (iVar1 = __callnewh(param_1), iVar1 != 0));
  }
  puVar2 = (undefined4 *)FUN_0040ef03();
  *puVar2 = 0xc;
  return 0;
}



// Library Function - Single Match
//  _strcpy_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl _strcpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  errno_t *peVar2;
  char *pcVar3;
  errno_t eVar4;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    if (_Src != (char *)0x0) {
      pcVar3 = _Dst;
      do {
        cVar1 = pcVar3[(int)_Src - (int)_Dst];
        *pcVar3 = cVar1;
        pcVar3 = pcVar3 + 1;
        if (cVar1 == '\0') break;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        return 0;
      }
      *_Dst = '\0';
      peVar2 = (errno_t *)FUN_0040ef03();
      eVar4 = 0x22;
      goto LAB_0040ea14;
    }
    *_Dst = '\0';
  }
  peVar2 = (errno_t *)FUN_0040ef03();
  eVar4 = 0x16;
LAB_0040ea14:
  *peVar2 = eVar4;
  FUN_0040ee46();
  return eVar4;
}



// Library Function - Single Match
//  _abort
// 
// Library: Visual Studio 2017 Release

void __cdecl _abort(void)

{
  code *pcVar1;
  int iVar2;
  
  iVar2 = ___acrt_get_sigabrt_handler();
  if (iVar2 != 0) {
    FUN_00412665(0x16);
  }
  iVar2 = (*(code *)0x680040e1)(0x17);
  if (iVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  ___acrt_call_reportfault(3,0x40000015,1);
  __exit(3);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __calloc_base
// 
// Library: Visual Studio 2015 Release

int __calloc_base(uint param_1,uint param_2)

{
  int iVar1;
  undefined4 *puVar2;
  size_t _Size;
  
  if ((param_1 == 0) || (param_2 <= 0xffffffe0 / param_1)) {
    _Size = param_1 * param_2;
    if (_Size == 0) {
      _Size = 1;
    }
    do {
      iVar1 = (*(code *)0xe8458900)(__strnicmp,8,_Size);
      if (iVar1 != 0) {
        return iVar1;
      }
      iVar1 = FUN_0040e385();
    } while ((iVar1 != 0) && (iVar1 = __callnewh(_Size), iVar1 != 0));
  }
  puVar2 = (undefined4 *)FUN_0040ef03();
  *puVar2 = 0xc;
  return 0;
}



// Library Function - Single Match
//  _wcsncmp
// 
// Library: Visual Studio 2017 Release

int __cdecl _wcsncmp(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)

{
  if (_MaxCount != 0) {
    for (; ((_MaxCount = _MaxCount - 1, _MaxCount != 0 && (*_Str1 != L'\0')) && (*_Str1 == *_Str2));
        _Str1 = _Str1 + 1) {
      _Str2 = _Str2 + 1;
    }
    return (uint)(ushort)*_Str1 - (uint)(ushort)*_Str2;
  }
  return _MaxCount;
}



// WARNING: Removing unreachable block (ram,0x0040eb4a)

int * __thiscall FUN_0040eb24(int *param_1_00,int *param_1)

{
  uint uVar1;
  int iVar2;
  
  *(undefined *)(param_1_00 + 3) = 0;
  if (param_1 == (int *)0x0) {
    iVar2 = FUN_0040fd7d();
    *param_1_00 = iVar2;
    param_1_00[1] = *(int *)(iVar2 + 0x4c);
    param_1_00[2] = *(int *)(iVar2 + 0x48);
    ___acrt_update_locale_info(iVar2,param_1_00 + 1);
    ___acrt_update_multibyte_info(*param_1_00,param_1_00 + 2);
    uVar1 = *(uint *)(*param_1_00 + 0x350);
    if ((uVar1 & 2) == 0) {
      *(uint *)(*param_1_00 + 0x350) = uVar1 | 2;
      *(undefined *)(param_1_00 + 3) = 1;
    }
  }
  else {
    param_1_00[1] = *param_1;
    param_1_00[2] = param_1[1];
  }
  return param_1_00;
}



// Library Function - Single Match
//  __chvalidchk_l
// 
// Library: Visual Studio 2015 Release

ushort __chvalidchk_l(int param_1,ushort param_2,int **param_3)

{
  ushort uVar1;
  ushort *puVar2;
  
  if (param_3 == (int **)0x0) {
    puVar2 = ___pctype_func();
    uVar1 = puVar2[param_1];
  }
  else {
    uVar1 = *(ushort *)(**param_3 + param_1 * 2);
  }
  return uVar1 & param_2;
}



// Library Function - Single Match
//  __ischartype_l
// 
// Library: Visual Studio 2015 Release

void __ischartype_l(int param_1,int param_2,_locale_t param_3)

{
  if ((param_3 == (_locale_t)0x0) || ((int)param_3->locinfo->lc_codepage < 2)) {
    __chvalidchk_l(param_1,param_2,param_3);
  }
  else {
    __isctype_l(param_1,param_2,param_3);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_call_reportfault
// 
// Library: Visual Studio 2017 Release

void ___acrt_call_reportfault(int param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  undefined4 local_324;
  undefined4 local_320;
  undefined4 local_2d4 [39];
  
  if (param_1 != -1) {
    FUN_0040bd49();
  }
  _memset(&local_324,0,0x50);
  _memset(local_2d4,0,0x2cc);
  local_2d4[0] = 0x10001;
  local_324 = param_2;
  local_320 = param_3;
  iVar1 = (*(code *)0xfe75e800)();
  (*(code *)0xfffffffe)();
  iVar2 = (*(code *)0xfc45c759)();
  if (((iVar2 == 0) && (iVar1 == 0)) && (param_1 != -1)) {
    FUN_0040bd49();
  }
  ___security_check_cookie_4();
  return;
}



void FUN_0040edbc(undefined4 param_1)

{
  uRam00414cf8 = param_1;
                    // WARNING: Read-only address (ram,0x00414cf8) is written
  return;
}



// WARNING: Removing unreachable block (ram,0x0040ee40)
// Library Function - Single Match
//  __invalid_parameter
// 
// Library: Visual Studio 2015 Release

void __invalid_parameter(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4
                        ,undefined4 param_5)

{
  uint uVar1;
  int iVar2;
  code *pcVar3;
  
  uVar1 = (uint)&stack0xfffffffc ^ 0x74c08447;
  iVar2 = FUN_0040fecb();
  if ((iVar2 == 0) || (pcVar3 = *(code **)(iVar2 + 0x35c), pcVar3 == (code *)0x0)) {
    pcVar3 = (code *)0x9dfc61f3;
  }
  (*(code *)0xff0875ff)(param_1,param_2,param_3,param_4,param_5);
  (*pcVar3)();
  ___security_check_cookie_4(uVar1);
  return;
}



void FUN_0040ee46(void)

{
  __invalid_parameter(0,0,0,0,0);
  return;
}



// Library Function - Single Match
//  __invoke_watson
// 
// Library: Visual Studio 2017 Release

void __cdecl
__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)

{
  code *pcVar1;
  int iVar2;
  undefined4 uVar3;
  
  iVar2 = (*(code *)0x680040e1)(0x17);
  if (iVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  ___acrt_call_reportfault(2,0xc0000417,1);
  uVar3 = (*(code *)0x1839068b)(0xc0000417);
  (*(code *)0x60681175)(uVar3);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___acrt_errno_from_os_error
//  __get_errno_from_oserr
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

int __cdecl FID_conflict____acrt_errno_from_os_error(ulong param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == *(ulong *)(uVar1 * 8 + 0x40eb70)) {
      return *(int *)(uVar1 * 8 + 0x40eb74);
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x2c);
  if (param_1 - 0x13 < 0x12) {
    return 0xd;
  }
  return (-(uint)(0xe < param_1 - 0xbc) & 0xe) + 8;
}



// Library Function - Single Match
//  ___acrt_errno_map_os_error
// 
// Library: Visual Studio 2015 Release

void ___acrt_errno_map_os_error(ulong param_1)

{
  ulong *puVar1;
  int iVar2;
  int *piVar3;
  
  puVar1 = (ulong *)FUN_0040eef0();
  *puVar1 = param_1;
  iVar2 = FID_conflict____acrt_errno_from_os_error(param_1);
  piVar3 = (int *)FUN_0040ef03();
  *piVar3 = iVar2;
  return;
}



int FUN_0040eef0(void)

{
  int iVar1;
  
  iVar1 = FUN_0040fecb();
  if (iVar1 == 0) {
    return 0x414054;
  }
  return iVar1 + 0x14;
}



int FUN_0040ef03(void)

{
  int iVar1;
  
  iVar1 = FUN_0040fecb();
  if (iVar1 == 0) {
    return 0x414050;
  }
  return iVar1 + 0x10;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  int __cdecl common_dupenv_s<char>(char * * const,unsigned int * const,char const *
// const,int,char const * const,int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int __cdecl
common_dupenv_s_char_
          (char **param_1,uint *param_2,char *param_3,int param_4,char *param_5,int param_6)

{
  int iVar1;
  
  ___acrt_lock(0xb);
  iVar1 = common_dupenv_s_nolock_char_(param_1,param_2,param_3,param_4,param_5,param_6);
  FUN_0040ef68();
  return iVar1;
}



void FUN_0040ef68(void)

{
  ___acrt_unlock(0xb);
  return;
}



// Library Function - Single Match
//  int __cdecl common_dupenv_s_nolock<char>(char * * const,unsigned int * const,char const *
// const,int,char const * const,int)
// 
// Library: Visual Studio 2015 Release

int __cdecl
common_dupenv_s_nolock_char_
          (char **param_1,uint *param_2,char *param_3,int param_4,char *param_5,int param_6)

{
  char cVar1;
  code *pcVar2;
  undefined4 *puVar3;
  char *_Src;
  char *_Dst;
  errno_t eVar4;
  int iVar5;
  char *pcVar6;
  
  if (param_1 != (char **)0x0) {
    *param_1 = (char *)0x0;
    if (param_2 != (uint *)0x0) {
      *param_2 = 0;
    }
    if (param_3 != (char *)0x0) {
      _Src = common_getenv_nolock_char_(param_3);
      if (_Src != (char *)0x0) {
        pcVar6 = _Src;
        do {
          cVar1 = *pcVar6;
          pcVar6 = pcVar6 + 1;
        } while (cVar1 != '\0');
        pcVar6 = pcVar6 + (1 - (int)(_Src + 1));
        _Dst = (char *)FUN_00413440(pcVar6,1);
        *param_1 = _Dst;
        if (_Dst == (char *)0x0) {
          puVar3 = (undefined4 *)FUN_0040ef03();
          *puVar3 = 0xc;
          return 0xc;
        }
        eVar4 = _strcpy_s(_Dst,(rsize_t)pcVar6,_Src);
        if (eVar4 != 0) {
          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          pcVar2 = (code *)swi(3);
          iVar5 = (*pcVar2)();
          return iVar5;
        }
        if (param_2 != (uint *)0x0) {
          *param_2 = (uint)pcVar6;
        }
      }
      return 0;
    }
  }
  puVar3 = (undefined4 *)FUN_0040ef03();
  *puVar3 = 0x16;
  FUN_0040ee46();
  return 0x16;
}



// Library Function - Single Match
//  char * __cdecl common_getenv_nolock<char>(char const * const)
// 
// Library: Visual Studio 2015 Release

char * __cdecl common_getenv_nolock_char_(char *param_1)

{
  char cVar1;
  char **ppcVar2;
  int iVar3;
  char *pcVar4;
  char *pcVar5;
  uint _MaxCount;
  
  ppcVar2 = (char **)thunk_FUN_0040dbea();
  if ((ppcVar2 != (char **)0x0) && (param_1 != (char *)0x0)) {
    pcVar5 = param_1;
    do {
      cVar1 = *pcVar5;
      pcVar5 = pcVar5 + 1;
    } while (cVar1 != '\0');
    _MaxCount = (int)pcVar5 - (int)(param_1 + 1);
    for (; *ppcVar2 != (char *)0x0; ppcVar2 = ppcVar2 + 1) {
      pcVar5 = *ppcVar2;
      pcVar4 = pcVar5;
      do {
        cVar1 = *pcVar4;
        pcVar4 = pcVar4 + 1;
      } while (cVar1 != '\0');
      if (((_MaxCount < (uint)((int)pcVar4 - (int)(pcVar5 + 1))) && (pcVar5[_MaxCount] == '=')) &&
         (iVar3 = __strnicoll(pcVar5,param_1,_MaxCount), iVar3 == 0)) {
        return *ppcVar2 + _MaxCount + 1;
      }
    }
  }
  return (char *)0x0;
}



// Library Function - Single Match
//  __dupenv_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl __dupenv_s(char **_PBuffer,size_t *_PBufferSizeInBytes,char *_VarName)

{
  int iVar1;
  
  iVar1 = common_dupenv_s_char_(_PBuffer,_PBufferSizeInBytes,_VarName,1,(char *)0x0,0);
  return iVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: bool __thiscall __crt_seh_guarded_call<bool>::operator()<class
// <lambda_eee62cb4a147bfbb98180ad682ce6e17>,class <lambda_5056f36f92c185fae794536d1ce2027b>&,class
// <lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518>>(class
// <lambda_eee62cb4a147bfbb98180ad682ce6e17>&&,class
// <lambda_5056f36f92c185fae794536d1ce2027b>&,class <lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518>&&)
// 
// Library: Visual Studio 2015 Release

bool __thiscall
__crt_seh_guarded_call<bool>::
operator___class__lambda_eee62cb4a147bfbb98180ad682ce6e17__class__lambda_5056f36f92c185fae794536d1ce2027b___class__lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518___
          (__crt_seh_guarded_call_bool_ *this,_lambda_eee62cb4a147bfbb98180ad682ce6e17_ *param_1,
          _lambda_5056f36f92c185fae794536d1ce2027b_ *param_2,
          _lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518_ *param_3)

{
  bool bVar1;
  
  ___acrt_lock(*(undefined4 *)param_1);
  bVar1 = <lambda_5056f36f92c185fae794536d1ce2027b>::operator__(param_2);
  FUN_0040f0e9();
  return bVar1;
}



void FUN_0040f0e9(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  int __cdecl common_spawnv<char>(int,char const * const,char const * const * const,char const *
// const * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl common_spawnv_char_(int param_1,char *param_2,char **param_3,char **param_4)

{
  rsize_t _SizeInBytes;
  char cVar1;
  undefined4 uVar2;
  code *pcVar3;
  undefined4 *puVar4;
  char *pcVar5;
  char *pcVar6;
  errno_t eVar7;
  int iVar8;
  char *_Dst;
  void *_Memory;
  char *local_c;
  
  if ((((param_2 == (char *)0x0) || (*param_2 == '\0')) || (param_3 == (char **)0x0)) ||
     ((*param_3 == (char *)0x0 || (**param_3 == '\0')))) {
    puVar4 = (undefined4 *)FUN_0040ef03();
    *puVar4 = 0x16;
    FUN_0040ee46();
    return -1;
  }
  pcVar5 = _strrchr(param_2,0x5c);
  pcVar6 = _strrchr(param_2,0x2f);
  local_c = param_2;
  if (pcVar6 == (char *)0x0) {
    if ((pcVar5 == (char *)0x0) && (pcVar5 = _strrchr(param_2,0x3a), pcVar5 == (char *)0x0)) {
      pcVar5 = param_2;
      do {
        cVar1 = *pcVar5;
        pcVar5 = pcVar5 + 1;
      } while (cVar1 != '\0');
      pcVar5 = pcVar5 + (3 - (int)(param_2 + 1));
      local_c = (char *)__calloc_base(pcVar5,1);
      if (local_c == (char *)0x0) {
        FID_conflict__free((void *)0x0);
        return -1;
      }
      eVar7 = _strcpy_s(local_c,(rsize_t)pcVar5,(char *)0x40ecd0);
      if ((eVar7 != 0) || (eVar7 = _strcat_s(local_c,(rsize_t)pcVar5,param_2), eVar7 != 0))
      goto LAB_0040f306;
      FID_conflict__free((void *)0x0);
      pcVar5 = local_c + 2;
    }
  }
  else if ((pcVar5 == (char *)0x0) || (pcVar5 < pcVar6)) {
    pcVar5 = pcVar6;
  }
  _Memory = (void *)(-(uint)(param_2 != local_c) & (uint)local_c);
  pcVar5 = _strrchr(pcVar5,0x2e);
  if (pcVar5 == (char *)0x0) {
    pcVar5 = local_c + 1;
    pcVar6 = local_c;
    do {
      cVar1 = *pcVar6;
      pcVar6 = pcVar6 + 1;
    } while (cVar1 != '\0');
    _SizeInBytes = ((int)pcVar6 - (int)pcVar5) + 5;
    _Dst = (char *)__calloc_base(_SizeInBytes,1);
    if (_Dst == (char *)0x0) {
      iVar8 = -1;
LAB_0040f2ec:
      FID_conflict__free(_Dst);
      goto LAB_0040f2f3;
    }
    eVar7 = _strcpy_s(_Dst,_SizeInBytes,local_c);
    if (eVar7 != 0) {
LAB_0040f306:
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar3 = (code *)swi(3);
      iVar8 = (*pcVar3)();
      return iVar8;
    }
    puVar4 = (undefined4 *)FUN_0040ef03();
    uVar2 = *puVar4;
    local_c = (char *)0x40ecd4;
    do {
      eVar7 = _strcpy_s(_Dst + ((int)pcVar6 - (int)pcVar5),5,local_c);
      if (eVar7 != 0) goto LAB_0040f306;
      eVar7 = __access_s(_Dst,0);
      if (eVar7 == 0) {
        puVar4 = (undefined4 *)FUN_0040ef03();
        *puVar4 = uVar2;
        iVar8 = FUN_0040f310(param_1,_Dst,param_3,param_4);
        goto LAB_0040f2ec;
      }
      local_c = local_c + 5;
    } while (local_c != (char *)0x40ece8);
    FID_conflict__free(_Dst);
  }
  else {
    eVar7 = __access_s(local_c,0);
    if (eVar7 == 0) {
      iVar8 = FUN_0040f310(param_1,local_c,param_3,param_4);
      goto LAB_0040f2f3;
    }
  }
  iVar8 = -1;
LAB_0040f2f3:
  FID_conflict__free(_Memory);
  return iVar8;
}



int FUN_0040f310(uint param_1,int param_2,int param_3,undefined4 param_4)

{
  code *pcVar1;
  bool bVar2;
  undefined4 *puVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  undefined4 local_70 [12];
  undefined2 local_3e;
  uchar *local_3c;
  int local_2c;
  int local_28;
  int local_1c;
  int local_18;
  undefined2 local_14;
  void *local_10;
  uchar *local_c;
  void *local_8;
  
  if ((param_2 != 0) && (param_3 != 0)) {
    if (param_1 < 5) {
      local_10 = (void *)0x0;
      local_8 = (void *)0x0;
      iVar4 = ___acrt_pack_narrow_command_line_and_environment(param_3,param_4,&local_10,&local_8);
      if (iVar4 == -1) {
        FID_conflict__free(local_8);
        local_8 = (void *)0x0;
        FID_conflict__free(local_10);
      }
      else {
        local_c = (uchar *)0x0;
        bVar2 = accumulate_inheritable_handles(&local_c,(uint *)&local_14,param_1 != 4);
        if (bVar2) {
          uVar6 = 0;
          if (param_1 == 4) {
            uVar6 = 8;
          }
          puVar3 = (undefined4 *)FUN_0040eef0();
          *puVar3 = 0;
          _memset(local_70,0,0x44);
          local_3e = local_14;
          local_3c = local_c;
          local_70[0] = 0x44;
          iVar5 = (*(code *)0x4589026a)(param_2,local_10,0,0,1,uVar6,local_8,0,local_70,&local_2c);
          iVar4 = local_2c;
          if (iVar5 == 0) {
            uVar6 = (*(code *)0x414cb805)();
            ___acrt_errno_map_os_error(uVar6);
            if (local_28 != -1) {
              (*(code *)0x8dfe4d8d)(local_28);
            }
            iVar5 = -1;
            if (local_2c != -1) {
              (*(code *)0x8dfe4d8d)(local_2c);
            }
          }
          else {
            if (param_1 == 2) {
              __exit(0);
              pcVar1 = (code *)swi(3);
              iVar4 = (*pcVar1)();
              return iVar4;
            }
            if (param_1 == 0) {
              (*(code *)0x45891045)(local_2c,0xffffffff);
              (*(code *)0xff458dec)(local_2c,&local_18);
              local_1c = local_18;
              if (local_28 != -1) {
                (*(code *)0x8dfe4d8d)(local_28);
              }
              iVar5 = local_1c;
              if (iVar4 != -1) {
                (*(code *)0x8dfe4d8d)(iVar4);
                iVar5 = local_1c;
              }
            }
            else {
              if (param_1 != 4) {
                if (local_28 != -1) {
                  (*(code *)0x8dfe4d8d)(local_28);
                }
                FID_conflict__free(local_c);
                local_c = (uchar *)0x0;
                FID_conflict__free(local_8);
                local_8 = (void *)0x0;
                FID_conflict__free(local_10);
                return local_2c;
              }
              if (local_28 != -1) {
                (*(code *)0x8dfe4d8d)(local_28);
              }
              if (local_2c != -1) {
                (*(code *)0x8dfe4d8d)(local_2c);
              }
              iVar5 = 0;
            }
          }
          FID_conflict__free(local_c);
          local_c = (uchar *)0x0;
          FID_conflict__free(local_8);
          local_8 = (void *)0x0;
          FID_conflict__free(local_10);
          return iVar5;
        }
        FID_conflict__free(local_c);
        local_c = (uchar *)0x0;
        FID_conflict__free(local_8);
        local_8 = (void *)0x0;
        FID_conflict__free(local_10);
      }
      return -1;
    }
    puVar3 = (undefined4 *)FUN_0040eef0();
    *puVar3 = 0;
  }
  puVar3 = (undefined4 *)FUN_0040ef03();
  *puVar3 = 0x16;
  FUN_0040ee46();
  return -1;
}



// Library Function - Single Match
//  public: bool __thiscall <lambda_5056f36f92c185fae794536d1ce2027b>::operator()(void)const 
// 
// Library: Visual Studio 2015 Release

bool __thiscall
<lambda_5056f36f92c185fae794536d1ce2027b>::operator__
          (_lambda_5056f36f92c185fae794536d1ce2027b_ *this)

{
  byte bVar1;
  undefined4 *puVar2;
  uint *puVar3;
  int iVar4;
  uint *puVar5;
  bool bVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  undefined4 *local_c;
  
  *(undefined4 *)**(undefined4 **)this = 0;
  *(undefined4 *)**(undefined4 **)(this + 4) = 0;
  uVar7 = 0x8b0c4d8b;
  uVar8 = 0x8b0c4d8a;
  do {
    if (*(char *)(*(int *)((uVar8 >> 6) * 4 + 0x414e68) + 0x28 + (uVar8 & 0x3f) * 0x30) == '\0')
    break;
    uVar8 = uVar8 - 1;
    uVar7 = uVar7 - 1;
  } while (uVar7 != 0);
  if (uVar7 < 0x3332) {
    uVar8 = uVar7 * 5 + 4 & 0xffff;
    puVar3 = (uint *)__calloc_base(uVar8,1);
    if (puVar3 == (uint *)0x0) {
      puVar2 = (undefined4 *)FUN_0040ef03();
      bVar6 = false;
      *puVar2 = 0xc;
    }
    else {
      puVar5 = puVar3 + 1;
      *puVar3 = uVar7;
      local_c = (undefined4 *)((int)puVar5 + uVar7);
      uVar9 = 0;
      puVar2 = local_c;
      if (uVar7 != 0) {
        do {
          iVar4 = (uVar9 & 0x3f) * 0x30 + *(int *)((uVar9 >> 6) * 4 + 0x414e68);
          bVar1 = *(byte *)(iVar4 + 0x28);
          if ((bVar1 & 0x10) == 0) {
            *(byte *)(uVar9 + (int)puVar5) = bVar1;
            *puVar2 = *(undefined4 *)(iVar4 + 0x18);
          }
          else {
            *(undefined *)(uVar9 + (int)puVar5) = 0;
            *puVar2 = 0xffffffff;
          }
          uVar9 = uVar9 + 1;
          puVar2 = puVar2 + 1;
        } while (uVar9 != uVar7);
      }
      if (**(char **)(this + 8) == '\0') {
        uVar9 = 0;
        while( true ) {
          uVar10 = uVar7;
          if (2 < uVar7) {
            uVar10 = 3;
          }
          if (uVar9 == uVar10) break;
          *(undefined *)puVar5 = 0;
          *local_c = 0xffffffff;
          uVar9 = uVar9 + 1;
          puVar5 = (uint *)((int)puVar5 + 1);
          local_c = local_c + 1;
        }
      }
      ***(int ***)this = (int)puVar3;
      bVar6 = true;
      ***(uint ***)(this + 4) = uVar8;
    }
    FID_conflict__free((void *)0x0);
  }
  else {
    puVar2 = (undefined4 *)FUN_0040ef03();
    *puVar2 = 0xc;
    bVar6 = false;
  }
  return bVar6;
}



// Library Function - Single Match
//  bool __cdecl accumulate_inheritable_handles(unsigned char * * const,unsigned int * const,bool)
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release

bool __cdecl accumulate_inheritable_handles(uchar **param_1,uint *param_2,bool param_3)

{
  bool bVar1;
  uchar ***local_1c;
  uint **local_18;
  bool *local_14;
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_bool_ local_5;
  
  local_1c = &param_1;
  local_18 = &param_2;
  local_14 = &param_3;
  local_c = 7;
  local_10 = 7;
  bVar1 = __crt_seh_guarded_call<bool>::
          operator___class__lambda_eee62cb4a147bfbb98180ad682ce6e17__class__lambda_5056f36f92c185fae794536d1ce2027b___class__lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518___
                    (&local_5,(_lambda_eee62cb4a147bfbb98180ad682ce6e17_ *)&local_10,
                     (_lambda_5056f36f92c185fae794536d1ce2027b_ *)&local_1c,
                     (_lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518_ *)&local_c);
  return bVar1;
}



void FUN_0040f699(int param_1,char *param_2,char **param_3,char **param_4)

{
  common_spawnv_char_(param_1,param_2,param_3,param_4);
  return;
}



// Library Function - Single Match
//  int __cdecl common_spawnvp<char>(int,char const * const,char const * const * const,char const *
// const * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl common_spawnvp_char_(int param_1,char *param_2,char **param_3,char **param_4)

{
  char cVar1;
  code *pcVar2;
  bool bVar3;
  undefined4 *puVar4;
  int *piVar5;
  int iVar6;
  int *piVar7;
  char *pcVar8;
  errno_t eVar9;
  char *_Str;
  char *pcVar10;
  int iVar11;
  char *pcVar12;
  char *local_1c;
  undefined2 local_18 [3];
  char local_11;
  undefined4 local_10;
  undefined local_c;
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  if ((((param_2 == (char *)0x0) || (*param_2 == '\0')) || (param_3 == (char **)0x0)) ||
     ((*param_3 == (char *)0x0 || (**param_3 == '\0')))) {
    puVar4 = (undefined4 *)FUN_0040ef03();
    *puVar4 = 0x16;
    FUN_0040ee46();
  }
  else {
    piVar5 = (int *)FUN_0040ef03();
    iVar11 = *piVar5;
    *piVar5 = 0;
    iVar6 = FUN_0040f699(param_1,param_2,param_3,param_4);
    if (((iVar6 == -1) && (piVar7 = (int *)FUN_0040ef03(), *piVar7 == 2)) &&
       ((pcVar8 = _strchr(param_2,0x5c), pcVar8 == (char *)0x0 &&
        ((pcVar8 = _strchr(param_2,0x2f), pcVar8 == (char *)0x0 && (param_2[1] != ':')))))) {
      local_10 = 0x48544150;
      local_c = 0;
      local_1c = (char *)0x0;
      eVar9 = __dupenv_s(&local_1c,(size_t *)0x0,(char *)&local_10);
      if (eVar9 == 0) {
        if (local_1c != (char *)0x0) {
          _Str = (char *)__calloc_base(0x104,1);
          pcVar8 = local_1c;
          if (_Str != (char *)0x0) {
            do {
              do {
                pcVar8 = (char *)FUN_00413a42(pcVar8,_Str,0x103);
                if ((pcVar8 == (char *)0x0) || (pcVar10 = _Str, *_Str == '\0')) goto LAB_0040f8fd;
                do {
                  pcVar12 = pcVar10;
                  pcVar10 = pcVar12 + 1;
                } while (*pcVar12 != '\0');
                pcVar10 = _strrchr(_Str,0x5c);
                if ((pcVar12 + -1 != pcVar10) &&
                   (pcVar10 = _strrchr(_Str,0x2f), pcVar12 + -1 != pcVar10)) {
                  local_18[0] = 0x5c;
                  eVar9 = _strcat_s(_Str,0x104,(char *)local_18);
                  if (eVar9 != 0) goto LAB_0040f936;
                }
                pcVar10 = _Str;
                do {
                  cVar1 = *pcVar10;
                  pcVar10 = pcVar10 + 1;
                } while (cVar1 != '\0');
                pcVar12 = param_2;
                do {
                  cVar1 = *pcVar12;
                  pcVar12 = pcVar12 + 1;
                } while (cVar1 != '\0');
                if ((char *)0x103 <
                    pcVar10 + (int)(pcVar12 + (-(int)(param_2 + 1) - (int)(_Str + 1))))
                goto LAB_0040f8fd;
                eVar9 = _strcat_s(_Str,0x104,param_2);
                if (eVar9 != 0) goto LAB_0040f936;
                puVar4 = (undefined4 *)FUN_0040ef03();
                *puVar4 = 0;
                iVar6 = FUN_0040f699(param_1,_Str,param_3,param_4);
                if (iVar6 != -1) goto LAB_0040f8fd;
                piVar7 = (int *)FUN_0040ef03();
              } while ((*piVar7 == 2) || (piVar7 = (int *)FUN_0040eef0(), *piVar7 == 0x15));
              pcVar10 = _strchr(_Str,0x2f);
              if (pcVar10 == _Str) {
                pcVar10 = _strchr(_Str + 1,0x2f);
                local_11 = '\x01';
                if (pcVar10 != _Str + 1) goto LAB_0040f8ab;
              }
              else {
LAB_0040f8ab:
                local_11 = '\0';
              }
              pcVar10 = _strchr(_Str,0x5c);
              if ((pcVar10 == _Str) && (pcVar10 = _strchr(_Str + 1,0x5c), pcVar10 == _Str + 1)) {
                bVar3 = true;
              }
              else {
                bVar3 = false;
              }
            } while ((local_11 != '\0') || (bVar3));
          }
LAB_0040f8fd:
          FID_conflict__free(_Str);
        }
      }
      else if (eVar9 == 0x16) {
LAB_0040f936:
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        pcVar2 = (code *)swi(3);
        iVar11 = (*pcVar2)();
        return iVar11;
      }
      FID_conflict__free(local_1c);
      local_1c = (char *)0x0;
    }
    if ((*piVar5 == 0) && (iVar11 != 0)) {
      *piVar5 = iVar11;
    }
  }
  iVar11 = ___security_check_cookie_4();
  return iVar11;
}



void FUN_0040f943(int param_1,char *param_2,char **param_3,char **param_4)

{
  common_spawnvp_char_(param_1,param_2,param_3,param_4);
  return;
}



// Library Function - Single Match
//  __waccess_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl __waccess_s(wchar_t *_Filename,int _AccessMode)

{
  undefined4 *puVar1;
  int iVar2;
  undefined4 uVar3;
  errno_t eVar4;
  byte local_2c [36];
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  if (_Filename == (wchar_t *)0x0) {
    puVar1 = (undefined4 *)FUN_0040eef0();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
  }
  else if ((_AccessMode & 0xfffffff9U) == 0) {
    iVar2 = (*(code *)0x458958f0)(_Filename,0,local_2c);
    if (iVar2 == 0) {
      uVar3 = (*(code *)0x414cb805)();
      ___acrt_errno_map_os_error(uVar3);
    }
    else {
      if ((((local_2c[0] & 0x10) != 0) || ((local_2c[0] & 1) == 0)) ||
         (((uint)_AccessMode >> 1 & 1) == 0)) goto LAB_0040f9ff;
      puVar1 = (undefined4 *)FUN_0040eef0();
      *puVar1 = 5;
      puVar1 = (undefined4 *)FUN_0040ef03();
      *puVar1 = 0xd;
    }
    FUN_0040ef03();
  }
  else {
    puVar1 = (undefined4 *)FUN_0040eef0();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
  }
LAB_0040f9ff:
  eVar4 = ___security_check_cookie_4();
  return eVar4;
}



// Library Function - Single Match
//  __access_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl __access_s(char *_Filename,int _AccessMode)

{
  errno_t eVar1;
  int iVar2;
  wchar_t *local_8;
  
  if (_Filename == (char *)0x0) {
    eVar1 = __waccess_s((wchar_t *)0x0,_AccessMode);
  }
  else {
    local_8 = (wchar_t *)0x0;
    iVar2 = ___acrt_copy_path_to_wide_string(_Filename,&local_8);
    if (iVar2 == 0) {
      eVar1 = -1;
    }
    else {
      eVar1 = __waccess_s(local_8,_AccessMode);
    }
    FID_conflict__free(local_8);
  }
  return eVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_15ade71b0218206bbe3333a0c9b79046>,class <lambda_da44e0f8b0f19ba52fefafb335991732>&,class
// <lambda_207f2d024fc103971653565357d6cd41>>(class
// <lambda_15ade71b0218206bbe3333a0c9b79046>&&,class
// <lambda_da44e0f8b0f19ba52fefafb335991732>&,class <lambda_207f2d024fc103971653565357d6cd41>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_15ade71b0218206bbe3333a0c9b79046__class__lambda_da44e0f8b0f19ba52fefafb335991732___class__lambda_207f2d024fc103971653565357d6cd41___
          (__crt_seh_guarded_call_void_ *this,_lambda_15ade71b0218206bbe3333a0c9b79046_ *param_1,
          _lambda_da44e0f8b0f19ba52fefafb335991732_ *param_2,
          _lambda_207f2d024fc103971653565357d6cd41_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  LOCK();
  **(int **)(**(int **)param_2 + 0x48) = **(int **)(**(int **)param_2 + 0x48) + 1;
  FUN_0040fa9f();
  return;
}



void FUN_0040fa9f(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_38edbb1296d33220d7e4dd0ed76b244a>,class <lambda_5ce1d447e08cb34b2473517608e21441>&,class
// <lambda_fb385d3da700c9147fc39e65dd577a8c>>(class
// <lambda_38edbb1296d33220d7e4dd0ed76b244a>&&,class
// <lambda_5ce1d447e08cb34b2473517608e21441>&,class <lambda_fb385d3da700c9147fc39e65dd577a8c>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_38edbb1296d33220d7e4dd0ed76b244a__class__lambda_5ce1d447e08cb34b2473517608e21441___class__lambda_fb385d3da700c9147fc39e65dd577a8c___
          (__crt_seh_guarded_call_void_ *this,_lambda_38edbb1296d33220d7e4dd0ed76b244a_ *param_1,
          _lambda_5ce1d447e08cb34b2473517608e21441_ *param_2,
          _lambda_fb385d3da700c9147fc39e65dd577a8c_ *param_3)

{
  int *_Memory;
  int iVar1;
  
  ___acrt_lock(*(undefined4 *)param_1);
  _Memory = *(int **)(**(int **)param_2 + 0x48);
  if (_Memory != (int *)0x0) {
    LOCK();
    iVar1 = *_Memory;
    *_Memory = iVar1 + -1;
    if ((iVar1 + -1 == 0) && (_Memory != (int *)0x414360)) {
      FID_conflict__free(_Memory);
    }
  }
  FUN_0040fb00();
  return;
}



void FUN_0040fb00(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_6affb1475c98b40b75cdec977db92e3c>,class <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>&,class
// <lambda_608742c3c92a14382c1684fc64f96c88>>(class
// <lambda_6affb1475c98b40b75cdec977db92e3c>&&,class
// <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>&,class <lambda_608742c3c92a14382c1684fc64f96c88>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_6affb1475c98b40b75cdec977db92e3c__class__lambda_b8d4b9c228a6ecc3f80208dbb4b4a104___class__lambda_608742c3c92a14382c1684fc64f96c88___
          (__crt_seh_guarded_call_void_ *this,_lambda_6affb1475c98b40b75cdec977db92e3c_ *param_1,
          _lambda_b8d4b9c228a6ecc3f80208dbb4b4a104_ *param_2,
          _lambda_608742c3c92a14382c1684fc64f96c88_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  replace_current_thread_locale_nolock(**(__acrt_ptd ***)param_2,(__crt_locale_data *)0x0);
  FUN_0040fb4b();
  return;
}



void FUN_0040fb4b(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_a7e850c220f1c8d1e6efeecdedd162c6>,class <lambda_46720907175c18b6c9d2717bc0d2d362>&,class
// <lambda_9048902d66e8d99359bc9897bbb930a8>>(class
// <lambda_a7e850c220f1c8d1e6efeecdedd162c6>&&,class
// <lambda_46720907175c18b6c9d2717bc0d2d362>&,class <lambda_9048902d66e8d99359bc9897bbb930a8>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_a7e850c220f1c8d1e6efeecdedd162c6__class__lambda_46720907175c18b6c9d2717bc0d2d362___class__lambda_9048902d66e8d99359bc9897bbb930a8___
          (__crt_seh_guarded_call_void_ *this,_lambda_a7e850c220f1c8d1e6efeecdedd162c6_ *param_1,
          _lambda_46720907175c18b6c9d2717bc0d2d362_ *param_2,
          _lambda_9048902d66e8d99359bc9897bbb930a8_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  replace_current_thread_locale_nolock
            (**(__acrt_ptd ***)param_2,*(__crt_locale_data **)**(undefined4 **)(param_2 + 4));
  FUN_0040fb9b();
  return;
}



void FUN_0040fb9b(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  void __cdecl construct_ptd(struct __acrt_ptd * const,struct __crt_locale_data * * const)
// 
// Library: Visual Studio 2017 Release

void __cdecl construct_ptd(__acrt_ptd *param_1,__crt_locale_data **param_2)

{
  undefined4 local_18;
  __acrt_ptd **local_14;
  __acrt_ptd **local_10;
  __crt_locale_data ***local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  *(undefined4 *)(param_1 + 0x18) = 1;
  *(undefined4 *)param_1 = 0x40ea28;
  *(undefined4 *)(param_1 + 0x350) = 1;
  *(undefined4 *)(param_1 + 0x48) = 0x414360;
  *(undefined2 *)(param_1 + 0x6c) = 0x43;
  *(undefined2 *)(param_1 + 0x172) = 0x43;
  *(undefined4 *)(param_1 + 0x34c) = 0;
  local_14 = &param_1;
  local_c = (__crt_locale_data ***)0x5;
  local_18 = 5;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_15ade71b0218206bbe3333a0c9b79046__class__lambda_da44e0f8b0f19ba52fefafb335991732___class__lambda_207f2d024fc103971653565357d6cd41___
            (&local_5,(_lambda_15ade71b0218206bbe3333a0c9b79046_ *)&local_18,
             (_lambda_da44e0f8b0f19ba52fefafb335991732_ *)&local_14,
             (_lambda_207f2d024fc103971653565357d6cd41_ *)&local_c);
  local_10 = &param_1;
  local_c = &param_2;
  local_18 = 4;
  local_14 = (__acrt_ptd **)0x4;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_a7e850c220f1c8d1e6efeecdedd162c6__class__lambda_46720907175c18b6c9d2717bc0d2d362___class__lambda_9048902d66e8d99359bc9897bbb930a8___
            (&local_5,(_lambda_a7e850c220f1c8d1e6efeecdedd162c6_ *)&local_14,
             (_lambda_46720907175c18b6c9d2717bc0d2d362_ *)&local_10,
             (_lambda_9048902d66e8d99359bc9897bbb930a8_ *)&local_18);
  return;
}



// Library Function - Single Match
//  void __stdcall destroy_fls(void *)
// 
// Library: Visual Studio 2017 Release

void destroy_fls(void *param_1)

{
  if (param_1 != (void *)0x0) {
    destroy_ptd((__acrt_ptd *)param_1);
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Single Match
//  void __cdecl destroy_ptd(struct __acrt_ptd * const)
// 
// Library: Visual Studio 2017 Release

void __cdecl destroy_ptd(__acrt_ptd *param_1)

{
  undefined4 local_14;
  __acrt_ptd **local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  if (*(void **)param_1 != (void *)0x40ea28) {
    FID_conflict__free(*(void **)param_1);
  }
  FID_conflict__free(*(void **)(param_1 + 0x3c));
  FID_conflict__free(*(void **)(param_1 + 0x30));
  FID_conflict__free(*(void **)(param_1 + 0x34));
  FID_conflict__free(*(void **)(param_1 + 0x38));
  FID_conflict__free(*(void **)(param_1 + 0x28));
  FID_conflict__free(*(void **)(param_1 + 0x2c));
  FID_conflict__free(*(void **)(param_1 + 0x40));
  FID_conflict__free(*(void **)(param_1 + 0x44));
  FID_conflict__free(*(void **)(param_1 + 0x360));
  local_10 = &param_1;
  local_c = 5;
  local_14 = 5;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_38edbb1296d33220d7e4dd0ed76b244a__class__lambda_5ce1d447e08cb34b2473517608e21441___class__lambda_fb385d3da700c9147fc39e65dd577a8c___
            (&local_5,(_lambda_38edbb1296d33220d7e4dd0ed76b244a_ *)&local_14,
             (_lambda_5ce1d447e08cb34b2473517608e21441_ *)&local_10,
             (_lambda_fb385d3da700c9147fc39e65dd577a8c_ *)&local_c);
  local_10 = &param_1;
  local_14 = 4;
  local_c = 4;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_6affb1475c98b40b75cdec977db92e3c__class__lambda_b8d4b9c228a6ecc3f80208dbb4b4a104___class__lambda_608742c3c92a14382c1684fc64f96c88___
            (&local_5,(_lambda_6affb1475c98b40b75cdec977db92e3c_ *)&local_c,
             (_lambda_b8d4b9c228a6ecc3f80208dbb4b4a104_ *)&local_10,
             (_lambda_608742c3c92a14382c1684fc64f96c88_ *)&local_14);
  return;
}



// Library Function - Single Match
//  void __cdecl replace_current_thread_locale_nolock(struct __acrt_ptd * const,struct
// __crt_locale_data * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl replace_current_thread_locale_nolock(__acrt_ptd *param_1,__crt_locale_data *param_2)

{
  int iVar1;
  
  if (*(int *)(param_1 + 0x4c) != 0) {
    ___acrt_release_locale_ref(*(undefined4 *)(param_1 + 0x4c));
    iVar1 = *(int *)(param_1 + 0x4c);
    if (((iVar1 != -0x2e08f7bb) && (iVar1 != 0x414580)) && (*(int *)(iVar1 + 0xc) == 0)) {
      ___acrt_free_locale(iVar1);
    }
  }
  *(__crt_locale_data **)(param_1 + 0x4c) = param_2;
  if (param_2 != (__crt_locale_data *)0x0) {
    ___acrt_add_locale_ref(param_2);
  }
  return;
}



__acrt_ptd * FUN_0040fd7d(void)

{
  code *pcVar1;
  undefined4 uVar2;
  __acrt_ptd *p_Var3;
  int iVar4;
  
  uVar2 = (*(code *)0x414cb805)();
  p_Var3 = (__acrt_ptd *)FUN_0041210f(0xec8b55ff);
  if (p_Var3 == (__acrt_ptd *)0x0) {
    iVar4 = ___acrt_FlsSetValue_8(0xec8b55ff,0xffffffff);
    if (iVar4 == 0) goto LAB_0040fe24;
    p_Var3 = (__acrt_ptd *)__calloc_base(1,0x364);
    if (p_Var3 == (__acrt_ptd *)0x0) {
      ___acrt_FlsSetValue_8(0xec8b55ff,0);
    }
    else {
      iVar4 = ___acrt_FlsSetValue_8(0xec8b55ff,p_Var3);
      if (iVar4 != 0) {
        construct_ptd(p_Var3,(__crt_locale_data **)0x41506c);
        FID_conflict__free((void *)0x0);
        goto LAB_0040fe14;
      }
      ___acrt_FlsSetValue_8(0xec8b55ff,0);
    }
    FID_conflict__free(p_Var3);
  }
  else {
    if (p_Var3 == (__acrt_ptd *)0xffffffff) goto LAB_0040fe24;
LAB_0040fe14:
    if (p_Var3 != (__acrt_ptd *)0x0) {
      (*(code *)0x468b0100)(uVar2);
      return p_Var3;
    }
  }
LAB_0040fe24:
  (*(code *)0x468b0100)(uVar2);
  _abort();
  pcVar1 = (code *)swi(3);
  p_Var3 = (__acrt_ptd *)(*pcVar1)();
  return p_Var3;
}



__acrt_ptd * FUN_0040fe31(void)

{
  code *pcVar1;
  __acrt_ptd *p_Var2;
  int iVar3;
  
  p_Var2 = (__acrt_ptd *)FUN_0041210f(0xec8b55ff);
  if (p_Var2 == (__acrt_ptd *)0x0) {
    iVar3 = ___acrt_FlsSetValue_8(0xec8b55ff,0xffffffff);
    if (iVar3 == 0) goto LAB_0040fec5;
    p_Var2 = (__acrt_ptd *)__calloc_base(1,0x364);
    if (p_Var2 == (__acrt_ptd *)0x0) {
      ___acrt_FlsSetValue_8(0xec8b55ff,0);
    }
    else {
      iVar3 = ___acrt_FlsSetValue_8(0xec8b55ff,p_Var2);
      if (iVar3 != 0) {
        construct_ptd(p_Var2,(__crt_locale_data **)0x41506c);
        FID_conflict__free((void *)0x0);
        goto LAB_0040febd;
      }
      ___acrt_FlsSetValue_8(0xec8b55ff,0);
    }
    FID_conflict__free(p_Var2);
  }
  else {
    if (p_Var2 == (__acrt_ptd *)0xffffffff) goto LAB_0040fec5;
LAB_0040febd:
    if (p_Var2 != (__acrt_ptd *)0x0) {
      return p_Var2;
    }
  }
LAB_0040fec5:
  _abort();
  pcVar1 = (code *)swi(3);
  p_Var2 = (__acrt_ptd *)(*pcVar1)();
  return p_Var2;
}



__acrt_ptd * FUN_0040fecb(void)

{
  undefined4 uVar1;
  __acrt_ptd *_Memory;
  int iVar2;
  
  uVar1 = (*(code *)0x414cb805)();
  _Memory = (__acrt_ptd *)FUN_0041210f(0xec8b55ff);
  if (_Memory == (__acrt_ptd *)0x0) {
    iVar2 = ___acrt_FlsSetValue_8(0xec8b55ff,0xffffffff);
    if (iVar2 == 0) goto LAB_0040fef5;
    _Memory = (__acrt_ptd *)__calloc_base(1,0x364);
    if (_Memory == (__acrt_ptd *)0x0) {
      ___acrt_FlsSetValue_8(0xec8b55ff,0);
      _Memory = (__acrt_ptd *)0x0;
    }
    else {
      iVar2 = ___acrt_FlsSetValue_8(0xec8b55ff,_Memory);
      if (iVar2 != 0) {
        construct_ptd(_Memory,(__crt_locale_data **)0x41506c);
        FID_conflict__free((void *)0x0);
        goto LAB_0040ff71;
      }
      ___acrt_FlsSetValue_8(0xec8b55ff,0);
    }
    FID_conflict__free(_Memory);
  }
  else {
    if (_Memory == (__acrt_ptd *)0xffffffff) goto LAB_0040fef5;
LAB_0040ff71:
    if (_Memory != (__acrt_ptd *)0x0) {
      (*(code *)0x468b0100)(uVar1);
      return _Memory;
    }
  }
LAB_0040fef5:
  (*(code *)0x468b0100)(uVar1);
  return (__acrt_ptd *)0x0;
}



uint FUN_0040ffc4(uint param_1,uint param_2)

{
  if (param_2 >= param_1 && param_2 != param_1) {
    return 0xffffffff;
  }
  return (uint)(param_2 < param_1);
}



// WARNING: Type propagation algorithm not settling

int FUN_0040ffdc(char **param_1,int *param_2)

{
  char cVar1;
  code *pcVar2;
  undefined4 *puVar3;
  char *pcVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  char **ppcVar10;
  char **_Memory;
  char **local_2c;
  char **local_28;
  undefined4 local_24;
  uint local_20;
  char **local_1c;
  char *local_18;
  char *local_14;
  char *local_10;
  char *local_c;
  undefined4 local_8;
  
  if (param_2 == (int *)0x0) {
    puVar3 = (undefined4 *)FUN_0040ef03();
    iVar8 = 0x16;
    *puVar3 = 0x16;
    FUN_0040ee46();
  }
  else {
    uVar7 = 0;
    *param_2 = 0;
    local_2c = (char **)0x0;
    local_28 = (char **)0x0;
    local_24 = 0;
    pcVar4 = *param_1;
    ppcVar10 = local_2c;
    while (local_2c = ppcVar10, pcVar4 != (char *)0x0) {
      local_8 = (char **)CONCAT13((char)((uint)local_8 >> 0x18),0x3f2a);
      pcVar4 = _strpbrk(*param_1,(char *)&local_8);
      if (pcVar4 == (char *)0x0) {
        iVar8 = FUN_004101bc(*param_1,0,0,&local_2c);
      }
      else {
        iVar8 = FUN_0041026f(*param_1,pcVar4,&local_2c);
      }
      ppcVar10 = local_2c;
      local_c = (char *)iVar8;
      if (iVar8 != 0) goto LAB_0041016a;
      param_1 = param_1 + 1;
      pcVar4 = *param_1;
    }
    local_c = (char *)0x0;
    local_10 = (char *)(((int)local_28 - (int)ppcVar10 >> 2) + 1);
    uVar9 = ~-(uint)(local_28 < ppcVar10) & ((int)local_28 - (int)ppcVar10) + 3U >> 2;
    local_8 = ppcVar10;
    if (uVar9 != 0) {
      uVar6 = 0;
      do {
        pcVar4 = *local_8;
        local_14 = pcVar4 + 1;
        do {
          cVar1 = *pcVar4;
          pcVar4 = pcVar4 + 1;
        } while (cVar1 != '\0');
        local_c = pcVar4 + (int)(local_c + (1 - (int)local_14));
        local_8 = local_8 + 1;
        uVar6 = uVar6 + 1;
      } while (uVar6 != uVar9);
    }
    iVar8 = FUN_0040db90(local_10,local_c,1);
    if (iVar8 == 0) {
      iVar8 = -1;
      local_c = (char *)0xffffffff;
    }
    else {
      local_10 = (char *)(iVar8 + (int)local_10 * 4);
      local_1c = (char **)local_10;
      local_8 = ppcVar10;
      if (ppcVar10 != local_28) {
        local_20 = iVar8 - (int)ppcVar10;
        do {
          local_18 = *local_8;
          local_14 = local_18;
          do {
            cVar1 = *local_14;
            local_14 = local_14 + 1;
          } while (cVar1 != '\0');
          local_14 = local_14 + (1 - (int)(local_18 + 1));
          iVar5 = FUN_0041404e(local_10,local_c + ((int)local_1c - (int)local_10),local_18,local_14)
          ;
          if (iVar5 != 0) {
            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
            pcVar2 = (code *)swi(3);
            iVar8 = (*pcVar2)();
            return iVar8;
          }
          *(char **)(local_20 + (int)local_8) = local_10;
          local_8 = local_8 + 1;
          local_10 = local_10 + (int)local_14;
        } while (local_8 != local_28);
      }
      local_c = (char *)0x0;
      *param_2 = iVar8;
      iVar8 = 0;
    }
    FID_conflict__free((void *)0x0);
LAB_0041016a:
    uVar9 = ~-(uint)(local_28 < ppcVar10) & (uint)((int)local_28 + (3 - (int)ppcVar10)) >> 2;
    _Memory = ppcVar10;
    local_20 = uVar9;
    local_1c = ppcVar10;
    if (uVar9 != 0) {
      do {
        FID_conflict__free(*ppcVar10);
        uVar7 = uVar7 + 1;
        ppcVar10 = ppcVar10 + 1;
        iVar8 = (int)local_c;
        _Memory = local_2c;
      } while (uVar7 != uVar9);
    }
    FID_conflict__free(_Memory);
  }
  return iVar8;
}



int FUN_004101bc(char *param_1,undefined4 param_2,uint param_3,int param_4)

{
  char cVar1;
  code *pcVar2;
  int iVar3;
  void *_Memory;
  char *pcVar4;
  char *pcVar5;
  
  pcVar4 = param_1;
  do {
    cVar1 = *pcVar4;
    pcVar4 = pcVar4 + 1;
  } while (cVar1 != '\0');
  pcVar4 = pcVar4 + (1 - (int)(param_1 + 1));
  if ((char *)~param_3 < pcVar4) {
    iVar3 = 0xc;
  }
  else {
    pcVar5 = pcVar4 + param_3 + 1;
    _Memory = (void *)__calloc_base(pcVar5,1);
    if (param_3 != 0) {
      iVar3 = FUN_0041404e(_Memory,pcVar5,param_2,param_3);
      if (iVar3 != 0) goto LAB_00410262;
    }
    iVar3 = FUN_0041404e((int)_Memory + param_3,(int)pcVar5 - param_3,param_1,pcVar4);
    if (iVar3 != 0) {
LAB_00410262:
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar2 = (code *)swi(3);
      iVar3 = (*pcVar2)();
      return iVar3;
    }
    iVar3 = expand_if_necessary();
    if (iVar3 == 0) {
      **(void ***)(param_4 + 4) = _Memory;
      iVar3 = 0;
      *(int *)(param_4 + 4) = *(int *)(param_4 + 4) + 4;
    }
    else {
      FID_conflict__free(_Memory);
    }
    FID_conflict__free((void *)0x0);
  }
  return iVar3;
}



void FUN_0041026f(char *param_1,char *param_2,int *param_3)

{
  char cVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  undefined local_148 [44];
  char local_11c;
  char local_11b;
  char local_11a;
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  for (; (((param_2 != param_1 && (cVar1 = *param_2, cVar1 != '/')) && (cVar1 != '\\')) &&
         (cVar1 != ':')); param_2 = (char *)FUN_00414099(param_1,param_2)) {
  }
  cVar1 = *param_2;
  if ((cVar1 == ':') && (param_2 != param_1 + 1)) {
    FUN_004101bc(param_1,0,0,param_3);
  }
  else {
    if ((cVar1 == '/') || ((cVar1 == '\\' || (bVar2 = 0, cVar1 == ':')))) {
      bVar2 = 1;
    }
    _memset(local_148,0,0x140);
    iVar3 = (*(code *)0x50f8458d)(param_1,0,local_148,0,0,0);
    if (iVar3 == -1) {
      FUN_004101bc(param_1,0,0,param_3);
    }
    else {
      iVar5 = param_3[1] - *param_3 >> 2;
      do {
        if (((local_11c != '.') ||
            ((local_11b != '\0' && ((local_11b != '.' || (local_11a != '\0')))))) &&
           (iVar4 = FUN_004101bc(&local_11c,param_1,
                                 -(uint)bVar2 & (uint)(param_2 + (1 - (int)param_1)),param_3),
           iVar4 != 0)) goto LAB_0041033c;
        iVar4 = (*(code *)0x50e8458d)(iVar3,local_148);
      } while (iVar4 != 0);
      iVar4 = param_3[1] - *param_3 >> 2;
      if (iVar5 != iVar4) {
        FUN_00413b59(*param_3 + iVar5 * 4,iVar4 - iVar5,4,&LAB_00405b6b);
      }
    }
LAB_0041033c:
    if (iVar3 != -1) {
      (*(code *)0xf44589f8)(iVar3);
    }
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall expand_if_necessary(int *param_1)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  
  if (param_1[1] == param_1[2]) {
    if (*param_1 == 0) {
      iVar2 = __calloc_base(4,4);
      *param_1 = iVar2;
      FID_conflict__free((void *)0x0);
      iVar2 = *param_1;
      if (iVar2 != 0) {
        param_1[1] = iVar2;
        param_1[2] = iVar2 + 0x10;
        goto LAB_004103fd;
      }
    }
    else {
      uVar3 = param_1[2] - *param_1 >> 2;
      if (uVar3 < 0x80000000) {
        iVar2 = FUN_0041234e(*param_1,uVar3 * 2,4);
        if (iVar2 == 0) {
          uVar1 = 0xc;
        }
        else {
          *param_1 = iVar2;
          param_1[1] = iVar2 + uVar3 * 4;
          param_1[2] = iVar2 + uVar3 * 8;
          uVar1 = 0;
        }
        FID_conflict__free((void *)0x0);
        return uVar1;
      }
    }
    uVar1 = 0xc;
  }
  else {
LAB_004103fd:
    uVar1 = 0;
  }
  return uVar1;
}



void FUN_00410476(void)

{
  FUN_0040ffdc();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_ceb1ee4838e85a9d631eb091e2fbe199>,class <lambda_ae742caa10f662c28703da3d2ea5e57e>&,class
// <lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>>(class
// <lambda_ceb1ee4838e85a9d631eb091e2fbe199>&&,class
// <lambda_ae742caa10f662c28703da3d2ea5e57e>&,class <lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_ceb1ee4838e85a9d631eb091e2fbe199__class__lambda_ae742caa10f662c28703da3d2ea5e57e___class__lambda_cd08b5d6af4937fe54fc07d0c9bf6b37___
          (__crt_seh_guarded_call_void_ *this,_lambda_ceb1ee4838e85a9d631eb091e2fbe199_ *param_1,
          _lambda_ae742caa10f662c28703da3d2ea5e57e_ *param_2,
          _lambda_cd08b5d6af4937fe54fc07d0c9bf6b37_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  <lambda_ae742caa10f662c28703da3d2ea5e57e>::operator__(param_2);
  FUN_004104b8();
  return;
}



void FUN_004104b8(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  public: void __thiscall <lambda_ae742caa10f662c28703da3d2ea5e57e>::operator()(void)const 
// 
// Library: Visual Studio 2017 Release

void __thiscall
<lambda_ae742caa10f662c28703da3d2ea5e57e>::operator__
          (_lambda_ae742caa10f662c28703da3d2ea5e57e_ *this)

{
  int iVar1;
  
  _memcpy_s((void *)0x80293a5c,0x101,(void *)(*(int *)(**(int **)this + 0x48) + 0x18),0x101);
  _memcpy_s((void *)0x57402fb,0x100,(void *)(*(int *)(**(int **)this + 0x48) + 0x119),0x100);
  LOCK();
  iVar1 = **(int **)**(undefined4 **)(this + 4) + -1;
  **(int **)**(undefined4 **)(this + 4) = iVar1;
  if ((iVar1 == 0) && (*(void **)**(undefined4 **)(this + 4) != (void *)0x414360)) {
    FID_conflict__free(*(void **)**(undefined4 **)(this + 4));
  }
  *(undefined4 *)**(undefined4 **)(this + 4) = *(undefined4 *)(**(int **)this + 0x48);
  LOCK();
  **(int **)(**(int **)this + 0x48) = **(int **)(**(int **)this + 0x48) + 1;
  return;
}



// Library Function - Single Match
//  wchar_t const * __cdecl CPtoLocaleName(int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

wchar_t * __cdecl CPtoLocaleName(int param_1)

{
  if (param_1 == 0x3a4) {
    return (wchar_t *)0x8d89ffff;
  }
  if (param_1 == 0x3a8) {
    return (wchar_t *)0xfffffddc;
  }
  if (param_1 == 0x3b5) {
    return (wchar_t *)0xfdd89589;
  }
  if (param_1 != 0x3b6) {
    return (wchar_t *)0x0;
  }
  return (wchar_t *)0x9d89ffff;
}



// Library Function - Single Match
//  int __cdecl getSystemCP(int)
// 
// Library: Visual Studio 2017 Release

int __cdecl getSystemCP(int param_1)

{
  int local_14;
  int local_10;
  char local_8;
  
  FUN_0040eb24(0);
                    // WARNING: Read-only address (ram,0x00414d08) is written
  uRam00414d08 = 0;
  if (param_1 == -2) {
                    // WARNING: Read-only address (ram,0x00414d08) is written
    uRam00414d08 = 1;
    param_1 = (*(code *)0xfffe7be8)();
  }
  else if (param_1 == -3) {
                    // WARNING: Read-only address (ram,0x00414d08) is written
    uRam00414d08 = 1;
    param_1 = (*(code *)0x458d5900)();
  }
  else if (param_1 == -4) {
                    // WARNING: Read-only address (ram,0x00414d08) is written
    uRam00414d08 = 1;
    param_1 = *(int *)(local_10 + 8);
  }
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return param_1;
}



// Library Function - Single Match
//  void __cdecl setSBCS(struct __crt_multibyte_data *)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl setSBCS(__crt_multibyte_data *param_1)

{
  int iVar1;
  __crt_multibyte_data *p_Var2;
  
  p_Var2 = param_1 + 0x18;
  _memset(p_Var2,0,0x101);
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  *(undefined4 *)(param_1 + 0x21c) = 0;
  iVar1 = 0x101;
  *(undefined4 *)(param_1 + 0xc) = 0;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  do {
    *p_Var2 = p_Var2[0x414360 - (int)param_1];
    p_Var2 = p_Var2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  p_Var2 = param_1 + 0x119;
  iVar1 = 0x100;
  do {
    *p_Var2 = p_Var2[0x414360 - (int)param_1];
    p_Var2 = p_Var2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return;
}



// Library Function - Single Match
//  void __cdecl setSBUpLow(struct __crt_multibyte_data *)
// 
// Library: Visual Studio 2015 Release

void __cdecl setSBUpLow(__crt_multibyte_data *param_1)

{
  byte bVar1;
  __crt_multibyte_data _Var2;
  int iVar3;
  uint uVar4;
  byte *pbVar5;
  __crt_multibyte_data *p_Var6;
  undefined local_71c [6];
  byte local_716;
  byte local_715 [13];
  ushort local_708 [512];
  __crt_multibyte_data local_308 [256];
  __crt_multibyte_data local_208 [256];
  undefined local_108 [256];
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  iVar3 = (*(code *)0x107d83ff)(*(undefined4 *)(param_1 + 4),local_71c);
  if (iVar3 == 0) {
    uVar4 = 0;
    do {
      p_Var6 = param_1 + uVar4 + 0x119;
      if (p_Var6 + (-0x61 - (int)(param_1 + 0x119)) + 0x20 < (__crt_multibyte_data *)0x1a) {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = (__crt_multibyte_data)((char)uVar4 + ' ');
LAB_004107c9:
        *p_Var6 = _Var2;
      }
      else {
        if (p_Var6 + (-0x61 - (int)(param_1 + 0x119)) < (__crt_multibyte_data *)0x1a) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = (__crt_multibyte_data)((char)uVar4 + -0x20);
          goto LAB_004107c9;
        }
        *p_Var6 = (__crt_multibyte_data)0x0;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  else {
    uVar4 = 0;
    do {
      local_108[uVar4] = (char)uVar4;
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
    pbVar5 = &local_716;
    local_108[0] = 0x20;
    while (local_716 != 0) {
      bVar1 = pbVar5[1];
      for (uVar4 = (uint)local_716; (uVar4 <= bVar1 && (uVar4 < 0x100)); uVar4 = uVar4 + 1) {
        local_108[uVar4] = 0x20;
      }
      pbVar5 = pbVar5 + 2;
      local_716 = *pbVar5;
    }
    FUN_004118f7(0,1,local_108,0x100,local_708,*(undefined4 *)(param_1 + 4),0);
    ___acrt_LCMapStringA
              (0,*(undefined4 *)(param_1 + 0x21c),0x100,local_108,0x100,local_208,0x100,
               *(undefined4 *)(param_1 + 4),0);
    ___acrt_LCMapStringA
              (0,*(undefined4 *)(param_1 + 0x21c),0x200,local_108,0x100,local_308,0x100,
               *(undefined4 *)(param_1 + 4),0);
    uVar4 = 0;
    do {
      if ((local_708[uVar4] & 1) == 0) {
        if ((local_708[uVar4] & 2) != 0) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = local_308[uVar4];
          goto LAB_00410770;
        }
        param_1[uVar4 + 0x119] = (__crt_multibyte_data)0x0;
      }
      else {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = local_208[uVar4];
LAB_00410770:
        param_1[uVar4 + 0x119] = _Var2;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  int __cdecl setmbcp_internal(int,bool,struct __acrt_ptd * const,struct __crt_multibyte_data * *
// const)
// 
// Library: Visual Studio 2017 Release

int __cdecl
setmbcp_internal(int param_1,bool param_2,__acrt_ptd *param_3,__crt_multibyte_data **param_4)

{
  int *piVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int iVar5;
  undefined4 *puVar6;
  __acrt_ptd **local_18;
  __crt_multibyte_data ***local_14;
  int local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  FUN_0041090c(param_3,param_4);
  local_10 = getSystemCP(param_1);
  if (local_10 == *(int *)(*(int *)(param_3 + 0x48) + 4)) {
    return 0;
  }
  puVar3 = (undefined4 *)__malloc_base(0x220);
  if (puVar3 != (undefined4 *)0x0) {
    puVar4 = *(undefined4 **)(param_3 + 0x48);
    puVar6 = puVar3;
    for (iVar5 = 0x88; iVar5 != 0; iVar5 = iVar5 + -1) {
      *puVar6 = *puVar4;
      puVar4 = puVar4 + 1;
      puVar6 = puVar6 + 1;
    }
    *puVar3 = 0;
    iVar5 = FUN_004109fa(local_10,puVar3);
    if (iVar5 != -1) {
      if (param_2 == false) {
        ___acrt_set_locale_changed();
      }
      piVar1 = *(int **)(param_3 + 0x48);
      LOCK();
      iVar2 = *piVar1;
      *piVar1 = *piVar1 + -1;
      if ((iVar2 == 1) && (*(int *)(param_3 + 0x48) != 0x414360)) {
        FID_conflict__free(*(void **)(param_3 + 0x48));
      }
      *puVar3 = 1;
      puVar4 = (undefined4 *)0x0;
      *(undefined4 **)(param_3 + 0x48) = puVar3;
      if (((byte)param_3[0x350] & 2) == 0) {
        local_18 = &param_3;
        local_14 = &param_4;
        local_10 = 5;
        local_c = 5;
        __crt_seh_guarded_call<void>::
        operator___class__lambda_ceb1ee4838e85a9d631eb091e2fbe199__class__lambda_ae742caa10f662c28703da3d2ea5e57e___class__lambda_cd08b5d6af4937fe54fc07d0c9bf6b37___
                  (&local_5,(_lambda_ceb1ee4838e85a9d631eb091e2fbe199_ *)&local_c,
                   (_lambda_ae742caa10f662c28703da3d2ea5e57e_ *)&local_18,
                   (_lambda_cd08b5d6af4937fe54fc07d0c9bf6b37_ *)&local_10);
        if (param_2 != false) {
          p_Ram0041463c = *param_4;
                    // WARNING: Read-only address (ram,0x0041463c) is written
        }
      }
      goto LAB_00410868;
    }
    puVar4 = (undefined4 *)FUN_0040ef03();
    *puVar4 = 0x16;
  }
  iVar5 = -1;
  puVar4 = puVar3;
LAB_00410868:
  FID_conflict__free(puVar4);
                    // WARNING: Read-only address (ram,0x0041463c) is written
  return iVar5;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

int * FUN_0041090c(int param_1,int **param_2)

{
  int iVar1;
  int *_Memory;
  
  if ((*(uint *)(param_1 + 0x350) & 0xe83eeb50) == 0) goto LAB_0041093e;
  if (*(int *)(param_1 + 0x4c) == 0) goto LAB_0041093e;
  _Memory = *(int **)(param_1 + 0x48);
  while (_Memory == (int *)0x0) {
    _abort();
LAB_0041093e:
    ___acrt_lock(5);
    _Memory = *(int **)(param_1 + 0x48);
    if (_Memory != *param_2) {
      if (_Memory != (int *)0x0) {
        LOCK();
        iVar1 = *_Memory;
        *_Memory = iVar1 + -1;
        if ((iVar1 + -1 == 0) && (_Memory != (int *)0x414360)) {
          FID_conflict__free(_Memory);
        }
      }
      _Memory = *param_2;
      *(int **)(param_1 + 0x48) = _Memory;
      LOCK();
      *_Memory = *_Memory + 1;
    }
    FUN_0041098e();
  }
  return _Memory;
}



void FUN_0041098e(void)

{
  ___acrt_unlock(5);
  return;
}



// WARNING: Removing unreachable block (ram,0x004109a8)
// Library Function - Single Match
//  ___acrt_initialize_multibyte
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_initialize_multibyte(void)

{
  return 1;
}



// Library Function - Single Match
//  ___acrt_update_thread_multibyte_data
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_update_thread_multibyte_data(void)

{
  undefined4 uVar1;
  
  uVar1 = FUN_0040fd7d(0x414d04);
  FUN_0041090c(uVar1);
  return;
}



void FUN_004109fa(int param_1,__crt_multibyte_data *param_2)

{
  byte bVar1;
  undefined2 uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  byte *pbVar6;
  __crt_multibyte_data *p_Var7;
  wchar_t *pwVar8;
  byte *pbVar9;
  undefined2 *puVar10;
  undefined2 *puVar11;
  uint uVar12;
  int local_20;
  int local_1c;
  byte local_16 [14];
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  uVar3 = getSystemCP(param_1);
  if (uVar3 != 0) {
    uVar12 = 0;
    uVar4 = 0;
    local_20 = 0;
LAB_00410a3b:
    if (*(uint *)(uVar4 + 0x414270) != uVar3) goto code_r0x00410a47;
    _memset(param_2 + 0x18,0,0x101);
    pbVar6 = (byte *)(local_20 * 0x30 + 0x414280);
    do {
      bVar1 = *pbVar6;
      pbVar9 = pbVar6;
      while ((bVar1 != 0 && (bVar1 = pbVar9[1], bVar1 != 0))) {
        for (uVar4 = (uint)*pbVar9; (uVar4 <= bVar1 && (uVar4 < 0x100)); uVar4 = uVar4 + 1) {
          param_2[uVar4 + 0x19] =
               (__crt_multibyte_data)((byte)param_2[uVar4 + 0x19] | *(byte *)(uVar12 + 0x414268));
          bVar1 = pbVar9[1];
        }
        pbVar9 = pbVar9 + 2;
        bVar1 = *pbVar9;
      }
      uVar12 = uVar12 + 1;
      pbVar6 = pbVar6 + 8;
    } while (uVar12 < 4);
    *(uint *)(param_2 + 4) = uVar3;
    *(undefined4 *)(param_2 + 8) = 1;
    pwVar8 = CPtoLocaleName(uVar3);
    *(wchar_t **)(param_2 + 0x21c) = pwVar8;
    puVar10 = (undefined2 *)(param_2 + 0xc);
    puVar11 = (undefined2 *)(local_20 * 0x30 + 0x414274);
    iVar5 = 6;
    do {
      uVar2 = *puVar11;
      puVar11 = puVar11 + 1;
      *puVar10 = uVar2;
      puVar10 = puVar10 + 1;
      iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    goto LAB_00410bda;
  }
  setSBCS(param_2);
LAB_00410be4:
  ___security_check_cookie_4();
  return;
code_r0x00410a47:
  local_20 = local_20 + 1;
  uVar4 = uVar4 + 0x30;
  if (0xef < uVar4) goto code_r0x00410a55;
  goto LAB_00410a3b;
code_r0x00410a55:
  if ((uVar3 != 65000) &&
     (((uVar3 != 0xfde9 || (iVar5 = (*(code *)0x458d5900)(), iVar5 == 0xfde9)) &&
      (iVar5 = (*(code *)0x50f4458d)(uVar3 & 0xffff), iVar5 != 0)))) {
    iVar5 = (*(code *)0x107d83ff)(uVar3,&local_1c);
    if (iVar5 == 0) {
      setSBCS(param_2);
    }
    else {
      _memset(param_2 + 0x18,0,0x101);
      *(uint *)(param_2 + 4) = uVar3;
      *(undefined4 *)(param_2 + 0x21c) = 0;
      if (local_1c == 2) {
        pbVar6 = local_16;
        while ((local_16[0] != 0 && (bVar1 = pbVar6[1], bVar1 != 0))) {
          for (uVar3 = (uint)*pbVar6; uVar3 <= bVar1; uVar3 = uVar3 + 1) {
            param_2[uVar3 + 0x19] = (__crt_multibyte_data)((byte)param_2[uVar3 + 0x19] | 4);
          }
          pbVar6 = pbVar6 + 2;
          local_16[0] = *pbVar6;
        }
        p_Var7 = param_2 + 0x1a;
        iVar5 = 0xfe;
        do {
          *p_Var7 = (__crt_multibyte_data)((byte)*p_Var7 | 8);
          p_Var7 = p_Var7 + 1;
          iVar5 = iVar5 + -1;
        } while (iVar5 != 0);
        pwVar8 = CPtoLocaleName(*(int *)(param_2 + 4));
        *(wchar_t **)(param_2 + 0x21c) = pwVar8;
        *(undefined4 *)(param_2 + 8) = 1;
      }
      else {
        *(undefined4 *)(param_2 + 8) = 0;
      }
      *(undefined4 *)(param_2 + 0xc) = 0;
      *(undefined4 *)(param_2 + 0x10) = 0;
      *(undefined4 *)(param_2 + 0x14) = 0;
LAB_00410bda:
      setSBUpLow(param_2);
    }
  }
  goto LAB_00410be4;
}



// Library Function - Single Match
//  _memcpy_s
// 
// Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

errno_t __cdecl _memcpy_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)

{
  errno_t eVar1;
  undefined4 *puVar2;
  errno_t *peVar3;
  
  if (_MaxCount == 0) {
    eVar1 = 0;
  }
  else if (_Dst == (void *)0x0) {
    puVar2 = (undefined4 *)FUN_0040ef03();
    eVar1 = 0x16;
    *puVar2 = 0x16;
    FUN_0040ee46();
  }
  else if ((_Src == (void *)0x0) || (_DstSize < _MaxCount)) {
    _memset(_Dst,0,_DstSize);
    if (_Src == (void *)0x0) {
      peVar3 = (errno_t *)FUN_0040ef03();
      eVar1 = 0x16;
    }
    else {
      if (_MaxCount <= _DstSize) {
        return 0x16;
      }
      peVar3 = (errno_t *)FUN_0040ef03();
      eVar1 = 0x22;
    }
    *peVar3 = eVar1;
    FUN_0040ee46();
  }
  else {
    FUN_0040c9c9(_Dst,_Src,_MaxCount);
    eVar1 = 0;
  }
  return eVar1;
}



// Library Function - Single Match
//  int __cdecl x_ismbbtype_l(struct __crt_locale_pointers *,unsigned int,int,int)
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release, Visual Studio 2017 Debug, Visual
// Studio 2017 Release

int __cdecl x_ismbbtype_l(__crt_locale_pointers *param_1,uint param_2,int param_3,int param_4)

{
  uint uVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  char local_8;
  
  FUN_0040eb24(param_1);
  if ((*(byte *)(local_c + 0x19 + (param_2 & 0xff)) & (byte)param_4) == 0) {
    iVar2 = 0;
    if (param_3 == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = (uint)*(ushort *)(*local_10 + (param_2 & 0xff) * 2) & param_3;
    }
    if (uVar1 == 0) goto LAB_00410cb7;
  }
  iVar2 = 1;
LAB_00410cb7:
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return iVar2;
}



// Library Function - Single Match
//  __ismbblead
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release, Visual Studio 2017 Debug, Visual
// Studio 2017 Release

int __cdecl __ismbblead(uint _C)

{
  int iVar1;
  
  iVar1 = x_ismbbtype_l((__crt_locale_pointers *)0x0,_C,0,4);
  return iVar1;
}



// Library Function - Single Match
//  wchar_t const * __cdecl find_end_of_double_null_terminated_sequence(wchar_t const * const)
// 
// Library: Visual Studio 2015 Release

wchar_t * __cdecl find_end_of_double_null_terminated_sequence(wchar_t *param_1)

{
  short sVar1;
  short *psVar2;
  
  sVar1 = *(short *)param_1;
  while (sVar1 != 0) {
    psVar2 = (short *)param_1;
    do {
      sVar1 = *psVar2;
      psVar2 = psVar2 + 1;
    } while (sVar1 != 0);
    param_1 = (wchar_t *)((int)param_1 + (((int)psVar2 - (int)((int)param_1 + 2) >> 1) + 1) * 2);
    sVar1 = *(short *)param_1;
  }
  return (wchar_t *)(short *)((int)param_1 + 2);
}



// Library Function - Single Match
//  ___dcrt_get_narrow_environment_from_os
// 
// Library: Visual Studio 2015 Release

void * ___dcrt_get_narrow_environment_from_os(void)

{
  wchar_t *pwVar1;
  wchar_t *pwVar2;
  int iVar3;
  void *_Memory;
  int iVar4;
  void *pvVar5;
  
  pwVar1 = (wchar_t *)(*(code *)0x8b047400)();
  if (pwVar1 != (wchar_t *)0x0) {
    pwVar2 = find_end_of_double_null_terminated_sequence(pwVar1);
    iVar4 = (int)pwVar2 - (int)pwVar1 >> 1;
    iVar3 = (*(code *)0x12750010)(0,0,pwVar1,iVar4,0,0,0,0);
    if (iVar3 != 0) {
      _Memory = (void *)__malloc_base(iVar3);
      if (_Memory == (void *)0x0) {
LAB_00410d7f:
        pvVar5 = (void *)0x0;
      }
      else {
        iVar3 = (*(code *)0x12750010)(0,0,pwVar1,iVar4,_Memory,iVar3,0,0);
        if (iVar3 == 0) goto LAB_00410d7f;
        pvVar5 = _Memory;
        _Memory = (void *)0x0;
      }
      FID_conflict__free(_Memory);
      goto LAB_00410d8c;
    }
  }
  pvVar5 = (void *)0x0;
LAB_00410d8c:
  if (pwVar1 != (wchar_t *)0x0) {
    (*(code *)0xffc35de5)(pwVar1);
  }
  return pvVar5;
}



// WARNING: Removing unreachable block (ram,0x00410df9)
// WARNING: Removing unreachable block (ram,0x00410dfe)
// WARNING: Removing unreachable block (ram,0x00410e06)
// WARNING: Removing unreachable block (ram,0x00410e13)
// WARNING: Removing unreachable block (ram,0x00410e1a)
// WARNING: Removing unreachable block (ram,0x00410e1f)
// WARNING: Removing unreachable block (ram,0x00410e26)
// WARNING: Removing unreachable block (ram,0x00410e49)
// WARNING: Removing unreachable block (ram,0x00410e51)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00410da0(char *param_1,int param_2)

{
  uint uVar1;
  char cVar2;
  char cVar3;
  code *pcVar4;
  undefined4 *puVar5;
  char *pcVar6;
  int iVar7;
  int iVar8;
  char *_Dst;
  errno_t eVar9;
  undefined4 uVar10;
  char *pcVar11;
  char *pcVar12;
  
  if (param_1 == (char *)0x0) {
    puVar5 = (undefined4 *)FUN_0040ef03();
    *puVar5 = 0x16;
    return 0xffffffff;
  }
  pcVar6 = _strchr(param_1,0x3d);
  pcVar12 = param_1;
  if ((pcVar6 == (char *)0x0) || (pcVar6 == param_1)) {
    puVar5 = (undefined4 *)FUN_0040ef03();
    *puVar5 = 0x16;
  }
  else {
    cVar2 = pcVar6[1];
    FUN_00411090();
    uVar10 = 0;
    iVar7 = find_in_environment_nolock_char_(param_1,(int)pcVar6 - (int)param_1);
    if ((-1 < iVar7) && (_DAT_8b104d8b != 0)) {
      FID_conflict__free(*(void **)(&DAT_8b104d8b + iVar7 * 4));
      if (cVar2 == '\0') {
        for (; *(int *)(&DAT_8b104d8b + iVar7 * 4) != 0; iVar7 = iVar7 + 1) {
          *(undefined4 *)(&DAT_8b104d8b + iVar7 * 4) = *(undefined4 *)(&DAT_8b104d8f + iVar7 * 4);
        }
        iVar8 = FUN_0041234e(&DAT_8b104d8b,iVar7,4);
        FID_conflict__free((void *)0x0);
        if (iVar8 != 0) {
LAB_00410f3c:
                    // WARNING: Read-only address (ram,0x00414ca0) is written
          iRam00414ca0 = iVar8;
        }
      }
      else {
        pcVar12 = (char *)0x0;
        *(char **)(&DAT_8b104d8b + iVar7 * 4) = param_1;
      }
      if (param_2 != 0) {
        pcVar11 = param_1;
        do {
          cVar3 = *pcVar11;
          pcVar11 = pcVar11 + 1;
        } while (cVar3 != '\0');
        _Dst = (char *)__calloc_base(pcVar11 + (2 - (int)(param_1 + 1)),1);
        if (_Dst != (char *)0x0) {
          eVar9 = _strcpy_s(_Dst,(rsize_t)(pcVar11 + (2 - (int)(param_1 + 1))),param_1);
          if (eVar9 != 0) {
            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
            pcVar4 = (code *)swi(3);
            uVar10 = (*pcVar4)();
            return uVar10;
          }
          (pcVar6 + (int)(_Dst + (1 - (int)param_1)))[-1] = '\0';
          iVar7 = (*(code *)0x1e80875)
                            (_Dst,-(uint)(cVar2 != '\0') &
                                  (uint)(pcVar6 + (int)(_Dst + (1 - (int)param_1))));
          if (iVar7 == 0) {
            puVar5 = (undefined4 *)FUN_0040ef03();
            uVar10 = 0xffffffff;
            *puVar5 = 0x2a;
          }
        }
        FID_conflict__free(_Dst);
      }
      goto LAB_00410fc4;
    }
    if (cVar2 == '\0') goto LAB_00410fc4;
    uVar1 = -iVar7 + 2;
    if (((uint)-iVar7 <= uVar1) && (uVar1 < 0x3fffffff)) {
      iVar8 = FUN_0041234e(&DAT_8b104d8b,uVar1,4);
      FID_conflict__free((void *)0x0);
      if (iVar8 != 0) {
        *(char **)(iVar8 + iVar7 * -4) = param_1;
        *(undefined4 *)(iVar8 + 4 + iVar7 * -4) = 0;
        pcVar12 = (char *)0x0;
        goto LAB_00410f3c;
      }
    }
  }
  uVar10 = 0xffffffff;
LAB_00410fc4:
  FID_conflict__free(pcVar12);
                    // WARNING: Read-only address (ram,0x00414ca0) is written
  return uVar10;
}



// Library Function - Single Match
//  char * * __cdecl copy_environment<char>(char * * const)
// 
// Library: Visual Studio 2015 Release

char ** __cdecl copy_environment_char_(char **param_1)

{
  char cVar1;
  char *pcVar2;
  code *pcVar3;
  char **ppcVar4;
  undefined4 uVar5;
  errno_t eVar6;
  int iVar7;
  char *pcVar8;
  
  if (param_1 == (char **)0x0) {
    ppcVar4 = (char **)0x0;
  }
  else {
    iVar7 = 0;
    pcVar2 = *param_1;
    ppcVar4 = param_1;
    while (pcVar2 != (char *)0x0) {
      ppcVar4 = ppcVar4 + 1;
      iVar7 = iVar7 + 1;
      pcVar2 = *ppcVar4;
    }
    ppcVar4 = (char **)__calloc_base(iVar7 + 1,4);
    if (ppcVar4 == (char **)0x0) {
LAB_0041107e:
      _abort();
LAB_00411083:
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar3 = (code *)swi(3);
      ppcVar4 = (char **)(*pcVar3)();
      return ppcVar4;
    }
    if (*param_1 != (char *)0x0) {
      iVar7 = (int)ppcVar4 - (int)param_1;
      do {
        pcVar8 = *param_1;
        pcVar2 = pcVar8 + 1;
        do {
          cVar1 = *pcVar8;
          pcVar8 = pcVar8 + 1;
        } while (cVar1 != '\0');
        uVar5 = __calloc_base(pcVar8 + (1 - (int)pcVar2),1);
        *(undefined4 *)(iVar7 + (int)param_1) = uVar5;
        FID_conflict__free((void *)0x0);
        if (*(int *)(iVar7 + (int)param_1) == 0) goto LAB_0041107e;
        eVar6 = _strcpy_s(*(char **)(iVar7 + (int)param_1),(rsize_t)(pcVar8 + (1 - (int)pcVar2)),
                          *param_1);
        if (eVar6 != 0) goto LAB_00411083;
        param_1 = param_1 + 1;
      } while (*param_1 != (char *)0x0);
    }
    FID_conflict__free((void *)0x0);
  }
  return ppcVar4;
}



// WARNING: Removing unreachable block (ram,0x0041109d)

void FUN_00411090(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  int __cdecl find_in_environment_nolock<char>(char const * const,unsigned int)
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

int __cdecl find_in_environment_nolock_char_(char *param_1,uint param_2)

{
  int iVar1;
  char **ppcVar2;
  
  ppcVar2 = (char **)&DAT_8b104d8b;
  if (_DAT_8b104d8b != 0) {
    do {
      iVar1 = __strnicoll(param_1,*ppcVar2,param_2);
      if ((iVar1 == 0) && (((*ppcVar2)[param_2] == '=' || ((*ppcVar2)[param_2] == '\0')))) {
        return (int)((int)ppcVar2 + 0x74efb275) >> 2;
      }
      ppcVar2 = ppcVar2 + 1;
    } while (*ppcVar2 != (char *)0x0);
  }
  return -((int)((int)ppcVar2 + 0x74efb275) >> 2);
}



void FUN_004110fe(void)

{
  FUN_00410da0();
  return;
}



// Library Function - Single Match
//  ___acrt_lock
// 
// Library: Visual Studio 2017 Release

void ___acrt_lock(int param_1)

{
  (*(code *)0x100c608)(param_1 * 0x18 + 0x414d10);
  return;
}



// Library Function - Single Match
//  ___acrt_unlock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_unlock(int param_1)

{
  (*(code *)0x9509e8)(param_1 * 0x18 + 0x414d10);
  return;
}



// Library Function - Single Match
//  ___acrt_get_process_end_policy
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_get_process_end_policy(void)

{
  int in_FS_OFFSET;
  int local_8;
  
  local_8 = 0;
  if ((-1 < *(int *)(*(int *)(*(int *)(in_FS_OFFSET + 0x30) + 0x10) + 8)) &&
     (FUN_00411f5e(&local_8), local_8 == 1)) {
    return 0;
  }
  return 1;
}



// Library Function - Single Match
//  ___acrt_lowio_create_handle_array
// 
// Library: Visual Studio 2015 Release

undefined4 * ___acrt_lowio_create_handle_array(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  
  puVar2 = (undefined4 *)__calloc_base(0x40,0x30);
  if (puVar2 == (undefined4 *)0x0) {
    puVar2 = (undefined4 *)0x0;
  }
  else if (puVar2 != puVar2 + 0x300) {
    puVar3 = puVar2 + 8;
    do {
      ___acrt_InitializeCriticalSectionEx_12(puVar3 + -8,4000,0);
      puVar3[-2] = 0xffffffff;
      *puVar3 = 0;
      puVar3[1] = 0;
      puVar1 = puVar3 + 4;
      puVar3[2] = 0xa0a0000;
      *(undefined *)(puVar3 + 3) = 10;
      *(byte *)((int)puVar3 + 0xd) = *(byte *)((int)puVar3 + 0xd) & 0xf8;
      *(undefined *)((int)puVar3 + 0xe) = 0;
      puVar3 = puVar3 + 0xc;
    } while (puVar1 != puVar2 + 0x300);
  }
  FID_conflict__free((void *)0x0);
  return puVar2;
}



// Library Function - Single Match
//  ___acrt_lowio_destroy_handle_array
// 
// Library: Visual Studio 2015 Release

void ___acrt_lowio_destroy_handle_array(void *param_1)

{
  void *pvVar1;
  
  if (param_1 != (void *)0x0) {
    pvVar1 = param_1;
    if (param_1 != (void *)((int)param_1 + 0xc00)) {
      do {
        (*(code *)0x458bc300)(pvVar1);
        pvVar1 = (void *)((int)pvVar1 + 0x30);
      } while (pvVar1 != (void *)((int)param_1 + 0xc00));
    }
    FID_conflict__free(param_1);
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___acrt_lowio_ensure_fh_exists
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_lowio_ensure_fh_exists(uint param_1)

{
  undefined4 *puVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  
  if (param_1 < 0x2000) {
    uVar3 = 0;
    ___acrt_lock(7);
    iVar4 = 0;
    iVar2 = -0x74f3b275;
    while (iVar2 <= (int)param_1) {
      if (*(int *)(iVar4 * 4 + 0x414e68) == 0) {
        iVar2 = ___acrt_lowio_create_handle_array();
        *(int *)(iVar4 * 4 + 0x414e68) = iVar2;
        if (iVar2 == 0) {
          uVar3 = 0xc;
          break;
        }
        iVar2 = -0x74f3b235;
                    // WARNING: Read-only address (ram,0x00415068) is written
        uRam00415068 = 0x8b0c4dcb;
      }
      iVar4 = iVar4 + 1;
    }
    FUN_00411316();
  }
  else {
    puVar1 = (undefined4 *)FUN_0040ef03();
    uVar3 = 9;
    *puVar1 = 9;
    FUN_0040ee46();
  }
  return uVar3;
}



void FUN_00411316(void)

{
  ___acrt_unlock(7);
  return;
}



// Library Function - Single Match
//  ___acrt_lowio_lock_fh
// 
// Library: Visual Studio 2017 Release

void ___acrt_lowio_lock_fh(uint param_1)

{
  (*(code *)0x100c608)((param_1 & 0x3f) * 0x30 + *(int *)(((int)param_1 >> 6) * 4 + 0x414e68));
  return;
}



// Library Function - Single Match
//  ___acrt_lowio_unlock_fh
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_lowio_unlock_fh(uint param_1)

{
  (*(code *)0x9509e8)((param_1 & 0x3f) * 0x30 + *(int *)(((int)param_1 >> 6) * 4 + 0x414e68));
  return;
}



// Library Function - Single Match
//  __free_osfhnd
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __free_osfhnd(int param_1)

{
  int iVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 uVar4;
  
  if ((-1 < param_1) && ((uint)param_1 < 0x8b0c4d8b)) {
    iVar3 = (param_1 & 0x3fU) * 0x30;
    iVar1 = *(int *)((param_1 >> 6) * 4 + 0x414e68);
    if (((*(byte *)(iVar3 + 0x28 + iVar1) & 1) != 0) && (*(int *)(iVar3 + 0x18 + iVar1) != -1)) {
      iVar1 = FUN_0040d82d();
      if (iVar1 == 1) {
        if (param_1 == 0) {
          uVar4 = 0xfffffff6;
        }
        else if (param_1 == 1) {
          uVar4 = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_004113cb;
          uVar4 = 0xfffffff4;
        }
        (*(code *)0xcc000000)(uVar4,0);
      }
LAB_004113cb:
      *(undefined4 *)(iVar3 + 0x18 + *(int *)((param_1 >> 6) * 4 + 0x414e68)) = 0xffffffff;
      return 0;
    }
  }
  puVar2 = (undefined4 *)FUN_0040ef03();
  *puVar2 = 9;
  puVar2 = (undefined4 *)FUN_0040eef0();
  *puVar2 = 0;
  return -1;
}



// Library Function - Single Match
//  __get_osfhandle
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

intptr_t __cdecl __get_osfhandle(int _FileHandle)

{
  int iVar1;
  undefined4 *puVar2;
  int iVar3;
  
  if (_FileHandle == -2) {
    puVar2 = (undefined4 *)FUN_0040eef0();
    *puVar2 = 0;
    puVar2 = (undefined4 *)FUN_0040ef03();
    *puVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < 0x8b0c4d8b)) {
      iVar3 = (_FileHandle & 0x3fU) * 0x30;
      iVar1 = *(int *)((_FileHandle >> 6) * 4 + 0x414e68);
      if ((*(byte *)(iVar1 + 0x28 + iVar3) & 1) != 0) {
        return *(intptr_t *)(iVar1 + 0x18 + iVar3);
      }
    }
    puVar2 = (undefined4 *)FUN_0040eef0();
    *puVar2 = 0;
    puVar2 = (undefined4 *)FUN_0040ef03();
    *puVar2 = 9;
    FUN_0040ee46();
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl initialize_inherited_file_handles_nolock(void)
// 
// Library: Visual Studio 2017 Release

void __cdecl initialize_inherited_file_handles_nolock(void)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  undefined local_4c [50];
  short local_1a;
  uint *local_18;
  int *local_8;
  
  (*(code *)0x5959ffff)(local_4c);
  if ((local_1a != 0) && (local_18 != (uint *)0x0)) {
    uVar3 = *local_18;
    local_8 = (int *)((int)local_18 + uVar3 + 4);
    if (0x1fff < (int)uVar3) {
      uVar3 = 0x2000;
    }
    ___acrt_lowio_ensure_fh_exists(uVar3);
    if (-0x74f3b275 < (int)uVar3) {
      uVar3 = 0x8b0c4d8b;
    }
    uVar4 = 0;
    if (uVar3 != 0) {
      do {
        iVar2 = *local_8;
        if ((((iVar2 != -1) && (iVar2 != -2)) &&
            (bVar1 = *(byte *)(uVar4 + 4 + (int)local_18), (bVar1 & 1) != 0)) &&
           (((bVar1 & 8) != 0 || (iVar2 = (*_exit_or_terminate_process)(iVar2), iVar2 != 0)))) {
          iVar2 = (uVar4 & 0x3f) * 0x30 + *(int *)(((int)uVar4 >> 6) * 4 + 0x414e68);
          *(int *)(iVar2 + 0x18) = *local_8;
          *(undefined *)(iVar2 + 0x28) = *(undefined *)(uVar4 + 4 + (int)local_18);
        }
        uVar4 = uVar4 + 1;
        local_8 = local_8 + 1;
      } while (uVar4 != uVar3);
    }
  }
  return;
}



// Library Function - Single Match
//  ___pctype_func
// 
// Library: Visual Studio 2015 Release

ushort * __cdecl ___pctype_func(void)

{
  int iVar1;
  ushort **local_8;
  
  iVar1 = FUN_0040fd7d();
  local_8 = *(ushort ***)(iVar1 + 0x4c);
  ___acrt_update_locale_info(iVar1,&local_8);
  return *local_8;
}



// Library Function - Single Match
//  ___acrt_locale_free_monetary
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_locale_free_monetary(int param_1)

{
  if (param_1 != 0) {
    if (*(void **)(param_1 + 0xc) != (void *)0x3bc78b08) {
      FID_conflict__free(*(void **)(param_1 + 0xc));
    }
    if (*(void **)(param_1 + 0x10) != (void *)0x830fd845) {
      FID_conflict__free(*(void **)(param_1 + 0x10));
    }
    if (*(void **)(param_1 + 0x14) != (void *)0x14e) {
      FID_conflict__free(*(void **)(param_1 + 0x14));
    }
    if (*(void **)(param_1 + 0x18) != (void *)0xe0458940) {
      FID_conflict__free(*(void **)(param_1 + 0x18));
    }
    if (*(void **)(param_1 + 0x1c) != (void *)0xc0332f8a) {
      FID_conflict__free(*(void **)(param_1 + 0x1c));
    }
    if (*(void **)(param_1 + 0x20) != (void *)0xe8458966) {
      FID_conflict__free(*(void **)(param_1 + 0x20));
    }
    if (*(void **)(param_1 + 0x24) != (void *)0x88cc458b) {
      FID_conflict__free(*(void **)(param_1 + 0x24));
    }
    if (*(void **)(param_1 + 0x38) != (void *)0x448a1974) {
      FID_conflict__free(*(void **)(param_1 + 0x38));
    }
    if (*(void **)(param_1 + 0x3c) != (void *)0xe1802e1a) {
      FID_conflict__free(*(void **)(param_1 + 0x3c));
    }
    if (*(void **)(param_1 + 0x40) != (void *)0xf44588fb) {
      FID_conflict__free(*(void **)(param_1 + 0x40));
    }
    if (*(void **)(param_1 + 0x44) != (void *)0x6af4458d) {
      FID_conflict__free(*(void **)(param_1 + 0x44));
    }
    if (*(void **)(param_1 + 0x48) != (void *)0xf56d8802) {
      FID_conflict__free(*(void **)(param_1 + 0x48));
    }
    if (*(void **)(param_1 + 0x4c) != (void *)0x2d1a4c88) {
      FID_conflict__free(*(void **)(param_1 + 0x4c));
    }
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_free_numeric
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_locale_free_numeric(void **param_1)

{
  if (param_1 != (void **)0x0) {
    if (*param_1 != (void *)0x33c84589) {
      FID_conflict__free(*param_1);
    }
    if (param_1[1] != (void *)0x890689c0) {
      FID_conflict__free(param_1[1]);
    }
    if (param_1[2] != (void *)0x46890446) {
      FID_conflict__free(param_1[2]);
    }
    if (param_1[0xc] != (void *)0x1a4c8a00) {
      FID_conflict__free(param_1[0xc]);
    }
    if (param_1[0xd] != (void *)0x4c1f62d) {
      FID_conflict__free(param_1[0xd]);
    }
  }
  return;
}



void FUN_004117db(void **param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  
  uVar2 = 0;
  uVar1 = ~-(uint)(param_1 + param_2 < param_1) & param_2 & 0x3fffffff;
  if (uVar1 != 0) {
    do {
      FID_conflict__free(*param_1);
      uVar2 = uVar2 + 1;
      param_1 = param_1 + 1;
    } while (uVar2 != uVar1);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_free_time
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_locale_free_time(int param_1)

{
  if (param_1 != 0) {
    FUN_004117db(param_1,7);
    FUN_004117db(param_1 + 0x1c,7);
    FUN_004117db(param_1 + 0x38,0xc);
    FUN_004117db(param_1 + 0x68,0xc);
    FUN_004117db(param_1 + 0x98,2);
    FID_conflict__free(*(void **)(param_1 + 0xa0));
    FID_conflict__free(*(void **)(param_1 + 0xa4));
    FID_conflict__free(*(void **)(param_1 + 0xa8));
    FUN_004117db(param_1 + 0xb4,7);
    FUN_004117db(param_1 + 0xd0,7);
    FUN_004117db(param_1 + 0xec,0xc);
    FUN_004117db(param_1 + 0x11c,0xc);
    FUN_004117db(param_1 + 0x14c,2);
    FID_conflict__free(*(void **)(param_1 + 0x154));
    FID_conflict__free(*(void **)(param_1 + 0x158));
    FID_conflict__free(*(void **)(param_1 + 0x15c));
    FID_conflict__free(*(void **)(param_1 + 0x160));
  }
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_004118f7(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,int param_6,int param_7)

{
  uint _Size;
  int iVar1;
  uint uVar2;
  int *_Dst;
  int iStack68;
  int iStack64;
  undefined4 uStack60;
  undefined4 uStack56;
  undefined4 uStack52;
  undefined4 uStack48;
  int local_20;
  int local_1c;
  char local_14;
  
  uStack48 = param_1;
  uStack52 = 0x411917;
  FUN_0040eb24();
  if (param_6 == 0) {
    param_6 = *(int *)(local_1c + 8);
  }
  uStack48 = 0;
  uStack52 = 0;
  uStack56 = param_4;
  uStack60 = param_3;
  iStack64 = (uint)(param_7 != 0) * 8 + 1;
  iStack68 = param_6;
  iVar1 = (*common_exit)();
  if (iVar1 == 0) goto LAB_004119d5;
  _Size = iVar1 * 2;
  uVar2 = -(uint)(_Size < _Size + 8) & _Size + 8;
  if (uVar2 == 0) {
    _Dst = (undefined4 *)0x0;
  }
  else if (uVar2 < 0x401) {
    _Dst = &iStack68;
    if (&stack0x00000000 != (undefined *)0x44) {
      iStack68 = 0xcccc;
      _Dst = &iStack68;
LAB_0041198e:
      _Dst = _Dst + 2;
    }
  }
  else {
    _Dst = (int *)__malloc_base(uVar2);
    if (_Dst != (undefined4 *)0x0) {
      *_Dst = 0xdddd;
      goto LAB_0041198e;
    }
  }
  if (_Dst != (undefined4 *)0x0) {
    _memset(_Dst,0,_Size);
    iVar1 = (*common_exit)(param_6,1,param_3,param_4,_Dst,iVar1);
    if (iVar1 != 0) {
      (*exit_or_terminate_process)(param_2,_Dst,iVar1,param_5);
    }
  }
  FUN_004119fb(_Dst);
LAB_004119d5:
  if (local_14 != '\0') {
    *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
  }
  ___security_check_cookie_4();
  return;
}



void FUN_004119fb(int param_1)

{
  if ((param_1 != 0) && (*(int *)(param_1 + -8) == 0xdddd)) {
    FID_conflict__free((int *)(param_1 + -8));
  }
  return;
}



// Library Function - Single Match
//  ___acrt_add_locale_ref
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_add_locale_ref(int param_1)

{
  int *piVar1;
  int **ppiVar2;
  int iVar3;
  
  LOCK();
  *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + 1;
  piVar1 = *(int **)(param_1 + 0x7c);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x84);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x80);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x8c);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  ppiVar2 = (int **)(param_1 + 0x28);
  iVar3 = 6;
  do {
    if ((ppiVar2[-2] != (int *)0x414640) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    ppiVar2 = ppiVar2 + 4;
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  ___acrt_locale_add_lc_time_reference(*(undefined4 *)(param_1 + 0x9c));
  return;
}



// Library Function - Single Match
//  ___acrt_free_locale
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_free_locale(void *param_1)

{
  int *piVar1;
  void **ppvVar2;
  int **ppiVar3;
  int local_8;
  
  if ((((*(int *)((int)param_1 + 0x88) != 0) && (*(int *)((int)param_1 + 0x88) != 0x414650)) &&
      (*(int **)((int)param_1 + 0x7c) != (int *)0x0)) && (**(int **)((int)param_1 + 0x7c) == 0)) {
    piVar1 = *(int **)((int)param_1 + 0x84);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      ___acrt_locale_free_monetary(*(undefined4 *)((int)param_1 + 0x88));
    }
    piVar1 = *(int **)((int)param_1 + 0x80);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      ___acrt_locale_free_numeric(*(undefined4 *)((int)param_1 + 0x88));
    }
    FID_conflict__free(*(void **)((int)param_1 + 0x7c));
    FID_conflict__free(*(void **)((int)param_1 + 0x88));
  }
  if ((*(int **)((int)param_1 + 0x8c) != (int *)0x0) && (**(int **)((int)param_1 + 0x8c) == 0)) {
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x90) + -0xfe));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x94) + -0x80));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x98) + -0x80));
    FID_conflict__free(*(void **)((int)param_1 + 0x8c));
  }
  ___acrt_locale_free_lc_time_if_unreferenced(*(undefined4 *)((int)param_1 + 0x9c));
  ppvVar2 = (void **)((int)param_1 + 0xa0);
  local_8 = 6;
  ppiVar3 = (int **)((int)param_1 + 0x28);
  do {
    if (((ppiVar3[-2] != (int *)0x414640) && (piVar1 = *ppiVar3, piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      FID_conflict__free(*ppvVar2);
    }
    if (((ppiVar3[-3] != (int *)0x0) && (piVar1 = ppiVar3[-1], piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
    }
    ppvVar2 = ppvVar2 + 1;
    ppiVar3 = ppiVar3 + 4;
    local_8 = local_8 + -1;
  } while (local_8 != 0);
  FID_conflict__free(param_1);
  return;
}



// Library Function - Single Match
//  ___acrt_locale_add_lc_time_reference
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int ___acrt_locale_add_lc_time_reference(int param_1)

{
  int *piVar1;
  int iVar2;
  
  if ((param_1 != 0) && (param_1 != 0x40f688)) {
    LOCK();
    piVar1 = (int *)(param_1 + 0xb0);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + 1;
    return iVar2 + 1;
  }
  return 0x7fffffff;
}



// Library Function - Single Match
//  ___acrt_locale_free_lc_time_if_unreferenced
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_locale_free_lc_time_if_unreferenced(void *param_1)

{
  if (((param_1 != (void *)0x0) && (param_1 != (void *)0x40f688)) &&
     (*(int *)((int)param_1 + 0xb0) == 0)) {
    ___acrt_locale_free_time(param_1);
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_release_lc_time_reference
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int ___acrt_locale_release_lc_time_reference(int param_1)

{
  int *piVar1;
  int iVar2;
  
  if ((param_1 != 0) && (param_1 != 0x40f688)) {
    LOCK();
    piVar1 = (int *)(param_1 + 0xb0);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + -1;
    return iVar2 + -1;
  }
  return 0x7fffffff;
}



// Library Function - Single Match
//  ___acrt_release_locale_ref
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_release_locale_ref(int param_1)

{
  int *piVar1;
  int **ppiVar2;
  int iVar3;
  
  if (param_1 != 0) {
    LOCK();
    *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + -1;
    piVar1 = *(int **)(param_1 + 0x7c);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x84);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x80);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x8c);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    ppiVar2 = (int **)(param_1 + 0x28);
    iVar3 = 6;
    do {
      if ((ppiVar2[-2] != (int *)0x414640) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      ppiVar2 = ppiVar2 + 4;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    ___acrt_locale_release_lc_time_reference(*(undefined4 *)(param_1 + 0x9c));
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___acrt_update_thread_locale_data
// 
// Library: Visual Studio 2015 Release

int ___acrt_update_thread_locale_data(void)

{
  int iVar1;
  int iVar2;
  
  iVar1 = FUN_0040fd7d();
  if (((*(uint *)(iVar1 + 0x350) & 0xe83eeb50) == 0) || (iVar2 = *(int *)(iVar1 + 0x4c), iVar2 == 0)
     ) {
    ___acrt_lock(4);
    iVar2 = __updatetlocinfoEx_nolock(iVar1 + 0x4c,0xd1f70845);
    FUN_00411d4b();
    if (iVar2 == 0) {
      _abort();
      iVar1 = ___acrt_unlock(4);
      return iVar1;
    }
  }
  return iVar2;
}



void FUN_00411d4b(void)

{
  ___acrt_unlock(4);
  return;
}



// Library Function - Single Match
//  __updatetlocinfoEx_nolock
// 
// Library: Visual Studio 2015 Release

int __updatetlocinfoEx_nolock(int *param_1,int param_2)

{
  int iVar1;
  
  if ((param_2 == 0) || (param_1 == (int *)0x0)) {
    param_2 = 0;
  }
  else {
    iVar1 = *param_1;
    if (iVar1 != param_2) {
      *param_1 = param_2;
      ___acrt_add_locale_ref(param_2);
      if (((iVar1 != 0) && (___acrt_release_locale_ref(iVar1), *(int *)(iVar1 + 0xc) == 0)) &&
         (iVar1 != 0x414580)) {
        ___acrt_free_locale(iVar1);
      }
    }
  }
  return param_2;
}



// Library Function - Multiple Matches With Different Base Names
//  int (__stdcall*__cdecl try_get_AreFileApisANSI(void))(void)
//  int (__stdcall*__cdecl try_get_CompareStringEx(void))(wchar_t const *,unsigned long,wchar_t
// const *,int,wchar_t const *,int,struct _nlsversioninfo *,void *,long)
//  int (__stdcall*__cdecl try_get_EnumSystemLocalesEx(void))(int (__stdcall*)(wchar_t *,unsigned
// long,long),unsigned long,long,void *)
//  int (__stdcall*__cdecl try_get_GetDateFormatEx(void))(wchar_t const *,unsigned long,struct
// _SYSTEMTIME const *,wchar_t const *,wchar_t *,int,wchar_t const *)
//   14 names - too many to list
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict_try_get_IsValidLocaleName(void)

{
  try_get_function(0,(char *)(destroy_ptd + 1),(module_id *)0x40fc60,(module_id *)(destroy_ptd + 1))
  ;
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  int (__stdcall*__cdecl try_get_AreFileApisANSI(void))(void)
//  int (__stdcall*__cdecl try_get_CompareStringEx(void))(wchar_t const *,unsigned long,wchar_t
// const *,int,wchar_t const *,int,struct _nlsversioninfo *,void *,long)
//  int (__stdcall*__cdecl try_get_EnumSystemLocalesEx(void))(int (__stdcall*)(wchar_t *,unsigned
// long,long),unsigned long,long,void *)
//  int (__stdcall*__cdecl try_get_GetDateFormatEx(void))(wchar_t const *,unsigned long,struct
// _SYSTEMTIME const *,wchar_t const *,wchar_t *,int,wchar_t const *)
//   14 names - too many to list
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict_try_get_IsValidLocaleName(void)

{
  try_get_function(1,(char *)0x40fc7c,(module_id *)0x40fc74,(module_id *)0x40fc7c);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  int (__stdcall*__cdecl try_get_AreFileApisANSI(void))(void)
//  int (__stdcall*__cdecl try_get_CompareStringEx(void))(wchar_t const *,unsigned long,wchar_t
// const *,int,wchar_t const *,int,struct _nlsversioninfo *,void *,long)
//  int (__stdcall*__cdecl try_get_EnumSystemLocalesEx(void))(int (__stdcall*)(wchar_t *,unsigned
// long,long),unsigned long,long,void *)
//  int (__stdcall*__cdecl try_get_GetDateFormatEx(void))(wchar_t const *,unsigned long,struct
// _SYSTEMTIME const *,wchar_t const *,wchar_t *,int,wchar_t const *)
//   14 names - too many to list
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict_try_get_IsValidLocaleName(void)

{
  try_get_function(0x14,(char *)0x40fcbc,(module_id *)0x40fcb4,(module_id *)0x40fcbc);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  int (__stdcall*__cdecl try_get_AreFileApisANSI(void))(void)
//  int (__stdcall*__cdecl try_get_CompareStringEx(void))(wchar_t const *,unsigned long,wchar_t
// const *,int,wchar_t const *,int,struct _nlsversioninfo *,void *,long)
//  int (__stdcall*__cdecl try_get_EnumSystemLocalesEx(void))(int (__stdcall*)(wchar_t *,unsigned
// long,long),unsigned long,long,void *)
//  int (__stdcall*__cdecl try_get_GetDateFormatEx(void))(wchar_t const *,unsigned long,struct
// _SYSTEMTIME const *,wchar_t const *,wchar_t *,int,wchar_t const *)
//   14 names - too many to list
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict_try_get_IsValidLocaleName(void)

{
  try_get_function(0x16,(char *)0x40fcd4,(module_id *)0x40fccc,(module_id *)0x40fcd4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  struct HINSTANCE__ * __cdecl try_get_first_available_module(enum `anonymous
// namespace'::module_id const * const,enum `anonymous namespace'::module_id const * const)
// 
// Library: Visual Studio 2017 Release

HINSTANCE__ * __cdecl try_get_first_available_module(module_id *param_1,module_id *param_2)

{
  HINSTANCE__ **ppHVar1;
  wchar_t *_Str1;
  HINSTANCE__ *pHVar2;
  HINSTANCE__ *pHVar3;
  int iVar4;
  
  do {
    if (param_1 == param_2) {
      return (HINSTANCE__ *)0x0;
    }
    ppHVar1 = (HINSTANCE__ **)(*param_1 * 4 + 0x415070);
    pHVar3 = *ppHVar1;
    if (pHVar3 == (HINSTANCE__ *)0x0) {
      _Str1 = *(wchar_t **)(*param_1 * 4 + 0x40f7f8);
      pHVar3 = (HINSTANCE__ *)(*FUN_0040e073)(_Str1,0,0x800);
      if (pHVar3 == (HINSTANCE__ *)0x0) {
        iVar4 = (*(code *)0x414cb805)();
        if (((iVar4 == 0x57) &&
            (iVar4 = _wcsncmp(_Str1,
                              L"崀诃嗿\xec8bjj痿\xe808﹢\xffff쒃崌诃嗿\xec8b䖋㴈䀀",7),
            iVar4 != 0)) &&
           (iVar4 = _wcsncmp(_Str1,L"﹢\xffff쒃崌诃嗿\xec8b䖋㴈䀀",7), iVar4 != 0)) {
          pHVar3 = (HINSTANCE__ *)(*FUN_0040e073)(_Str1,0,0);
        }
        else {
          pHVar3 = (HINSTANCE__ *)0x0;
        }
        if (pHVar3 == (HINSTANCE__ *)0x0) {
          *ppHVar1 = (HINSTANCE__ *)0xffffffff;
          goto LAB_00411ec3;
        }
      }
      pHVar2 = *ppHVar1;
      *ppHVar1 = pHVar3;
      if (pHVar2 != (HINSTANCE__ *)0x0) {
        (*(code *)0x8bcc0000)(pHVar3);
      }
LAB_00411ebf:
      if (pHVar3 != (HINSTANCE__ *)0x0) {
        return pHVar3;
      }
    }
    else if (pHVar3 != (HINSTANCE__ *)0xffffffff) goto LAB_00411ebf;
LAB_00411ec3:
    param_1 = param_1 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void * __cdecl try_get_function(enum `anonymous namespace'::function_id,char const * const,enum
// A0x391cf84c::module_id const * const,enum A0x391cf84c::module_id const * const)
// 
// Library: Visual Studio 2017 Release

void * __cdecl
try_get_function(function_id param_1,char *param_2,module_id *param_3,module_id *param_4)

{
  uint *puVar1;
  HINSTANCE__ *pHVar2;
  uint uVar3;
  void *pvVar4;
  
  puVar1 = (uint *)(param_1 * 4 + 0x4150c0);
  pvVar4 = (void *)((*puVar1 ^ 0x74c08447) >> 7 | (*puVar1 ^ 0x74c08447) << 0x19);
  if (pvVar4 == (void *)0xffffffff) {
    pvVar4 = (void *)0x0;
  }
  else if (pvVar4 == (void *)0x0) {
    pHVar2 = try_get_first_available_module(param_3,param_4);
    if ((pHVar2 == (HINSTANCE__ *)0x0) ||
       (pvVar4 = (void *)(*FUN_0040e073)(pHVar2,param_2), pvVar4 == (void *)0x0)) {
      *puVar1 = 0x8b3f7bb8;
      pvVar4 = (void *)0x0;
    }
    else {
      uVar3 = __crt_fast_encode_pointer__(pvVar4);
      *puVar1 = uVar3;
    }
  }
  return pvVar4;
}



void FUN_00411f5e(undefined4 param_1)

{
  uint uVar1;
  code *pcVar2;
  
  uVar1 = (uint)&stack0xfffffffc ^ 0x74c08447;
  pcVar2 = (code *)try_get_function(0x1c,(char *)0x40fcec,(module_id *)0x40fce8,
                                    (module_id *)0x40fcec);
  if (pcVar2 != (code *)0x0) {
    (*(code *)0xff0875ff)(0xfffffffa,param_1);
    (*pcVar2)();
  }
  ___security_check_cookie_4(uVar1);
  return;
}



void FUN_00411fb5(void)

{
  uint uVar1;
  code *pcVar2;
  
  uVar1 = (uint)&stack0xfffffffc ^ 0x74c08447;
  pcVar2 = (code *)FID_conflict_try_get_IsValidLocaleName();
  if (pcVar2 != (code *)0x0) {
    (*(code *)0xff0875ff)();
    (*pcVar2)();
  }
  ___security_check_cookie_4(uVar1);
  return;
}



// Library Function - Single Match
//  ___acrt_CompareStringEx@36
// 
// Library: Visual Studio 2015 Release

void ___acrt_CompareStringEx_36
               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
               undefined4 param_9)

{
  code *pcVar1;
  undefined4 uVar2;
  
  pcVar1 = (code *)FID_conflict_try_get_IsValidLocaleName();
  if (pcVar1 == (code *)0x0) {
    uVar2 = FUN_00412294(param_1,0);
    (*(code *)0xf8830000)(uVar2,param_2,param_3,param_4,param_5,param_6);
  }
  else {
    (*(code *)0xff0875ff)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_FlsAlloc@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsAlloc_4(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(3,"=",(module_id *)0x40fc8c,(module_id *)0x40fc94);
  if (pcVar1 == (code *)0x0) {
    (*(code *)0xde830)();
  }
  else {
    (*(code *)0xff0875ff)(param_1);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



void FUN_004120b9(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(4,"",(module_id *)0x40fc94,(module_id *)0x40fc9c);
  if (pcVar1 == (code *)0x0) {
    (*(code *)0x8b9e8e8)(param_1);
  }
  else {
    (*(code *)0xff0875ff)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



void FUN_0041210f(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(5,"",(module_id *)0x40fc9c,(module_id *)0x40fca4);
  if (pcVar1 == (code *)0x0) {
    (*(code *)0xc4830000)(param_1);
  }
  else {
    (*(code *)0xff0875ff)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_FlsSetValue@8
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsSetValue_8(undefined4 param_1,undefined4 param_2)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(6,&DAT_0040e268,(module_id *)0x40fca4,(module_id *)0x40fcac);
  if (pcVar1 == (code *)0x0) {
    (*(code *)0x658bc304)(param_1,param_2);
  }
  else {
    (*(code *)0xff0875ff)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_InitializeCriticalSectionEx@12
// 
// Library: Visual Studio 2015 Release

void ___acrt_InitializeCriticalSectionEx_12
               (undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(0x12,&LAB_0040e27c,(module_id *)0x40fcac,(module_id *)0x40fcb4);
  if (pcVar1 == (code *)0x0) {
    (*(code *)0xff008bec)(param_1,param_2);
  }
  else {
    (*(code *)0xff0875ff)(param_1,param_2,param_3);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_CompareStringEx@36
// 
// Library: Visual Studio 2015 Release

void ___acrt_CompareStringEx_36
               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
               undefined4 param_9)

{
  code *pcVar1;
  undefined4 uVar2;
  
  pcVar1 = (code *)FID_conflict_try_get_IsValidLocaleName();
  if (pcVar1 == (code *)0x0) {
    uVar2 = FUN_00412294(param_1,0);
    (*(code *)0x64207401)(uVar2,param_2,param_3,param_4,param_5,param_6);
  }
  else {
    (*(code *)0xff0875ff)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



void FUN_00412294(undefined4 param_1,undefined4 param_2)

{
  uint uVar1;
  code *pcVar2;
  
  uVar1 = (uint)&stack0xfffffffc ^ 0x74c08447;
  pcVar2 = (code *)FID_conflict_try_get_IsValidLocaleName();
  if (pcVar2 == (code *)0x0) {
    ___acrt_DownlevelLocaleNameToLCID(param_1);
  }
  else {
    (*(code *)0xff0875ff)(param_1,param_2);
    (*pcVar2)();
  }
  ___security_check_cookie_4(uVar1);
  return;
}



// Library Function - Single Match
//  ___acrt_uninitialize_winapi_thunks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___acrt_uninitialize_winapi_thunks(char param_1)

{
  int *piVar1;
  
  if (param_1 == '\0') {
    piVar1 = (int *)0x415070;
    do {
      if (*piVar1 != 0) {
        if (*piVar1 != -1) {
          (*(code *)0x8bcc0000)(*piVar1);
        }
        *piVar1 = 0;
      }
      piVar1 = piVar1 + 1;
    } while (piVar1 != (int *)0x4150c0);
  }
  return 1;
}



void FUN_0041234e(void)

{
  __recalloc_base();
  return;
}



// Library Function - Single Match
//  __recalloc_base
// 
// Library: Visual Studio 2019 Release

int __recalloc_base(int param_1,uint param_2,uint param_3)

{
  undefined4 *puVar1;
  int iVar2;
  uint uVar3;
  
  if ((param_2 == 0) || (param_3 <= 0xffffffe0 / param_2)) {
    if (param_1 == 0) {
      uVar3 = 0;
    }
    else {
      uVar3 = FUN_00414447(param_1);
    }
    param_2 = param_2 * param_3;
    iVar2 = __realloc_base(param_1,param_2);
    if ((iVar2 != 0) && (uVar3 < param_2)) {
      _memset((void *)(iVar2 + uVar3),0,param_2 - uVar3);
    }
  }
  else {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0xc;
    iVar2 = 0;
  }
  return iVar2;
}



// Library Function - Single Match
//  ___acrt_execute_initializers
// 
// Library: Visual Studio 2015 Release

void ___acrt_execute_initializers(code **param_1,code **param_2)

{
  code **ppcVar1;
  code *pcVar2;
  char cVar3;
  uint uVar4;
  code **ppcVar5;
  
  uVar4 = (uint)&stack0xfffffffc ^ 0x74c08447;
  ppcVar5 = param_1;
  if (param_1 != param_2) {
    do {
      pcVar2 = *ppcVar5;
      if (pcVar2 != (code *)0x0) {
        (*(code *)0xff0875ff)();
        cVar3 = (*pcVar2)();
        if (cVar3 == '\0') break;
      }
      ppcVar5 = ppcVar5 + 2;
    } while (ppcVar5 != param_2);
    if ((ppcVar5 != param_2) && (ppcVar5 != param_1)) {
      ppcVar5 = ppcVar5 + -1;
      do {
        if ((ppcVar5[-1] != (code *)0x0) && (pcVar2 = *ppcVar5, pcVar2 != (code *)0x0)) {
          (*(code *)0xff0875ff)(0);
          (*pcVar2)();
        }
        ppcVar1 = ppcVar5 + -1;
        ppcVar5 = ppcVar5 + -2;
      } while (ppcVar1 != param_1);
    }
  }
  ___security_check_cookie_4(uVar4);
  return;
}



void FUN_00412464(int param_1,int param_2)

{
  code *pcVar1;
  uint uVar2;
  
  uVar2 = (uint)&stack0xfffffffc ^ 0x74c08447;
  if (param_1 != param_2) {
    do {
      pcVar1 = *(code **)(param_2 + -4);
      if (pcVar1 != (code *)0x0) {
        (*(code *)0xff0875ff)(0);
        (*pcVar1)();
      }
      param_2 = param_2 + -8;
    } while (param_2 != param_1);
  }
  ___security_check_cookie_4(uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_004124ac(undefined4 param_1)

{
  __strnicmp = param_1;
  return;
}



// Library Function - Single Match
//  __callnewh
// 
// Library: Visual Studio 2015 Release

int __cdecl __callnewh(size_t _Size)

{
  uint uVar1;
  code *pcVar2;
  int iVar3;
  
  uVar1 = (uint)&stack0xfffffffc ^ 0x74c08447;
  pcVar2 = (code *)__query_new_handler();
  if (pcVar2 != (code *)0x0) {
    (*(code *)0xff0875ff)(_Size);
    (*pcVar2)();
  }
  iVar3 = ___security_check_cookie_4(uVar1);
  return iVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __query_new_handler
// 
// Library: Visual Studio 2015 Release

uint __query_new_handler(void)

{
  uint uVar1;
  
  ___acrt_lock(0);
  uVar1 = __strnicmp ^ 0x74c08447;
  FUN_00412548();
  return uVar1 >> 7 | uVar1 << 0x19;
}



void FUN_00412548(void)

{
  ___acrt_unlock(0);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void (__cdecl*__thiscall __crt_seh_guarded_call<void (__cdecl*)(int)>::operator()<class
// <lambda_cbab9ec6f41b0180b23cc171c22676b0>,class <lambda_44731a7d0e6d81c3e6aa82d741081786>&,class
// <lambda_4b292cb8dd18144e164572427af410ab>>(class
// <lambda_cbab9ec6f41b0180b23cc171c22676b0>&&,class
// <lambda_44731a7d0e6d81c3e6aa82d741081786>&,class
// <lambda_4b292cb8dd18144e164572427af410ab>&&))(int)
// 
// Library: Visual Studio 2017 Release

FuncDef280 * __thiscall
__crt_seh_guarded_call<void_(__cdecl*)(int)>::
operator___class__lambda_cbab9ec6f41b0180b23cc171c22676b0__class__lambda_44731a7d0e6d81c3e6aa82d741081786___class__lambda_4b292cb8dd18144e164572427af410ab___
          (__crt_seh_guarded_call_void____cdecl___int__ *this,
          _lambda_cbab9ec6f41b0180b23cc171c22676b0_ *param_1,
          _lambda_44731a7d0e6d81c3e6aa82d741081786_ *param_2,
          _lambda_4b292cb8dd18144e164572427af410ab_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  FUN_0041259f();
  return (FuncDef280 *)0x8f39afe2;
}



void FUN_0041259f(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  void (__cdecl** __cdecl get_global_action_nolock(int))(int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void____cdecl____int_ * __cdecl get_global_action_nolock(int param_1)

{
  if (param_1 == 2) {
    return (void____cdecl____int_ *)0x415158;
  }
  if (param_1 != 6) {
    if (param_1 == 0xf) {
      return (void____cdecl____int_ *)0x415164;
    }
    if (param_1 == 0x15) {
      return (void____cdecl____int_ *)0x41515c;
    }
    if (param_1 != 0x16) {
      return (void____cdecl____int_ *)0x0;
    }
  }
  return (void____cdecl____int_ *)0x415160;
}



// Library Function - Single Match
//  struct __crt_signal_action_t * __cdecl siglookup(int,struct __crt_signal_action_t * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

__crt_signal_action_t * __cdecl siglookup(int param_1,__crt_signal_action_t *param_2)

{
  __crt_signal_action_t *p_Var1;
  
  p_Var1 = param_2 + -0x1bf67a90;
  if (param_2 != p_Var1) {
    do {
      if (*(int *)(param_2 + 4) == param_1) {
        return param_2;
      }
      param_2 = param_2 + 0xc;
    } while (param_2 != p_Var1);
  }
  return (__crt_signal_action_t *)0x0;
}



// Library Function - Single Match
//  ___acrt_get_sigabrt_handler
// 
// Library: Visual Studio 2017 Release

void ___acrt_get_sigabrt_handler(void)

{
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void____cdecl___int__ local_5;
  
  local_c = 3;
  local_10 = 3;
  __crt_seh_guarded_call<void_(__cdecl*)(int)>::
  operator___class__lambda_cbab9ec6f41b0180b23cc171c22676b0__class__lambda_44731a7d0e6d81c3e6aa82d741081786___class__lambda_4b292cb8dd18144e164572427af410ab___
            (&local_5,(_lambda_cbab9ec6f41b0180b23cc171c22676b0_ *)&local_10,
             (_lambda_44731a7d0e6d81c3e6aa82d741081786_ *)&local_5,
             (_lambda_4b292cb8dd18144e164572427af410ab_ *)&local_c);
  return;
}



void FUN_0041263e(undefined4 param_1)

{
  uRam00415158 = param_1;
  uRam0041515c = param_1;
  uRam00415160 = param_1;
  uRam00415164 = param_1;
                    // WARNING: Read-only address (ram,0x00415158) is written
                    // WARNING: Read-only address (ram,0x0041515c) is written
                    // WARNING: Read-only address (ram,0x00415160) is written
                    // WARNING: Read-only address (ram,0x00415164) is written
  return;
}



int FUN_0041265c(void)

{
  int iVar1;
  
  iVar1 = FUN_0040fd7d();
  return iVar1 + 8;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4

void FUN_00412665(int param_1)

{
  code **ppcVar1;
  __crt_signal_action_t *p_Var2;
  undefined4 *puVar3;
  __crt_signal_action_t *p_Var4;
  int iVar5;
  char extraout_CL;
  char cVar6;
  code *pcVar7;
  __crt_signal_action_t **pp_Var8;
  undefined4 local_38;
  __crt_signal_action_t *local_34;
  char local_21;
  
  pp_Var8 = (__crt_signal_action_t **)0x0;
  local_38 = 0;
  local_21 = '\x01';
  if (8 < param_1) {
    if (param_1 == 0xb) goto LAB_004126bf;
    if ((param_1 == 0xf) || ((0x14 < param_1 && (param_1 < 0x17)))) goto LAB_004126b4;
LAB_004126e3:
    puVar3 = (undefined4 *)FUN_0040ef03();
    *puVar3 = 0x16;
    FUN_0040ee46();
    goto LAB_00412855;
  }
  if (param_1 == 8) {
LAB_004126bf:
    pp_Var8 = (__crt_signal_action_t **)FUN_0040fecb();
    if (pp_Var8 == (__crt_signal_action_t **)0x0) goto LAB_00412855;
    p_Var2 = siglookup(param_1,*pp_Var8);
    if (p_Var2 == (__crt_signal_action_t *)0x0) goto LAB_004126e3;
    ppcVar1 = (code **)(p_Var2 + 8);
    cVar6 = '\0';
    local_21 = '\0';
  }
  else {
    if (param_1 != 2) {
      if (param_1 == 4) goto LAB_004126bf;
      if (param_1 != 6) goto LAB_004126e3;
    }
LAB_004126b4:
    ppcVar1 = (code **)get_global_action_nolock(param_1);
    cVar6 = extraout_CL;
  }
  local_34 = (__crt_signal_action_t *)0x0;
  if (cVar6 != '\0') {
    ___acrt_lock(3);
    cVar6 = local_21;
  }
  if (cVar6 == '\0') {
    pcVar7 = *ppcVar1;
  }
  else {
    pcVar7 = (code *)(((uint)*ppcVar1 ^ 0x74c08447) >> 7 | ((uint)*ppcVar1 ^ 0x74c08447) << 0x19);
    cVar6 = local_21;
  }
  if (pcVar7 != (code *)0x1) {
    if (pcVar7 == (code *)0x0) {
      if (cVar6 != '\0') {
        ___acrt_unlock(3);
      }
      __exit(3);
    }
    if (((param_1 == 8) || (param_1 == 0xb)) || (param_1 == 4)) {
      local_34 = pp_Var8[1];
      pp_Var8[1] = (__crt_signal_action_t *)0x0;
      if (param_1 == 8) {
        puVar3 = (undefined4 *)FUN_0041265c();
        local_38 = *puVar3;
        puVar3 = (undefined4 *)FUN_0041265c();
        *puVar3 = 0x8c;
        goto LAB_0041279a;
      }
    }
    else {
LAB_0041279a:
      if (param_1 == 8) {
        p_Var2 = *pp_Var8;
        for (p_Var4 = p_Var2 + 0x2b7c4; p_Var4 != p_Var2 + 0x7908f7f0; p_Var4 = p_Var4 + 0xc) {
          *(undefined4 *)(p_Var4 + 8) = 0;
        }
        goto LAB_004127dc;
      }
    }
    *ppcVar1 = (code *)0x74c08447;
  }
LAB_004127dc:
  FUN_00412813();
  if (pcVar7 != (code *)0x1) {
    if (param_1 == 8) {
      iVar5 = FUN_0040fd7d();
      (*(code *)0xff0875ff)(8,*(undefined4 *)(iVar5 + 8));
      (*pcVar7)();
    }
    else {
      (*(code *)0xff0875ff)(param_1);
      (*pcVar7)();
      if ((param_1 != 0xb) && (param_1 != 4)) goto LAB_00412855;
    }
    pp_Var8[1] = local_34;
    if (param_1 == 8) {
      iVar5 = FUN_0040fd7d();
      *(undefined4 *)(iVar5 + 8) = local_38;
    }
  }
LAB_00412855:
  FUN_00417562();
  return;
}



void FUN_00412813(void)

{
  int unaff_EBP;
  
  if (*(char *)(unaff_EBP + -0x1d) != '\0') {
    ___acrt_unlock(3);
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_2866be3712abc81a800a822484c830d8>,class <lambda_39ca0ed439415581b5b15c265174cece>&,class
// <lambda_2b24c74d71094a6cd0cb82e44167d71b>>(class
// <lambda_2866be3712abc81a800a822484c830d8>&&,class
// <lambda_39ca0ed439415581b5b15c265174cece>&,class <lambda_2b24c74d71094a6cd0cb82e44167d71b>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_2866be3712abc81a800a822484c830d8__class__lambda_39ca0ed439415581b5b15c265174cece___class__lambda_2b24c74d71094a6cd0cb82e44167d71b___
          (__crt_seh_guarded_call_void_ *this,_lambda_2866be3712abc81a800a822484c830d8_ *param_1,
          _lambda_39ca0ed439415581b5b15c265174cece_ *param_2,
          _lambda_2b24c74d71094a6cd0cb82e44167d71b_ *param_3)

{
  char cVar1;
  int iVar2;
  
  __lock_file(*(FILE **)param_1);
  cVar1 = FUN_004129cd(**(undefined4 **)param_2,*(undefined4 *)(param_2 + 4));
  if ((cVar1 != '\0') &&
     ((**(char **)(param_2 + 8) != '\0' || ((*(uint *)(**(int **)param_2 + 0xc) >> 1 & 1) != 0)))) {
    iVar2 = __fflush_nolock(**(FILE ***)param_2);
    if (iVar2 == -1) {
      **(undefined4 **)(param_2 + 0xc) = 0xffffffff;
    }
    else {
      **(int **)(param_2 + 4) = **(int **)(param_2 + 4) + 1;
    }
  }
  FUN_004128d0();
  return;
}



void FUN_004128d0(void)

{
  int unaff_EBP;
  
  FUN_00412bfd(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_2cc53f568c5a2bb6f192f930a45d44ea>,class <lambda_ab61a845afdef5b7c387490eaf3616ee>&,class
// <lambda_c2ffc0b7726aa6be21d5f0026187e748>>(class
// <lambda_2cc53f568c5a2bb6f192f930a45d44ea>&&,class
// <lambda_ab61a845afdef5b7c387490eaf3616ee>&,class <lambda_c2ffc0b7726aa6be21d5f0026187e748>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_2cc53f568c5a2bb6f192f930a45d44ea__class__lambda_ab61a845afdef5b7c387490eaf3616ee___class__lambda_c2ffc0b7726aa6be21d5f0026187e748___
          (__crt_seh_guarded_call_void_ *this,_lambda_2cc53f568c5a2bb6f192f930a45d44ea_ *param_1,
          _lambda_ab61a845afdef5b7c387490eaf3616ee_ *param_2,
          _lambda_c2ffc0b7726aa6be21d5f0026187e748_ *param_3)

{
  char cVar1;
  undefined4 *puVar2;
  undefined4 *local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 *local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  __crt_seh_guarded_call_void_ local_1d [17];
  undefined4 uStack12;
  undefined4 local_8;
  
  local_8 = 0x413150;
  uStack12 = 0x4128e8;
  ___acrt_lock(*(undefined4 *)param_1);
  local_8 = 0;
  for (puVar2 = (undefined4 *)&DAT_d3e80000; local_30 = puVar2, puVar2 != (undefined4 *)0xd440031c;
      puVar2 = puVar2 + 1) {
    local_24 = *puVar2;
    cVar1 = FUN_004129cd(local_24,*(undefined4 *)param_2);
    if (cVar1 != '\0') {
      local_34 = *(undefined4 *)(param_2 + 8);
      local_38 = *(undefined4 *)(param_2 + 4);
      local_3c = *(undefined4 *)param_2;
      local_40 = &local_24;
      local_28 = local_24;
      local_2c = local_24;
      operator___class__lambda_2866be3712abc81a800a822484c830d8__class__lambda_39ca0ed439415581b5b15c265174cece___class__lambda_2b24c74d71094a6cd0cb82e44167d71b___
                (local_1d,(_lambda_2866be3712abc81a800a822484c830d8_ *)&local_2c,
                 (_lambda_39ca0ed439415581b5b15c265174cece_ *)&local_40,
                 (_lambda_2b24c74d71094a6cd0cb82e44167d71b_ *)&local_28);
    }
  }
  local_8 = 0xfffffffe;
  FUN_00412972();
  return;
}



void FUN_00412972(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  int __cdecl common_flush_all(bool)
// 
// Library: Visual Studio 2017 Release

int __cdecl common_flush_all(bool param_1)

{
  int *local_24;
  bool *local_20;
  int *local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  int local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  local_c = 0;
  local_24 = &local_c;
  local_10 = 0;
  local_20 = &param_1;
  local_1c = &local_10;
  local_14 = 8;
  local_18 = 8;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_2cc53f568c5a2bb6f192f930a45d44ea__class__lambda_ab61a845afdef5b7c387490eaf3616ee___class__lambda_c2ffc0b7726aa6be21d5f0026187e748___
            (&local_5,(_lambda_2cc53f568c5a2bb6f192f930a45d44ea_ *)&local_18,
             (_lambda_ab61a845afdef5b7c387490eaf3616ee_ *)&local_24,
             (_lambda_c2ffc0b7726aa6be21d5f0026187e748_ *)&local_14);
  if (param_1 == false) {
    local_c = local_10;
  }
  return local_c;
}



undefined4 FUN_004129cd(int param_1,int *param_2)

{
  char cVar1;
  
  if (param_1 != 0) {
    if ((*(uint *)(param_1 + 0xc) >> 0xd & 1) != 0) {
      cVar1 = FUN_004129ff(*(uint *)(param_1 + 0xc));
      if (cVar1 != '\0') {
        return 1;
      }
      *param_2 = *param_2 + 1;
    }
  }
  return 0;
}



uint FUN_004129ff(uint param_1)

{
  if ((((byte)param_1 & 3) == 2) && ((param_1 & 0xc0) != 0)) {
    return param_1 & 0xffffff00 | 1;
  }
  return param_1 & 0xffffff00 | (uint)((byte)(param_1 >> 0xb) & 1);
}



// Library Function - Single Match
//  ___acrt_stdio_flush_nolock
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_stdio_flush_nolock(FILE *param_1)

{
  int *piVar1;
  int _FileHandle;
  uint uVar2;
  uint uVar3;
  char *_Buf;
  
  piVar1 = &param_1->_flag;
  if ((((byte)*piVar1 & 3) == 2) && ((*piVar1 & 0xc0U) != 0)) {
    _Buf = (char *)param_1->_cnt;
    uVar3 = (int)param_1->_ptr - (int)_Buf;
    param_1->_ptr = _Buf;
    param_1->_base = (char *)0x0;
    if (0 < (int)uVar3) {
      uVar2 = uVar3;
      _FileHandle = __fileno(param_1);
      uVar2 = __write(_FileHandle,_Buf,uVar2);
      if (uVar3 != uVar2) {
        LOCK();
        *piVar1 = *piVar1 | 0x10;
        return 0xffffffff;
      }
      if (((uint)*piVar1 >> 2 & 1) != 0) {
        LOCK();
        *piVar1 = *piVar1 & 0xfffffffd;
      }
    }
  }
  return 0;
}



// Library Function - Single Match
//  __fflush_nolock
// 
// Library: Visual Studio 2015 Release

int __cdecl __fflush_nolock(FILE *_File)

{
  int iVar1;
  
  if (_File == (FILE *)0x0) {
    iVar1 = common_flush_all(false);
    return iVar1;
  }
  iVar1 = ___acrt_stdio_flush_nolock(_File);
  if (iVar1 == 0) {
    if (((uint)_File->_flag >> 0xb & 1) != 0) {
      iVar1 = __fileno(_File);
      iVar1 = __commit(iVar1);
      if (iVar1 != 0) goto LAB_00412aa6;
    }
    iVar1 = 0;
  }
  else {
LAB_00412aa6:
    iVar1 = -1;
  }
  return iVar1;
}



// Library Function - Single Match
//  __flushall
// 
// Library: Visual Studio 2017 Release

int __cdecl __flushall(void)

{
  int iVar1;
  
  iVar1 = common_flush_all(true);
  return iVar1;
}



// Library Function - Single Match
//  __lock_file
// 
// Library: Visual Studio 2017 Release

void __cdecl __lock_file(FILE *_File)

{
  (*(code *)0x100c608)(_File + 1);
  return;
}



void FUN_00412bfd(int param_1)

{
  (*(code *)0x9509e8)(param_1 + 0x20);
  return;
}



// Library Function - Single Match
//  ___hw_cw_sse2
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

uint ___hw_cw_sse2(uint param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = (param_1 & 0x10) << 3;
  if ((param_1 & 8) != 0) {
    uVar1 = uVar1 | 0x200;
  }
  if ((param_1 & 4) != 0) {
    uVar1 = uVar1 | 0x400;
  }
  if ((param_1 & 2) != 0) {
    uVar1 = uVar1 | 0x800;
  }
  if ((param_1 & 1) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  if ((param_1 & 0x80000) != 0) {
    uVar1 = uVar1 | 0x100;
  }
  uVar2 = param_1 & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x2000;
    }
    else if (uVar2 == 0x200) {
      uVar1 = uVar1 | 0x4000;
    }
    else if (uVar2 == 0x300) {
      uVar1 = uVar1 | 0x6000;
    }
  }
  param_1 = param_1 & 0x3000000;
  if (param_1 == 0x1000000) {
    uVar1 = uVar1 | 0x8040;
  }
  else {
    if (param_1 == 0x2000000) {
      return uVar1 | 0x40;
    }
    if (param_1 == 0x3000000) {
      return uVar1 | 0x8000;
    }
  }
  return uVar1;
}



// WARNING: Removing unreachable block (ram,0x00412e28)
// WARNING: Removing unreachable block (ram,0x00412e44)
// WARNING: Removing unreachable block (ram,0x00412e47)
// WARNING: Removing unreachable block (ram,0x00412e4e)
// WARNING: Removing unreachable block (ram,0x00412e51)
// WARNING: Removing unreachable block (ram,0x00412e58)
// WARNING: Removing unreachable block (ram,0x00412e5b)
// WARNING: Removing unreachable block (ram,0x00412e5f)
// WARNING: Removing unreachable block (ram,0x00412e62)
// WARNING: Removing unreachable block (ram,0x00412e69)
// WARNING: Removing unreachable block (ram,0x00412e6f)
// WARNING: Removing unreachable block (ram,0x00412e7a)
// WARNING: Removing unreachable block (ram,0x00412e9e)
// WARNING: Removing unreachable block (ram,0x00412e82)
// WARNING: Removing unreachable block (ram,0x00412e96)
// WARNING: Removing unreachable block (ram,0x00412e8a)
// WARNING: Removing unreachable block (ram,0x00412e8e)
// WARNING: Removing unreachable block (ram,0x00412ea4)
// WARNING: Removing unreachable block (ram,0x00412ecb)
// WARNING: Removing unreachable block (ram,0x00412eb0)
// WARNING: Removing unreachable block (ram,0x00412ec3)
// WARNING: Removing unreachable block (ram,0x00412eb7)
// WARNING: Removing unreachable block (ram,0x00412ebb)
// WARNING: Removing unreachable block (ram,0x00412ed1)
// WARNING: Removing unreachable block (ram,0x00412ee4)
// WARNING: Removing unreachable block (ram,0x00412f0b)
// WARNING: Removing unreachable block (ram,0x00412f0e)
// WARNING: Removing unreachable block (ram,0x00412f15)
// WARNING: Removing unreachable block (ram,0x00412f18)
// WARNING: Removing unreachable block (ram,0x00412f1f)
// WARNING: Removing unreachable block (ram,0x00412f22)
// WARNING: Removing unreachable block (ram,0x00412f29)
// WARNING: Removing unreachable block (ram,0x00412f2c)
// WARNING: Removing unreachable block (ram,0x00412f33)
// WARNING: Removing unreachable block (ram,0x00412f39)
// WARNING: Removing unreachable block (ram,0x00412f44)
// WARNING: Removing unreachable block (ram,0x00412f68)
// WARNING: Removing unreachable block (ram,0x00412f4c)
// WARNING: Removing unreachable block (ram,0x00412f60)
// WARNING: Removing unreachable block (ram,0x00412f54)
// WARNING: Removing unreachable block (ram,0x00412f58)
// WARNING: Removing unreachable block (ram,0x00412f6e)
// WARNING: Removing unreachable block (ram,0x00412f92)
// WARNING: Removing unreachable block (ram,0x00412f77)
// WARNING: Removing unreachable block (ram,0x00412f8a)
// WARNING: Removing unreachable block (ram,0x00412f7e)
// WARNING: Removing unreachable block (ram,0x00412f82)
// WARNING: Removing unreachable block (ram,0x00412f98)
// WARNING: Removing unreachable block (ram,0x00412fa5)
// WARNING: Removing unreachable block (ram,0x00412fab)

uint FUN_00412cb8(uint param_1,uint param_2)

{
  ushort uVar1;
  ushort uVar2;
  uint uVar3;
  uint uVar4;
  ushort in_FPUControlWord;
  
  uVar3 = (in_FPUControlWord & 1) << 4;
  if ((in_FPUControlWord & 4) != 0) {
    uVar3 = uVar3 | 8;
  }
  if ((in_FPUControlWord & 8) != 0) {
    uVar3 = uVar3 | 4;
  }
  if ((in_FPUControlWord & 0x10) != 0) {
    uVar3 = uVar3 | 2;
  }
  if ((in_FPUControlWord & 0x20) != 0) {
    uVar3 = uVar3 | 1;
  }
  if ((in_FPUControlWord & 2) != 0) {
    uVar3 = uVar3 | 0x80000;
  }
  uVar1 = in_FPUControlWord & 0xc00;
  if ((in_FPUControlWord & 0xc00) != 0) {
    if (uVar1 == 0x400) {
      uVar3 = uVar3 | 0x100;
    }
    else if (uVar1 == 0x800) {
      uVar3 = uVar3 | 0x200;
    }
    else if (uVar1 == 0xc00) {
      uVar3 = uVar3 | 0x300;
    }
  }
  if ((in_FPUControlWord & 0x300) == 0) {
    uVar3 = uVar3 | 0x20000;
  }
  else if ((in_FPUControlWord & 0x300) == 0x200) {
    uVar3 = uVar3 | 0x10000;
  }
  if ((in_FPUControlWord & 0x1000) != 0) {
    uVar3 = uVar3 | 0x40000;
  }
  uVar4 = ~param_2 & uVar3 | param_1 & param_2;
  if (uVar4 != uVar3) {
    uVar1 = __hw_cw(uVar4);
    uVar4 = (uVar1 & 1) << 4;
    if ((uVar1 & 4) != 0) {
      uVar4 = uVar4 | 8;
    }
    if ((uVar1 & 8) != 0) {
      uVar4 = uVar4 | 4;
    }
    if ((uVar1 & 0x10) != 0) {
      uVar4 = uVar4 | 2;
    }
    if ((uVar1 & 0x20) != 0) {
      uVar4 = uVar4 | 1;
    }
    if ((uVar1 & 2) != 0) {
      uVar4 = uVar4 | 0x80000;
    }
    uVar2 = uVar1 & 0xc00;
    if ((uVar1 & 0xc00) != 0) {
      if (uVar2 == 0x400) {
        uVar4 = uVar4 | 0x100;
      }
      else if (uVar2 == 0x800) {
        uVar4 = uVar4 | 0x200;
      }
      else if (uVar2 == 0xc00) {
        uVar4 = uVar4 | 0x300;
      }
    }
    if ((uVar1 & 0x300) == 0) {
      uVar4 = uVar4 | 0x20000;
    }
    else if ((uVar1 & 0x300) == 0x200) {
      uVar4 = uVar4 | 0x10000;
    }
    if ((uVar1 & 0x1000) != 0) {
      uVar4 = uVar4 | 0x40000;
    }
  }
  return uVar4;
}



// Library Function - Single Match
//  __hw_cw
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

uint __hw_cw(uint param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = param_1 >> 4 & 1;
  if ((param_1 & 8) != 0) {
    uVar1 = uVar1 | 4;
  }
  if ((param_1 & 4) != 0) {
    uVar1 = uVar1 | 8;
  }
  if ((param_1 & 2) != 0) {
    uVar1 = uVar1 | 0x10;
  }
  if ((param_1 & 1) != 0) {
    uVar1 = uVar1 | 0x20;
  }
  if ((param_1 & 0x80000) != 0) {
    uVar1 = uVar1 | 2;
  }
  uVar2 = param_1 & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x400;
    }
    else if (uVar2 == 0x200) {
      uVar1 = uVar1 | 0x800;
    }
    else if (uVar2 == 0x300) {
      uVar1 = uVar1 | 0xc00;
    }
  }
  if ((param_1 & 0x30000) == 0) {
    uVar1 = uVar1 | 0x300;
  }
  else if ((param_1 & 0x30000) == 0x10000) {
    uVar1 = uVar1 | 0x200;
  }
  if ((param_1 & 0x40000) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  return uVar1;
}



// WARNING: Could not reconcile some variable overlaps
// Library Function - Single Match
//  int __cdecl common_tox_l<&bool __cdecl internal_isupper_l(int,struct __crt_locale_pointers *
// const),&int __cdecl internal_map_lower(int,struct __crt_locale_pointers * const)>(int,unsigned
// long,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl
common_tox_l__bool___cdecl_internal_isupper_l_int_struct___crt_locale_pointers__const___int___cdecl_internal_map_lower_int_struct___crt_locale_pointers__const__
          (int param_1,ulong param_2,__crt_locale_pointers *param_3)

{
  byte bVar1;
  bool bVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 uVar5;
  int local_20;
  localeinfo_struct local_1c;
  char local_14;
  uint local_10;
  undefined2 local_c;
  undefined local_a;
  ushort local_8;
  undefined local_6;
  
  FUN_0040eb24(param_3);
  if ((uint)param_1 < 0x100) {
    bVar2 = internal_isupper_l(param_1,(__crt_locale_pointers *)&local_1c);
    if (bVar2) {
      bVar1 = (local_1c.locinfo)->pclmap[param_1];
      if (local_14 == '\0') {
        return (uint)bVar1;
      }
      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
      return (uint)bVar1;
    }
    if (local_14 == '\0') {
      return param_1;
    }
    *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
    return param_1;
  }
  local_8 = 0;
  local_6 = 0;
  if (1 < (int)(local_1c.locinfo)->lc_codepage) {
    local_10 = param_1 >> 8;
    iVar3 = __isleadbyte_l(local_10 & 0xff,&local_1c);
    if (iVar3 != 0) {
      local_8 = CONCAT11((byte)param_1,(char)local_10);
      local_6 = 0;
      uVar5 = 2;
      goto LAB_00413116;
    }
  }
  puVar4 = (undefined4 *)FUN_0040ef03();
  *puVar4 = 0x2a;
  uVar5 = 1;
  local_8 = (ushort)(byte)param_1;
LAB_00413116:
  local_c = 0;
  local_a = 0;
  iVar3 = ___acrt_LCMapStringA
                    (&local_1c,(local_1c.locinfo)->locale_name[2],param_2,&local_8,uVar5,&local_c,3,
                     (local_1c.locinfo)->lc_collate_cp,1);
  if (iVar3 == 0) {
    if (local_14 != '\0') {
      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
    }
  }
  else if (iVar3 == 1) {
    param_1 = (int)(byte)local_c;
    if (local_14 != '\0') {
      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
    }
  }
  else {
    param_1 = (int)CONCAT11((byte)local_c,local_c._1_1_);
    if (local_14 != '\0') {
      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
    }
  }
  return param_1;
}



// Library Function - Single Match
//  bool __cdecl internal_isupper_l(int,struct __crt_locale_pointers * const)
// 
// Library: Visual Studio 2017 Release

bool __cdecl internal_isupper_l(int param_1,__crt_locale_pointers *param_2)

{
  int iVar1;
  
  iVar1 = __ischartype_l(param_1,1,param_2);
  return iVar1 != 0;
}



// Library Function - Single Match
//  __tolower_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __tolower_l(int _C,_locale_t _Locale)

{
  int iVar1;
  
  iVar1 = common_tox_l__bool___cdecl_internal_isupper_l_int_struct___crt_locale_pointers__const___int___cdecl_internal_map_lower_int_struct___crt_locale_pointers__const__
                    (_C,0x100,(__crt_locale_pointers *)_Locale);
  return iVar1;
}



undefined4 FUN_004131d6(ushort *param_1,byte *param_2,uint param_3,undefined4 param_4)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  int local_14;
  localeinfo_struct local_10;
  char local_8;
  
  if ((param_2 == (byte *)0x0) || (param_3 == 0)) {
    return 0;
  }
  if (*param_2 == 0) {
    if (param_1 == (ushort *)0x0) {
      return 0;
    }
    *param_1 = 0;
    return 0;
  }
  FUN_0040eb24(param_4);
  if ((local_10.locinfo)->locale_name[2] == (wchar_t *)0x0) {
    if (param_1 != (ushort *)0x0) {
      *param_1 = (ushort)*param_2;
    }
    uVar3 = 1;
    goto LAB_004132bc;
  }
  iVar1 = __isleadbyte_l((uint)*param_2,&local_10);
  if (iVar1 == 0) {
    uVar3 = 1;
    iVar1 = FUN_0041512f((local_10.locinfo)->lc_collate_cp,9,param_2,1,param_1,
                         param_1 != (ushort *)0x0);
    if (iVar1 != 0) goto LAB_004132bc;
LAB_004132ae:
    puVar2 = (undefined4 *)FUN_0040ef03();
    uVar3 = 0xffffffff;
    *puVar2 = 0x2a;
  }
  else {
    if ((int)(local_10.locinfo)->lc_codepage < 2) {
LAB_00413279:
      uVar3 = (local_10.locinfo)->lc_codepage;
LAB_0041327c:
      if ((param_3 < uVar3) || (param_2[1] == 0)) goto LAB_004132ae;
    }
    else {
      uVar3 = (local_10.locinfo)->lc_codepage;
      if ((int)param_3 < (int)(local_10.locinfo)->lc_codepage) goto LAB_0041327c;
      iVar1 = FUN_0041512f((local_10.locinfo)->lc_collate_cp,9,param_2,
                           (local_10.locinfo)->lc_codepage,param_1,param_1 != (ushort *)0x0);
      if (iVar1 == 0) goto LAB_00413279;
    }
    uVar3 = (local_10.locinfo)->lc_codepage;
  }
LAB_004132bc:
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
    return uVar3;
  }
  return uVar3;
}



void FUN_004132d4(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_004131d6(param_1,param_2,param_3,0);
  return;
}



// Library Function - Single Match
//  ___acrt_update_locale_info
// 
// Library: Visual Studio 2015 Release

void ___acrt_update_locale_info(int param_1,int *param_2)

{
  int iVar1;
  
  if ((*param_2 != -0x2e08f7bb) && ((*(uint *)(param_1 + 0x350) & 0xe83eeb50) == 0)) {
    iVar1 = ___acrt_update_thread_locale_data();
    *param_2 = iVar1;
  }
  return;
}



// Library Function - Single Match
//  ___acrt_update_multibyte_info
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_update_multibyte_info(int param_1,int *param_2)

{
  int iVar1;
  
  if ((*param_2 != 0x7501fb80) && ((*(uint *)(param_1 + 0x350) & 0xe83eeb50) == 0)) {
    iVar1 = ___acrt_update_thread_multibyte_data();
    *param_2 = iVar1;
  }
  return;
}



// Library Function - Single Match
//  __fileno
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __fileno(FILE *_File)

{
  undefined4 *puVar1;
  
  if (_File == (FILE *)0x0) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
    return -1;
  }
  return _File->_file;
}



// Library Function - Single Match
//  __isctype_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __isctype_l(int _C,int _Type,_locale_t _Locale)

{
  int iVar1;
  undefined4 uVar2;
  int local_24;
  localeinfo_struct local_20;
  char local_18;
  undefined local_14;
  undefined local_13;
  undefined local_12;
  undefined4 local_10;
  undefined2 local_c;
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  FUN_0040eb24(_Locale);
  if (0x100 < _C + 1U) {
    iVar1 = __isleadbyte_l(_C >> 8 & 0xff,&local_20);
    if (iVar1 == 0) {
      local_13 = 0;
      uVar2 = 1;
      local_14 = (char)_C;
    }
    else {
      local_12 = 0;
      uVar2 = 2;
      local_14 = (char)((uint)_C >> 8);
      local_13 = (char)_C;
    }
    local_10 = 0;
    local_c = 0;
    iVar1 = FUN_004118f7(&local_20,1,&local_14,uVar2,&local_10,(local_20.locinfo)->lc_collate_cp,1);
    if (iVar1 == 0) {
      if (local_18 != '\0') {
        *(uint *)(local_24 + 0x350) = *(uint *)(local_24 + 0x350) & 0xfffffffd;
      }
      goto LAB_00413431;
    }
  }
  if (local_18 != '\0') {
    *(uint *)(local_24 + 0x350) = *(uint *)(local_24 + 0x350) & 0xfffffffd;
  }
LAB_00413431:
  iVar1 = ___security_check_cookie_4();
  return iVar1;
}



void FUN_00413440(void)

{
  __calloc_base();
  return;
}



// WARNING: Removing unreachable block (ram,0x00413459)
// Library Function - Single Match
//  __strnicoll
// 
// Library: Visual Studio 2017 Release

int __cdecl __strnicoll(char *_Str1,char *_Str2,size_t _MaxCount)

{
  int iVar1;
  
  iVar1 = __strnicoll_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  __strnicoll_l
// 
// Library: Visual Studio 2017 Release

int __cdecl __strnicoll_l(char *_Str1,char *_Str2,size_t _MaxCount,_locale_t _Locale)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  int local_14;
  localeinfo_struct local_10;
  char local_8;
  
  FUN_0040eb24(_Locale);
  if (_MaxCount == 0) {
    iVar3 = 0;
  }
  else if ((_Str1 == (char *)0x0) || (_Str2 == (char *)0x0)) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
    iVar3 = 0x7fffffff;
  }
  else {
    iVar3 = 0x7fffffff;
    if (_MaxCount < 0x80000000) {
      if ((local_10.locinfo)->locale_name[1] == (wchar_t *)0x0) {
        iVar3 = __strnicmp_l(_Str1,_Str2,_MaxCount,&local_10);
      }
      else {
        iVar2 = ___acrt_CompareStringA
                          (&local_10,(local_10.locinfo)->locale_name[1],0x1001,_Str1,_MaxCount,_Str2
                           ,_MaxCount,(local_10.locinfo)->lc_category[0].locale);
        if (iVar2 == 0) {
          puVar1 = (undefined4 *)FUN_0040ef03();
          *puVar1 = 0x16;
        }
        else {
          iVar3 = iVar2 + -2;
        }
      }
    }
    else {
      puVar1 = (undefined4 *)FUN_0040ef03();
      *puVar1 = 0x16;
      FUN_0040ee46();
    }
  }
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return iVar3;
}



// Library Function - Single Match
//  _strcat_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl _strcat_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  errno_t *peVar2;
  char *pcVar3;
  int iVar4;
  errno_t eStack16;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    pcVar3 = _Dst;
    if (_Src != (char *)0x0) {
      do {
        if (*pcVar3 == '\0') break;
        pcVar3 = pcVar3 + 1;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        iVar4 = (int)_Src - (int)pcVar3;
        do {
          cVar1 = pcVar3[iVar4];
          *pcVar3 = cVar1;
          pcVar3 = pcVar3 + 1;
          if (cVar1 == '\0') break;
          _SizeInBytes = _SizeInBytes - 1;
        } while (_SizeInBytes != 0);
        if (_SizeInBytes != 0) {
          return 0;
        }
        *_Dst = '\0';
        peVar2 = (errno_t *)FUN_0040ef03();
        eStack16 = 0x22;
        goto LAB_00413564;
      }
    }
    *_Dst = '\0';
  }
  peVar2 = (errno_t *)FUN_0040ef03();
  eStack16 = 0x16;
LAB_00413564:
  *peVar2 = eStack16;
  FUN_0040ee46();
  return eStack16;
}



// Library Function - Single Match
//  int __cdecl construct_command_line<char>(char const * const * const,char * * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl construct_command_line_char_(char **param_1,char **param_2)

{
  char cVar1;
  code *pcVar2;
  undefined4 *puVar3;
  errno_t eVar4;
  char *pcVar5;
  char *pcVar6;
  char **ppcVar7;
  int iVar8;
  char *pcVar9;
  char *pcVar10;
  char *local_8;
  
  local_8 = (char *)0x0;
  *param_2 = (char *)0x0;
  pcVar5 = *param_1;
  ppcVar7 = param_1;
  if (pcVar5 != (char *)0x0) {
    do {
      pcVar10 = pcVar5 + 1;
      do {
        cVar1 = *pcVar5;
        pcVar5 = pcVar5 + 1;
      } while (cVar1 != '\0');
      ppcVar7 = ppcVar7 + 1;
      local_8 = pcVar5 + (int)(local_8 + (1 - (int)pcVar10));
      pcVar5 = *ppcVar7;
    } while (pcVar5 != (char *)0x0);
    if ((char *)0x1 < local_8) goto LAB_004135e9;
  }
  local_8 = (char *)0x1;
LAB_004135e9:
  pcVar5 = (char *)__calloc_base(local_8,1);
  if (pcVar5 == (char *)0x0) {
    ___acrt_errno_map_os_error(8);
    puVar3 = (undefined4 *)FUN_0040ef03();
    iVar8 = 0xc;
    *puVar3 = 0xc;
  }
  else {
    pcVar10 = pcVar5;
    if (*param_1 != (char *)0x0) {
      do {
        eVar4 = _strcpy_s(pcVar10,(rsize_t)(pcVar5 + ((int)local_8 - (int)pcVar10)),*param_1);
        if (eVar4 != 0) {
          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          pcVar2 = (code *)swi(3);
          iVar8 = (*pcVar2)();
          return iVar8;
        }
        pcVar6 = *param_1;
        pcVar9 = pcVar6 + 1;
        do {
          cVar1 = *pcVar6;
          pcVar6 = pcVar6 + 1;
        } while (cVar1 != '\0');
        param_1 = param_1 + 1;
        pcVar9 = pcVar10 + ((int)pcVar6 - (int)pcVar9);
        *pcVar9 = ' ';
        pcVar10 = pcVar9 + 1;
      } while (*param_1 != (char *)0x0);
      *pcVar9 = '\0';
    }
    *param_2 = pcVar5;
    iVar8 = 0;
  }
  FID_conflict__free((void *)0x0);
  return iVar8;
}



// Library Function - Single Match
//  int __cdecl construct_environment_block<char>(char const * const * const,char * * const)
// 
// Library: Visual Studio 2015 Release

int __cdecl construct_environment_block_char_(char **param_1,char **param_2)

{
  char cVar1;
  code *pcVar2;
  errno_t eVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  char *pcVar7;
  undefined4 *puVar8;
  char **ppcVar9;
  char *pcVar10;
  uintptr_t unaff_EDI;
  char **local_2c;
  char *local_28;
  char *local_24;
  char *local_20;
  char *local_1c;
  char local_15;
  undefined4 local_14;
  undefined4 local_10;
  undefined2 local_c;
  undefined local_a;
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  local_2c = param_1;
  *param_2 = (char *)0x0;
  if (param_1 != (char **)0x0) {
    local_14 = 0x74737953;
    local_10 = 0x6f526d65;
    local_c = 0x746f;
    local_a = 0;
    local_28 = (char *)0x0;
    eVar3 = __dupenv_s(&local_28,(size_t *)0x0,(char *)&local_14);
    if (eVar3 == 0) {
      if (local_28 == (char *)0x0) {
        local_24 = (char *)0x0;
      }
      else {
        local_24 = local_28;
        do {
          cVar1 = *local_24;
          local_24 = local_24 + 1;
        } while (cVar1 != '\0');
        local_24 = local_24 + (1 - (int)(local_28 + 1));
      }
      local_24 = local_24 + 0xb;
      local_1c = (char *)0x2;
      pcVar5 = *param_1;
      ppcVar9 = param_1;
      while (pcVar5 != (char *)0x0) {
        pcVar6 = pcVar5 + 1;
        do {
          cVar1 = *pcVar5;
          pcVar5 = pcVar5 + 1;
        } while (cVar1 != '\0');
        ppcVar9 = ppcVar9 + 1;
        local_1c = pcVar5 + (int)(local_1c + (1 - (int)pcVar6));
        pcVar5 = *ppcVar9;
      }
      pcVar5 = (char *)___dcrt_get_narrow_environment_from_os();
      if (pcVar5 != (char *)0x0) {
        cVar1 = *pcVar5;
        pcVar6 = pcVar5;
        while (cVar1 != '=') {
          do {
            cVar1 = *pcVar6;
            pcVar6 = pcVar6 + 1;
          } while (cVar1 != '\0');
          cVar1 = *pcVar6;
        }
        cVar1 = *pcVar6;
        pcVar7 = pcVar6;
        while ((((cVar1 == '=' && (pcVar7[1] != '\0')) && (pcVar7[2] == ':')) && (pcVar7[3] == '='))
              ) {
          pcVar7 = pcVar7 + 4;
          do {
            cVar1 = *pcVar7;
            pcVar7 = pcVar7 + 1;
          } while (cVar1 != '\0');
          cVar1 = *pcVar7;
        }
        pcVar7 = pcVar7 + -(int)pcVar6;
        pcVar10 = *param_1;
        local_20 = pcVar7;
        while (pcVar10 != (char *)0x0) {
          puVar8 = &local_14;
          do {
            cVar1 = *(char *)puVar8;
            puVar8 = (undefined4 *)((int)puVar8 + 1);
          } while (cVar1 != '\0');
          iVar4 = __strnicmp(*param_1,(char *)&local_14,(int)puVar8 - ((int)&local_14 + 1));
          if (iVar4 == 0) {
            local_15 = '\x01';
            local_1c = local_1c + (int)pcVar7;
            goto LAB_004137e1;
          }
          param_1 = param_1 + 1;
          pcVar10 = *param_1;
        }
        local_15 = '\0';
        local_1c = local_1c + (int)pcVar7 + (int)local_24;
LAB_004137e1:
        pcVar7 = (char *)__calloc_base(local_1c,1);
        if (pcVar7 == (char *)0x0) {
          ___acrt_errno_map_os_error(0xe);
          puVar8 = (undefined4 *)FUN_0040ef03();
          *puVar8 = 0xc;
        }
        else {
          pcVar10 = pcVar7;
          if (local_20 != (char *)0x0) {
            FUN_0040c9c9(pcVar7,pcVar6,local_20);
            local_1c = local_1c + -(int)local_20;
            pcVar10 = pcVar7 + (int)local_20;
          }
          for (; *local_2c != (char *)0x0; local_2c = local_2c + 1) {
            eVar3 = _strcpy_s(pcVar10,(rsize_t)local_1c,*local_2c);
            if (eVar3 != 0) goto LAB_0041391a;
            pcVar6 = *local_2c;
            local_20 = pcVar6 + 1;
            do {
              cVar1 = *pcVar6;
              pcVar6 = pcVar6 + 1;
            } while (cVar1 != '\0');
            local_1c = local_1c + -(int)(pcVar6 + (1 - (int)local_20));
            pcVar10 = pcVar10 + (int)(pcVar6 + (1 - (int)local_20));
          }
          if (local_15 == '\0') {
            eVar3 = _strcpy_s(pcVar10,(rsize_t)local_24,(char *)&local_14);
            if (((eVar3 != 0) ||
                (eVar3 = _strcat_s(pcVar10,(rsize_t)local_24,(char *)0x40fd14), eVar3 != 0)) ||
               ((local_28 != (char *)0x0 &&
                (eVar3 = _strcat_s(pcVar10,(rsize_t)local_24,local_28), eVar3 != 0))))
            goto LAB_0041391a;
            pcVar10 = pcVar10 + (int)local_24;
          }
          if (pcVar10 == pcVar7) {
            *pcVar10 = '\0';
            pcVar10 = pcVar10 + 1;
          }
          *pcVar10 = '\0';
          *param_2 = pcVar7;
        }
        FID_conflict__free((void *)0x0);
      }
      FID_conflict__free(pcVar5);
    }
    else {
      if (eVar3 == 0x16) {
        unaff_EDI = 0;
LAB_0041391a:
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,unaff_EDI);
        pcVar2 = (code *)swi(3);
        iVar4 = (*pcVar2)();
        return iVar4;
      }
      FUN_0040ef03();
    }
    FID_conflict__free(local_28);
  }
  iVar4 = ___security_check_cookie_4();
  return iVar4;
}



// Library Function - Single Match
//  ___acrt_pack_narrow_command_line_and_environment
// 
// Library: Visual Studio 2015 Release

undefined4
___acrt_pack_narrow_command_line_and_environment
          (char **param_1,char **param_2,char **param_3,char **param_4)

{
  int iVar1;
  undefined4 uVar2;
  char *local_c;
  char *local_8;
  
  uVar2 = 0;
  local_8 = (char *)0x0;
  iVar1 = construct_command_line_char_(param_1,&local_8);
  if (iVar1 == 0) {
    local_c = (char *)0x0;
    iVar1 = construct_environment_block_char_(param_2,&local_c);
    if (iVar1 == 0) {
      *param_3 = local_8;
      *param_4 = local_c;
      FID_conflict__free((void *)0x0);
      FID_conflict__free((void *)0x0);
    }
    else {
      FID_conflict__free(local_c);
      FID_conflict__free(local_8);
      uVar2 = 0xffffffff;
    }
  }
  else {
    FID_conflict__free(local_8);
    uVar2 = 0xffffffff;
  }
  return uVar2;
}



uint FUN_0041399b(char *param_1,char *param_2,uint param_3)

{
  undefined4 *puVar1;
  char *pcVar2;
  char cVar3;
  char *pcVar4;
  
  if (param_2 != (char *)0x0) {
    if (param_3 != 0) {
      *param_2 = '\0';
    }
    if (1 < param_3) {
      for (; *param_1 == ';'; param_1 = param_1 + 1) {
      }
      pcVar4 = param_2 + (param_3 - 1);
      pcVar2 = param_1;
      while (cVar3 = *pcVar2, cVar3 != '\0') {
        if (cVar3 == ';') goto LAB_00413a2b;
        if (cVar3 == '\"') {
          pcVar2 = pcVar2 + 1;
          cVar3 = *pcVar2;
          if (cVar3 == '\0') break;
          do {
            if (cVar3 == '\"') break;
            *param_2 = cVar3;
            param_2 = param_2 + 1;
            pcVar2 = pcVar2 + 1;
            if (param_2 == pcVar4) goto LAB_00413a19;
            cVar3 = *pcVar2;
          } while (cVar3 != '\0');
          if (*pcVar2 == '\0') break;
          pcVar2 = pcVar2 + 1;
        }
        else {
          *param_2 = cVar3;
          param_2 = param_2 + 1;
          pcVar2 = pcVar2 + 1;
          if (param_2 == pcVar4) {
LAB_00413a19:
            *param_2 = '\0';
            puVar1 = (undefined4 *)FUN_0040ef03();
            *puVar1 = 0x22;
            return 0;
          }
        }
      }
      for (; *pcVar2 == ';'; pcVar2 = pcVar2 + 1) {
LAB_00413a2b:
      }
      *param_2 = '\0';
      return -(uint)(pcVar2 != param_1) & (uint)pcVar2;
    }
  }
  puVar1 = (undefined4 *)FUN_0040ef03();
  *puVar1 = 0x16;
  return 0;
}



void FUN_00413a42(void)

{
  FUN_0041399b();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_copy_path_to_wide_string
// 
// Library: Visual Studio 2015 Release

undefined4 __thiscall
___acrt_copy_path_to_wide_string(undefined4 param_1_00,int param_1,void **param_2)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  void *pvVar5;
  undefined4 uVar6;
  void *_Memory;
  
  if (param_1 == 0) {
    puVar1 = (undefined4 *)FUN_0040ef03(param_1_00);
    *puVar1 = 0x16;
    FUN_0040ee46();
    uVar2 = 0;
  }
  else if (param_2 == (void **)0x0) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
    uVar2 = 0;
  }
  else {
    iVar3 = FUN_00411fb5();
    uVar2 = 0;
    *param_2 = (void *)0x0;
    iVar4 = (*common_exit)(iVar3 == 0,0,param_1,0xffffffff,0,0);
    if (iVar4 == 0) {
      uVar2 = (*(code *)0x414cb805)();
      ___acrt_errno_map_os_error(uVar2);
      uVar2 = 0;
    }
    else {
      pvVar5 = (void *)__malloc_base(iVar4 * 2);
      _Memory = pvVar5;
      if (pvVar5 != (void *)0x0) {
        iVar3 = (*common_exit)(iVar3 == 0,0,param_1,0xffffffff,pvVar5,iVar4);
        if (iVar3 == 0) {
          uVar6 = (*(code *)0x414cb805)();
          ___acrt_errno_map_os_error(uVar6);
        }
        else {
          _Memory = (void *)0x0;
          uVar2 = 1;
          *param_2 = pvVar5;
        }
      }
      FID_conflict__free(_Memory);
    }
  }
  return uVar2;
}



// Library Function - Multiple Matches With Different Base Names
//  void __cdecl swap(char *,char *,unsigned int)
//  _swap
//  _swap_c
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict__swap(undefined *param_1,undefined *param_2,int param_3)

{
  undefined *puVar1;
  undefined uVar2;
  undefined *puVar3;
  
  if ((param_1 != param_2) && (puVar3 = param_2, param_3 != 0)) {
    do {
      puVar1 = puVar3 + 1;
      uVar2 = puVar1[(int)(param_1 + (-1 - (int)param_2))];
      puVar1[(int)(param_1 + (-1 - (int)param_2))] = *puVar3;
      *puVar3 = uVar2;
      param_3 = param_3 + -1;
      puVar3 = puVar1;
    } while (param_3 != 0);
  }
  return;
}



void FUN_00413b59(undefined *param_1,uint param_2,uint param_3,code *param_4)

{
  undefined *puVar1;
  undefined uVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined *puVar5;
  undefined *puVar6;
  uint uVar7;
  undefined *puVar8;
  undefined *puVar9;
  undefined *local_114;
  int local_110;
  undefined *local_108;
  undefined *local_fc;
  undefined4 auStack248 [30];
  undefined4 auStack128 [30];
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  local_108 = param_1;
  if ((((param_1 == (undefined *)0x0) && (param_2 != 0)) || (param_3 == 0)) ||
     (param_4 == (code *)0x0)) {
    puVar3 = (undefined4 *)FUN_0040ef03();
    *puVar3 = 0x16;
    FUN_0040ee46();
  }
  else {
    local_110 = 0;
    if (1 < param_2) {
      puVar5 = param_1 + (param_2 - 1) * param_3;
LAB_00413bdb:
      while (uVar7 = (uint)((int)puVar5 - (int)local_108) / param_3 + 1, 8 < uVar7) {
        puVar9 = local_108 + (uVar7 >> 1) * param_3;
        (*(code *)0xff0875ff)(local_108,puVar9);
        iVar4 = (*param_4)();
        if (0 < iVar4) {
          FID_conflict__swap(local_108,puVar9,param_3);
        }
        (*(code *)0xff0875ff)(local_108,puVar5);
        iVar4 = (*param_4)();
        if (0 < iVar4) {
          FID_conflict__swap(local_108,puVar5,param_3);
        }
        (*(code *)0xff0875ff)(puVar9,puVar5);
        iVar4 = (*param_4)();
        local_114 = local_108;
        local_fc = puVar5;
        if (0 < iVar4) {
          FID_conflict__swap(puVar9,puVar5,param_3);
        }
LAB_00413d79:
        if (local_114 < puVar9) {
          do {
            local_114 = local_114 + param_3;
            if (puVar9 <= local_114) goto LAB_00413dba;
            (*(code *)0xff0875ff)(local_114,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 < 1);
          puVar8 = local_fc;
          if (puVar9 <= local_114) goto LAB_00413dba;
        }
        else {
LAB_00413dba:
          do {
            local_114 = local_114 + param_3;
            puVar8 = local_fc;
            if (puVar5 < local_114) break;
            (*(code *)0xff0875ff)(local_114,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 < 1);
        }
        do {
          local_fc = puVar8;
          puVar8 = local_fc + -param_3;
          if (puVar8 <= puVar9) break;
          (*(code *)0xff0875ff)(puVar8,puVar9);
          iVar4 = (*param_4)();
        } while (0 < iVar4);
        if (local_114 <= puVar8) {
          puVar6 = puVar8;
          uVar7 = param_3;
          if (local_114 != puVar8) {
            do {
              puVar1 = puVar6 + 1;
              uVar2 = puVar1[(int)(local_114 + (-1 - (int)puVar8))];
              puVar1[(int)(local_114 + (-1 - (int)puVar8))] = *puVar6;
              *puVar6 = uVar2;
              uVar7 = uVar7 - 1;
              puVar6 = puVar1;
            } while (uVar7 != 0);
          }
          local_fc = puVar8;
          if (puVar9 == puVar8) {
            puVar9 = local_114;
          }
          goto LAB_00413d79;
        }
        if (puVar9 < local_fc) {
          do {
            local_fc = local_fc + -param_3;
            if (local_fc <= puVar9) goto LAB_00413eda;
            (*(code *)0xff0875ff)(local_fc,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 == 0);
          if (local_fc <= puVar9) goto LAB_00413eda;
        }
        else {
LAB_00413eda:
          do {
            local_fc = local_fc + -param_3;
            if (local_fc <= local_108) break;
            (*(code *)0xff0875ff)(local_fc,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 == 0);
        }
        if ((int)local_fc - (int)local_108 < (int)puVar5 - (int)local_114) goto LAB_00413f60;
        if (local_108 < local_fc) {
          auStack128[local_110] = local_108;
          auStack248[local_110] = local_fc;
          local_110 = local_110 + 1;
        }
        local_108 = local_114;
        if (puVar5 <= local_114) goto LAB_00413c9e;
      }
      for (; puVar8 = local_108, puVar9 = local_108, local_108 < puVar5; puVar5 = puVar5 + -param_3)
      {
        while (puVar9 = puVar9 + param_3, puVar9 <= puVar5) {
          (*(code *)0xff0875ff)(puVar9,puVar8);
          iVar4 = (*param_4)();
          if (0 < iVar4) {
            puVar8 = puVar9;
          }
        }
        if (puVar8 != puVar5) {
          puVar9 = puVar5;
          uVar7 = param_3;
          do {
            uVar2 = puVar9[(int)puVar8 - (int)puVar5];
            (puVar9 + 1)[((int)puVar8 - (int)puVar5) + -1] = *puVar9;
            *puVar9 = uVar2;
            uVar7 = uVar7 - 1;
            puVar9 = puVar9 + 1;
          } while (uVar7 != 0);
        }
      }
      goto LAB_00413c9e;
    }
  }
LAB_00413ba7:
  ___security_check_cookie_4();
  return;
LAB_00413f60:
  if (local_114 < puVar5) {
    auStack128[local_110] = local_114;
    auStack248[local_110] = puVar5;
    local_110 = local_110 + 1;
  }
  puVar5 = local_fc;
  if (local_fc <= local_108) {
LAB_00413c9e:
    local_110 = local_110 + -1;
    if (-1 < local_110) {
      local_108 = (undefined *)auStack128[local_110];
      puVar5 = (undefined *)auStack248[local_110];
      goto LAB_00413bdb;
    }
    goto LAB_00413ba7;
  }
  goto LAB_00413bdb;
}



undefined4 FUN_00413f9d(char *param_1,int param_2,int param_3,int param_4)

{
  char cVar1;
  undefined4 *puVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  undefined4 uVar6;
  
  if (param_4 == 0) {
    if (param_1 == (char *)0x0) {
      if (param_2 == 0) {
        return 0;
      }
    }
    else {
LAB_00413fbf:
      if (param_2 != 0) {
        if (param_4 == 0) {
          *param_1 = '\0';
          return 0;
        }
        if (param_3 != 0) {
          iVar3 = param_4;
          iVar4 = param_2;
          pcVar5 = param_1;
          if (param_4 == -1) {
            do {
              cVar1 = pcVar5[param_3 - (int)param_1];
              *pcVar5 = cVar1;
              pcVar5 = pcVar5 + 1;
              if (cVar1 == '\0') break;
              iVar4 = iVar4 + -1;
            } while (iVar4 != 0);
          }
          else {
            do {
              cVar1 = pcVar5[param_3 - (int)param_1];
              *pcVar5 = cVar1;
              pcVar5 = pcVar5 + 1;
              if ((cVar1 == '\0') || (iVar4 = iVar4 + -1, iVar4 == 0)) break;
              iVar3 = iVar3 + -1;
            } while (iVar3 != 0);
            if (iVar3 == 0) {
              *pcVar5 = '\0';
            }
          }
          if (iVar4 != 0) {
            return 0;
          }
          if (param_4 == -1) {
            param_1[param_2 + -1] = '\0';
            return 0x50;
          }
          *param_1 = '\0';
          puVar2 = (undefined4 *)FUN_0040ef03();
          uVar6 = 0x22;
          goto LAB_00413fdf;
        }
        *param_1 = '\0';
      }
    }
  }
  else if (param_1 != (char *)0x0) goto LAB_00413fbf;
  puVar2 = (undefined4 *)FUN_0040ef03();
  uVar6 = 0x16;
LAB_00413fdf:
  *puVar2 = uVar6;
  FUN_0040ee46();
  return uVar6;
}



void FUN_0041404e(void)

{
  FUN_00413f9d();
  return;
}



// Library Function - Single Match
//  _strpbrk
// 
// Library: Visual Studio

char * __cdecl _strpbrk(char *_Str,char *_Control)

{
  byte bVar1;
  char *pcVar2;
  byte *pbVar3;
  undefined4 uStack40;
  undefined4 uStack36;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  
  uStack12 = 0;
  uStack16 = 0;
  uStack20 = 0;
  uStack24 = 0;
  uStack28 = 0;
  uStack32 = 0;
  uStack36 = 0;
  uStack40 = 0;
  for (; bVar1 = *_Control, bVar1 != 0; _Control = (char *)((byte *)_Control + 1)) {
    pbVar3 = (byte *)((int)&uStack40 + ((int)(uint)bVar1 >> 3));
    *pbVar3 = *pbVar3 | '\x01' << (bVar1 & 7);
  }
  do {
    pbVar3 = (byte *)_Str;
    pcVar2 = (char *)(uint)*pbVar3;
    if (*pbVar3 == 0) {
      return pcVar2;
    }
    _Str = (char *)(pbVar3 + 1);
  } while ((*(byte *)((int)&uStack40 + ((int)pcVar2 >> 3)) >> ((uint)pcVar2 & 7) & 1) == 0);
  return (char *)pbVar3;
}



void FUN_00414099(undefined4 param_1,undefined4 param_2)

{
  FUN_004140b0(param_1,param_2,0);
  return;
}



byte * FUN_004140b0(byte *param_1,byte *param_2,undefined4 param_3)

{
  undefined4 *puVar1;
  byte *pbVar2;
  int local_14;
  int local_c;
  char local_8;
  
  if ((param_1 == (byte *)0x0) || (param_2 == (byte *)0x0)) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
  }
  else if (param_1 < param_2) {
    FUN_0040eb24(param_3);
    if (*(int *)(local_c + 8) != 0) {
      pbVar2 = param_2 + -1;
      do {
        pbVar2 = pbVar2 + -1;
        if (pbVar2 < param_1) break;
      } while ((*(byte *)(*pbVar2 + 0x19 + local_c) & 4) != 0);
      param_2 = param_2 + -((int)param_2 - (int)pbVar2 & 1U);
    }
    if (local_8 == '\0') {
      return param_2 + -1;
    }
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
    return param_2 + -1;
  }
  return (byte *)0x0;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00414136(int *param_1,undefined4 param_2,uint param_3,undefined4 param_4,int param_5,
                 undefined4 param_6,int param_7,int param_8,int param_9)

{
  int iVar1;
  uint uVar2;
  int *piVar3;
  int iVar4;
  int *piVar5;
  int iStack48;
  int iStack44;
  undefined4 uStack40;
  int iStack36;
  undefined4 uStack32;
  int iStack28;
  
  iVar4 = param_5;
  if (0 < param_5) {
    iStack28 = param_5;
    uStack32 = param_4;
    iStack36 = 0x41415a;
    iVar1 = ___strncnt();
    iVar4 = iVar1 + 1;
    if (param_5 <= iVar1) {
      iVar4 = iVar1;
    }
  }
  if (param_8 == 0) {
    param_8 = *(int *)(*param_1 + 8);
  }
  iStack28 = 0;
  uStack32 = 0;
  uStack40 = param_4;
  iStack44 = (uint)(param_9 != 0) * 8 + 1;
  iStack48 = param_8;
  iStack36 = iVar4;
  iVar1 = (*common_exit)();
  if (iVar1 == 0) goto LAB_004142f7;
  uVar2 = iVar1 * 2 + 8;
  uVar2 = -(uint)((uint)(iVar1 * 2) < uVar2) & uVar2;
  if (uVar2 == 0) {
    piVar3 = (undefined4 *)0x0;
  }
  else if (uVar2 < 0x401) {
    piVar3 = &iStack48;
    if (&stack0x00000000 != (undefined *)0x30) {
      iStack48 = 0xcccc;
      piVar3 = &iStack48;
LAB_004141de:
      piVar3 = piVar3 + 2;
    }
  }
  else {
    piVar3 = (int *)__malloc_base(uVar2);
    if (piVar3 != (undefined4 *)0x0) {
      *piVar3 = 0xdddd;
      goto LAB_004141de;
    }
  }
  if (((piVar3 != (undefined4 *)0x0) &&
      (iVar4 = (*common_exit)(param_8,1,param_4,iVar4,piVar3,iVar1), iVar4 != 0)) &&
     (iVar4 = ___acrt_CompareStringEx_36(param_2,param_3,piVar3,iVar1,0,0,0,0,0), iVar4 != 0)) {
    if ((param_3 & 0x400) == 0) {
      uVar2 = iVar4 * 2 + 8;
      uVar2 = -(uint)((uint)(iVar4 * 2) < uVar2) & uVar2;
      if (uVar2 == 0) {
        piVar5 = (undefined4 *)0x0;
LAB_004142a9:
        if ((piVar5 != (undefined4 *)0x0) &&
           (iVar1 = ___acrt_CompareStringEx_36(param_2,param_3,piVar3,iVar1,piVar5,iVar4,0,0,0),
           iVar1 != 0)) {
          if (param_7 == 0) {
            param_7 = 0;
            param_6 = 0;
          }
          iVar4 = (*(code *)0x12750010)(param_8,0,piVar5,iVar4,param_6,param_7,0,0);
          if (iVar4 != 0) {
            FUN_004119fb(piVar5);
            goto LAB_004142ee;
          }
        }
      }
      else if (uVar2 < 0x401) {
        piVar5 = &iStack48;
        if (&stack0x00000000 != (undefined *)0x30) {
          iStack48 = 0xcccc;
          piVar5 = &iStack48;
LAB_004142a2:
          piVar5 = piVar5 + 2;
          goto LAB_004142a9;
        }
      }
      else {
        piVar5 = (int *)__malloc_base(uVar2);
        if (piVar5 != (undefined4 *)0x0) {
          *piVar5 = 0xdddd;
          goto LAB_004142a2;
        }
      }
      FUN_004119fb(piVar5);
    }
    else if ((param_7 != 0) && (iVar4 <= param_7)) {
      ___acrt_CompareStringEx_36(param_2,param_3,piVar3,iVar1,param_6,param_7,0,0,0);
    }
  }
LAB_004142ee:
  FUN_004119fb(piVar3);
LAB_004142f7:
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_LCMapStringA
// 
// Library: Visual Studio 2015 Release

void ___acrt_LCMapStringA
               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
               undefined4 param_9)

{
  int local_14;
  undefined local_10 [8];
  char local_8;
  
  FUN_0040eb24(param_1);
  FUN_00414136(local_10,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  int __cdecl GetTableIndexFromLocaleName(wchar_t const *)
// 
// Library: Visual Studio 2017 Release

int __cdecl GetTableIndexFromLocaleName(wchar_t *param_1)

{
  ushort uVar1;
  int iVar2;
  int iVar3;
  ushort uVar4;
  ushort *puVar5;
  int local_10;
  int local_c;
  int local_8;
  
  local_c = 0;
  local_10 = 0xe3;
  while( true ) {
    local_8 = 0x55;
    iVar2 = (local_10 + local_c) / 2;
    puVar5 = *(ushort **)(iVar2 * 8 + 0x410e38);
    iVar3 = (int)param_1 - (int)puVar5;
    do {
      uVar4 = *(ushort *)(iVar3 + (int)puVar5);
      if ((ushort)(uVar4 - 0x41) < 0x1a) {
        uVar4 = uVar4 + 0x20;
      }
      uVar1 = *puVar5;
      if ((ushort)(uVar1 - 0x41) < 0x1a) {
        uVar1 = uVar1 + 0x20;
      }
      puVar5 = puVar5 + 1;
      local_8 = local_8 + -1;
    } while (((local_8 != 0) && (uVar4 != 0)) && (uVar4 == uVar1));
    if ((uint)uVar4 == (uint)uVar1) break;
    if ((int)((uint)uVar4 - (uint)uVar1) < 0) {
      local_10 = iVar2 + -1;
    }
    else {
      local_c = iVar2 + 1;
    }
    if (local_10 < local_c) {
      return -1;
    }
  }
  return *(int *)(iVar2 * 8 + 0x410e3c);
}



// Library Function - Single Match
//  ___acrt_DownlevelLocaleNameToLCID
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_DownlevelLocaleNameToLCID(wchar_t *param_1)

{
  uint uVar1;
  
  if (param_1 != (wchar_t *)0x0) {
    uVar1 = GetTableIndexFromLocaleName(param_1);
    if ((-1 < (int)uVar1) && (uVar1 < 0xe4)) {
      return *(undefined4 *)(uVar1 * 8 + 0x40fd18);
    }
  }
  return 0;
}



void FUN_00414447(void)

{
  __msize_base();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __msize_base
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 __msize_base(int param_1)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  
  if (param_1 == 0) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
    return 0xffffffff;
  }
  uVar2 = (*(code *)0x68408b00)(__strnicmp,0,param_1);
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __realloc_base
// 
// Library: Visual Studio 2015 Release

int __realloc_base(void *param_1,uint param_2)

{
  int iVar1;
  undefined4 *puVar2;
  
  if (param_1 == (void *)0x0) {
    iVar1 = __malloc_base(param_2);
  }
  else {
    if (param_2 == 0) {
      FID_conflict__free(param_1);
    }
    else {
      if (param_2 < 0xffffffe1) {
        do {
          iVar1 = (*(code *)0xa808e8c1)(__strnicmp,0,param_1,param_2);
          if (iVar1 != 0) {
            return iVar1;
          }
          iVar1 = FUN_0040e385();
        } while ((iVar1 != 0) && (iVar1 = __callnewh(param_2), iVar1 != 0));
      }
      puVar2 = (undefined4 *)FUN_0040ef03();
      *puVar2 = 0xc;
    }
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_9e9de3de5fa147e2223d7db92bc10aa6>,class <lambda_38ce7e780aa69e748d6df282ebc68efe>&,class
// <lambda_8ca6da459f0f6780f1cff60fdc3d00e5>>(class
// <lambda_9e9de3de5fa147e2223d7db92bc10aa6>&&,class
// <lambda_38ce7e780aa69e748d6df282ebc68efe>&,class <lambda_8ca6da459f0f6780f1cff60fdc3d00e5>&&)
// 
// Library: Visual Studio 2017 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_9e9de3de5fa147e2223d7db92bc10aa6__class__lambda_38ce7e780aa69e748d6df282ebc68efe___class__lambda_8ca6da459f0f6780f1cff60fdc3d00e5___
          (__crt_seh_guarded_call_int_ *this,_lambda_9e9de3de5fa147e2223d7db92bc10aa6_ *param_1,
          _lambda_38ce7e780aa69e748d6df282ebc68efe_ *param_2,
          _lambda_8ca6da459f0f6780f1cff60fdc3d00e5_ *param_3)

{
  uint _FileHandle;
  intptr_t iVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  int iVar5;
  
  iVar5 = 0;
  ___acrt_lowio_lock_fh(*(undefined4 *)param_1);
  _FileHandle = **(uint **)param_2;
  if ((*(byte *)(*(int *)(((int)_FileHandle >> 6) * 4 + 0x414e68) + 0x28 +
                (_FileHandle & 0x3f) * 0x30) & 1) != 0) {
    iVar1 = __get_osfhandle(_FileHandle);
    iVar2 = (*(code *)0xff107501)(iVar1);
    if (iVar2 != 0) goto LAB_0041455e;
    puVar3 = (undefined4 *)FUN_0040eef0();
    uVar4 = (*(code *)0x414cb805)();
    *puVar3 = uVar4;
  }
  puVar3 = (undefined4 *)FUN_0040ef03();
  *puVar3 = 9;
  iVar5 = -1;
LAB_0041455e:
  FUN_0041457a();
  return iVar5;
}



void FUN_0041457a(void)

{
  int unaff_EBP;
  
  ___acrt_lowio_unlock_fh(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  __commit
// 
// Library: Visual Studio 2017 Release

int __cdecl __commit(int _FileHandle)

{
  undefined4 *puVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 9;
  }
  else {
    if (((-1 < _FileHandle) && ((uint)_FileHandle < 0x8b0c4d8b)) &&
       ((*(byte *)(*(int *)((_FileHandle >> 6) * 4 + 0x414e68) + 0x28 + (_FileHandle & 0x3fU) * 0x30
                  ) & 1) != 0)) {
      local_10 = &_FileHandle;
      local_c = _FileHandle;
      local_14 = _FileHandle;
      iVar2 = __crt_seh_guarded_call<int>::
              operator___class__lambda_9e9de3de5fa147e2223d7db92bc10aa6__class__lambda_38ce7e780aa69e748d6df282ebc68efe___class__lambda_8ca6da459f0f6780f1cff60fdc3d00e5___
                        (&local_5,(_lambda_9e9de3de5fa147e2223d7db92bc10aa6_ *)&local_14,
                         (_lambda_38ce7e780aa69e748d6df282ebc68efe_ *)&local_10,
                         (_lambda_8ca6da459f0f6780f1cff60fdc3d00e5_ *)&local_c);
      return iVar2;
    }
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 9;
    FUN_0040ee46();
  }
  return -1;
}



void FUN_00414605(undefined4 *param_1,uint param_2,byte *param_3,int param_4)

{
  byte bVar1;
  byte *pbVar2;
  undefined4 uVar3;
  ushort *puVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  int iVar8;
  int iVar9;
  byte *pbVar10;
  byte *pbVar11;
  undefined4 uVar12;
  uint local_28;
  byte *local_24;
  undefined2 local_20;
  undefined2 local_1c [2];
  undefined local_18 [8];
  byte local_10;
  undefined local_f;
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  iVar8 = (int)param_2 >> 6;
  iVar9 = (param_2 & 0x3f) * 0x30;
  uVar7 = *(undefined4 *)(*(int *)(iVar8 * 4 + 0x414e68) + 0x18 + iVar9);
  pbVar2 = param_3 + param_4;
  uVar3 = (*(code *)0x15ff0875)();
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  if (param_3 < pbVar2) {
    local_24 = param_3 + 1;
    pbVar10 = param_3;
    do {
      local_1c[0] = 0;
      local_20 = local_20 & 0xff | (ushort)*pbVar10 << 8;
      iVar5 = *(int *)(iVar8 * 4 + 0x414e68);
      bVar1 = *(byte *)(iVar5 + 0x2d + iVar9);
      if ((bVar1 & 4) == 0) {
        puVar4 = ___pctype_func();
        if (-1 < (short)puVar4[*pbVar10]) {
          uVar12 = 1;
          pbVar11 = pbVar10;
          goto LAB_004146e1;
        }
        if (pbVar2 <= local_24) {
          *(byte *)(*(int *)(iVar8 * 4 + 0x414e68) + 0x2e + iVar9) = *pbVar10;
          pbVar2 = (byte *)(*(int *)(iVar8 * 4 + 0x414e68) + 0x2d + iVar9);
          *pbVar2 = *pbVar2 | 4;
          param_1[1] = param_1[1] + 1;
          break;
        }
        iVar5 = FUN_004132d4(local_1c,pbVar10,2);
        if (iVar5 == -1) break;
        pbVar10 = pbVar10 + 1;
        local_24 = local_24 + 1;
      }
      else {
        local_10 = *(byte *)(iVar5 + 0x2e + iVar9);
        uVar6 = CONCAT11(*pbVar10,bVar1) & 0xfffffffb;
        uVar12 = 2;
        local_f = (undefined)(uVar6 >> 8);
        *(char *)(iVar5 + 0x2d + iVar9) = (char)uVar6;
        pbVar11 = &local_10;
LAB_004146e1:
        iVar5 = FUN_004132d4(local_1c,pbVar11,uVar12);
        if (iVar5 == -1) break;
      }
      pbVar10 = pbVar10 + 1;
      local_24 = local_24 + 1;
      uVar6 = (*(code *)0x12750010)(uVar3,0,local_1c,1,local_18,5,0,0);
      if (uVar6 == 0) break;
      iVar5 = (*(code *)0xff8bc35d)(uVar7,local_18,uVar6,&local_28,0);
      if (iVar5 == 0) {
LAB_004147ae:
        uVar7 = (*(code *)0x414cb805)();
        *param_1 = uVar7;
        break;
      }
      param_1[1] = pbVar10 + (param_1[2] - (int)param_3);
      if (local_28 < uVar6) break;
      if (local_20._1_1_ == '\n') {
        local_20 = 0xd;
        iVar5 = (*(code *)0xff8bc35d)(uVar7,&local_20,1,&local_28,0);
        if (iVar5 == 0) goto LAB_004147ae;
        if (local_28 == 0) break;
        param_1[2] = param_1[2] + 1;
        param_1[1] = param_1[1] + 1;
      }
    } while (pbVar10 < pbVar2);
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  struct `anonymous namespace'::write_result __cdecl write_double_translated_unicode_nolock(char
// const * const,unsigned int)
//  struct `anonymous namespace'::write_result __cdecl write_double_translated_unicode_nolock(char
// const * const,unsigned int)
// 
// Library: Visual Studio 2015 Release

undefined4 * write_double_translated_unicode_nolock(undefined4 *param_1,short *param_2,int param_3)

{
  short sVar1;
  short sVar2;
  short *psVar3;
  undefined4 uVar4;
  
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  psVar3 = (short *)(param_3 + (int)param_2);
  if (param_2 < psVar3) {
    do {
      sVar2 = *param_2;
      sVar1 = FUN_004155e2(sVar2);
      if (sVar1 != sVar2) {
LAB_00414825:
        uVar4 = (*(code *)0x414cb805)();
        *param_1 = uVar4;
        return param_1;
      }
      param_1[1] = param_1[1] + 2;
      if (sVar2 == 10) {
        sVar2 = FUN_004155e2(0xd);
        if (sVar2 != 0xd) goto LAB_00414825;
        param_1[1] = param_1[1] + 1;
        param_1[2] = param_1[2] + 1;
      }
      param_2 = param_2 + 1;
    } while (param_2 < psVar3);
  }
  return param_1;
}



uint FUN_00414836(uint param_1)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  undefined local_8 [4];
  
  iVar1 = __isatty(param_1);
  if (iVar1 == 0) {
    uVar3 = 0;
  }
  else {
    iVar4 = (int)param_1 >> 6;
    iVar1 = (param_1 & 0x3f) * 0x30;
    uVar3 = *(uint *)(iVar4 * 4 + 0x414e68);
    if ((*(char *)(uVar3 + 0x28 + iVar1) < '\0') &&
       ((iVar2 = FUN_0040fd7d(), *(int *)(*(int *)(iVar2 + 0x4c) + 0xa8) != 0 ||
        (uVar3 = *(uint *)(iVar4 * 4 + 0x414e68), *(char *)(uVar3 + 0x29 + iVar1) != '\0')))) {
      uVar3 = FUN_0040e018(*(undefined4 *)(*(int *)(iVar4 * 4 + 0x414e68) + 0x18 + iVar1),local_8);
      uVar3 = uVar3 & 0xffffff00 | (uint)(uVar3 != 0);
    }
    else {
      uVar3 = uVar3 & 0xffffff00;
    }
  }
  return uVar3;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Multiple Matches With Same Base Name
//  struct `anonymous namespace'::write_result __cdecl write_text_ansi_nolock(int,char const *
// const,unsigned int)
//  struct `anonymous namespace'::write_result __cdecl write_text_ansi_nolock(int,char const *
// const,unsigned int)
// 
// Library: Visual Studio 2015 Release

void write_text_ansi_nolock(undefined4 *param_1,uint param_2,char *param_3,int param_4)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  char *pcVar4;
  uint local_1410;
  char *local_140c;
  char local_1408 [5120];
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  uVar3 = *(undefined4 *)
           (*(int *)(((int)param_2 >> 6) * 4 + 0x414e68) + 0x18 + (param_2 & 0x3f) * 0x30);
  *param_1 = 0;
  local_140c = param_3 + param_4;
  param_1[1] = 0;
  param_1[2] = 0;
  do {
    if (local_140c <= param_3) break;
    pcVar4 = local_1408;
    do {
      if (local_140c <= param_3) break;
      cVar1 = *param_3;
      param_3 = param_3 + 1;
      if (cVar1 == '\n') {
        param_1[2] = param_1[2] + 1;
        *pcVar4 = '\r';
        pcVar4 = pcVar4 + 1;
      }
      *pcVar4 = cVar1;
      pcVar4 = pcVar4 + 1;
    } while (pcVar4 < local_1408 + 0x13ff);
    iVar2 = (*(code *)0xff8bc35d)(uVar3,local_1408,(int)pcVar4 - (int)local_1408,&local_1410,0);
    if (iVar2 == 0) {
      uVar3 = (*(code *)0x414cb805)();
      *param_1 = uVar3;
      break;
    }
    param_1[1] = param_1[1] + local_1410;
  } while ((uint)((int)pcVar4 - (int)local_1408) <= local_1410);
  ___security_check_cookie_4();
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

void FUN_0041498b(undefined4 *param_1,uint param_2,short *param_3,int param_4)

{
  short sVar1;
  int iVar2;
  undefined4 uVar3;
  short *psVar4;
  uint local_1410;
  short *local_140c;
  short local_1408 [2560];
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  uVar3 = *(undefined4 *)
           (*(int *)(((int)param_2 >> 6) * 4 + 0x414e68) + 0x18 + (param_2 & 0x3f) * 0x30);
  local_140c = (short *)(param_4 + (int)param_3);
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  do {
    if (local_140c <= param_3) break;
    psVar4 = local_1408;
    do {
      if (local_140c <= param_3) break;
      sVar1 = *param_3;
      param_3 = param_3 + 1;
      if (sVar1 == 10) {
        param_1[2] = param_1[2] + 2;
        *psVar4 = 0xd;
        psVar4 = psVar4 + 1;
      }
      *psVar4 = sVar1;
      psVar4 = psVar4 + 1;
    } while (psVar4 < local_1408 + 0x9ff);
    iVar2 = (*(code *)0xff8bc35d)(uVar3,local_1408,(int)psVar4 - (int)local_1408,&local_1410,0);
    if (iVar2 == 0) {
      uVar3 = (*(code *)0x414cb805)();
      *param_1 = uVar3;
      break;
    }
    param_1[1] = param_1[1] + local_1410;
  } while ((uint)((int)psVar4 - (int)local_1408) <= local_1410);
  ___security_check_cookie_4();
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Multiple Matches With Same Base Name
//  struct `anonymous namespace'::write_result __cdecl write_text_utf8_nolock(int,char const *
// const,unsigned int)
//  struct `anonymous namespace'::write_result __cdecl write_text_utf8_nolock(int,char const *
// const,unsigned int)
// 
// Library: Visual Studio 2015 Release

void write_text_utf8_nolock(undefined4 *param_1,uint param_2,short *param_3,int param_4)

{
  short sVar1;
  short *psVar2;
  uint uVar3;
  int iVar4;
  undefined4 uVar5;
  uint uVar6;
  short *psVar7;
  int local_1418;
  undefined4 local_1414;
  short *local_1410;
  undefined local_140c [3416];
  short local_6b4 [854];
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  local_1414 = *(undefined4 *)
                (*(int *)(((int)param_2 >> 6) * 4 + 0x414e68) + 0x18 + (param_2 & 0x3f) * 0x30);
  local_1410 = (short *)(param_4 + (int)param_3);
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  psVar7 = param_3;
  if (param_3 < local_1410) {
    do {
      uVar6 = 0;
      psVar2 = local_6b4;
      do {
        if (local_1410 <= psVar7) break;
        sVar1 = *psVar7;
        psVar7 = psVar7 + 1;
        if (sVar1 == 10) {
          *psVar2 = 0xd;
          psVar2 = psVar2 + 1;
        }
        *psVar2 = sVar1;
        psVar2 = psVar2 + 1;
      } while (psVar2 < local_6b4 + 0x354);
      uVar3 = (*(code *)0x12750010)
                        (0xfde9,0,local_6b4,(int)psVar2 - (int)local_6b4 >> 1,local_140c,0xd55,0,0);
      if (uVar3 == 0) {
LAB_00414b8b:
        uVar5 = (*(code *)0x414cb805)();
        *param_1 = uVar5;
        break;
      }
      do {
        iVar4 = (*(code *)0xff8bc35d)(local_1414,local_140c + uVar6,uVar3 - uVar6,&local_1418,0);
        if (iVar4 == 0) goto LAB_00414b8b;
        uVar6 = uVar6 + local_1418;
      } while (uVar6 < uVar3);
      param_1[1] = (int)psVar7 - (int)param_3;
    } while (psVar7 < local_1410);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __write
// 
// Library: Visual Studio 2017 Release

int __cdecl __write(int _FileHandle,void *_Buf,uint _MaxCharCount)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_0040eef0();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < 0x8b0c4d8b)) {
      iVar2 = (_FileHandle & 0x3fU) * 0x30;
      if ((*(byte *)(*(int *)((_FileHandle >> 6) * 4 + 0x414e68) + 0x28 + iVar2) & 1) != 0) {
        ___acrt_lowio_lock_fh(_FileHandle);
        iVar3 = -1;
        if ((*(byte *)(*(int *)((_FileHandle >> 6) * 4 + 0x414e68) + 0x28 + iVar2) & 1) == 0) {
          puVar1 = (undefined4 *)FUN_0040ef03();
          *puVar1 = 9;
          puVar1 = (undefined4 *)FUN_0040eef0();
          *puVar1 = 0;
        }
        else {
          iVar3 = FUN_00414c8e(_FileHandle,_Buf,_MaxCharCount);
        }
        FUN_00414c65();
        return iVar3;
      }
    }
    puVar1 = (undefined4 *)FUN_0040eef0();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 9;
    FUN_0040ee46();
  }
  return -1;
}



void FUN_00414c65(void)

{
  ___acrt_lowio_unlock_fh();
  return;
}



void FUN_00414c8e(uint param_1,char *param_2,uint param_3)

{
  char cVar1;
  char *pcVar2;
  char cVar3;
  undefined4 *puVar4;
  int *piVar5;
  int iVar6;
  int local_30;
  undefined4 local_2c;
  undefined4 uStack40;
  int local_24;
  int local_20;
  int local_1c;
  uint local_18;
  int local_14;
  int local_10;
  char *local_c;
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  local_c = param_2;
  local_18 = param_3;
  if (param_3 == 0) goto LAB_00414e91;
  if (param_2 == (char *)0x0) {
    puVar4 = (undefined4 *)FUN_0040eef0();
    *puVar4 = 0;
    puVar4 = (undefined4 *)FUN_0040ef03();
    *puVar4 = 0x16;
    FUN_0040ee46();
    goto LAB_00414e91;
  }
  local_10 = (int)param_1 >> 6;
  local_14 = (param_1 & 0x3f) * 0x30;
  iVar6 = *(int *)(local_10 * 4 + 0x414e68);
  cVar1 = *(char *)(iVar6 + 0x29 + local_14);
  if (((cVar1 == '\x02') || (cVar1 == '\x01')) && ((~param_3 & 1) == 0)) {
    puVar4 = (undefined4 *)FUN_0040eef0();
    *puVar4 = 0;
    puVar4 = (undefined4 *)FUN_0040ef03();
    *puVar4 = 0x16;
    FUN_0040ee46();
    goto LAB_00414e91;
  }
  if ((*(byte *)(iVar6 + 0x28 + local_14) & 0x20) != 0) {
    __lseeki64_nolock(param_1,0,2);
  }
  local_24 = 0;
  local_20 = 0;
  local_1c = 0;
  cVar3 = FUN_00414836(param_1);
  pcVar2 = local_c;
  if (cVar3 == '\0') {
    iVar6 = *(int *)(local_10 * 4 + 0x414e68);
    if (*(char *)(iVar6 + 0x28 + local_14) < '\0') {
      if (cVar1 == '\0') {
        piVar5 = (int *)write_text_ansi_nolock(&local_30,param_1,local_c,local_18);
      }
      else if (cVar1 == '\x01') {
        piVar5 = (int *)write_text_utf8_nolock(&local_30,param_1,local_c,local_18);
      }
      else {
        if (cVar1 != '\x02') goto LAB_00414e2b;
        piVar5 = (int *)FUN_0041498b(&local_30,param_1,local_c,local_18);
      }
    }
    else {
      local_30 = 0;
      local_2c = 0;
      uStack40 = 0;
      iVar6 = (*(code *)0xff8bc35d)
                        (*(undefined4 *)(iVar6 + 0x18 + local_14),local_c,local_18,&local_2c,0);
      if (iVar6 == 0) {
        local_30 = (*(code *)0x414cb805)();
      }
      piVar5 = &local_30;
    }
LAB_00414e1f:
    local_24 = *piVar5;
    local_20 = piVar5[1];
    local_1c = piVar5[2];
  }
  else {
    if (cVar1 == '\0') {
      piVar5 = (int *)FUN_00414605(&local_30,param_1,local_c,local_18);
      goto LAB_00414e1f;
    }
    if ((byte)(cVar1 - 1U) < 2) {
      piVar5 = (int *)write_double_translated_unicode_nolock(&local_30,local_c,local_18);
      goto LAB_00414e1f;
    }
  }
LAB_00414e2b:
  if (local_20 == 0) {
    if (local_24 == 0) {
      if (((*(byte *)(*(int *)(local_10 * 4 + 0x414e68) + 0x28 + local_14) & 0x40) == 0) ||
         (*pcVar2 != '\x1a')) {
        puVar4 = (undefined4 *)FUN_0040ef03();
        *puVar4 = 0x1c;
        puVar4 = (undefined4 *)FUN_0040eef0();
        *puVar4 = 0;
      }
    }
    else if (local_24 == 5) {
      puVar4 = (undefined4 *)FUN_0040ef03();
      *puVar4 = 9;
      puVar4 = (undefined4 *)FUN_0040eef0();
      *puVar4 = 5;
    }
    else {
      ___acrt_errno_map_os_error(local_24);
    }
  }
LAB_00414e91:
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_stdio_free_buffer_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_stdio_free_buffer_nolock(undefined4 *param_1)

{
  uint *puVar1;
  
  puVar1 = param_1 + 3;
  if (((*puVar1 >> 0xd & 1) != 0) && ((*puVar1 >> 6 & 1) != 0)) {
    FID_conflict__free((void *)param_1[1]);
    LOCK();
    *puVar1 = *puVar1 & 0xfffffebf;
    param_1[1] = 0;
    *param_1 = 0;
    param_1[2] = 0;
  }
  return;
}



// Library Function - Single Match
//  __isatty
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __isatty(int _FileHandle)

{
  undefined4 *puVar1;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < 0x8b0c4d8b)) {
      return *(byte *)(*(int *)((_FileHandle >> 6) * 4 + 0x414e68) + 0x28 +
                      (_FileHandle & 0x3fU) * 0x30) & 0x40;
    }
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 9;
    FUN_0040ee46();
  }
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Removing unreachable block (ram,0x00414fe9)
// WARNING: Removing unreachable block (ram,0x0041503a)
// WARNING: Removing unreachable block (ram,0x00414ff0)
// WARNING: Removing unreachable block (ram,0x00414ff9)
// Library Function - Single Match
//  ___set_fpsr_sse2
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release

void ___set_fpsr_sse2(void)

{
  return;
}



// Library Function - Single Match
//  __clrfp
// 
// Library: Visual Studio 2015 Release

int __clrfp(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// Library Function - Single Match
//  __ctrlfp
// 
// Library: Visual Studio 2015 Release

int __ctrlfp(void)

{
  short in_FPUControlWord;
  
  return (int)in_FPUControlWord;
}



// Library Function - Single Match
//  __set_statfp
// 
// Library: Visual Studio 2017 Release

void __set_statfp(void)

{
  return;
}



// Library Function - Single Match
//  __statfp
// 
// Library: Visual Studio 2015 Release

int __statfp(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// Library Function - Single Match
//  __isleadbyte_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __isleadbyte_l(int _C,_locale_t _Locale)

{
  ushort uVar1;
  int local_14;
  int *local_10;
  char local_8;
  
  FUN_0040eb24(_Locale);
  uVar1 = *(ushort *)(*local_10 + (_C & 0xffU) * 2);
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return uVar1 & 0x8000;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041512f(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,undefined4 param_6)

{
  (*common_exit)(param_1,param_2,param_3,param_4,param_5,param_6);
  return;
}



// WARNING: Removing unreachable block (ram,0x0041515d)
// WARNING: Removing unreachable block (ram,0x0041517a)
// WARNING: Removing unreachable block (ram,0x00415163)
// WARNING: Removing unreachable block (ram,0x00415180)
// WARNING: Removing unreachable block (ram,0x0041519e)
// WARNING: Removing unreachable block (ram,0x0041518a)
// Library Function - Single Match
//  __strnicmp
// 
// Library: Visual Studio 2017 Release

int __cdecl __strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  int iVar1;
  
  iVar1 = __strnicmp_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  __strnicmp_l
// 
// Library: Visual Studio 2017 Release

int __cdecl __strnicmp_l(char *_Str1,char *_Str2,size_t _MaxCount,_locale_t _Locale)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int local_14;
  localeinfo_struct local_10;
  char local_8;
  
  if (_MaxCount == 0) {
    iVar3 = 0;
  }
  else {
    FUN_0040eb24(_Locale);
    iVar3 = 0x7fffffff;
    if (((_Str1 == (char *)0x0) || (_Str2 == (char *)0x0)) || (0x7fffffff < _MaxCount)) {
      puVar1 = (undefined4 *)FUN_0040ef03();
      *puVar1 = 0x16;
      FUN_0040ee46();
    }
    else if ((local_10.locinfo)->locale_name[2] == (wchar_t *)0x0) {
      iVar3 = ___ascii_strnicmp(_Str1,_Str2,_MaxCount);
    }
    else {
      iVar4 = (int)_Str1 - (int)_Str2;
      do {
        iVar3 = __tolower_l((uint)((byte *)_Str2)[iVar4],&local_10);
        iVar2 = __tolower_l((uint)(byte)*_Str2,&local_10);
        _Str2 = (char *)((byte *)_Str2 + 1);
        _MaxCount = _MaxCount - 1;
        if ((_MaxCount == 0) || (iVar3 == 0)) break;
      } while (iVar3 == iVar2);
      iVar3 = iVar3 - iVar2;
    }
    if (local_8 != '\0') {
      *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
    }
  }
  return iVar3;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe

void FUN_00415272(int *param_1,undefined4 param_2,undefined4 param_3,byte *param_4,uint *param_5,
                 byte *param_6,uint *param_7,byte *param_8)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  byte **ppbVar4;
  int iVar5;
  byte *pbVar6;
  byte **ppbVar7;
  byte *pbStack84;
  undefined4 uStack80;
  byte *pbStack76;
  uint *puStack72;
  byte *pbStack68;
  uint *puStack64;
  byte **local_20;
  uint local_1c;
  byte local_16 [14];
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  if ((int)param_5 < 1) {
    if ((int)param_5 < -1) goto LAB_004154d1;
  }
  else {
    puStack64 = param_5;
    pbStack68 = param_4;
    puStack72 = (uint *)0x4152ad;
    param_5 = (uint *)___strncnt();
  }
  if ((int)param_7 < 1) {
    if ((int)param_7 < -1) goto LAB_004154d1;
  }
  else {
    puStack64 = param_7;
    pbStack68 = param_6;
    puStack72 = (uint *)0x4152c2;
    param_7 = (uint *)___strncnt();
  }
  if (param_8 == (byte *)0x0) {
    param_8 = *(byte **)(*param_1 + 8);
  }
  if ((param_5 == (uint *)0x0) || (param_7 == (uint *)0x0)) {
    if (param_5 == param_7) {
      puStack64 = (uint *)0x2;
      goto LAB_004154d1;
    }
    if (1 < (int)param_7) goto LAB_004154d1;
    if ((int)param_5 < 2) {
      puStack64 = &local_1c;
      puStack72 = (uint *)0x415324;
      pbStack68 = param_8;
      iVar1 = (*(code *)0x107d83ff)();
      if (iVar1 == 0) goto LAB_004154d1;
      if ((int)param_5 < 1) {
        if (0 < (int)param_7) {
          puStack64 = (uint *)0x2;
          if ((1 < local_1c) && (pbVar6 = local_16, local_16[0] != 0)) {
            while (pbVar6[1] != 0) {
              if (((*pbVar6 <= *param_6) && (*param_6 <= pbVar6[1])) ||
                 (pbVar6 = pbVar6 + 2, *pbVar6 == 0)) break;
            }
          }
          goto LAB_004154d1;
        }
        goto LAB_00415394;
      }
      puStack64 = (uint *)0x2;
      if (1 < local_1c) {
        pbVar6 = local_16;
        while ((local_16[0] != 0 && (pbVar6[1] != 0))) {
          if ((*pbVar6 <= *param_4) && (*param_4 <= pbVar6[1])) goto LAB_004154d1;
          pbVar6 = pbVar6 + 2;
          local_16[0] = *pbVar6;
        }
      }
    }
    puStack64 = (uint *)0x3;
    goto LAB_004154d1;
  }
LAB_00415394:
  puStack64 = (uint *)0x0;
  pbStack68 = (byte *)0x0;
  pbStack76 = param_4;
  uStack80 = 9;
  pbStack84 = param_8;
  puStack72 = param_5;
  iVar1 = (*(code *)0x7d8318ec)();
  if (iVar1 == 0) goto LAB_004154d1;
  uVar2 = iVar1 * 2 + 8;
  uVar2 = -(uint)((uint)(iVar1 * 2) < uVar2) & uVar2;
  if (uVar2 == 0) {
    local_20 = (byte **)0x0;
  }
  else if (uVar2 < 0x401) {
    ppbVar7 = &pbStack84;
    local_20 = &pbStack84;
    if (&stack0x00000000 != (undefined *)0x54) {
      pbStack84 = (byte *)0xcccc;
LAB_004153f3:
      local_20 = ppbVar7 + 2;
    }
  }
  else {
    ppbVar7 = (byte **)__malloc_base(uVar2);
    local_20 = ppbVar7;
    if (ppbVar7 != (byte **)0x0) {
      *ppbVar7 = (byte *)0xdddd;
      goto LAB_004153f3;
    }
  }
  if (((local_20 != (byte **)0x0) &&
      (iVar3 = (*(code *)0x7d8318ec)(param_8,1,param_4,param_5,local_20,iVar1), iVar3 != 0)) &&
     (iVar3 = (*(code *)0x7d8318ec)(param_8,9,param_6,param_7,0,0), iVar3 != 0)) {
    uVar2 = iVar3 * 2 + 8;
    uVar2 = -(uint)((uint)(iVar3 * 2) < uVar2) & uVar2;
    if (uVar2 == 0) {
      ppbVar7 = (byte **)0x0;
LAB_00415481:
      if ((ppbVar7 != (byte **)0x0) &&
         (iVar5 = (*(code *)0x7d8318ec)(param_8,1,param_6,param_7,ppbVar7,iVar3), iVar5 != 0)) {
        ___acrt_CompareStringEx_36(param_2,param_3,local_20,iVar1,ppbVar7,iVar3,0,0,0);
      }
    }
    else if (uVar2 < 0x401) {
      ppbVar4 = &pbStack84;
      ppbVar7 = &pbStack84;
      if (&stack0x00000000 != (undefined *)0x54) {
        pbStack84 = (byte *)0xcccc;
LAB_0041547a:
        ppbVar7 = ppbVar4 + 2;
        goto LAB_00415481;
      }
    }
    else {
      ppbVar4 = (byte **)__malloc_base(uVar2);
      ppbVar7 = ppbVar4;
      if (ppbVar4 != (byte **)0x0) {
        *ppbVar4 = (byte *)0xdddd;
        goto LAB_0041547a;
      }
    }
    FUN_004119fb(ppbVar7);
  }
  FUN_004119fb(local_20);
LAB_004154d1:
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_CompareStringA
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_CompareStringA
               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8)

{
  int local_14;
  undefined local_10 [8];
  char local_8;
  
  FUN_0040eb24(param_1);
  FUN_00415272(local_10,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  ___strncnt
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___strncnt(char *param_1,int param_2)

{
  char cVar1;
  int iVar2;
  
  iVar2 = 0;
  cVar1 = *param_1;
  while ((cVar1 != '\0' && (iVar2 != param_2))) {
    iVar2 = iVar2 + 1;
    cVar1 = param_1[iVar2];
  }
  return;
}



// Library Function - Single Match
//  __int64 __cdecl common_lseek_nolock<__int64>(int,__int64,int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

__int64 __cdecl common_lseek_nolock___int64_(int param_1,__int64 param_2,int param_3)

{
  byte *pbVar1;
  intptr_t iVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined4 uVar5;
  uint local_c;
  uint local_8;
  
  iVar2 = __get_osfhandle(param_1);
  if (iVar2 == -1) {
    puVar3 = (undefined4 *)FUN_0040ef03();
    *puVar3 = 9;
  }
  else {
    iVar4 = (*(code *)0x6cd)(iVar2,param_2,&local_c,param_3);
    if (iVar4 == 0) {
      uVar5 = (*(code *)0x414cb805)();
      ___acrt_errno_map_os_error(uVar5);
    }
    else if ((local_c & local_8) != 0xffffffff) {
      pbVar1 = (byte *)(*(int *)((param_1 >> 6) * 4 + 0x414e68) + 0x28 + (param_1 & 0x3fU) * 0x30);
      *pbVar1 = *pbVar1 & 0xfd;
      goto LAB_004155c1;
    }
  }
  local_c = 0xffffffff;
  local_8 = 0xffffffff;
LAB_004155c1:
  return CONCAT44(local_8,local_c);
}



// Library Function - Single Match
//  __lseeki64_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

longlong __cdecl __lseeki64_nolock(int _FileHandle,longlong _Offset,int _Origin)

{
  __int64 _Var1;
  
  _Var1 = common_lseek_nolock___int64_(_FileHandle,_Offset,_Origin);
  return _Var1;
}



uint FUN_004155e2(ushort param_1)

{
  int iVar1;
  uint uVar2;
  undefined local_8 [4];
  
  iVar1 = FUN_004159b9();
  if ((iVar1 != 0) && (uVar2 = FID_conflict____dcrt_read_console(&param_1,1,local_8), uVar2 != 0)) {
    return uVar2 & 0xffff0000 | (uint)param_1;
  }
  return 0xffff;
}



// Library Function - Single Match
//  __fclose_nolock
// 
// Library: Visual Studio 2017 Release

int __cdecl __fclose_nolock(FILE *_File)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  
  if (_File == (FILE *)0x0) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x16;
    FUN_0040ee46();
    iVar2 = -1;
  }
  else {
    iVar2 = -1;
    if (((uint)_File->_flag >> 0xd & 1) != 0) {
      iVar2 = ___acrt_stdio_flush_nolock(_File);
      ___acrt_stdio_free_buffer_nolock(_File);
      iVar3 = __fileno(_File);
      iVar3 = __close(iVar3);
      if (iVar3 < 0) {
        iVar2 = -1;
      }
      else if (_File->_tmpfname != (char *)0x0) {
        FID_conflict__free(_File->_tmpfname);
        _File->_tmpfname = (char *)0x0;
      }
    }
    __acrt_stdio_free_stream(SUB41(_File,0));
  }
  return iVar2;
}



// Library Function - Single Match
//  ___ascii_strnicmp
// 
// Library: Visual Studio 2017 Release

int __cdecl ___ascii_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  
  if (_MaxCount != 0) {
    do {
      bVar2 = *_Str1;
      bVar1 = *_Str2;
      if ((bVar2 == 0) || (bVar1 == 0)) break;
      _Str1 = (char *)((byte *)_Str1 + 1);
      _Str2 = (char *)((byte *)_Str2 + 1);
      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
        bVar2 = bVar2 + 0x20;
      }
      if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
        bVar1 = bVar1 + 0x20;
      }
      bVar3 = bVar2 < bVar1;
      if (bVar2 != bVar1) goto LAB_0041598a;
      _MaxCount = _MaxCount - 1;
    } while (_MaxCount != 0);
    _MaxCount = 0;
    bVar3 = bVar2 < bVar1;
    if (bVar2 != bVar1) {
LAB_0041598a:
      _MaxCount = 0xffffffff;
      if (!bVar3) {
        _MaxCount = 1;
      }
    }
  }
  return _MaxCount;
}



// Library Function - Multiple Matches With Different Base Names
//  void __cdecl __dcrt_lowio_initialize_console_input(void)
//  void __cdecl __dcrt_lowio_initialize_console_output(void)
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void FID_conflict___dcrt_lowio_initialize_console_input(void)

{
  uRam00414760 = (*(code *)0xe800414c)(0x411df8,0x40000000,3,0,3,0,0);
                    // WARNING: Read-only address (ram,0x00414760) is written
  return;
}



// WARNING: Removing unreachable block (ram,0x004159c4)

undefined4 FUN_004159b9(void)

{
  return 1;
}



// Library Function - Multiple Matches With Different Base Names
//  ___dcrt_terminate_console_input
//  ___dcrt_terminate_console_output
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void FID_conflict____dcrt_terminate_console_output(void)

{
  (*(code *)0x8dfe4d8d)(0x6a50dc45);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___dcrt_read_console
//  ___dcrt_write_console
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

int FID_conflict____dcrt_read_console(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  
  iVar1 = (*(code *)0xec680b75)(0x6a50dc45,param_1,param_2,param_3,0);
  if (iVar1 == 0) {
    iVar2 = (*(code *)0x414cb805)();
    if (iVar2 == 6) {
      FID_conflict____dcrt_terminate_console_output();
      FID_conflict___dcrt_lowio_initialize_console_input();
      iVar1 = (*(code *)0xec680b75)(0x6a50dc45,param_1,param_2,param_3,0);
    }
  }
  return iVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_218ce3db14220d0be481dae8ef3383b6>,class <lambda_628dfdc04ba53c8bfc02c9951375f3f5>&,class
// <lambda_57dc472bd5c9d5f3b2cbca59b8a843ae>>(class
// <lambda_218ce3db14220d0be481dae8ef3383b6>&&,class
// <lambda_628dfdc04ba53c8bfc02c9951375f3f5>&,class <lambda_57dc472bd5c9d5f3b2cbca59b8a843ae>&&)
// 
// Library: Visual Studio 2017 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_218ce3db14220d0be481dae8ef3383b6__class__lambda_628dfdc04ba53c8bfc02c9951375f3f5___class__lambda_57dc472bd5c9d5f3b2cbca59b8a843ae___
          (__crt_seh_guarded_call_int_ *this,_lambda_218ce3db14220d0be481dae8ef3383b6_ *param_1,
          _lambda_628dfdc04ba53c8bfc02c9951375f3f5_ *param_2,
          _lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_ *param_3)

{
  uint _FileHandle;
  int iVar1;
  undefined4 *puVar2;
  
  ___acrt_lowio_lock_fh(*(undefined4 *)param_1);
  _FileHandle = **(uint **)param_2;
  if ((*(byte *)(*(int *)(((int)_FileHandle >> 6) * 4 + 0x414e68) + 0x28 +
                (_FileHandle & 0x3f) * 0x30) & 1) == 0) {
    puVar2 = (undefined4 *)FUN_0040ef03();
    *puVar2 = 9;
    iVar1 = -1;
  }
  else {
    iVar1 = __close_nolock(_FileHandle);
  }
  FUN_00415aba();
  return iVar1;
}



void FUN_00415aba(void)

{
  int unaff_EBP;
  
  ___acrt_lowio_unlock_fh(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  __close
// 
// Library: Visual Studio 2017 Release

int __cdecl __close(int _FileHandle)

{
  undefined4 *puVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_0040eef0();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 9;
  }
  else {
    if (((-1 < _FileHandle) && ((uint)_FileHandle < 0x8b0c4d8b)) &&
       ((*(byte *)(*(int *)((_FileHandle >> 6) * 4 + 0x414e68) + 0x28 + (_FileHandle & 0x3fU) * 0x30
                  ) & 1) != 0)) {
      local_10 = &_FileHandle;
      local_c = _FileHandle;
      local_14 = _FileHandle;
      iVar2 = __crt_seh_guarded_call<int>::
              operator___class__lambda_218ce3db14220d0be481dae8ef3383b6__class__lambda_628dfdc04ba53c8bfc02c9951375f3f5___class__lambda_57dc472bd5c9d5f3b2cbca59b8a843ae___
                        (&local_5,(_lambda_218ce3db14220d0be481dae8ef3383b6_ *)&local_14,
                         (_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ *)&local_10,
                         (_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_ *)&local_c);
      return iVar2;
    }
    puVar1 = (undefined4 *)FUN_0040eef0();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 9;
    FUN_0040ee46();
  }
  return -1;
}



// Library Function - Single Match
//  __close_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int __cdecl __close_nolock(int _FileHandle)

{
  intptr_t iVar1;
  intptr_t iVar2;
  int iVar3;
  
  iVar1 = __get_osfhandle(_FileHandle);
  if (iVar1 != -1) {
    if (((_FileHandle == 1) && ((DAT_800974c8 & 1) != 0)) ||
       ((_FileHandle == 2 && ((DAT_80097498 & 1) != 0)))) {
      iVar1 = __get_osfhandle(2);
      iVar2 = __get_osfhandle(1);
      if (iVar2 == iVar1) goto LAB_00415b6b;
    }
    iVar1 = __get_osfhandle(_FileHandle);
    iVar3 = (*(code *)0x8dfe4d8d)(iVar1);
    if (iVar3 == 0) {
      iVar3 = (*(code *)0x414cb805)();
      goto LAB_00415bbd;
    }
  }
LAB_00415b6b:
  iVar3 = 0;
LAB_00415bbd:
  __free_osfhnd(_FileHandle);
  *(undefined *)(*(int *)((_FileHandle >> 6) * 4 + 0x414e68) + 0x28 + (_FileHandle & 0x3fU) * 0x30)
       = 0;
  if (iVar3 == 0) {
    iVar3 = 0;
  }
  else {
    ___acrt_errno_map_os_error(iVar3);
    iVar3 = -1;
  }
  return iVar3;
}



// Library Function - Single Match
//  void __cdecl __acrt_stdio_free_stream(class __crt_stdio_stream)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl __acrt_stdio_free_stream(__crt_stdio_stream param_1)

{
  undefined3 in_stack_00000005;
  
  *_param_1 = 0;
  _param_1[1] = 0;
  _param_1[2] = 0;
  _param_1[4] = 0xffffffff;
  _param_1[5] = 0;
  _param_1[6] = 0;
  _param_1[7] = 0;
  _param_1[3] = 0;
  return;
}



// Library Function - Single Match
//  __CIlog10_pentium4
// 
// Library: Visual Studio

void __CIlog10_pentium4(void)

{
  float10 in_ST0;
  
  start((double)in_ST0);
  return;
}



// Library Function - Single Match
//  start
// 
// Library: Visual Studio 2015 Release

float10 start(double param_1)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  double dVar7;
  double dVar8;
  undefined in_XMM0 [16];
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double local_c;
  
  iVar4 = 0;
  while( true ) {
    uVar2 = (uint)(ushort)(SUB162(in_XMM0 >> 0x30,0) >> 4);
    dVar7 = (double)(SUB168(in_XMM0,0) & 0x8b55ff8bc310c483 | 0xffcc61e8530040e2);
    dVar8 = (double)(SUB168(in_XMM0,0) & 0x87d8b57565351ec | 0xd74c0850cc483ff);
    uVar1 = SUB82(dVar7 + -5.373849949687784e-294,0) & 0x7f0;
    dVar12 = (double)((ulonglong)dVar8 & 0x6a000008006800);
    dVar10 = (double)((ulonglong)dVar7 & 0x40f7f89d1c8b7deb) * *(double *)(uVar1 + 0x412440) -
             -1.804538335243427e-245;
    dVar7 = (dVar7 - (double)((ulonglong)dVar7 & 0x40f7f89d1c8b7deb)) *
            *(double *)(uVar1 + 0x412440);
    dVar9 = (dVar8 - dVar12) * *(double *)(uVar1 + 0x412448);
    dVar8 = dVar7 + dVar10;
    dVar12 = dVar9 + (dVar12 * *(double *)(uVar1 + 0x412448) - 7.461925053768913e-75);
    uVar3 = uVar2 - 1;
    if (uVar3 < 0x7fe) {
      iVar4 = (uVar2 - 0x3ff) + iVar4;
      dVar11 = (double)iVar4;
      iVar5 = 0;
      if (uVar1 + iVar4 * 0x400 == 0) {
        iVar5 = 0x10;
      }
      return (float10)(((dVar12 * -4.688256824479921e-254 + -1.301560362017528e-255) * dVar12 +
                       -2.59770304122807e+92) * dVar12 * dVar12 +
                       ((dVar8 * -3.36606440829417e+16 + 3.796199486712926e-171) * dVar8 +
                       -4.425656832514134e+307) * dVar8 * dVar8 * dVar8 * dVar8 * dVar8 +
                       dVar8 * -1.065130626544581e+211 +
                       *(double *)(uVar1 + 0x412038) + dVar11 * 1.871325155146762e+39 +
                       (double)((ulonglong)dVar9 & *(ulonglong *)(iVar5 + 0x411e68)) +
                      *(double *)(uVar1 + 0x412030) + dVar10 + dVar11 * -1.082476769420496e-255 +
                      (double)((ulonglong)dVar7 & *(ulonglong *)(iVar5 + 0x411e60)));
    }
    local_c = (double)-(ulonglong)(param_1 == 33728.68741766798);
    if (SUB82(local_c,0) != 0) break;
    if (uVar3 != 0xffffffff) {
      if (uVar3 < 0x7ff) {
        local_c = -4.688256178466265e-254;
        if ((double)((ulonglong)param_1 & 0x8b55ff8bc310c483 | 0xffcc61e8530040e2) ==
            -3.986167010786999e+307) {
          return (float10)-1.366277726645864e-284;
        }
        uVar6 = 0x3e9;
      }
      else if (((uVar2 & 0x7ff) < 0x7ff) ||
              ((SUB84(param_1,0) | (uint)((ulonglong)param_1 >> 0x20) & 0xfffff) == 0)) {
        local_c = -NAN;
        uVar6 = 9;
      }
      else {
        uVar6 = 0x3e9;
      }
      goto LAB_00415e73;
    }
    in_XMM0 = CONCAT88(dVar12,param_1 * -2.176234577080787e+41);
    iVar4 = -0x34;
  }
  local_c = 9.590130421638815e-273;
  uVar6 = 8;
LAB_00415e73:
  ___libm_error_support(&param_1,&param_1,&local_c,uVar6);
  return (float10)local_c;
}



float10 __fastcall
FUN_00416469(undefined4 param_1_00,undefined4 param_2_00,undefined2 param_1,undefined4 param_2,
            undefined4 param_3,undefined4 param_4,undefined4 param_5,undefined4 param_6)

{
  float10 in_ST0;
  undefined local_24 [8];
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  double local_c;
  
  local_14 = param_5;
  local_10 = param_6;
  local_c = (double)in_ST0;
  local_1c = param_3;
  local_18 = param_4;
  __87except(param_2_00,local_24,&param_1);
  return (float10)local_c;
}



float10 __fastcall
FUN_00416480(undefined4 param_1,undefined4 param_2,undefined2 param_3,undefined4 param_4,
            undefined4 param_5,undefined4 param_6)

{
  float10 in_ST0;
  undefined local_24 [8];
  undefined4 uStack28;
  undefined4 uStack24;
  double dStack12;
  
  dStack12 = (double)in_ST0;
  uStack28 = param_5;
  uStack24 = param_6;
  __87except(param_2,local_24,&param_3);
  return (float10)dStack12;
}



// WARNING: Removing unreachable block (ram,0x004164e9)
// Library Function - Single Match
//  ___libm_error_support
// 
// Library: Visual Studio 2015 Release

void ___libm_error_support(undefined8 *param_1,undefined8 *param_2,undefined8 *param_3,int param_4)

{
  undefined8 uVar1;
  code *pcVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 local_28;
  undefined4 local_24;
  undefined8 local_20;
  undefined8 local_18;
  undefined8 local_10;
  uint local_8;
  
  local_8 = (uint)&stack0xfffffffc ^ 0x74c08447;
  pcVar2 = (code *)(*(code *)0x1c15ff50)(0x1600);
  if (0x1a < param_4) {
    if (param_4 != 0x1b) {
      if (param_4 == 0x1c) {
        local_24 = 0x412004;
      }
      else if (param_4 == 0x31) {
        local_24 = 0x412018;
      }
      else if (param_4 == 0x3a) {
        local_24 = 0x412010;
      }
      else {
        if (param_4 != 0x3d) {
          if ((param_4 != 1000) && (param_4 != 0x3e9)) goto LAB_004166c4;
          uVar1 = *param_1;
          goto LAB_00416611;
        }
        local_24 = 0x412008;
      }
      goto LAB_00416530;
    }
    local_28 = 2;
LAB_00416682:
    local_24 = 0x412004;
    goto LAB_00416689;
  }
  if (param_4 == 0x1a) {
    uVar1 = 0x3ff0000000000000;
LAB_00416611:
    *param_3 = uVar1;
    goto LAB_004166c4;
  }
  if (param_4 < 0xf) {
    if (param_4 == 0xe) {
      local_28 = 3;
      local_24 = 0x412000;
    }
    else {
      if (param_4 != 2) {
        if (param_4 == 3) {
          local_24 = 0x411ff4;
        }
        else {
          if (param_4 == 8) {
            local_28 = 2;
            local_24 = 0x411ff8;
            goto LAB_00416689;
          }
          if (param_4 != 9) goto LAB_004166c4;
          local_24 = 0x411ff8;
        }
LAB_00416530:
        local_28 = 1;
        local_20 = *param_1;
        local_18 = *param_2;
        local_10 = *param_3;
        (*(code *)0xff0875ff)(&local_28);
        iVar3 = (*pcVar2)();
        if (iVar3 == 0) {
          puVar4 = (undefined4 *)FUN_0040ef03();
          *puVar4 = 0x21;
        }
        goto LAB_004166bf;
      }
      local_28 = 2;
      local_24 = 0x411ff4;
    }
LAB_00416689:
    local_20 = *param_1;
    local_18 = *param_2;
    local_10 = *param_3;
    (*(code *)0xff0875ff)(&local_28);
    iVar3 = (*pcVar2)();
    if (iVar3 == 0) {
      puVar4 = (undefined4 *)FUN_0040ef03();
      *puVar4 = 0x22;
    }
  }
  else {
    if (param_4 == 0xf) {
      local_24 = 0x412000;
    }
    else {
      if (param_4 == 0x18) {
        local_28 = 3;
        goto LAB_00416682;
      }
      if (param_4 != 0x19) goto LAB_004166c4;
      local_24 = 0x412004;
    }
    local_28 = 4;
    local_20 = *param_1;
    local_18 = *param_2;
    local_10 = *param_3;
    (*(code *)0xff0875ff)(&local_28);
    (*pcVar2)();
  }
LAB_004166bf:
  *param_3 = local_10;
LAB_004166c4:
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  __ceil_default
// 
// Library: Visual Studio 2015 Release

float10 __ceil_default(double param_1)

{
  uint uVar1;
  int iVar2;
  float10 fVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  
  uVar1 = __ctrlfp(0x1b3f,0xffff);
  if ((param_1._6_2_ & 0x7ff0) == 0x7ff0) {
    iVar2 = __sptype();
    if (iVar2 - 1U < 3) {
      __ctrlfp(uVar1,0xffff);
      return (float10)param_1;
    }
    uVar5 = SUB84(param_1 + 6.661824445939716e-268,0);
    uVar6 = (undefined4)((ulonglong)(param_1 + 6.661824445939716e-268) >> 0x20);
    uVar4 = 8;
  }
  else {
    fVar3 = (float10)__frnd(SUB84(param_1,0),(int)((ulonglong)param_1 >> 0x20));
    if (((float10)param_1 == fVar3) || ((uVar1 & 0x20) != 0)) {
      __ctrlfp(uVar1,0xffff);
      return (float10)(double)fVar3;
    }
    uVar5 = SUB84((double)fVar3,0);
    uVar6 = (undefined4)((ulonglong)(double)fVar3 >> 0x20);
    uVar4 = 0x10;
  }
  fVar3 = (float10)__except1(uVar4,0xc,param_1,uVar5,uVar6,uVar1);
  return fVar3;
}



// Library Function - Single Match
//  __d_inttype
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 __d_inttype(double param_1)

{
  uint uVar1;
  float10 fVar2;
  undefined8 extraout_var;
  double dVar3;
  
  uVar1 = __fpclass(param_1);
  if ((uVar1 & 0x90) == 0) {
    fVar2 = (float10)__frnd(param_1,extraout_var);
    if ((float10)param_1 == fVar2) {
      dVar3 = (double)((float10)param_1 * (float10)1.280880428129783e+63);
      fVar2 = (float10)__frnd();
      if ((float10)dVar3 == fVar2) {
        return 2;
      }
      return 1;
    }
  }
  return 0;
}



// Library Function - Single Match
//  __powhlp
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 __powhlp(int param_1,int param_2_00,int param_2,int param_4,undefined8 *param_3)

{
  double dVar1;
  undefined8 uVar2;
  int iVar3;
  
  dVar1 = ABS((double)CONCAT44(param_2_00,param_1));
  if (param_4 == 0x7ff00000) {
    if (param_2 != 0) goto LAB_0041688b;
    uVar2 = 0x3ff0000000000000;
    if (dVar1 <= 1.0) {
      if ((ushort)((ushort)(1.0 < dVar1) << 8 | (ushort)(dVar1 == 1.0) << 0xe) == 0) {
        uVar2 = 0;
      }
      goto LAB_0041691c;
    }
  }
  else {
    if ((param_4 == -0x100000) && (param_2 == 0)) {
      if (dVar1 <= 1.0) {
        uVar2 = 0x3ff0000000000000;
        if ((ushort)((ushort)(1.0 < dVar1) << 8 | (ushort)(dVar1 == 1.0) << 0xe) == 0) {
          uVar2 = 0x7401a80de8c1c18b;
        }
      }
      else {
        uVar2 = 0;
      }
      goto LAB_0041691c;
    }
LAB_0041688b:
    if (param_2_00 != 0x7ff00000) {
      if (param_2_00 != -0x100000) {
        return 0;
      }
      if (param_1 != 0) {
        return 0;
      }
      iVar3 = __d_inttype(CONCAT44(param_4,param_2));
      uVar2 = 0;
      dVar1 = (double)CONCAT44(param_4,param_2);
      if ((ushort)((ushort)(dVar1 < 0.0) << 8 | (ushort)(dVar1 == 0.0) << 0xe) == 0) {
        uVar2 = 0x7401a80de8c1c18b;
        if (iVar3 == 1) {
          uVar2 = 0xf401a80de8c1c18b;
        }
      }
      else if (0.0 <= dVar1) {
        uVar2 = 0x3ff0000000000000;
      }
      else if (iVar3 == 1) {
        uVar2 = 0xff0c458b0775c084;
      }
      goto LAB_0041691c;
    }
    if (param_1 != 0) {
      return 0;
    }
    dVar1 = (double)CONCAT44(param_4,param_2);
    if ((ushort)((ushort)(dVar1 < 0.0) << 8 | (ushort)(dVar1 == 0.0) << 0xe) != 0) {
      uVar2 = 0;
      if (0.0 <= dVar1) {
        uVar2 = 0x3ff0000000000000;
      }
      goto LAB_0041691c;
    }
  }
  uVar2 = 0x7401a80de8c1c18b;
LAB_0041691c:
  *param_3 = uVar2;
  return 0;
}



// Library Function - Single Match
//  __87except
// 
// Library: Visual Studio 2015 Release

void __87except(int param_1,int *param_2,ushort *param_3)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  uint local_94;
  undefined local_90 [48];
  undefined8 local_60;
  uint local_50;
  uint local_14;
  
  local_14 = (uint)&stack0xfffffff0 ^ 0x74c08447;
  local_94 = (uint)*param_3;
  iVar2 = *param_2;
  if (iVar2 == 1) {
LAB_0041698a:
    uVar3 = 8;
  }
  else if (iVar2 == 2) {
    uVar3 = 4;
  }
  else if (iVar2 == 3) {
    uVar3 = 0x11;
  }
  else if (iVar2 == 4) {
    uVar3 = 0x12;
  }
  else {
    if (iVar2 == 5) goto LAB_0041698a;
    if (iVar2 != 8) goto LAB_004169ec;
    uVar3 = 0x10;
  }
  iVar2 = __handle_exc(uVar3,param_2 + 6,local_94);
  if (iVar2 == 0) {
    if (((param_1 == 0x10) || (param_1 == 0x16)) || (param_1 == 0x1d)) {
      local_60 = *(undefined8 *)(param_2 + 4);
      local_50 = local_50 & 0xffffffe3 | 3;
    }
    else {
      local_50 = local_50 & 0xfffffffe;
    }
    __raise_exc(local_90,&local_94,uVar3,param_1,param_2 + 2,param_2 + 6);
  }
LAB_004169ec:
  __ctrlfp(local_94,0xffff);
  if (((*param_2 == 8) || (cVar1 = ___acrt_has_user_matherr(), cVar1 == '\0')) ||
     (iVar2 = ___acrt_invoke_user_matherr(param_2), iVar2 == 0)) {
    __set_errno_from_matherr(*param_2);
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  __frnd
// 
// Library: Visual Studio 2015 Release

float10 __frnd(double param_1)

{
  return (float10)ROUND(param_1);
}



// Library Function - Single Match
//  __errcode
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __errcode(uint param_1)

{
  int iStack8;
  
  if ((param_1 & 0x20) == 0) {
    if ((param_1 & 8) != 0) {
      return 1;
    }
    if ((param_1 & 4) == 0) {
      if ((param_1 & 1) == 0) {
        return (param_1 & 2) * 2;
      }
      iStack8 = 3;
    }
    else {
      iStack8 = 2;
    }
  }
  else {
    iStack8 = 5;
  }
  return iStack8;
}



// Library Function - Single Match
//  __except1
// 
// Library: Visual Studio 2015 Release

void __except1(undefined4 param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,
              undefined4 param_5)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  undefined local_90 [64];
  uint local_50;
  uint local_14;
  
  uVar3 = param_5;
  local_14 = (uint)&stack0xfffffff0 ^ 0x74c08447;
  iVar2 = __handle_exc(param_1,&param_4,param_5);
  if (iVar2 == 0) {
    local_50 = local_50 & 0xfffffffe;
    __raise_exc_ex(local_90,&param_5,param_1,param_2,&param_3,&param_4,0);
    uVar3 = param_5;
  }
  iVar2 = __errcode(param_1);
  cVar1 = ___acrt_has_user_matherr();
  if ((cVar1 == '\0') || (iVar2 == 0)) {
    __set_errno_from_matherr(iVar2);
    __ctrlfp();
  }
  else {
    __umatherr(iVar2,param_2,param_3,0,param_4,uVar3);
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  __handle_exc
// 
// Library: Visual Studio 2017 Release

bool __handle_exc(uint param_1,double *param_2,uint param_3)

{
  double dVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  float10 fVar6;
  float10 fVar7;
  uint local_14;
  byte bStack16;
  undefined uStack15;
  ushort uStack14;
  uint local_8;
  
  uVar5 = param_1 & 0x1f;
  if (((param_1 & 8) != 0) && ((param_3 & 1) != 0)) {
    __set_statfp(1);
    uVar5 = param_1 & 0x17;
    goto LAB_00416d0f;
  }
  if ((param_1 & param_3 & 4) != 0) {
    __set_statfp(4);
    uVar5 = param_1 & 0x1b;
    goto LAB_00416d0f;
  }
  if (((param_1 & 1) == 0) || ((param_3 & 8) == 0)) {
    if (((param_1 & 2) != 0) && ((param_3 & 0x10) != 0)) {
      uVar5 = param_1 >> 4 & 1;
      if (*param_2 == 0.0) {
        uVar5 = 1;
      }
      else {
        fVar6 = (float10)__decomp(*param_2,&local_8);
        iVar2 = local_8 - 0x600;
        dVar1 = (double)fVar6;
        local_14 = SUB84(dVar1,0);
        bStack16 = (byte)((ulonglong)dVar1 >> 0x20);
        uStack15 = (undefined)((ulonglong)dVar1 >> 0x28);
        uStack14 = (ushort)((ulonglong)dVar1 >> 0x30);
        fVar7 = (float10)0;
        if (iVar2 < -0x432) {
          fVar7 = fVar7 * fVar6;
          uVar5 = 1;
        }
        else {
          local_8 = (uint)((ushort)((ushort)(fVar7 < fVar6) << 8 | (ushort)(fVar7 == fVar6) << 0xe)
                          == 0);
          uStack14 = uStack14 & 0xf | 0x10;
          if (iVar2 < -0x3fd) {
            iVar2 = -0x3fd - iVar2;
            uVar3 = (uint)((ulonglong)dVar1 >> 0x20) & 0xfffff | 0x100000;
            do {
              if (((local_14 & 1) != 0) && (uVar5 == 0)) {
                uVar5 = 1;
              }
              local_14 = local_14 >> 1;
              if ((bStack16 & 1) != 0) {
                local_14 = local_14 | 0x80000000;
              }
              uVar4 = uVar3 >> 1;
              bStack16 = (byte)uVar4;
              uStack15 = (undefined)(uVar4 >> 8);
              uStack14 = (ushort)(uVar3 >> 0x11);
              iVar2 = iVar2 + -1;
              uVar3 = uVar4;
            } while (iVar2 != 0);
          }
          fVar7 = (float10)(double)CONCAT26(uStack14,CONCAT15(uStack15,CONCAT14(bStack16,local_14)))
          ;
          if (local_8 != 0) {
            fVar7 = -fVar7;
          }
        }
        *param_2 = (double)fVar7;
      }
      if (uVar5 != 0) {
        __set_statfp(0x10);
      }
      uVar5 = param_1 & 0x1d;
    }
    goto LAB_00416d0f;
  }
  __set_statfp(8);
  uVar5 = param_3 & 0xc00;
  if (uVar5 == 0) {
    if (*param_2 <= 0.0) {
LAB_00416c1c:
      dVar1 = 6.320771569552188e+250;
      goto LAB_00416c22;
    }
LAB_00416c14:
    dVar1 = 6.320771569552188e+250;
LAB_00416c24:
    *param_2 = dVar1;
  }
  else {
    if (uVar5 == 0x400) {
      if (*param_2 <= 0.0) goto LAB_00416c1c;
      dVar1 = 5.164500081461625e+120;
      goto LAB_00416c24;
    }
    if (uVar5 == 0x800) {
      if (0.0 < *param_2) goto LAB_00416c14;
      dVar1 = 5.164500081461625e+120;
LAB_00416c22:
      dVar1 = -dVar1;
      goto LAB_00416c24;
    }
    if (uVar5 == 0xc00) {
      dVar1 = 5.164500081461625e+120;
      if (0.0 < *param_2) goto LAB_00416c24;
      goto LAB_00416c22;
    }
  }
  uVar5 = param_1 & 0x1e;
LAB_00416d0f:
  if (((param_1 & 0x10) != 0) && ((param_3 & 0x20) != 0)) {
    __set_statfp(0x20);
    uVar5 = uVar5 & 0xffffffef;
  }
  return uVar5 == 0;
}



// Library Function - Single Match
//  __raise_exc
// 
// Library: Visual Studio 2015 Release

void __raise_exc(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                undefined4 param_5,undefined4 param_6)

{
  __raise_exc_ex(param_1,param_2,param_3,param_4,param_5,param_6,0);
  return;
}



// Library Function - Single Match
//  __raise_exc_ex
// 
// Library: Visual Studio 2015 Release

void __raise_exc_ex(uint *param_1,uint *param_2,uint param_3,int param_4,undefined8 *param_5,
                   undefined8 *param_6,int param_7)

{
  uint *puVar1;
  undefined8 *puVar2;
  uint uVar3;
  undefined4 uVar4;
  
  puVar1 = param_2;
  param_1[1] = 0;
  uVar4 = 0xc000000d;
  param_1[2] = 0;
  param_1[3] = 0;
  if ((param_3 & 0x10) != 0) {
    uVar4 = 0xc000008f;
    param_1[1] = param_1[1] | 1;
  }
  if ((param_3 & 2) != 0) {
    uVar4 = 0xc0000093;
    param_1[1] = param_1[1] | 2;
  }
  if ((param_3 & 1) != 0) {
    uVar4 = 0xc0000091;
    param_1[1] = param_1[1] | 4;
  }
  if ((param_3 & 4) != 0) {
    uVar4 = 0xc000008e;
    param_1[1] = param_1[1] | 8;
  }
  if ((param_3 & 8) != 0) {
    uVar4 = 0xc0000090;
    param_1[1] = param_1[1] | 0x10;
  }
  param_1[2] = param_1[2] ^ (~(*param_2 << 4) ^ param_1[2]) & 0x10;
  param_1[2] = param_1[2] ^ (~(*param_2 * 2) ^ param_1[2]) & 8;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 1) ^ param_1[2]) & 4;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 3) ^ param_1[2]) & 2;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 5) ^ param_1[2]) & 1;
  uVar3 = __statfp();
  puVar2 = param_6;
  if ((uVar3 & 1) != 0) {
    param_1[3] = param_1[3] | 0x10;
  }
  if ((uVar3 & 4) != 0) {
    param_1[3] = param_1[3] | 8;
  }
  if ((uVar3 & 8) != 0) {
    param_1[3] = param_1[3] | 4;
  }
  if ((uVar3 & 0x10) != 0) {
    param_1[3] = param_1[3] | 2;
  }
  if ((uVar3 & 0x20) != 0) {
    param_1[3] = param_1[3] | 1;
  }
  uVar3 = *puVar1 & 0xc00;
  if (uVar3 == 0) {
    *param_1 = *param_1 & 0xfffffffc;
  }
  else {
    if (uVar3 == 0x400) {
      uVar3 = *param_1 & 0xfffffffd | 1;
    }
    else {
      if (uVar3 != 0x800) {
        if (uVar3 == 0xc00) {
          *param_1 = *param_1 | 3;
        }
        goto LAB_00416eb7;
      }
      uVar3 = *param_1 & 0xfffffffe | 2;
    }
    *param_1 = uVar3;
  }
LAB_00416eb7:
  uVar3 = *puVar1 & 0x300;
  if (uVar3 == 0) {
    uVar3 = *param_1 & 0xffffffeb | 8;
LAB_00416eed:
    *param_1 = uVar3;
  }
  else {
    if (uVar3 == 0x200) {
      uVar3 = *param_1 & 0xffffffe7 | 4;
      goto LAB_00416eed;
    }
    if (uVar3 == 0x300) {
      *param_1 = *param_1 & 0xffffffe3;
    }
  }
  *param_1 = *param_1 ^ (param_4 << 5 ^ *param_1) & 0x1ffe0;
  param_1[8] = param_1[8] | 1;
  if (param_7 == 0) {
    param_1[8] = param_1[8] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 4) = *param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 0x14) = *param_6;
  }
  else {
    param_1[8] = param_1[8] & 0xffffffe1;
    param_1[4] = *(uint *)param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe1;
    param_1[0x14] = *(uint *)param_6;
  }
  __clrfp();
  (*(code *)0x6d736308)(uVar4,0,1,&param_1);
  if ((*(byte *)(param_1 + 2) & 0x10) != 0) {
    *puVar1 = *puVar1 & 0xfffffffe;
  }
  if ((*(byte *)(param_1 + 2) & 8) != 0) {
    *puVar1 = *puVar1 & 0xfffffffb;
  }
  if ((*(byte *)(param_1 + 2) & 4) != 0) {
    *puVar1 = *puVar1 & 0xfffffff7;
  }
  if ((*(byte *)(param_1 + 2) & 2) != 0) {
    *puVar1 = *puVar1 & 0xffffffef;
  }
  if ((*(byte *)(param_1 + 2) & 1) != 0) {
    *puVar1 = *puVar1 & 0xffffffdf;
  }
  uVar3 = *param_1 & 3;
  if (uVar3 == 0) {
    *puVar1 = *puVar1 & 0xfffff3ff;
  }
  else {
    if (uVar3 == 1) {
      uVar3 = *puVar1 & 0xfffff7ff | 0x400;
    }
    else {
      if (uVar3 != 2) {
        if (uVar3 == 3) {
          *puVar1 = *puVar1 | 0xc00;
        }
        goto LAB_00416ffe;
      }
      uVar3 = *puVar1 & 0xfffffbff | 0x800;
    }
    *puVar1 = uVar3;
  }
LAB_00416ffe:
  uVar3 = *param_1 >> 2 & 7;
  if (uVar3 == 0) {
    uVar3 = *puVar1 & 0xfffff3ff | 0x300;
  }
  else {
    if (uVar3 != 1) {
      if (uVar3 == 2) {
        *puVar1 = *puVar1 & 0xfffff3ff;
      }
      goto LAB_0041702f;
    }
    uVar3 = *puVar1 & 0xfffff3ff | 0x200;
  }
  *puVar1 = uVar3;
LAB_0041702f:
  if (param_7 == 0) {
    *puVar2 = *(undefined8 *)(param_1 + 0x14);
  }
  else {
    *(uint *)puVar2 = param_1[0x14];
  }
  return;
}



// Library Function - Single Match
//  __set_errno_from_matherr
// 
// Library: Visual Studio 2015 Release

void __set_errno_from_matherr(int param_1)

{
  undefined4 *puVar1;
  
  if (param_1 == 1) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x21;
  }
  else if (param_1 - 2U < 2) {
    puVar1 = (undefined4 *)FUN_0040ef03();
    *puVar1 = 0x22;
    return;
  }
  return;
}



// Library Function - Single Match
//  __umatherr
// 
// Library: Visual Studio 2015 Release

float10 __umatherr(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4,
                  undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8_00,
                  undefined4 param_8)

{
  double dVar1;
  int iVar2;
  undefined4 local_24;
  int local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 uStack8;
  
  local_20 = 0;
  iVar2 = 0;
  do {
    if (*(int *)(iVar2 * 8 + 0x412858) == param_2) {
      local_20 = *(int *)(__crt_seh_guarded_call<void>::
                          operator___class__lambda_2866be3712abc81a800a822484c830d8__class__lambda_39ca0ed439415581b5b15c265174cece___class__lambda_2b24c74d71094a6cd0cb82e44167d71b___
                         + iVar2 * 8 + 1);
      break;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 < 0x1d);
  if (local_20 == 0) {
    __ctrlfp(param_8,0xffff);
    __set_errno_from_matherr(param_1);
    dVar1 = (double)CONCAT44(param_8_00,param_7);
  }
  else {
    local_1c = param_3;
    local_18 = param_4;
    local_14 = param_5;
    local_10 = param_6;
    local_c = param_7;
    local_24 = param_1;
    uStack8 = param_8_00;
    __ctrlfp(param_8,0xffff);
    iVar2 = ___acrt_invoke_user_matherr(&local_24);
    if (iVar2 == 0) {
      __set_errno_from_matherr(param_1);
    }
    dVar1 = (double)CONCAT44(uStack8,local_c);
  }
  return (float10)dVar1;
}



// Library Function - Single Match
//  __decomp
// 
// Library: Visual Studio 2015 Release

void __decomp(int param_1,uint param_2_00,int *param_2)

{
  uint uVar1;
  double dVar2;
  ushort uVar3;
  int iVar4;
  
  dVar2 = (double)CONCAT17(param_2_00._3_1_,
                           CONCAT16(param_2_00._2_1_,CONCAT24((undefined2)param_2_00,param_1)));
  if (dVar2 == 0.0) {
    iVar4 = 0;
  }
  else {
    uVar3 = (ushort)(param_2_00 >> 0x10);
    if (((param_2_00 & 0x7ff00000) == 0) && (((param_2_00 & 0xfffff) != 0 || (param_1 != 0)))) {
      iVar4 = -0x3fd;
      if ((param_2_00 & 0x100000) == 0) {
        do {
          uVar1 = param_2_00 * 2;
          param_2_00._0_2_ = (undefined2)uVar1;
          param_2_00 = uVar1;
          if (param_1 < 0) {
            param_2_00 = uVar1 | 1;
          }
          param_1 = param_1 * 2;
          iVar4 = iVar4 + -1;
        } while ((uVar1 & 0x100000) == 0);
        uVar3 = (ushort)(uVar1 >> 0x10);
      }
      param_2_00._2_1_ = (undefined)(uVar3 & 0xffef);
      param_2_00._3_1_ = (byte)((uVar3 & 0xffef) >> 8);
      if ((ushort)((ushort)(0.0 < dVar2) << 8 | (ushort)(dVar2 == 0.0) << 0xe) == 0) {
        param_2_00._3_1_ = param_2_00._3_1_ | 0x80;
      }
      __set_exp(CONCAT17(param_2_00._3_1_,
                         CONCAT16(param_2_00._2_1_,CONCAT24((undefined2)param_2_00,param_1))),0);
    }
    else {
      __set_exp(dVar2,0);
      iVar4 = (uVar3 >> 4 & 0x7ff) - 0x3fe;
    }
  }
  *param_2 = iVar4;
  return;
}



// Library Function - Single Match
//  __set_exp
// 
// Library: Visual Studio 2015 Release

float10 __set_exp(ulonglong param_1,short param_2)

{
  double local_c;
  
  local_c = (double)(param_1 & 0xffffffffffff |
                    (ulonglong)(ushort)((param_2 + 0x3fe) * 0x10 | param_1._6_2_ & 0x800f) << 0x30);
  return (float10)local_c;
}



// Library Function - Single Match
//  __sptype
// 
// Library: Visual Studio 2015 Release

undefined4 __sptype(int param_1,uint param_2)

{
  undefined4 uStack8;
  
  if (param_2 == 0x7ff00000) {
    if (param_1 == 0) {
      return 1;
    }
  }
  else if ((param_2 == 0xfff00000) && (param_1 == 0)) {
    return 2;
  }
  if ((param_2._2_2_ & 0x7ff8) == 0x7ff8) {
    uStack8 = 3;
  }
  else {
    if (((param_2._2_2_ & 0x7ff8) != 0x7ff0) || (((param_2 & 0x7ffff) == 0 && (param_1 == 0)))) {
      return 0;
    }
    uStack8 = 4;
  }
  return uStack8;
}



// Library Function - Single Match
//  __fpclass
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __fpclass(double _X)

{
  int iVar1;
  int iStack8;
  
  if ((_X._6_2_ & 0x7ff0) == 0x7ff0) {
    iVar1 = __sptype();
    if (iVar1 == 1) {
      return 0x200;
    }
    if (iVar1 == 2) {
      iStack8 = 4;
    }
    else {
      if (iVar1 != 3) {
        return 1;
      }
      iStack8 = 2;
    }
    return iStack8;
  }
  if ((((ulonglong)_X & 0x7ff0000000000000) == 0) &&
     ((((ulonglong)_X & 0xfffff00000000) != 0 || (_X._0_4_ != 0)))) {
    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff90) + 0x80;
  }
  if (_X == 0.0) {
    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffffe0) + 0x40;
  }
  return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff08) + 0x100;
}



void FUN_0041731c(void)

{
                    // WARNING: Treating indirect jump as call
  (*(code *)0x680040e1)();
  return;
}



// Library Function - Single Match
//  __FindPESection
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase,DWORD_PTR rva)

{
  int iVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  uint uVar3;
  
  uVar3 = 0;
  iVar1 = *(int *)(pImageBase + 0x3c);
  p_Var2 = (PIMAGE_SECTION_HEADER)
           (pImageBase + *(ushort *)(pImageBase + iVar1 + 0x14) + 0x18 + iVar1);
  if (*(ushort *)(pImageBase + iVar1 + 6) != 0) {
    do {
      if ((p_Var2->VirtualAddress <= rva) && (rva < p_Var2->Misc + p_Var2->VirtualAddress)) {
        return p_Var2;
      }
      uVar3 = uVar3 + 1;
      p_Var2 = p_Var2 + 1;
    } while (uVar3 < *(ushort *)(pImageBase + iVar1 + 6));
  }
  return (PIMAGE_SECTION_HEADER)0x0;
}



// Library Function - Single Match
//  __IsNonwritableInCurrentImage
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2019 Release

BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)

{
  uint uVar1;
  BOOL BVar2;
  PIMAGE_SECTION_HEADER p_Var3;
  int **in_FS_OFFSET;
  int *local_14;
  undefined4 uStack16;
  undefined4 local_c;
  undefined4 local_8;
  
  uStack16 = 0x401ba0;
  local_14 = *in_FS_OFFSET;
  local_c = 0x7481b677;
  *in_FS_OFFSET = (int *)&local_14;
  local_8 = 0;
  BVar2 = __ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_00400000);
  if (BVar2 != 0) {
    p_Var3 = __FindPESection((PBYTE)&IMAGE_DOS_HEADER_00400000,(DWORD_PTR)(pTarget + -0x400000));
    if (p_Var3 != (PIMAGE_SECTION_HEADER)0x0) {
      uVar1 = p_Var3->Characteristics;
      *in_FS_OFFSET = local_14;
      return ~(uVar1 >> 0x1f) & 1;
    }
  }
  *in_FS_OFFSET = local_14;
  return 0;
}



// Library Function - Single Match
//  __ValidateImageBase
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release

BOOL __cdecl __ValidateImageBase(PBYTE pImageBase)

{
  uint uVar1;
  
  if (*(short *)pImageBase != 0x5a4d) {
    return 0;
  }
  uVar1 = 0;
  if (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550) {
    uVar1 = (uint)(*(short *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b);
  }
  return uVar1;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// Library Function - Single Match
//  __SEH_prolog4_GS
// 
// Library: Visual Studio 2015 Release

void __SEH_prolog4_GS(undefined4 param_1,int param_2)

{
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  param_2 = -param_2;
  *(undefined4 *)((int)auStack28 + param_2 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + param_2 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + param_2 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + param_2 + 4) = (uint)&stack0x00000008 ^ 0x74c08447;
  *(undefined4 *)((int)auStack28 + param_2) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

void FUN_00417562(void)

{
  ___security_check_cookie_4();
  return;
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

uint __alloca_probe_16(void)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 0xf;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

uint __alloca_probe_8(void)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 7;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __alloca_probe
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __alloca_probe(void)

{
  undefined *in_EAX;
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 unaff_retaddr;
  undefined auStack4 [4];
  
  puVar2 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX))
  ;
  for (puVar1 = (undefined4 *)((uint)auStack4 & 0xfffff000); puVar2 < puVar1;
      puVar1 = puVar1 + -0x400) {
  }
  *puVar2 = unaff_retaddr;
  return;
}



// WARNING: Removing unreachable block (ram,0x0041780f)
// WARNING: Removing unreachable block (ram,0x00417836)
// WARNING: Removing unreachable block (ram,0x00417866)
// WARNING: Removing unreachable block (ram,0x00417879)
// WARNING: Removing unreachable block (ram,0x00417880)
// WARNING: Removing unreachable block (ram,0x00417883)
// WARNING: Removing unreachable block (ram,0x0041784e)
// WARNING: Removing unreachable block (ram,0x00417854)
// WARNING: Removing unreachable block (ram,0x0041785b)
// WARNING: Removing unreachable block (ram,0x0041785e)
// WARNING: Removing unreachable block (ram,0x00417907)
// WARNING: Removing unreachable block (ram,0x0041790f)
// WARNING: Removing unreachable block (ram,0x00417911)
// WARNING: Removing unreachable block (ram,0x0041791d)
// WARNING: Removing unreachable block (ram,0x0041791f)
// WARNING: Removing unreachable block (ram,0x0041792a)
// WARNING: Removing unreachable block (ram,0x00417926)
// WARNING: Removing unreachable block (ram,0x0041792c)
// Library Function - Single Match
//  _strrchr
// 
// Library: Visual Studio 2015 Release

char * __cdecl _strrchr(char *_Str,int _Ch)

{
  uint uVar1;
  char *pcVar2;
  undefined (*pauVar3) [16];
  char *pcVar4;
  int iVar5;
  uint uVar6;
  undefined (*pauVar7) [16];
  undefined auVar8 [16];
  
  uVar6 = _Ch & 0xff;
  if (uVar6 == 0) {
    pcVar4 = (char *)((uint)_Str & 0xfffffff0);
    auVar8 = CONCAT115(-(pcVar4[0xf] == '\0'),
                       CONCAT114(-(pcVar4[0xe] == '\0'),
                                 CONCAT113(-(pcVar4[0xd] == '\0'),
                                           CONCAT112(-(pcVar4[0xc] == '\0'),
                                                     CONCAT111(-(pcVar4[0xb] == '\0'),
                                                               CONCAT110(-(pcVar4[10] == '\0'),
                                                                         CONCAT19(-(pcVar4[9] ==
                                                                                   '\0'),CONCAT18(-(
                                                  pcVar4[8] == '\0'),
                                                  CONCAT17(-(pcVar4[7] == '\0'),
                                                           CONCAT16(-(pcVar4[6] == '\0'),
                                                                    CONCAT15(-(pcVar4[5] == '\0'),
                                                                             CONCAT14(-(pcVar4[4] ==
                                                                                       '\0'),
                                                  CONCAT13(-(pcVar4[3] == '\0'),
                                                           CONCAT12(-(pcVar4[2] == '\0'),
                                                                    CONCAT11(-(pcVar4[1] == '\0'),
                                                                             -(*pcVar4 == '\0'))))))
                                                  ))))))))));
    uVar6 = (uint)(ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                           (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                           (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                           (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                           (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                           (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                           (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                           (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                           (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                           (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                           (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                           (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                           (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                           (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                           (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe |
                          (ushort)((byte)-(pcVar4[0xf] == '\0') >> 7) << 0xf) &
            -1 << ((byte)_Str & 0xf);
    while (uVar6 == 0) {
      pcVar2 = pcVar4 + 0x1f;
      auVar8 = CONCAT115(-(*pcVar2 == '\0'),
                         CONCAT114(-(pcVar4[0x1e] == '\0'),
                                   CONCAT113(-(pcVar4[0x1d] == '\0'),
                                             CONCAT112(-(pcVar4[0x1c] == '\0'),
                                                       CONCAT111(-(pcVar4[0x1b] == '\0'),
                                                                 CONCAT110(-(pcVar4[0x1a] == '\0'),
                                                                           CONCAT19(-(pcVar4[0x19]
                                                                                     == '\0'),
                                                                                    CONCAT18(-(
                                                  pcVar4[0x18] == '\0'),
                                                  CONCAT17(-(pcVar4[0x17] == '\0'),
                                                           CONCAT16(-(pcVar4[0x16] == '\0'),
                                                                    CONCAT15(-(pcVar4[0x15] == '\0')
                                                                             ,CONCAT14(-(pcVar4[0x14
                                                  ] == '\0'),
                                                  CONCAT13(-(pcVar4[0x13] == '\0'),
                                                           CONCAT12(-(pcVar4[0x12] == '\0'),
                                                                    CONCAT11(-(pcVar4[0x11] == '\0')
                                                                             ,-(pcVar4[0x10] == '\0'
                                                                               ))))))))))))))));
      pcVar4 = pcVar4 + 0x10;
      uVar6 = (uint)(ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                             (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                             (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                             (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                             (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                             (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                             (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                             (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                             (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                             (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                             (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                             (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                             (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                             (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                             (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe |
                            (ushort)((byte)-(*pcVar2 == '\0') >> 7) << 0xf);
    }
    iVar5 = 0;
    if (uVar6 != 0) {
      for (; (uVar6 >> iVar5 & 1) == 0; iVar5 = iVar5 + 1) {
      }
    }
    pauVar3 = (undefined (*) [16])(pcVar4 + iVar5);
  }
  else {
    pauVar3 = (undefined (*) [16])0x0;
    uVar1 = (uint)_Str & 0xf;
    while (uVar1 != 0) {
      if ((byte)*_Str == uVar6) {
        pauVar3 = (undefined (*) [16])_Str;
      }
      if ((byte)*_Str == 0) {
        return (char *)pauVar3;
      }
      _Str = _Str + 1;
      uVar1 = (uint)_Str & 0xf;
    }
    do {
      pauVar7 = (undefined (*) [16])((int)_Str + 0x10);
      iVar5 = pcmpistri(ZEXT416(uVar6),*(undefined (*) [16])_Str,0x40);
      if ((undefined (*) [16])0xffffffef < _Str) {
        pauVar3 = (undefined (*) [16])(pauVar7[-1] + iVar5);
      }
      _Str = (char *)pauVar7;
    } while (pauVar7 != (undefined (*) [16])0x0);
  }
  return (char *)pauVar3;
}



// WARNING: Removing unreachable block (ram,0x004179a1)
// WARNING: Removing unreachable block (ram,0x004179b9)
// WARNING: Removing unreachable block (ram,0x00417a1b)
// WARNING: Removing unreachable block (ram,0x004179c2)
// WARNING: Removing unreachable block (ram,0x004179c6)
// WARNING: Removing unreachable block (ram,0x004179ce)
// WARNING: Removing unreachable block (ram,0x004179d9)
// WARNING: Removing unreachable block (ram,0x00417a20)
// WARNING: Removing unreachable block (ram,0x00417a5d)
// WARNING: Removing unreachable block (ram,0x00417a27)
// WARNING: Removing unreachable block (ram,0x00417a2b)
// WARNING: Removing unreachable block (ram,0x00417a56)
// WARNING: Removing unreachable block (ram,0x00417a2f)
// WARNING: Removing unreachable block (ram,0x00417a33)
// WARNING: Removing unreachable block (ram,0x00417a4f)
// WARNING: Removing unreachable block (ram,0x00417a3a)
// WARNING: Removing unreachable block (ram,0x00417a3e)
// WARNING: Removing unreachable block (ram,0x00417a48)
// WARNING: Removing unreachable block (ram,0x00417a42)
// WARNING: Removing unreachable block (ram,0x00417a46)
// WARNING: Removing unreachable block (ram,0x004179ff)
// WARNING: Removing unreachable block (ram,0x00417a06)
// WARNING: Removing unreachable block (ram,0x00417a0d)
// WARNING: Removing unreachable block (ram,0x00417a15)
// WARNING: Removing unreachable block (ram,0x00417a17)
// Library Function - Single Match
//  _strchr
// 
// Library: Visual Studio 2015 Release

char * __cdecl _strchr(char *_Str,int _Val)

{
  int iVar1;
  uint uVar2;
  char *pcVar3;
  undefined auVar4 [16];
  char cVar5;
  char cVar7;
  char cVar8;
  char cVar9;
  char cVar10;
  char cVar11;
  char cVar12;
  char cVar13;
  undefined auVar6 [16];
  
  auVar6 = pshuflw(ZEXT216(CONCAT11((undefined)_Val,(undefined)_Val)),
                   ZEXT216(CONCAT11((undefined)_Val,(undefined)_Val)),0);
  uVar2 = -1 << (sbyte)((uint)_Str & 0xf);
  pcVar3 = _Str + -((uint)_Str & 0xf);
  while( true ) {
    cVar5 = SUB161(auVar6,0);
    cVar7 = SUB161(auVar6 >> 8,0);
    cVar8 = SUB161(auVar6 >> 0x10,0);
    cVar9 = SUB161(auVar6 >> 0x18,0);
    cVar10 = SUB161(auVar6 >> 0x20,0);
    cVar11 = SUB161(auVar6 >> 0x28,0);
    cVar12 = SUB161(auVar6 >> 0x30,0);
    cVar13 = SUB161(auVar6 >> 0x38,0);
    auVar4 = CONCAT115(-(pcVar3[0xf] == '\0'),
                       CONCAT114(-(pcVar3[0xe] == '\0'),
                                 CONCAT113(-(pcVar3[0xd] == '\0'),
                                           CONCAT112(-(pcVar3[0xc] == '\0'),
                                                     CONCAT111(-(pcVar3[0xb] == '\0'),
                                                               CONCAT110(-(pcVar3[10] == '\0'),
                                                                         CONCAT19(-(pcVar3[9] ==
                                                                                   '\0'),CONCAT18(-(
                                                  pcVar3[8] == '\0'),
                                                  CONCAT17(-(pcVar3[7] == '\0'),
                                                           CONCAT16(-(pcVar3[6] == '\0'),
                                                                    CONCAT15(-(pcVar3[5] == '\0'),
                                                                             CONCAT14(-(pcVar3[4] ==
                                                                                       '\0'),
                                                  CONCAT13(-(pcVar3[3] == '\0'),
                                                           CONCAT12(-(pcVar3[2] == '\0'),
                                                                    CONCAT11(-(pcVar3[1] == '\0'),
                                                                             -(*pcVar3 == '\0'))))))
                                                  )))))))))) |
             CONCAT115(-(pcVar3[0xf] == cVar13),
                       CONCAT114(-(pcVar3[0xe] == cVar12),
                                 CONCAT113(-(pcVar3[0xd] == cVar11),
                                           CONCAT112(-(pcVar3[0xc] == cVar10),
                                                     CONCAT111(-(pcVar3[0xb] == cVar9),
                                                               CONCAT110(-(pcVar3[10] == cVar8),
                                                                         CONCAT19(-(pcVar3[9] ==
                                                                                   cVar7),CONCAT18(-
                                                  (pcVar3[8] == cVar5),
                                                  CONCAT17(-(pcVar3[7] == cVar13),
                                                           CONCAT16(-(pcVar3[6] == cVar12),
                                                                    CONCAT15(-(pcVar3[5] == cVar11),
                                                                             CONCAT14(-(pcVar3[4] ==
                                                                                       cVar10),
                                                  CONCAT13(-(pcVar3[3] == cVar9),
                                                           CONCAT12(-(pcVar3[2] == cVar8),
                                                                    CONCAT11(-(pcVar3[1] == cVar7),
                                                                             -(*pcVar3 == cVar5)))))
                                                  )))))))))));
    uVar2 = (ushort)((ushort)(SUB161(auVar4 >> 7,0) & 1) |
                     (ushort)(SUB161(auVar4 >> 0xf,0) & 1) << 1 |
                     (ushort)(SUB161(auVar4 >> 0x17,0) & 1) << 2 |
                     (ushort)(SUB161(auVar4 >> 0x1f,0) & 1) << 3 |
                     (ushort)(SUB161(auVar4 >> 0x27,0) & 1) << 4 |
                     (ushort)(SUB161(auVar4 >> 0x2f,0) & 1) << 5 |
                     (ushort)(SUB161(auVar4 >> 0x37,0) & 1) << 6 |
                     (ushort)(SUB161(auVar4 >> 0x3f,0) & 1) << 7 |
                     (ushort)(SUB161(auVar4 >> 0x47,0) & 1) << 8 |
                     (ushort)(SUB161(auVar4 >> 0x4f,0) & 1) << 9 |
                     (ushort)(SUB161(auVar4 >> 0x57,0) & 1) << 10 |
                     (ushort)(SUB161(auVar4 >> 0x5f,0) & 1) << 0xb |
                     (ushort)(SUB161(auVar4 >> 0x67,0) & 1) << 0xc |
                     (ushort)(SUB161(auVar4 >> 0x6f,0) & 1) << 0xd |
                     (ushort)(SUB161(auVar4 >> 0x77,0) & 1) << 0xe |
                    (ushort)SUB161(auVar4 >> 0x7f,0) << 0xf) & uVar2;
    if (uVar2 != 0) break;
    uVar2 = 0xffffffff;
    pcVar3 = pcVar3 + 0x10;
  }
  iVar1 = 0;
  if (uVar2 != 0) {
    for (; (uVar2 >> iVar1 & 1) == 0; iVar1 = iVar1 + 1) {
    }
  }
  pcVar3 = pcVar3 + iVar1;
  if (cVar5 != *pcVar3) {
    pcVar3 = (char *)0x0;
  }
  return pcVar3;
}



undefined4 FUN_0041f45e(void)

{
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041f46e(void)

{
  code *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined local_c [4];
  uint local_8;
  
  pcVar1 = _DAT_1000c070;
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar2 = (*_DAT_1000c070)(0x10010ad4,0x10000000,3,0,3,0,0);
  uVar3 = (*pcVar1)(0x10010a98,0x80000000,0,0,3,0,0);
  uVar4 = (*_DAT_1000c06c)(uVar3,0);
  uVar5 = FUN_0041fbf1(uVar4);
  (*_DAT_1000c068)(uVar3,uVar5,uVar4,local_c,0);
  (*_DAT_1000c064)(uVar2,uVar5,uVar4,local_c,0);
  (*_DAT_1000c060)(uVar2);
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041f50e(void)

{
  undefined4 uVar1;
  code *pcVar2;
  code *pcVar3;
  undefined local_10 [7];
  undefined local_9;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_1000c05c)(0x10010afc);
  pcVar3 = _DAT_1000c058;
  pcVar2 = (code *)(*_DAT_1000c058)(uVar1,0x10010b04);
  pcVar3 = (code *)(*pcVar3)(uVar1,0x10010b18);
  if ((pcVar2 != (code *)0x0) && (pcVar3 != (code *)0x0)) {
    (*pcVar2)(0x13,1,0,&local_9);
    (*pcVar3)(0xc0000022,0,0,0,6,local_10);
  }
  (*_DAT_1000c164)(6,0x5000f);
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041f59e(void)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  __time64_t _Var4;
  undefined local_18 [8];
  int local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar1,local_18);
  uVar1 = (*_DAT_1000c158)(0);
  iVar2 = 0x1d4c;
  do {
    do {
      iVar3 = iVar2;
      (*_DAT_1000c054)(iVar3);
      _Var4 = FID_conflict___time64((__time64_t *)0x0);
      FUN_0042227b((int)_Var4);
      iVar2 = FUN_0042225a(0x8800c6);
      iVar2 = FUN_0042225a(local_c + 0xf + iVar2 % 0xf);
      iVar2 = FUN_0042225a(uVar1,0,0,local_10 + 0xf + iVar2 % 0xf);
      iVar2 = FUN_0042225a((local_c - iVar2 % 0xf) + 0xf);
      iVar2 = FUN_0042225a((local_10 - iVar2 % 0xf) + 0xf);
      iVar2 = FUN_0042225a(iVar2 % 0xf + 0xf);
      (*_DAT_1000c028)(uVar1,iVar2 % 0xf + 0xf);
      iVar2 = FUN_0042225a(0xee0086);
      iVar2 = FUN_0042225a(local_c + 0xf + iVar2 % 0xf);
      iVar2 = FUN_0042225a(uVar1,0,0,local_10 + 0xf + iVar2 % 0xf);
      iVar2 = FUN_0042225a((local_c - iVar2 % 0xf) + 0xf);
      iVar2 = FUN_0042225a((local_10 - iVar2 % 0xf) + 0xf);
      iVar2 = FUN_0042225a(iVar2 % 0xf + 0xf);
      (*_DAT_1000c028)(uVar1,iVar2 % 0xf + 0xf);
      iVar2 = iVar3 + -0x2ee;
    } while (0x2ee < iVar3);
    iVar2 = iVar3;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041f70e(void)

{
  undefined4 uVar1;
  int iVar2;
  undefined local_18 [12];
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar1,local_18);
  uVar1 = (*_DAT_1000c158)(0);
  iVar2 = 0;
  if (local_c != 0) {
    do {
      (*_DAT_1000c028)(uVar1,iVar2,0,10,local_c,uVar1,iVar2,0,10,local_c,0x550009);
      iVar2 = iVar2 + 1;
    } while (iVar2 != local_c);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041f77e(void)

{
  code *pcVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  undefined local_18 [8];
  int local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar8 = 0;
  iVar7 = 0;
  uVar2 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar2,local_18);
  pcVar1 = _DAT_1000c154;
  iVar3 = (*_DAT_1000c154)(0xb);
  iVar4 = (*pcVar1)(0xc);
  if (0 < local_c) {
    do {
      (*_DAT_1000c054)(5);
      uVar2 = (*_DAT_1000c14c)(0,0x7f02);
      uVar2 = (*_DAT_1000c158)(0,iVar7,iVar8,uVar2);
      (*_DAT_1000c150)(uVar2);
      iVar6 = iVar4 + iVar7;
      iVar5 = iVar3 + iVar8;
      if (iVar6 != local_10) {
        iVar5 = iVar8;
      }
      iVar7 = 0;
      if (iVar6 != local_10) {
        iVar7 = iVar6;
      }
      iVar8 = iVar5;
    } while (iVar5 < local_c);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041f81e(void)

{
  undefined local_1c [16];
  undefined4 local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_c = 0;
  local_1c = ZEXT1216(ZEXT412(0x204) << 0x40);
  (*_DAT_1000c16c)(0,0x803,0x3000,local_1c);
  (*_DAT_1000c16c)(local_1c._4_4_,0x80d,0x100,0);
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041f87e(void)

{
  code *pcVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  short local_10 [2];
  short local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar2 = (*_DAT_1000c050)(0x10010b2c);
  if (iVar2 != 0) {
    do {
      pcVar1 = _DAT_1000c154;
      (*_DAT_1000c054)(0x68);
      uVar3 = (*_DAT_1000c158)(0);
      (*_DAT_1000c024)(uVar3,1);
      (*_DAT_1000c148)(local_10);
      iVar4 = (*pcVar1)(0xb);
      iVar5 = (*pcVar1)(0xc);
      uVar6 = (*_DAT_1000c14c)(iVar2,0x67);
      (*_DAT_1000c150)(uVar3,(int)local_10[0] - iVar4 / 2,(int)local_c - iVar5 / 2,uVar6);
    } while( true );
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041f91e(void)

{
  undefined4 uVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  __time64_t _Var9;
  int local_28;
  int local_20;
  int local_1c;
  undefined local_18 [8];
  int local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_1000c158)(0);
  uVar2 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar2,local_18);
  uVar6 = local_10 >> 0x1f;
  local_1c = 0;
  local_20 = 0;
  iVar3 = (int)(local_10 + (uVar6 & 3)) >> 2;
  iVar5 = iVar3;
  iVar8 = iVar3;
  do {
    (*_DAT_1000c054)(0x10);
    _Var9 = FID_conflict___time64((__time64_t *)0x0);
    FUN_0042227b((int)_Var9);
    local_1c = local_1c + iVar5;
    iVar7 = iVar5;
    if (local_10 / 2 <= local_1c) {
      iVar7 = -((int)((uVar6 & 3) + local_10) >> 2);
    }
    iVar5 = iVar3;
    if (SBORROW4(local_1c,-(local_10 / 2)) == local_1c + local_10 / 2 < 0) {
      iVar5 = iVar7;
    }
    local_20 = local_20 + iVar8;
    local_28 = iVar8;
    if (local_c / 2 <= local_20) {
      local_28 = -((int)(local_10 + (uVar6 & 3)) >> 2);
    }
    uVar2 = (*_DAT_1000c020)(uVar1,local_10,local_c);
    uVar4 = (*_DAT_1000c01c)(uVar1);
    (*_DAT_1000c018)(uVar4,uVar2);
    (*_DAT_1000c014)(uVar4,0,0,local_10,local_c,uVar1,0,0,0xcc0020);
    (*_DAT_1000c014)(uVar1,0,0,local_10,local_c,uVar4,local_1c,local_20,0xcc0020);
    (*_DAT_1000c010)(uVar4);
    (*_DAT_1000c00c)(uVar2);
    iVar8 = iVar3;
    if (SBORROW4(local_20,-(local_c / 2)) == local_20 + local_c / 2 < 0) {
      iVar8 = local_28;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041fa6e(void)

{
  code *pcVar1;
  undefined4 uVar2;
  undefined local_18 [8];
  undefined4 local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar2 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar2,local_18);
  pcVar1 = _DAT_1000c054;
  do {
    (*pcVar1)(1000);
    uVar2 = (*_DAT_1000c158)(0);
    (*_DAT_1000c028)(uVar2,0,local_c,local_10,-local_c,uVar2,0,0,local_10,local_c,0xcc0020);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0041face(void)

{
  code *pcVar1;
  undefined4 uVar2;
  bool bVar3;
  int iVar4;
  int iVar5;
  undefined local_28 [8];
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  int local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar2 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar2,local_28);
  uVar2 = (*_DAT_1000c158)(0);
  (*_DAT_1000c008)(uVar2,0xff);
  (*_DAT_1000c024)(uVar2,0);
  (*_DAT_1000c004)(uVar2,0x10010b48,0x18,&local_10);
  iVar4 = 0;
  iVar5 = -local_c;
  if (0 < local_20) {
    do {
      (*_DAT_1000c054)(2);
      iVar5 = iVar5 + local_c;
      (*_DAT_1000c000)(uVar2,iVar4,iVar5,0x10010b48,0x18);
      if (local_1c <= iVar5) {
        iVar5 = -local_c;
        iVar4 = iVar4 + local_10;
      }
    } while (iVar4 < local_20);
  }
  (*_DAT_1000c004)(uVar2,0x10010b78,0x10,&local_18);
  pcVar1 = _DAT_1000c008;
  bVar3 = false;
  do {
    if (bVar3) {
      (*pcVar1)(uVar2,0);
      (*_DAT_1000c024)(uVar2,0xff);
    }
    (*_DAT_1000c054)(0x68);
    (*_DAT_1000c000)(uVar2,local_20 / 2 - local_18 / 2,local_1c / 2 - local_14 / 2,0x10010b78,0x10);
    (*pcVar1)(uVar2,0xff);
    (*_DAT_1000c024)(uVar2,0);
    bVar3 = (bool)(bVar3 ^ 1);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  @__security_check_cookie@4
// 
// Library: Visual Studio 2015 Release

void __fastcall ___security_check_cookie_4(int param_1)

{
  if (param_1 == _DAT_10012000) {
    return;
  }
  ___report_gsfailure();
  return;
}



void FUN_0041fbf1(uint param_1)

{
  operator_new(param_1);
  return;
}



// Library Function - Single Match
//  int __stdcall dllmain_crt_dispatch(struct HINSTANCE__ * const,unsigned long,void * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int dllmain_crt_dispatch(HINSTANCE__ *param_1,ulong param_2,void *param_3)

{
  uint uVar1;
  
  if (param_2 == 0) {
    uVar1 = FUN_0041fd4c(param_3 != (void *)0x0);
  }
  else if (param_2 == 1) {
    uVar1 = FUN_0041fc4d(param_1,param_3);
  }
  else {
    if (param_2 == 2) {
      uVar1 = ___scrt_dllmain_crt_thread_attach();
    }
    else {
      if (param_2 != 3) {
        return 1;
      }
      uVar1 = ___scrt_dllmain_crt_thread_detach();
    }
    uVar1 = uVar1 & 0xff;
  }
  return uVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0041fc4d(undefined4 param_1,undefined4 param_2)

{
  code *pcVar1;
  bool bVar2;
  char cVar3;
  int iVar4;
  code **ppcVar5;
  undefined4 uVar6;
  
  cVar3 = ___scrt_initialize_crt(0);
  if (cVar3 != '\0') {
    ___scrt_acquire_startup_lock();
    bVar2 = true;
    if (_DAT_10012b18 != 0) {
      FUN_00420451(7);
      pcVar1 = (code *)swi(3);
      uVar6 = (*pcVar1)();
      return uVar6;
    }
    _DAT_10012b18 = 1;
    cVar3 = FUN_004201fc();
    if (cVar3 != '\0') {
      FUN_00420575();
      FUN_00420117();
      FUN_0042013b();
      iVar4 = __initterm_e(0x1000c180,0x1000c190);
      if ((iVar4 == 0) && (cVar3 = ___scrt_dllmain_after_initialize_c(), cVar3 != '\0')) {
        __initterm(0x1000c178,0x1000c17c);
        _DAT_10012b18 = 2;
        bVar2 = false;
      }
    }
    FUN_0041fd3a();
    if (!bVar2) {
      ppcVar5 = (code **)FUN_0042044b();
      if ((*ppcVar5 != (code *)0x0) &&
         (cVar3 = ___scrt_is_nonwritable_in_current_image(ppcVar5), cVar3 != '\0')) {
        pcVar1 = *ppcVar5;
        FUN_004205cb(param_1,2,param_2);
        (*pcVar1)();
      }
      _DAT_100127d8 = _DAT_100127d8 + 1;
      return 1;
    }
  }
  return 0;
}



void FUN_0041fd3a(void)

{
  int unaff_EBP;
  
  ___scrt_release_startup_lock(*(undefined4 *)(unaff_EBP + -0x1d));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_0041fd4c(undefined4 param_1)

{
  code *pcVar1;
  char cVar2;
  uint uVar3;
  
  if (_DAT_100127d8 < 1) {
    uVar3 = 0;
  }
  else {
    _DAT_100127d8 = _DAT_100127d8 + -1;
    ___scrt_acquire_startup_lock();
    if (_DAT_10012b18 != 2) {
      FUN_00420451(7);
      pcVar1 = (code *)swi(3);
      uVar3 = (*pcVar1)();
      return uVar3;
    }
    FUN_00420269();
    __scrt_uninitialize_type_info();
    FUN_004205a0();
    _DAT_10012b18 = 0;
    FUN_0041fdbd();
    cVar2 = ___scrt_uninitialize_crt(param_1,0);
    uVar3 = (uint)(cVar2 != '\0');
  }
  return uVar3;
}



void FUN_0041fdbd(void)

{
  int unaff_EBP;
  
  FUN_0042028c();
  ___scrt_release_startup_lock(*(undefined4 *)(unaff_EBP + -0x1c));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_0041fdd4(HINSTANCE__ *param_1,ulong param_2,void *param_3)

{
  code *pcVar1;
  int iVar2;
  
  pcVar1 = _DAT_1000c1b0;
  if ((param_2 == 0) && (_DAT_100127d8 < 1)) {
    iVar2 = 0;
  }
  else {
    if ((param_2 == 1) || (param_2 == 2)) {
      if (_DAT_1000c1b0 != (code *)0x0) {
        FUN_004205cb(param_1,param_2,param_3);
        iVar2 = (*pcVar1)();
        if (iVar2 == 0) {
          return 0;
        }
      }
      iVar2 = dllmain_crt_dispatch(param_1,param_2,param_3);
      if (iVar2 == 0) {
        return 0;
      }
    }
    iVar2 = FUN_0041f45e(param_1,param_2,param_3);
    if ((param_2 == 1) && (iVar2 == 0)) {
      FUN_0041f45e(param_1,0,param_3);
      dllmain_crt_dispatch(param_1,0,param_3);
      pcVar1 = _DAT_1000c1b0;
      if (_DAT_1000c1b0 != (code *)0x0) {
        FUN_004205cb(param_1,0,param_3);
        (*pcVar1)();
      }
    }
    if (((param_2 == 0) || (param_2 == 3)) &&
       (iVar2 = dllmain_crt_dispatch(param_1,param_2,param_3), pcVar1 = _DAT_1000c1b0, iVar2 != 0))
    {
      if (_DAT_1000c1b0 == (code *)0x0) {
        iVar2 = 1;
      }
      else {
        FUN_004205cb(param_1,param_2,param_3);
        iVar2 = (*pcVar1)();
      }
    }
  }
  return iVar2;
}



// Library Function - Single Match
//  __DllMainCRTStartup@12
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void __DllMainCRTStartup_12(undefined4 param_1,int param_2,undefined4 param_3)

{
  if (param_2 == 1) {
    ___security_init_cookie();
  }
  FUN_0041fdd4(param_1,param_2,param_3);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___raise_securityfailure
// 
// Library: Visual Studio 2015 Release

void ___raise_securityfailure(undefined4 param_1)

{
  undefined4 uVar1;
  
  (*_DAT_1000c084)(0);
  (*_DAT_1000c080)(param_1);
  uVar1 = (*_DAT_1000c088)(0xc0000409);
  (*_DAT_1000c08c)(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___report_gsfailure
// 
// Library: Visual Studio 2015 Release

void __cdecl ___report_gsfailure(void)

{
  code *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 uVar5;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte bVar6;
  byte bVar7;
  byte in_AF;
  byte bVar8;
  byte bVar9;
  byte in_TF;
  byte in_IF;
  byte bVar10;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined8 uVar11;
  undefined4 unaff_retaddr;
  
  uVar11 = FUN_00429a1d(0x17);
  uVar4 = (uint)uVar11;
  bVar6 = 0;
  bVar10 = 0;
  bVar9 = (int)uVar4 < 0;
  bVar8 = uVar4 == 0;
  bVar7 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;
  uVar5 = extraout_ECX;
  uVar2 = unaff_retaddr;
  uVar3 = unaff_EBP;
  if (!(bool)bVar8) {
    pcVar1 = (code *)swi(0x29);
    uVar11 = (*pcVar1)();
    uVar5 = extraout_ECX_00;
    uVar2 = unaff_retaddr;
    uVar3 = unaff_EBP;
  }
  _DAT_100128e4 = uVar3;
  _DAT_100127ec = uVar2;
  _DAT_100128f0 =
       (uint)(in_NT & 1) * 0x4000 | (uint)(bVar10 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200 |
       (uint)(in_TF & 1) * 0x100 | (uint)(bVar9 & 1) * 0x80 | (uint)(bVar8 & 1) * 0x40 |
       (uint)(in_AF & 1) * 0x10 | (uint)(bVar7 & 1) * 4 | (uint)(bVar6 & 1) |
       (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 |
       (uint)(in_AC & 1) * 0x40000;
  _DAT_100128f4 = &stack0x00000004;
  _DAT_10012830 = 0x10001;
  _DAT_100127e0 = 0xc0000409;
  _DAT_100127e4 = 1;
  _DAT_100127f0 = 1;
  uRam100127f4 = 2;
  _DAT_100128bc = in_GS;
  _DAT_100128c0 = in_FS;
  _DAT_100128c4 = in_ES;
  _DAT_100128c8 = in_DS;
  _DAT_100128cc = unaff_EDI;
  _DAT_100128d0 = unaff_ESI;
  _DAT_100128d4 = unaff_EBX;
  _DAT_100128dc = uVar5;
  _DAT_100128e8 = _DAT_100127ec;
  _DAT_100128ec = in_CS;
  _DAT_100128f8 = in_SS;
  ___raise_securityfailure(0x1000c1b4);
  _DAT_100128d8 = (undefined4)((ulonglong)uVar11 >> 0x20);
  _DAT_100128e0 = (undefined4)uVar11;
  return;
}



// Library Function - Single Match
//  void * __cdecl operator new(unsigned int)
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void * __cdecl operator_new(uint param_1)

{
  code *pcVar1;
  void *pvVar2;
  undefined auStack20 [8];
  undefined4 uStack12;
  
  do {
    uStack12 = 0x420067;
    pvVar2 = (void *)FUN_004223d3();
    if (pvVar2 != (void *)0x0) {
      return pvVar2;
    }
    uStack12 = 0x42005a;
    pvVar2 = (void *)__callnewh(param_1);
  } while (pvVar2 != (void *)0x0);
  if (param_1 != 0xffffffff) {
    __scrt_throw_std_bad_alloc();
    return pvVar2;
  }
  FUN_00420687();
  __CxxThrowException_8(auStack20,0x100111c0);
  pcVar1 = (code *)swi(3);
  pvVar2 = (void *)(*pcVar1)();
  return pvVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_0042007d(void)

{
  uint uVar1;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  uint local_8;
  
  local_10 = 0;
  local_c = 0;
  (*_DAT_1000c0a0)(&local_10);
  local_8 = local_c ^ local_10;
  uVar1 = (*_DAT_1000c09c)();
  local_8 = local_8 ^ uVar1;
  uVar1 = (*_DAT_1000c098)();
  local_8 = local_8 ^ uVar1;
  (*_DAT_1000c094)(&local_18);
  return local_14 ^ local_18 ^ local_8 ^ (uint)&local_8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___security_init_cookie
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl ___security_init_cookie(void)

{
  if ((_DAT_10012000 == 0xbb40e64e) || ((_DAT_10012000 & 0xffff0000) == 0)) {
    _DAT_10012000 = FUN_0042007d();
    if (_DAT_10012000 == 0xbb40e64e) {
      _DAT_10012000 = 0xbb40e64f;
    }
    else if ((_DAT_10012000 & 0xffff0000) == 0) {
      _DAT_10012000 = _DAT_10012000 | (_DAT_10012000 | 0x4711) << 0x10;
    }
  }
  _DAT_10012004 = ~_DAT_10012000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00420117(void)

{
  (*_DAT_1000c0a4)(0x10012b00);
  return;
}



// Library Function - Single Match
//  void __cdecl __scrt_uninitialize_type_info(void)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl __scrt_uninitialize_type_info(void)

{
  ___std_type_info_destroy_list(0x10012b00);
  return;
}



undefined4 FUN_0042012f(void)

{
  return 0x10012b08;
}



undefined4 FUN_00420135(void)

{
  return 0x10012b10;
}



void FUN_0042013b(void)

{
  uint *puVar1;
  
  puVar1 = (uint *)FUN_0042012f();
  *puVar1 = *puVar1 | 4;
  puVar1[1] = puVar1[1];
  puVar1 = (uint *)FUN_00420135();
  *puVar1 = *puVar1 | 2;
  puVar1[1] = puVar1[1];
  return;
}



// Library Function - Single Match
//  struct _IMAGE_SECTION_HEADER * __cdecl find_pe_section(unsigned char * const,unsigned int)
// 
// Library: Visual Studio 2015 Release

_IMAGE_SECTION_HEADER * __cdecl find_pe_section(uchar *param_1,uint param_2)

{
  int iVar1;
  _IMAGE_SECTION_HEADER *p_Var2;
  _IMAGE_SECTION_HEADER *p_Var3;
  
  iVar1 = *(int *)(param_1 + 0x3c);
  p_Var2 = (_IMAGE_SECTION_HEADER *)
           (param_1 + (uint)*(ushort *)(param_1 + iVar1 + 0x14) + iVar1 + 0x18);
  p_Var3 = p_Var2 + *(ushort *)(param_1 + iVar1 + 6);
  while( true ) {
    if (p_Var2 == p_Var3) {
      return (_IMAGE_SECTION_HEADER *)0x0;
    }
    if ((p_Var2->VirtualAddress <= param_2) && (param_2 < p_Var2->Misc + p_Var2->VirtualAddress))
    break;
    p_Var2 = p_Var2 + 1;
  }
  return p_Var2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_acquire_startup_lock
// 
// Library: Visual Studio 2015 Release

undefined4 ___scrt_acquire_startup_lock(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int in_FS_OFFSET;
  
  iVar2 = ___scrt_is_ucrt_dll_in_use();
  if (iVar2 == 0) {
    return 0;
  }
  iVar2 = *(int *)(*(int *)(in_FS_OFFSET + 0x18) + 4);
  while( true ) {
    iVar3 = 0;
    LOCK();
    iVar1 = iVar2;
    if (_DAT_10012b1c != 0) {
      iVar3 = _DAT_10012b1c;
      iVar1 = _DAT_10012b1c;
    }
    _DAT_10012b1c = iVar1;
    if (iVar3 == 0) break;
    if (iVar2 == iVar3) {
      return 1;
    }
  }
  return 0;
}



// Library Function - Single Match
//  ___scrt_dllmain_after_initialize_c
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 ___scrt_dllmain_after_initialize_c(void)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = ___scrt_is_ucrt_dll_in_use();
  if (iVar1 == 0) {
    uVar2 = FUN_004208e9();
    iVar1 = FUN_00422b2c(uVar2);
    if (iVar1 != 0) {
      return 0;
    }
    common_initialize_environment_nolock_char_();
  }
  else {
    FUN_00420750();
  }
  return 1;
}



bool FUN_004201fc(void)

{
  char cVar1;
  
  cVar1 = FUN_004202d2(0);
  return cVar1 != '\0';
}



// Library Function - Single Match
//  ___scrt_dllmain_crt_thread_attach
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___scrt_dllmain_crt_thread_attach(void)

{
  char cVar1;
  
  cVar1 = ___vcrt_thread_attach();
  if (cVar1 != '\0') {
    cVar1 = FUN_0042303e();
    if (cVar1 != '\0') {
      return 1;
    }
    ___vcrt_thread_detach();
  }
  return 0;
}



// Library Function - Single Match
//  ___scrt_dllmain_crt_thread_detach
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___scrt_dllmain_crt_thread_detach(void)

{
  FUN_00423049();
  ___vcrt_thread_detach();
  return 1;
}



// Library Function - Single Match
//  ___scrt_dllmain_exception_filter
// 
// Library: Visual Studio 2015 Release

void ___scrt_dllmain_exception_filter
               (undefined4 param_1,int param_2,undefined4 param_3,code *param_4,undefined4 param_5,
               undefined4 param_6)

{
  int iVar1;
  
  iVar1 = ___scrt_is_ucrt_dll_in_use();
  if ((iVar1 == 0) && (param_2 == 1)) {
    FUN_004205cb(param_1,0,param_3);
    (*param_4)();
  }
  __seh_filter_dll(param_5,param_6);
  return;
}



void FUN_00420269(void)

{
  int iVar1;
  
  iVar1 = ___scrt_is_ucrt_dll_in_use();
  if (iVar1 != 0) {
    __execute_onexit_table(&DAT_10012b20);
    return;
  }
  iVar1 = FUN_0042282d();
  if (iVar1 != 0) {
    return;
  }
  common_exit(0,0,1);
  return;
}



undefined FUN_0042028c(void)

{
  ___acrt_uninitialize_critical(0);
  ___vcrt_uninitialize_ptd();
  return 1;
}



// Library Function - Single Match
//  ___scrt_initialize_crt
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined ___scrt_initialize_crt(int param_1)

{
  char cVar1;
  
  if (param_1 == 0) {
    DAT_10012b39 = 1;
  }
  FUN_00420750();
  cVar1 = ___vcrt_initialize();
  if (cVar1 != '\0') {
    cVar1 = ___acrt_initialize();
    if (cVar1 != '\0') {
      return 1;
    }
    ___vcrt_uninitialize(0);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_004202d2(int param_1)

{
  code *pcVar1;
  byte bVar2;
  int iVar3;
  undefined4 uVar4;
  
  if (DAT_10012b38 == '\0') {
    if ((param_1 != 0) && (param_1 != 1)) {
      FUN_00420451(5);
      pcVar1 = (code *)swi(3);
      uVar4 = (*pcVar1)();
      return uVar4;
    }
    iVar3 = ___scrt_is_ucrt_dll_in_use();
    if ((iVar3 == 0) || (param_1 != 0)) {
      bVar2 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
      _DAT_10012b20 = (0xffffffffU >> bVar2 | -1 << 0x20 - bVar2) ^ _DAT_10012000;
      _DAT_10012b24 = _DAT_10012b20;
      _DAT_10012b28 = _DAT_10012b20;
      _DAT_10012b2c = _DAT_10012b20;
      _DAT_10012b30 = _DAT_10012b20;
      _DAT_10012b34 = _DAT_10012b20;
    }
    else {
      iVar3 = __initialize_onexit_table(&DAT_10012b20);
      if ((iVar3 != 0) || (iVar3 = __initialize_onexit_table(&DAT_10012b2c), iVar3 != 0)) {
        return 0;
      }
    }
    DAT_10012b38 = '\x01';
  }
  return 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_is_nonwritable_in_current_image
// 
// Library: Visual Studio 2015 Release

undefined4 ___scrt_is_nonwritable_in_current_image(int param_1)

{
  _IMAGE_SECTION_HEADER *p_Var1;
  
  if ((((_DAT_10000000 == 0x5a4d) && (*(int *)(_DAT_1000003c + 0x10000000) == 0x4550)) &&
      (*(short *)(_DAT_1000003c + 0x10000018) == 0x10b)) &&
     ((p_Var1 = find_pe_section(&DAT_10000000,param_1 + 0xf0000000),
      p_Var1 != (_IMAGE_SECTION_HEADER *)0x0 && (-1 < (int)p_Var1->Characteristics)))) {
    return 1;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_release_startup_lock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int ___scrt_release_startup_lock(char param_1)

{
  int iVar1;
  int iVar2;
  
  iVar2 = ___scrt_is_ucrt_dll_in_use();
  iVar1 = _DAT_10012b1c;
  if ((iVar2 != 0) && (param_1 == '\0')) {
    _DAT_10012b1c = 0;
    iVar2 = iVar1;
  }
  return iVar2;
}



// Library Function - Single Match
//  ___scrt_uninitialize_crt
// 
// Library: Visual Studio 2017 Release

undefined ___scrt_uninitialize_crt(undefined4 param_1,char param_2)

{
  if ((DAT_10012b39 == '\0') || (param_2 == '\0')) {
    ___acrt_uninitialize(param_1);
    ___vcrt_uninitialize(param_1);
  }
  return 1;
}



undefined4 FUN_0042044b(void)

{
  return 0x100131e8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00420451(void)

{
  code *pcVar1;
  int iVar2;
  int iVar3;
  undefined4 local_328 [39];
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 *local_c;
  undefined4 *local_8;
  
  iVar2 = FUN_00429a1d();
  if (iVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  FUN_0042056d();
  _memset(local_328,0,0x2cc);
  local_328[0] = 0x10001;
  _memset(&local_5c,0,0x50);
  local_5c = 0x40000015;
  local_58 = 1;
  iVar2 = (*_DAT_1000c0a8)();
  local_c = &local_5c;
  local_8 = local_328;
  (*_DAT_1000c084)();
  iVar3 = (*_DAT_1000c080)();
  if ((iVar3 == 0) && (iVar2 != 1)) {
    FUN_0042056d();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0042056d(void)

{
  _DAT_10012b3c = 0;
  return;
}



// WARNING: Removing unreachable block (ram,0x00420585)
// WARNING: Removing unreachable block (ram,0x00420586)
// WARNING: Removing unreachable block (ram,0x0042058c)
// WARNING: Removing unreachable block (ram,0x00420595)
// WARNING: Removing unreachable block (ram,0x0042059c)

void FUN_00420575(void)

{
  return;
}



// WARNING: Removing unreachable block (ram,0x004205b0)
// WARNING: Removing unreachable block (ram,0x004205b1)
// WARNING: Removing unreachable block (ram,0x004205b7)
// WARNING: Removing unreachable block (ram,0x004205c0)
// WARNING: Removing unreachable block (ram,0x004205c7)

void FUN_004205a0(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_004205cb(void)

{
                    // WARNING: Could not recover jumptable at 0x004205cb. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_1000c174)();
  return;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __SEH_prolog4
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __SEH_prolog4(undefined4 param_1,int param_2)

{
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  param_2 = -param_2;
  *(undefined4 *)((int)auStack28 + param_2 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + param_2 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + param_2 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + param_2 + 4) = _DAT_10012000 ^ (uint)&stack0x00000008;
  *(undefined4 *)((int)auStack28 + param_2) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __SEH_epilog4
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __SEH_epilog4(void)

{
  undefined4 *unaff_EBP;
  undefined4 *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  *in_FS_OFFSET = unaff_EBP[-4];
  *unaff_EBP = unaff_retaddr;
  return;
}



undefined4 * __thiscall FUN_00420639(undefined4 *param_1_00,exception *param_1)

{
  std::exception::exception((exception *)param_1_00,param_1);
  *param_1_00 = 0x1000c1e0;
  return param_1_00;
}



undefined4 * __fastcall FUN_00420654(undefined4 *param_1)

{
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[1] = 0x1000c1e8;
  *param_1 = 0x1000c1e0;
  return param_1;
}



undefined4 * __thiscall FUN_0042066c(undefined4 *param_1_00,exception *param_1)

{
  std::exception::exception((exception *)param_1_00,param_1);
  *param_1_00 = 0x1000c1fc;
  return param_1_00;
}



undefined4 * __fastcall FUN_00420687(undefined4 *param_1)

{
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[1] = 0x1000c204;
  *param_1 = 0x1000c1fc;
  return param_1;
}



// Library Function - Single Match
//  public: __thiscall std::exception::exception(class std::exception const &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

exception * __thiscall std::exception::exception(exception *this,exception *param_1)

{
  *(undefined4 *)this = 0x1000c1c0;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 0;
  ___std_exception_copy(param_1 + 4,this + 4);
  return this;
}



undefined4 * __thiscall FUN_004206dc(undefined4 *param_1_00,byte param_1)

{
  *param_1_00 = 0x1000c1c0;
  ___std_exception_destroy(param_1_00 + 1);
  if ((param_1 & 1) != 0) {
    FUN_004208fa(param_1_00,0xc);
  }
  return param_1_00;
}



// Library Function - Single Match
//  void __cdecl __scrt_throw_std_bad_alloc(void)
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl __scrt_throw_std_bad_alloc(void)

{
  code *pcVar1;
  undefined local_10 [12];
  
  FUN_00420654();
  __CxxThrowException_8(local_10,0x1001116c);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_00420726(void)

{
  code *pcVar1;
  undefined local_10 [12];
  
  FUN_00420687();
  __CxxThrowException_8(local_10,0x100111c0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Removing unreachable block (ram,0x004207cc)
// WARNING: Removing unreachable block (ram,0x00420791)
// WARNING: Removing unreachable block (ram,0x00420844)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00420750(void)

{
  int *piVar1;
  uint *puVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint in_XCR0;
  
  _DAT_10012b40 = 0;
  _DAT_10012010 = _DAT_10012010 | 1;
  iVar4 = FUN_00429a1d(10);
  uVar3 = _DAT_10012010;
  if (iVar4 != 0) {
    _DAT_10012010 = _DAT_10012010 | 2;
    _DAT_10012b40 = 1;
    piVar1 = (int *)cpuid_basic_info(0);
    puVar2 = (uint *)cpuid_Version_info(1);
    uVar6 = puVar2[3];
    if (((piVar1[1] ^ 0x756e6547U | piVar1[3] ^ 0x6c65746eU | piVar1[2] ^ 0x49656e69U) == 0) &&
       (((((uVar5 = *puVar2 & 0xfff3ff0, uVar5 == 0x106c0 || (uVar5 == 0x20660)) ||
          (uVar5 == 0x20670)) || ((uVar5 == 0x30650 || (uVar5 == 0x30660)))) || (uVar5 == 0x30670)))
       ) {
      _DAT_10012b44 = _DAT_10012b44 | 1;
    }
    if (*piVar1 < 7) {
      uVar5 = 0;
    }
    else {
      iVar4 = cpuid_Extended_Feature_Enumeration_info(7);
      uVar5 = *(uint *)(iVar4 + 4);
      if ((uVar5 & 0x200) != 0) {
        _DAT_10012b44 = _DAT_10012b44 | 2;
      }
    }
    if ((uVar6 & 0x100000) != 0) {
      _DAT_10012010 = uVar3 | 6;
      _DAT_10012b40 = 2;
      if ((((uVar6 & 0x8000000) != 0) && ((uVar6 & 0x10000000) != 0)) && ((in_XCR0 & 6) == 6)) {
        _DAT_10012010 = uVar3 | 0xe;
        _DAT_10012b40 = 3;
        if ((uVar5 & 0x20) != 0) {
          _DAT_10012010 = uVar3 | 0x2e;
          _DAT_10012b40 = 5;
        }
      }
    }
  }
  return 0;
}



undefined4 FUN_004208e9(void)

{
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_is_ucrt_dll_in_use
// 
// Library: Visual Studio 2015 Release

bool ___scrt_is_ucrt_dll_in_use(void)

{
  return _DAT_100131e4 != 0;
}



void FUN_004208fa(undefined4 param_1)

{
  thunk_FUN_004230cf(param_1);
  return;
}



undefined4 * __thiscall FUN_00420908(undefined4 *param_1_00,byte param_1)

{
  *param_1_00 = 0x1000c220;
  if ((param_1 & 1) != 0) {
    FUN_004208fa(param_1_00,0xc);
  }
  return param_1_00;
}



void thunk_FUN_004230cf(void *param_1)

{
  FID_conflict__free(param_1);
  return;
}



// Library Function - Single Match
//  _ValidateLocalCookies
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void _ValidateLocalCookies(int *param_1)

{
  if (*param_1 != -2) {
    ___security_check_cookie_4();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0042097e(int *param_1,int param_2,undefined4 param_3)

{
  int iVar1;
  code *pcVar2;
  int iVar3;
  BOOL BVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  int *local_20;
  undefined4 local_1c;
  int local_18;
  int local_14;
  undefined4 local_10;
  uint local_c;
  char local_5;
  
  local_5 = '\0';
  iVar6 = param_2 + 0x10;
  local_c = *(uint *)(param_2 + 8) ^ _DAT_10012000;
  local_10 = 1;
  local_14 = iVar6;
  _ValidateLocalCookies(local_c,iVar6);
  ___except_validate_context_record(param_3);
  iVar7 = *(int *)(param_2 + 0xc);
  if ((*(byte *)(param_1 + 1) & 0x66) == 0) {
    local_20 = param_1;
    local_1c = param_3;
    *(int ***)(param_2 + -4) = &local_20;
    if (iVar7 == -2) {
      return local_10;
    }
    do {
      iVar3 = iVar7 * 3 + 4;
      iVar1 = *(int *)(local_c + iVar3 * 4);
      local_18 = local_c + iVar3 * 4;
      if (*(int *)(local_18 + 4) != 0) {
        iVar3 = __EH4_CallFilterFunc_8();
        local_5 = '\x01';
        if (iVar3 < 0) {
          local_10 = 0;
          goto LAB_00420a96;
        }
        if (0 < iVar3) {
          if (((*param_1 == -0x1f928c9d) && (_DAT_1000cae8 != (code *)0x0)) &&
             (BVar4 = __IsNonwritableInCurrentImage(&DAT_1000cae8), pcVar2 = _DAT_1000cae8,
             BVar4 != 0)) {
            FUN_004205cb(param_1,1);
            (*pcVar2)();
            iVar6 = local_14;
          }
          FUN_00420ef2();
          if (*(int *)(param_2 + 0xc) != iVar7) {
            __EH4_LocalUnwind_16(iVar6,&DAT_10012000);
          }
          *(int *)(param_2 + 0xc) = iVar1;
          _ValidateLocalCookies(local_c,iVar6);
          __EH4_TransferToHandler_8();
          pcVar2 = (code *)swi(3);
          uVar5 = (*pcVar2)();
          return uVar5;
        }
      }
      iVar7 = iVar1;
    } while (iVar1 != -2);
    if (local_5 == '\0') {
      return local_10;
    }
  }
  else {
    if (iVar7 == -2) {
      return local_10;
    }
    __EH4_LocalUnwind_16(iVar6,&DAT_10012000);
  }
LAB_00420a96:
  _ValidateLocalCookies(local_c,iVar6);
  return local_10;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___std_type_info_destroy_list
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___std_type_info_destroy_list(undefined4 param_1)

{
  undefined4 *puVar1;
  undefined4 *_Memory;
  
  _Memory = (undefined4 *)(*_DAT_1000c0b4)(param_1);
  while (_Memory != (undefined4 *)0x0) {
    puVar1 = (undefined4 *)*_Memory;
    FID_conflict__free(_Memory);
    _Memory = puVar1;
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_initialize
// 
// Library: Visual Studio 2015 Release

undefined ___vcrt_initialize(void)

{
  char cVar1;
  
  ___vcrt_initialize_pure_virtual_call_handler();
  ___vcrt_initialize_winapi_thunks();
  cVar1 = ___vcrt_initialize_locks();
  if (cVar1 != '\0') {
    cVar1 = FUN_00421073();
    if (cVar1 != '\0') {
      return 1;
    }
    ___vcrt_uninitialize_locks();
  }
  return 0;
}



// Library Function - Single Match
//  ___vcrt_thread_attach
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

uint ___vcrt_thread_attach(void)

{
  uint uVar1;
  
  uVar1 = ___vcrt_getptd_noexit();
  return uVar1 & 0xffffff00 | (uint)(uVar1 != 0);
}



// Library Function - Single Match
//  ___vcrt_thread_detach
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___vcrt_thread_detach(void)

{
  FUN_00420f9e(0);
  return 1;
}



// Library Function - Single Match
//  ___vcrt_uninitialize
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined ___vcrt_uninitialize(char param_1)

{
  if (param_1 == '\0') {
    ___vcrt_uninitialize_ptd();
    ___vcrt_uninitialize_locks();
    ___vcrt_uninitialize_winapi_thunks(0);
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _memset
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void * __cdecl _memset(void *_Dst,int _Val,size_t _Size)

{
  int iVar1;
  undefined *puVar2;
  int *piVar3;
  
  if (_Size == 0) {
    return _Dst;
  }
  iVar1 = (_Val & 0xffU) * 0x1010101;
  piVar3 = (int *)_Dst;
  if (0x20 < (int)_Size) {
    if (0x7f < (int)_Size) {
      puVar2 = (undefined *)_Dst;
      if ((_DAT_10012b44 >> 1 & 1) != 0) {
        for (; _Size != 0; _Size = _Size - 1) {
          *puVar2 = (char)iVar1;
          puVar2 = puVar2 + 1;
        }
        return _Dst;
      }
      if ((_DAT_10012010 >> 1 & 1) == 0) goto joined_r0x00420c79;
      *(int *)_Dst = iVar1;
      *(int *)((int)_Dst + 4) = iVar1;
      *(int *)((int)_Dst + 8) = iVar1;
      *(int *)((int)_Dst + 0xc) = iVar1;
      piVar3 = (int *)((int)_Dst + 0x10U & 0xfffffff0);
      _Size = (int)_Dst + (_Size - (int)piVar3);
      if (0x80 < (int)_Size) {
        do {
          *piVar3 = iVar1;
          piVar3[1] = iVar1;
          piVar3[2] = iVar1;
          piVar3[3] = iVar1;
          piVar3[4] = iVar1;
          piVar3[5] = iVar1;
          piVar3[6] = iVar1;
          piVar3[7] = iVar1;
          piVar3[8] = iVar1;
          piVar3[9] = iVar1;
          piVar3[10] = iVar1;
          piVar3[0xb] = iVar1;
          piVar3[0xc] = iVar1;
          piVar3[0xd] = iVar1;
          piVar3[0xe] = iVar1;
          piVar3[0xf] = iVar1;
          piVar3[0x10] = iVar1;
          piVar3[0x11] = iVar1;
          piVar3[0x12] = iVar1;
          piVar3[0x13] = iVar1;
          piVar3[0x14] = iVar1;
          piVar3[0x15] = iVar1;
          piVar3[0x16] = iVar1;
          piVar3[0x17] = iVar1;
          piVar3[0x18] = iVar1;
          piVar3[0x19] = iVar1;
          piVar3[0x1a] = iVar1;
          piVar3[0x1b] = iVar1;
          piVar3[0x1c] = iVar1;
          piVar3[0x1d] = iVar1;
          piVar3[0x1e] = iVar1;
          piVar3[0x1f] = iVar1;
          piVar3 = piVar3 + 0x20;
          _Size = _Size - 0x80;
        } while ((_Size & 0xffffff00) != 0);
        goto LAB_00420c3e;
      }
    }
    if ((_DAT_10012010 >> 1 & 1) != 0) {
LAB_00420c3e:
      if (0x1f < _Size) {
        do {
          *piVar3 = iVar1;
          piVar3[1] = iVar1;
          piVar3[2] = iVar1;
          piVar3[3] = iVar1;
          piVar3[4] = iVar1;
          piVar3[5] = iVar1;
          piVar3[6] = iVar1;
          piVar3[7] = iVar1;
          piVar3 = piVar3 + 8;
          _Size = _Size - 0x20;
        } while (0x1f < _Size);
        if ((_Size & 0x1f) == 0) {
          return _Dst;
        }
      }
      piVar3 = (int *)((int)piVar3 + (_Size - 0x20));
      *piVar3 = iVar1;
      piVar3[1] = iVar1;
      piVar3[2] = iVar1;
      piVar3[3] = iVar1;
      piVar3[4] = iVar1;
      piVar3[5] = iVar1;
      piVar3[6] = iVar1;
      piVar3[7] = iVar1;
      return _Dst;
    }
  }
joined_r0x00420c79:
  for (; (_Size & 3) != 0; _Size = _Size - 1) {
    *(char *)piVar3 = (char)iVar1;
    piVar3 = (int *)((int)piVar3 + 1);
  }
  if ((_Size & 4) != 0) {
    *piVar3 = iVar1;
    piVar3 = piVar3 + 1;
    _Size = _Size - 4;
  }
  for (; (_Size & 0xfffffff8) != 0; _Size = _Size - 8) {
    *piVar3 = iVar1;
    piVar3[1] = iVar1;
    piVar3 = piVar3 + 2;
  }
  return _Dst;
}



// Library Function - Single Match
//  ___std_exception_copy
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___std_exception_copy(char **param_1,char **param_2)

{
  char *pcVar1;
  char cVar2;
  char *_Dst;
  char *pcVar3;
  char *pcVar4;
  
  if ((*(char *)(param_1 + 1) == '\0') || (pcVar3 = *param_1, pcVar3 == (char *)0x0)) {
    *param_2 = *param_1;
    *(undefined *)(param_2 + 1) = 0;
  }
  else {
    pcVar1 = pcVar3 + 1;
    do {
      cVar2 = *pcVar3;
      pcVar3 = pcVar3 + 1;
    } while (cVar2 != '\0');
    _Dst = (char *)FUN_004223d3(pcVar3 + (1 - (int)pcVar1));
    pcVar4 = _Dst;
    if (_Dst != (char *)0x0) {
      _strcpy_s(_Dst,(rsize_t)(pcVar3 + (1 - (int)pcVar1)),*param_1);
      pcVar4 = (char *)0x0;
      *param_2 = _Dst;
      *(undefined *)(param_2 + 1) = 1;
    }
    FUN_004230cf(pcVar4);
  }
  return;
}



// Library Function - Single Match
//  ___std_exception_destroy
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___std_exception_destroy(undefined4 *param_1)

{
  if (*(char *)(param_1 + 1) != '\0') {
    FUN_004230cf(*param_1);
  }
  *param_1 = 0;
  *(undefined *)(param_1 + 1) = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __CxxThrowException@8
// 
// Library: Visual Studio 2015 Release

void __CxxThrowException_8(int *param_1,byte *param_2)

{
  code *pcVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  undefined4 local_24 [4];
  undefined4 local_14;
  undefined4 local_10;
  int *local_c;
  byte *local_8;
  
  puVar3 = (undefined4 *)&DAT_1000c224;
  puVar4 = local_24;
  for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {
    *puVar4 = *puVar3;
    puVar3 = puVar3 + 1;
    puVar4 = puVar4 + 1;
  }
  if ((param_2 != (byte *)0x0) && ((*param_2 & 0x10) != 0)) {
    iVar2 = *(int *)(*param_1 + -4);
    pcVar1 = *(code **)(iVar2 + 0x20);
    param_2 = *(byte **)(iVar2 + 0x18);
    FUN_004205cb((int *)(*param_1 + -4));
    (*pcVar1)();
  }
  local_c = param_1;
  if ((param_2 != (byte *)0x0) && ((*param_2 & 8) != 0)) {
    local_10 = 0x1994000;
  }
  local_8 = param_2;
  (*_DAT_1000c0b8)(local_24[0],local_24[1],local_14,&local_10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __local_unwind4
// 
// Library: Visual Studio

void __local_unwind4(uint *param_1,int param_2,uint param_3)

{
  undefined4 *puVar1;
  uint uVar2;
  undefined4 *in_FS_OFFSET;
  undefined4 uStack40;
  undefined4 uStack36;
  uint local_20;
  uint uStack28;
  int iStack24;
  uint *puStack20;
  
  puStack20 = param_1;
  iStack24 = param_2;
  uStack28 = param_3;
  uStack36 = 0x100029f0;
  uStack40 = *in_FS_OFFSET;
  local_20 = _DAT_10012000 ^ (uint)&uStack40;
  *in_FS_OFFSET = &uStack40;
  while( true ) {
    uVar2 = *(uint *)(param_2 + 0xc);
    if ((uVar2 == 0xfffffffe) || ((param_3 != 0xfffffffe && (uVar2 <= param_3)))) break;
    puVar1 = (undefined4 *)((*(uint *)(param_2 + 8) ^ *param_1) + 0x10 + uVar2 * 0xc);
    *(undefined4 *)(param_2 + 0xc) = *puVar1;
    if (puVar1[1] == 0) {
      __NLG_Notify(0x101);
      FUN_004215a9();
    }
  }
  *in_FS_OFFSET = uStack40;
  return;
}



// Library Function - Single Match
//  @_EH4_CallFilterFunc@8
// 
// Library: Visual Studio

void __fastcall __EH4_CallFilterFunc_8(code *param_1)

{
  (*param_1)();
  return;
}



// Library Function - Single Match
//  @_EH4_TransferToHandler@8
// 
// Library: Visual Studio

void __fastcall __EH4_TransferToHandler_8(code *UNRECOVERED_JUMPTABLE)

{
  __NLG_Notify(1);
                    // WARNING: Could not recover jumptable at 0x00420eed. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_00420ef2(undefined4 param_1,undefined4 param_2)

{
  (*_DAT_1000c0bc)(param_1,0x10002aa9,param_2,0);
  return;
}



// Library Function - Single Match
//  @_EH4_LocalUnwind@16
// 
// Library: Visual Studio

void __fastcall
__EH4_LocalUnwind_16
          (undefined4 param_1_00,undefined4 param_2_00,undefined4 param_1,undefined4 param_2)

{
  __local_unwind4(param_2,param_1_00,param_2_00);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___except_validate_context_record
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___except_validate_context_record(int param_1)

{
  uint *puVar1;
  uint uVar2;
  code *pcVar3;
  int in_FS_OFFSET;
  
  if (_DAT_1000c174 != 0x1000249b) {
    uVar2 = *(uint *)(param_1 + 0xc4);
    if ((uVar2 < *(uint *)(*(int *)(in_FS_OFFSET + 0x18) + 8)) ||
       (puVar1 = (uint *)(*(int *)(in_FS_OFFSET + 0x18) + 4), *puVar1 <= uVar2 && uVar2 != *puVar1))
    {
      pcVar3 = (code *)swi(0x29);
      (*pcVar3)();
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___except_validate_jump_buffer
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___except_validate_jump_buffer(int param_1)

{
  uint *puVar1;
  uint uVar2;
  code *pcVar3;
  int in_FS_OFFSET;
  
  if (_DAT_1000c174 != 0x1000249b) {
    uVar2 = *(uint *)(param_1 + 0x10);
    if ((uVar2 < *(uint *)(*(int *)(in_FS_OFFSET + 0x18) + 8)) ||
       (puVar1 = (uint *)(*(int *)(in_FS_OFFSET + 0x18) + 4), *puVar1 <= uVar2 && uVar2 != *puVar1))
    {
      pcVar3 = (code *)swi(0x29);
      (*pcVar3)();
    }
  }
  return;
}



void FUN_00420f82(void *param_1)

{
  if ((param_1 != (void *)0x0) && (param_1 != (void *)0x10012b84)) {
    FID_conflict__free(param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00420f9e(void *param_1)

{
  if (_DAT_10012020 != -1) {
    if (param_1 == (void *)0x0) {
      param_1 = (void *)___vcrt_FlsGetValue(_DAT_10012020);
    }
    ___vcrt_FlsSetValue(_DAT_10012020,0);
    if ((param_1 != (void *)0x0) && (param_1 != (void *)0x10012b84)) {
      FID_conflict__free(param_1);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_getptd_noexit
// 
// Library: Visual Studio 2015 Release

void * ___vcrt_getptd_noexit(void)

{
  undefined4 uVar1;
  void *pvVar2;
  int iVar3;
  void *pvVar4;
  void *_Memory;
  
  if (_DAT_10012020 == -1) {
    return (void *)0x0;
  }
  uVar1 = (*_DAT_1000c0c0)();
  pvVar2 = (void *)___vcrt_FlsGetValue(_DAT_10012020);
  if (pvVar2 == (void *)0xffffffff) {
LAB_00421021:
    pvVar2 = (void *)0x0;
    goto LAB_00421067;
  }
  if (pvVar2 != (void *)0x0) goto LAB_00421067;
  iVar3 = ___vcrt_FlsSetValue(_DAT_10012020,0xffffffff);
  if (iVar3 == 0) goto LAB_00421021;
  pvVar4 = (void *)__calloc_base(1,0x28);
  if (pvVar4 == (void *)0x0) {
LAB_00421049:
    ___vcrt_FlsSetValue(_DAT_10012020,0);
    pvVar2 = (void *)0x0;
    _Memory = pvVar4;
  }
  else {
    iVar3 = ___vcrt_FlsSetValue(_DAT_10012020,pvVar4);
    if (iVar3 == 0) goto LAB_00421049;
    _Memory = (void *)0x0;
    pvVar2 = pvVar4;
  }
  FID_conflict__free(_Memory);
LAB_00421067:
  (*_DAT_1000c0c4)(uVar1);
  return pvVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00421073(void)

{
  int iVar1;
  
  _DAT_10012020 = ___vcrt_FlsAlloc(0x10002b24);
  if (_DAT_10012020 != -1) {
    iVar1 = ___vcrt_FlsSetValue(_DAT_10012020,0x10012b84);
    if (iVar1 != 0) {
      return 1;
    }
    if (_DAT_10012020 != -1) {
      ___vcrt_FlsFree(_DAT_10012020);
      _DAT_10012020 = -1;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_uninitialize_ptd
// 
// Library: Visual Studio 2015 Release

undefined4 ___vcrt_uninitialize_ptd(void)

{
  if (_DAT_10012020 != -1) {
    ___vcrt_FlsFree(_DAT_10012020);
    _DAT_10012020 = -1;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_initialize_locks
// 
// Library: Visual Studio 2015 Release

undefined4 ___vcrt_initialize_locks(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  
  iVar3 = 0x10012bac;
  uVar2 = 0;
  do {
    iVar1 = ___vcrt_InitializeCriticalSectionEx(iVar3,4000,0);
    if (iVar1 == 0) {
      ___vcrt_uninitialize_locks();
      return 0;
    }
    _DAT_10012bc4 = _DAT_10012bc4 + 1;
    uVar2 = uVar2 + 0x18;
    iVar3 = iVar3 + 0x18;
  } while (uVar2 < 0x18);
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_uninitialize_locks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 ___vcrt_uninitialize_locks(void)

{
  int iVar1;
  int iVar2;
  
  if (_DAT_10012bc4 != 0) {
    iVar2 = _DAT_10012bc4 * 0x18 + 0x10012b94;
    iVar1 = _DAT_10012bc4;
    do {
      (*_DAT_1000c0d0)(iVar2);
      _DAT_10012bc4 = _DAT_10012bc4 + -1;
      iVar2 = iVar2 + -0x18;
      iVar1 = iVar1 + -1;
    } while (iVar1 != 0);
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void * __cdecl __crt_fast_encode_pointer<void *>(void * const)
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void * __cdecl __crt_fast_encode_pointer_void__(void *param_1)

{
  byte bVar1;
  
  bVar1 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
  return (void *)(((uint)param_1 >> bVar1 | (int)param_1 << 0x20 - bVar1) ^ _DAT_10012000);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  struct HINSTANCE__ * __cdecl try_get_first_available_module(enum `anonymous
// namespace'::module_id const * const,enum `anonymous namespace'::module_id const * const)
// 
// Library: Visual Studio 2017 Release

HINSTANCE__ * __cdecl try_get_first_available_module(module_id *param_1,module_id *param_2)

{
  HINSTANCE__ **ppHVar1;
  wchar_t *_Str1;
  HINSTANCE__ *pHVar2;
  HINSTANCE__ *pHVar3;
  int iVar4;
  
  do {
    if (param_1 == param_2) {
      return (HINSTANCE__ *)0x0;
    }
    ppHVar1 = (HINSTANCE__ **)(&DAT_10012bc8 + *param_1 * 4);
    pHVar3 = *ppHVar1;
    if (pHVar3 == (HINSTANCE__ *)0x0) {
      _Str1 = *(wchar_t **)(*param_1 * 4 + 0x1000c9c0);
      pHVar3 = (HINSTANCE__ *)(*_DAT_1000c0ec)(_Str1,0,0x800);
      if (pHVar3 == (HINSTANCE__ *)0x0) {
        iVar4 = (*_DAT_1000c0c0)();
        if (((iVar4 == 0x57) && (iVar4 = _wcsncmp(_Str1,(wchar_t *)0x1000ca58,7), iVar4 != 0)) &&
           (iVar4 = _wcsncmp(_Str1,(wchar_t *)0x1000ca68,7), iVar4 != 0)) {
          pHVar3 = (HINSTANCE__ *)(*_DAT_1000c0ec)(_Str1,0,0);
        }
        else {
          pHVar3 = (HINSTANCE__ *)0x0;
        }
        if (pHVar3 == (HINSTANCE__ *)0x0) {
          *ppHVar1 = (HINSTANCE__ *)0xffffffff;
          goto LAB_00421209;
        }
      }
      pHVar2 = *ppHVar1;
      *ppHVar1 = pHVar3;
      if (pHVar2 != (HINSTANCE__ *)0x0) {
        (*_DAT_1000c0e8)(pHVar3);
      }
LAB_00421205:
      if (pHVar3 != (HINSTANCE__ *)0x0) {
        return pHVar3;
      }
    }
    else if (pHVar3 != (HINSTANCE__ *)0xffffffff) goto LAB_00421205;
LAB_00421209:
    param_1 = param_1 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_00421222(int param_1,undefined4 param_2,module_id *param_3,module_id *param_4)

{
  uint *puVar1;
  HINSTANCE__ *pHVar2;
  byte bVar3;
  uint uVar4;
  
  puVar1 = (uint *)(&DAT_10012bd4 + param_1 * 4);
  bVar3 = (byte)_DAT_10012000 & 0x1f;
  uVar4 = (_DAT_10012000 ^ *puVar1) >> bVar3 | (_DAT_10012000 ^ *puVar1) << 0x20 - bVar3;
  if (uVar4 != 0xffffffff) {
    if (uVar4 != 0) {
      return uVar4;
    }
    pHVar2 = try_get_first_available_module(param_3,param_4);
    if ((pHVar2 != (HINSTANCE__ *)0x0) && (uVar4 = (*_DAT_1000c058)(pHVar2,param_2), uVar4 != 0)) {
      bVar3 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
      *puVar1 = (uVar4 >> bVar3 | uVar4 << 0x20 - bVar3) ^ _DAT_10012000;
      return uVar4;
    }
    bVar3 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
    *puVar1 = (0xffffffffU >> bVar3 | -1 << 0x20 - bVar3) ^ _DAT_10012000;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_FlsAlloc
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsAlloc(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00421222(0,0x1000ca80,0x1000ca78,0x1000ca80);
  if (pcVar1 != (code *)0x0) {
    FUN_004205cb(param_1);
    (*pcVar1)();
    return;
  }
                    // WARNING: Could not recover jumptable at 0x004212dd. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_1000c0d8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_FlsFree
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsFree(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00421222(1,0x1000ca94,0x1000ca8c,0x1000ca94);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0e4)(param_1);
  }
  else {
    FUN_004205cb();
    (*pcVar1)();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_FlsGetValue
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsGetValue(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00421222(2,0x1000caa4,0x1000ca9c,0x1000caa4);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0dc)(param_1);
  }
  else {
    FUN_004205cb();
    (*pcVar1)();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_FlsSetValue
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsSetValue(undefined4 param_1,undefined4 param_2)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00421222(3,0x1000cab8,0x1000cab0,0x1000cab8);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0e0)(param_1,param_2);
  }
  else {
    FUN_004205cb();
    (*pcVar1)();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_InitializeCriticalSectionEx
// 
// Library: Visual Studio 2015 Release

void ___vcrt_InitializeCriticalSectionEx(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00421222(4,0x1000cacc,0x1000cac4,0x1000cacc);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c07c)(param_1,param_2);
  }
  else {
    FUN_004205cb(param_1,param_2,param_3);
    (*pcVar1)();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_initialize_winapi_thunks
// 
// Library: Visual Studio 2015 Release

void ___vcrt_initialize_winapi_thunks(void)

{
  byte bVar1;
  uint *puVar2;
  int iVar3;
  uint uVar4;
  
  puVar2 = (uint *)&DAT_10012bd4;
  bVar1 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
  iVar3 = 0;
  uVar4 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ _DAT_10012000;
  do {
    iVar3 = iVar3 + 1;
    *puVar2 = uVar4;
    puVar2 = puVar2 + 1;
  } while (iVar3 != 5);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_uninitialize_winapi_thunks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___vcrt_uninitialize_winapi_thunks(char param_1)

{
  int *piVar1;
  
  if (param_1 == '\0') {
    piVar1 = (int *)&DAT_10012bc8;
    do {
      if (*piVar1 != 0) {
        if (*piVar1 != -1) {
          (*_DAT_1000c0e8)(*piVar1);
        }
        *piVar1 = 0;
      }
      piVar1 = piVar1 + 1;
    } while (piVar1 != (int *)&DAT_10012bd4);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_initialize_pure_virtual_call_handler
// 
// Library: Visual Studio 2015 Release

void ___vcrt_initialize_pure_virtual_call_handler(void)

{
  byte bVar1;
  
  bVar1 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
  _DAT_10012be8 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ _DAT_10012000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __global_unwind2
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __global_unwind2(undefined4 param_1)

{
  (*_DAT_1000c0bc)(param_1,0x10003029,0,0,&stack0xfffffffc);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __local_unwind2
// 
// Library: Visual Studio

void __local_unwind2(int param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  undefined4 *in_FS_OFFSET;
  undefined4 local_20;
  undefined4 uStack28;
  undefined4 local_18;
  int iStack20;
  
  iStack20 = param_1;
  uStack28 = 0x10003031;
  local_20 = *in_FS_OFFSET;
  uVar2 = _DAT_10012000 ^ (uint)&local_20;
  *in_FS_OFFSET = &local_20;
  while( true ) {
    uVar1 = *(uint *)(param_1 + 0xc);
    if ((uVar1 == 0xffffffff) || ((param_2 != 0xffffffff && (uVar1 <= param_2)))) break;
    local_18 = *(undefined4 *)(*(int *)(param_1 + 8) + uVar1 * 0xc);
    *(undefined4 *)(param_1 + 0xc) = local_18;
    if (*(int *)(*(int *)(param_1 + 8) + 4 + uVar1 * 0xc) == 0) {
      __NLG_Notify(0x101);
      FUN_004215a9(uVar2);
    }
  }
  *in_FS_OFFSET = local_20;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __NLG_Notify1
// 
// Library: Visual Studio

undefined4 __fastcall __NLG_Notify1(undefined4 param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  _DAT_10012034 = in_EAX;
  _DAT_10012038 = param_1;
  _DAT_1001203c = unaff_EBP;
  return in_EAX;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __NLG_Notify
// 
// Library: Visual Studio

void __NLG_Notify(ulong param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  _DAT_10012034 = in_EAX;
  _DAT_10012038 = param_1;
  _DAT_1001203c = unaff_EBP;
  return;
}



void FUN_004215a9(void)

{
  code *in_EAX;
  
  (*in_EAX)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 FUN_004215ae(undefined8 *param_1,undefined8 *param_2,uint param_3)

{
  undefined auVar1 [32];
  undefined auVar2 [32];
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  undefined4 uVar19;
  undefined4 uVar20;
  undefined4 uVar21;
  undefined4 uVar22;
  undefined4 uVar23;
  undefined4 uVar24;
  undefined4 uVar25;
  undefined4 uVar26;
  undefined4 uVar27;
  undefined4 uVar28;
  undefined4 uVar29;
  undefined4 uVar30;
  int iVar31;
  uint uVar32;
  uint uVar33;
  int iVar34;
  undefined8 *puVar35;
  undefined4 *puVar36;
  undefined4 *puVar37;
  undefined8 *puVar38;
  undefined4 *puVar39;
  undefined4 *puVar40;
  undefined4 uVar41;
  undefined4 uVar42;
  undefined4 uVar43;
  undefined8 uVar44;
  
  if ((param_2 < param_1) && (param_1 < (undefined8 *)(param_3 + (int)param_2))) {
    puVar36 = (undefined4 *)((int)param_2 + param_3);
    puVar39 = (undefined4 *)((int)param_1 + param_3);
    uVar32 = param_3;
    if (0x1f < param_3) {
      if ((_DAT_10012010 >> 1 & 1) == 0) {
        if (((uint)puVar39 & 3) != 0) {
          uVar32 = (uint)puVar39 & 3;
          param_3 = param_3 - uVar32;
          do {
            *(undefined *)((int)puVar39 - 1) = *(undefined *)((int)puVar36 + -1);
            puVar36 = (undefined4 *)((int)puVar36 + -1);
            puVar39 = (undefined4 *)((int)puVar39 - 1);
            uVar32 = uVar32 - 1;
          } while (uVar32 != 0);
        }
        if (0x1f < param_3) {
          uVar32 = param_3 >> 2;
          while( true ) {
            puVar39 = puVar39 + -1;
            puVar36 = puVar36 + -1;
            if (uVar32 == 0) break;
            uVar32 = uVar32 - 1;
            *puVar39 = *puVar36;
          }
                    // WARNING: Could not emulate address calculation at 0x004218b6
                    // WARNING: Treating indirect jump as call
          uVar44 = (**(code **)(&DAT_10003460 + (param_3 & 3) * 4))();
          return uVar44;
        }
      }
      else {
        while (puVar37 = puVar36, puVar40 = puVar39, ((uint)puVar39 & 0xf) != 0) {
          puVar36 = (undefined4 *)((int)puVar36 + -1);
          puVar39 = (undefined4 *)((int)puVar39 + -1);
          *(undefined *)puVar39 = *(undefined *)puVar36;
          param_3 = param_3 - 1;
        }
        do {
          puVar36 = puVar37;
          puVar39 = puVar40;
          if (param_3 < 0x80) break;
          puVar36 = puVar37 + -0x20;
          puVar39 = puVar40 + -0x20;
          uVar41 = puVar37[-0x1f];
          uVar42 = puVar37[-0x1e];
          uVar43 = puVar37[-0x1d];
          uVar3 = puVar37[-0x1c];
          uVar4 = puVar37[-0x1b];
          uVar5 = puVar37[-0x1a];
          uVar6 = puVar37[-0x19];
          uVar7 = puVar37[-0x18];
          uVar8 = puVar37[-0x17];
          uVar9 = puVar37[-0x16];
          uVar10 = puVar37[-0x15];
          uVar11 = puVar37[-0x14];
          uVar12 = puVar37[-0x13];
          uVar13 = puVar37[-0x12];
          uVar14 = puVar37[-0x11];
          uVar15 = puVar37[-0x10];
          uVar16 = puVar37[-0xf];
          uVar17 = puVar37[-0xe];
          uVar18 = puVar37[-0xd];
          uVar19 = puVar37[-0xc];
          uVar20 = puVar37[-0xb];
          uVar21 = puVar37[-10];
          uVar22 = puVar37[-9];
          uVar23 = puVar37[-8];
          uVar24 = puVar37[-7];
          uVar25 = puVar37[-6];
          uVar26 = puVar37[-5];
          uVar27 = puVar37[-4];
          uVar28 = puVar37[-3];
          uVar29 = puVar37[-2];
          uVar30 = puVar37[-1];
          *puVar39 = *puVar36;
          puVar40[-0x1f] = uVar41;
          puVar40[-0x1e] = uVar42;
          puVar40[-0x1d] = uVar43;
          puVar40[-0x1c] = uVar3;
          puVar40[-0x1b] = uVar4;
          puVar40[-0x1a] = uVar5;
          puVar40[-0x19] = uVar6;
          puVar40[-0x18] = uVar7;
          puVar40[-0x17] = uVar8;
          puVar40[-0x16] = uVar9;
          puVar40[-0x15] = uVar10;
          puVar40[-0x14] = uVar11;
          puVar40[-0x13] = uVar12;
          puVar40[-0x12] = uVar13;
          puVar40[-0x11] = uVar14;
          puVar40[-0x10] = uVar15;
          puVar40[-0xf] = uVar16;
          puVar40[-0xe] = uVar17;
          puVar40[-0xd] = uVar18;
          puVar40[-0xc] = uVar19;
          puVar40[-0xb] = uVar20;
          puVar40[-10] = uVar21;
          puVar40[-9] = uVar22;
          puVar40[-8] = uVar23;
          puVar40[-7] = uVar24;
          puVar40[-6] = uVar25;
          puVar40[-5] = uVar26;
          puVar40[-4] = uVar27;
          puVar40[-3] = uVar28;
          puVar40[-2] = uVar29;
          puVar40[-1] = uVar30;
          param_3 = param_3 - 0x80;
          puVar37 = puVar36;
          puVar40 = puVar39;
        } while ((param_3 & 0xffffff80) != 0);
        puVar37 = puVar36;
        puVar40 = puVar39;
        if (0x1f < param_3) {
          do {
            puVar36 = puVar37 + -8;
            puVar39 = puVar40 + -8;
            uVar41 = puVar37[-7];
            uVar42 = puVar37[-6];
            uVar43 = puVar37[-5];
            uVar3 = puVar37[-4];
            uVar4 = puVar37[-3];
            uVar5 = puVar37[-2];
            uVar6 = puVar37[-1];
            *puVar39 = *puVar36;
            puVar40[-7] = uVar41;
            puVar40[-6] = uVar42;
            puVar40[-5] = uVar43;
            puVar40[-4] = uVar3;
            puVar40[-3] = uVar4;
            puVar40[-2] = uVar5;
            puVar40[-1] = uVar6;
            param_3 = param_3 - 0x20;
            puVar37 = puVar36;
            puVar40 = puVar39;
          } while ((param_3 & 0xffffffe0) != 0);
        }
      }
    }
    for (; (param_3 & 0xfffffffc) != 0; param_3 = param_3 - 4) {
      puVar39 = puVar39 + -1;
      puVar36 = puVar36 + -1;
      *puVar39 = *puVar36;
    }
    for (; param_3 != 0; param_3 = param_3 - 1) {
      puVar39 = (undefined4 *)((int)puVar39 - 1);
      puVar36 = (undefined4 *)((int)puVar36 + -1);
      *(undefined *)puVar39 = *(undefined *)puVar36;
    }
    return CONCAT44(uVar32,param_1);
  }
  uVar32 = param_3;
  puVar38 = param_1;
  if (0x1f < param_3) {
    if (param_3 < 0x80) {
      if ((_DAT_10012010 >> 1 & 1) != 0) {
LAB_00421a7b:
        if (uVar32 == 0) goto LAB_00421ade;
        for (param_3 = uVar32 >> 5; param_3 != 0; param_3 = param_3 - 1) {
          uVar41 = *(undefined4 *)((int)param_2 + 4);
          uVar42 = *(undefined4 *)(param_2 + 1);
          uVar43 = *(undefined4 *)((int)param_2 + 0xc);
          uVar3 = *(undefined4 *)(param_2 + 2);
          uVar4 = *(undefined4 *)((int)param_2 + 0x14);
          uVar5 = *(undefined4 *)(param_2 + 3);
          uVar6 = *(undefined4 *)((int)param_2 + 0x1c);
          *(undefined4 *)puVar38 = *(undefined4 *)param_2;
          *(undefined4 *)((int)puVar38 + 4) = uVar41;
          *(undefined4 *)(puVar38 + 1) = uVar42;
          *(undefined4 *)((int)puVar38 + 0xc) = uVar43;
          *(undefined4 *)(puVar38 + 2) = uVar3;
          *(undefined4 *)((int)puVar38 + 0x14) = uVar4;
          *(undefined4 *)(puVar38 + 3) = uVar5;
          *(undefined4 *)((int)puVar38 + 0x1c) = uVar6;
          param_2 = param_2 + 4;
          puVar38 = puVar38 + 4;
        }
        goto LAB_00421aa9;
      }
LAB_004217d5:
      uVar32 = (uint)param_1 & 3;
      while (uVar32 != 0) {
        *(undefined *)puVar38 = *(undefined *)param_2;
        param_3 = param_3 - 1;
        param_2 = (undefined8 *)((int)param_2 + 1);
        puVar38 = (undefined8 *)((int)puVar38 + 1);
        uVar32 = (uint)puVar38 & 3;
      }
    }
    else {
      if ((_DAT_10012b44 >> 1 & 1) != 0) {
        for (; uVar32 != 0; uVar32 = uVar32 - 1) {
          *(undefined *)puVar38 = *(undefined *)param_2;
          param_2 = (undefined8 *)((int)param_2 + 1);
          puVar38 = (undefined8 *)((int)puVar38 + 1);
        }
        return CONCAT44(param_3,param_1);
      }
      if (((((uint)param_1 ^ (uint)param_2) & 0xf) == 0) && ((_DAT_10012010 >> 1 & 1) != 0)) {
        if (((uint)param_2 & 0xf) != 0) {
          uVar33 = 0x10 - ((uint)param_2 & 0xf);
          param_3 = param_3 - uVar33;
          for (uVar32 = uVar33 & 3; uVar32 != 0; uVar32 = uVar32 - 1) {
            *(undefined *)puVar38 = *(undefined *)param_2;
            param_2 = (undefined8 *)((int)param_2 + 1);
            puVar38 = (undefined8 *)((int)puVar38 + 1);
          }
          for (uVar33 = uVar33 >> 2; uVar33 != 0; uVar33 = uVar33 - 1) {
            *(undefined4 *)puVar38 = *(undefined4 *)param_2;
            param_2 = (undefined8 *)((int)param_2 + 4);
            puVar38 = (undefined8 *)((int)puVar38 + 4);
          }
        }
        uVar32 = param_3 & 0x7f;
        for (param_3 = param_3 >> 7; param_3 != 0; param_3 = param_3 - 1) {
          uVar41 = *(undefined4 *)((int)param_2 + 4);
          uVar42 = *(undefined4 *)(param_2 + 1);
          uVar43 = *(undefined4 *)((int)param_2 + 0xc);
          uVar3 = *(undefined4 *)(param_2 + 2);
          uVar4 = *(undefined4 *)((int)param_2 + 0x14);
          uVar5 = *(undefined4 *)(param_2 + 3);
          uVar6 = *(undefined4 *)((int)param_2 + 0x1c);
          uVar7 = *(undefined4 *)(param_2 + 4);
          uVar8 = *(undefined4 *)((int)param_2 + 0x24);
          uVar9 = *(undefined4 *)(param_2 + 5);
          uVar10 = *(undefined4 *)((int)param_2 + 0x2c);
          uVar11 = *(undefined4 *)(param_2 + 6);
          uVar12 = *(undefined4 *)((int)param_2 + 0x34);
          uVar13 = *(undefined4 *)(param_2 + 7);
          uVar14 = *(undefined4 *)((int)param_2 + 0x3c);
          *(undefined4 *)puVar38 = *(undefined4 *)param_2;
          *(undefined4 *)((int)puVar38 + 4) = uVar41;
          *(undefined4 *)(puVar38 + 1) = uVar42;
          *(undefined4 *)((int)puVar38 + 0xc) = uVar43;
          *(undefined4 *)(puVar38 + 2) = uVar3;
          *(undefined4 *)((int)puVar38 + 0x14) = uVar4;
          *(undefined4 *)(puVar38 + 3) = uVar5;
          *(undefined4 *)((int)puVar38 + 0x1c) = uVar6;
          *(undefined4 *)(puVar38 + 4) = uVar7;
          *(undefined4 *)((int)puVar38 + 0x24) = uVar8;
          *(undefined4 *)(puVar38 + 5) = uVar9;
          *(undefined4 *)((int)puVar38 + 0x2c) = uVar10;
          *(undefined4 *)(puVar38 + 6) = uVar11;
          *(undefined4 *)((int)puVar38 + 0x34) = uVar12;
          *(undefined4 *)(puVar38 + 7) = uVar13;
          *(undefined4 *)((int)puVar38 + 0x3c) = uVar14;
          uVar41 = *(undefined4 *)((int)param_2 + 0x44);
          uVar42 = *(undefined4 *)(param_2 + 9);
          uVar43 = *(undefined4 *)((int)param_2 + 0x4c);
          uVar3 = *(undefined4 *)(param_2 + 10);
          uVar4 = *(undefined4 *)((int)param_2 + 0x54);
          uVar5 = *(undefined4 *)(param_2 + 0xb);
          uVar6 = *(undefined4 *)((int)param_2 + 0x5c);
          uVar7 = *(undefined4 *)(param_2 + 0xc);
          uVar8 = *(undefined4 *)((int)param_2 + 100);
          uVar9 = *(undefined4 *)(param_2 + 0xd);
          uVar10 = *(undefined4 *)((int)param_2 + 0x6c);
          uVar11 = *(undefined4 *)(param_2 + 0xe);
          uVar12 = *(undefined4 *)((int)param_2 + 0x74);
          uVar13 = *(undefined4 *)(param_2 + 0xf);
          uVar14 = *(undefined4 *)((int)param_2 + 0x7c);
          *(undefined4 *)(puVar38 + 8) = *(undefined4 *)(param_2 + 8);
          *(undefined4 *)((int)puVar38 + 0x44) = uVar41;
          *(undefined4 *)(puVar38 + 9) = uVar42;
          *(undefined4 *)((int)puVar38 + 0x4c) = uVar43;
          *(undefined4 *)(puVar38 + 10) = uVar3;
          *(undefined4 *)((int)puVar38 + 0x54) = uVar4;
          *(undefined4 *)(puVar38 + 0xb) = uVar5;
          *(undefined4 *)((int)puVar38 + 0x5c) = uVar6;
          *(undefined4 *)(puVar38 + 0xc) = uVar7;
          *(undefined4 *)((int)puVar38 + 100) = uVar8;
          *(undefined4 *)(puVar38 + 0xd) = uVar9;
          *(undefined4 *)((int)puVar38 + 0x6c) = uVar10;
          *(undefined4 *)(puVar38 + 0xe) = uVar11;
          *(undefined4 *)((int)puVar38 + 0x74) = uVar12;
          *(undefined4 *)(puVar38 + 0xf) = uVar13;
          *(undefined4 *)((int)puVar38 + 0x7c) = uVar14;
          param_2 = param_2 + 0x10;
          puVar38 = puVar38 + 0x10;
        }
        goto LAB_00421a7b;
      }
      if (((_DAT_10012b44 & 1) == 0) || (((uint)param_1 & 3) != 0)) goto LAB_004217d5;
      if (((uint)param_2 & 3) == 0) {
        if (((uint)param_1 >> 2 & 1) != 0) {
          uVar41 = *(undefined4 *)param_2;
          param_3 = param_3 - 4;
          param_2 = (undefined8 *)((int)param_2 + 4);
          *(undefined4 *)param_1 = uVar41;
          param_1 = (undefined8 *)((int)param_1 + 4);
        }
        if (((uint)param_1 >> 3 & 1) != 0) {
          uVar44 = *param_2;
          param_3 = param_3 - 8;
          param_2 = param_2 + 1;
          *param_1 = uVar44;
          param_1 = param_1 + 1;
        }
        if (((uint)param_2 & 7) == 0) {
          puVar38 = param_2 + -1;
          uVar41 = *(undefined4 *)param_2;
          uVar42 = *(undefined4 *)((int)param_2 + 4);
          do {
            puVar35 = puVar38;
            uVar4 = *(undefined4 *)(puVar35 + 4);
            uVar5 = *(undefined4 *)((int)puVar35 + 0x24);
            param_3 = param_3 - 0x30;
            auVar1 = *(undefined (*) [32])(puVar35 + 2);
            uVar43 = *(undefined4 *)(puVar35 + 7);
            uVar3 = *(undefined4 *)((int)puVar35 + 0x3c);
            auVar2 = *(undefined (*) [32])(puVar35 + 4);
            *(undefined4 *)(param_1 + 1) = uVar41;
            *(undefined4 *)((int)param_1 + 0xc) = uVar42;
            *(undefined4 *)(param_1 + 2) = uVar4;
            *(undefined4 *)((int)param_1 + 0x14) = uVar5;
            *(undefined (*) [16])(param_1 + 2) = SUB3216(auVar1 >> 0x40,0);
            *(undefined (*) [16])(param_1 + 4) = SUB3216(auVar2 >> 0x40,0);
            param_1 = param_1 + 6;
            puVar38 = puVar35 + 6;
            uVar41 = uVar43;
            uVar42 = uVar3;
          } while (0x2f < (int)param_3);
          puVar35 = puVar35 + 7;
        }
        else if (((uint)param_2 >> 3 & 1) == 0) {
          iVar31 = (int)param_2 + -4;
          uVar41 = *(undefined4 *)param_2;
          uVar42 = *(undefined4 *)((int)param_2 + 4);
          uVar43 = *(undefined4 *)(param_2 + 1);
          do {
            iVar34 = iVar31;
            uVar6 = *(undefined4 *)(iVar34 + 0x20);
            param_3 = param_3 - 0x30;
            auVar1 = *(undefined (*) [32])(iVar34 + 0x10);
            uVar3 = *(undefined4 *)(iVar34 + 0x34);
            uVar4 = *(undefined4 *)(iVar34 + 0x38);
            uVar5 = *(undefined4 *)(iVar34 + 0x3c);
            auVar2 = *(undefined (*) [32])(iVar34 + 0x20);
            *(undefined4 *)((int)param_1 + 4) = uVar41;
            *(undefined4 *)(param_1 + 1) = uVar42;
            *(undefined4 *)((int)param_1 + 0xc) = uVar43;
            *(undefined4 *)(param_1 + 2) = uVar6;
            *(undefined (*) [16])(param_1 + 2) = SUB3216(auVar1 >> 0x20,0);
            *(undefined (*) [16])(param_1 + 4) = SUB3216(auVar2 >> 0x20,0);
            param_1 = param_1 + 6;
            iVar31 = iVar34 + 0x30;
            uVar41 = uVar3;
            uVar42 = uVar4;
            uVar43 = uVar5;
          } while (0x2f < (int)param_3);
          puVar35 = (undefined8 *)(iVar34 + 0x34);
        }
        else {
          iVar31 = (int)param_2 + -0xc;
          uVar41 = *(undefined4 *)param_2;
          do {
            iVar34 = iVar31;
            uVar43 = *(undefined4 *)(iVar34 + 0x20);
            uVar3 = *(undefined4 *)(iVar34 + 0x24);
            uVar4 = *(undefined4 *)(iVar34 + 0x28);
            param_3 = param_3 - 0x30;
            auVar1 = *(undefined (*) [32])(iVar34 + 0x10);
            uVar42 = *(undefined4 *)(iVar34 + 0x3c);
            auVar2 = *(undefined (*) [32])(iVar34 + 0x20);
            *(undefined4 *)((int)param_1 + 0xc) = uVar41;
            *(undefined4 *)(param_1 + 2) = uVar43;
            *(undefined4 *)((int)param_1 + 0x14) = uVar3;
            *(undefined4 *)(param_1 + 3) = uVar4;
            *(undefined (*) [16])(param_1 + 2) = SUB3216(auVar1 >> 0x60,0);
            *(undefined (*) [16])(param_1 + 4) = SUB3216(auVar2 >> 0x60,0);
            param_1 = param_1 + 6;
            iVar31 = iVar34 + 0x30;
            uVar41 = uVar42;
          } while (0x2f < (int)param_3);
          puVar35 = (undefined8 *)(iVar34 + 0x3c);
        }
        for (; 0xf < (int)param_3; param_3 = param_3 - 0x10) {
          uVar41 = *(undefined4 *)puVar35;
          uVar42 = *(undefined4 *)((int)puVar35 + 4);
          uVar43 = *(undefined4 *)(puVar35 + 1);
          uVar3 = *(undefined4 *)((int)puVar35 + 0xc);
          puVar35 = puVar35 + 2;
          *(undefined4 *)param_1 = uVar41;
          *(undefined4 *)((int)param_1 + 4) = uVar42;
          *(undefined4 *)(param_1 + 1) = uVar43;
          *(undefined4 *)((int)param_1 + 0xc) = uVar3;
          param_1 = param_1 + 2;
        }
        if ((param_3 >> 2 & 1) != 0) {
          uVar41 = *(undefined4 *)puVar35;
          param_3 = param_3 - 4;
          puVar35 = (undefined8 *)((int)puVar35 + 4);
          *(undefined4 *)param_1 = uVar41;
          param_1 = (undefined8 *)((int)param_1 + 4);
        }
        if ((param_3 >> 3 & 1) != 0) {
          param_3 = param_3 - 8;
          *param_1 = *puVar35;
        }
                    // WARNING: Could not recover jumptable at 0x004217d3. Too many branches
                    // WARNING: Treating indirect jump as call
        uVar44 = (**(code **)(param_3 * 4 + 0x100033b4))();
        return uVar44;
      }
    }
    uVar32 = param_3;
    if (0x1f < param_3) {
      for (uVar32 = param_3 >> 2; uVar32 != 0; uVar32 = uVar32 - 1) {
        *(undefined4 *)puVar38 = *(undefined4 *)param_2;
        param_2 = (undefined8 *)((int)param_2 + 4);
        puVar38 = (undefined8 *)((int)puVar38 + 4);
      }
                    // WARNING: Could not emulate address calculation at 0x00421803
                    // WARNING: Treating indirect jump as call
      uVar44 = (**(code **)((param_3 & 3) * 4 + 0x100033b4))();
      return uVar44;
    }
  }
LAB_00421aa9:
  if ((uVar32 & 0x1f) != 0) {
    for (uVar33 = (uVar32 & 0x1f) >> 2; uVar33 != 0; uVar33 = uVar33 - 1) {
      param_3 = *(uint *)param_2;
      *(uint *)puVar38 = param_3;
      puVar38 = (undefined8 *)((int)puVar38 + 4);
      param_2 = (undefined8 *)((int)param_2 + 4);
    }
    for (uVar32 = uVar32 & 3; uVar32 != 0; uVar32 = uVar32 - 1) {
      *(undefined *)puVar38 = *(undefined *)param_2;
      param_2 = (undefined8 *)((int)param_2 + 1);
      puVar38 = (undefined8 *)((int)puVar38 + 1);
    }
  }
LAB_00421ade:
  return CONCAT44(param_3,param_1);
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// Library Function - Single Match
//  __CallSettingFrame@12
// 
// Library: Visual Studio

void __CallSettingFrame_12(undefined4 param_1,undefined4 param_2,int param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)__NLG_Notify1(param_3);
  (*pcVar1)();
  if (param_3 == 0x100) {
    param_3 = 2;
  }
  __NLG_Notify1(param_3);
  return;
}



void FUN_00422187(undefined4 param_1,code *param_2)

{
  (*param_2)();
  return;
}



undefined4 FUN_00422194(undefined4 *param_1,int param_2)

{
  undefined4 *puVar1;
  int extraout_ECX;
  undefined8 uVar2;
  uint local_c;
  int iVar3;
  
  if (param_1 == (undefined4 *)0x0) {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 0x16;
    FUN_00423576();
  }
  else if (param_2 == 1) {
    local_c = 0;
    iVar3 = 0;
    FUN_00423976(&local_c);
    iVar3 = (iVar3 + -0x19db1de) - (uint)(local_c < 0xd53e8000);
    if ((iVar3 < 0x483f078) || ((iVar3 < 0x483f079 && (local_c + 0x2ac18000 < 0xdd478000)))) {
      uVar2 = __alldvrm(local_c + 0x2ac18000,iVar3,10000000,0);
      *param_1 = (int)uVar2;
      param_1[1] = (int)((ulonglong)uVar2 >> 0x20);
      param_1[2] = extraout_ECX * 100;
      return 1;
    }
  }
  return 0;
}



// Library Function - Multiple Matches With Different Base Names
//  __int64 __cdecl common_time<__int64>(__int64 * const)
//  __time64
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

__time64_t __cdecl FID_conflict___time64(__time64_t *_Time)

{
  int iVar1;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 uStack12;
  undefined4 uStack8;
  
  local_14 = 0;
  local_10 = 0;
  uStack12 = 0;
  uStack8 = 0;
  iVar1 = FUN_00422194(&local_14,1);
  if (iVar1 != 1) {
    local_14 = 0xffffffff;
    local_10 = 0xffffffff;
  }
  if (_Time != (__time64_t *)0x0) {
    *(undefined4 *)_Time = local_14;
    *(undefined4 *)((int)_Time + 4) = local_10;
  }
  return CONCAT44(local_10,local_14);
}



uint FUN_0042225a(void)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = FUN_00423ea2();
  uVar2 = *(int *)(iVar1 + 0x18) * 0x343fd + 0x269ec3;
  *(uint *)(iVar1 + 0x18) = uVar2;
  return uVar2 >> 0x10 & 0x7fff;
}



void FUN_0042227b(undefined4 param_1)

{
  int iVar1;
  
  iVar1 = FUN_00423ea2();
  *(undefined4 *)(iVar1 + 0x18) = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __initterm
// 
// Library: Visual Studio 2015 Release

void __thiscall __initterm(code *param_1_00,code **param_1,code **param_2)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar3 = 0;
  uVar2 = ~-(uint)(param_2 < param_1) & (uint)((int)param_2 + (3 - (int)param_1)) >> 2;
  if (uVar2 != 0) {
    do {
      param_1_00 = *param_1;
      if (param_1_00 != (code *)0x0) {
        (*_DAT_1000c174)();
        (*param_1_00)();
      }
      param_1 = param_1 + 1;
      uVar3 = uVar3 + 1;
    } while (uVar3 != uVar2);
  }
  ___security_check_cookie_4(param_1_00,uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __initterm_e
// 
// Library: Visual Studio 2015 Release

void __initterm_e(code **param_1,code **param_2)

{
  code *pcVar1;
  uint uVar2;
  int iVar3;
  
  uVar2 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  for (; param_1 != param_2; param_1 = param_1 + 1) {
    pcVar1 = *param_1;
    if (pcVar1 != (code *)0x0) {
      (*_DAT_1000c174)();
      iVar3 = (*pcVar1)();
      if (iVar3 != 0) break;
    }
  }
  ___security_check_cookie_4(uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0042232e(undefined4 param_1)

{
  _DAT_10012bf0 = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __callnewh
// 
// Library: Visual Studio 2015 Release

int __cdecl __callnewh(size_t _Size)

{
  uint uVar1;
  code *pcVar2;
  int iVar3;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)__query_new_handler();
  if (pcVar2 != (code *)0x0) {
    (*_DAT_1000c174)(_Size);
    (*pcVar2)();
  }
  iVar3 = ___security_check_cookie_4(uVar1);
  return iVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __query_new_handler
// 
// Library: Visual Studio 2015 Release

uint __query_new_handler(void)

{
  byte bVar1;
  uint uVar2;
  
  ___acrt_lock(0);
  bVar1 = (byte)_DAT_10012000 & 0x1f;
  uVar2 = _DAT_10012000 ^ _DAT_10012bf0;
  FUN_004223ca();
  return uVar2 >> bVar1 | uVar2 << 0x20 - bVar1;
}



void FUN_004223ca(void)

{
  ___acrt_unlock(0);
  return;
}



void FUN_004223d3(void)

{
  __malloc_base();
  return;
}



// Library Function - Single Match
//  __seh_filter_dll
// 
// Library: Visual Studio 2015 Release

undefined4 __seh_filter_dll(int param_1,undefined4 param_2)

{
  undefined4 uVar1;
  
  if (param_1 != -0x1f928c9d) {
    return 0;
  }
  uVar1 = __seh_filter_exe(0xe06d7363,param_2);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __seh_filter_exe
// 
// Library: Visual Studio 2015 Release

void __seh_filter_exe(uint param_1,uint *param_2)

{
  uint *puVar1;
  code *pcVar2;
  uint uVar3;
  uint **ppuVar4;
  uint *puVar5;
  uint *puVar6;
  uint *extraout_var;
  uint *puVar7;
  
  uVar3 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  ppuVar4 = (uint **)FUN_00423ff0();
  puVar7 = extraout_var;
  if (ppuVar4 != (uint **)0x0) {
    puVar1 = *ppuVar4;
    for (puVar6 = puVar1; puVar6 != puVar1 + 0x24; puVar6 = puVar6 + 3) {
      if (*puVar6 == param_1) goto LAB_00422441;
    }
    puVar6 = (uint *)0x0;
LAB_00422441:
    if ((puVar6 != (uint *)0x0) && (pcVar2 = (code *)puVar6[2], pcVar2 != (code *)0x0)) {
      if (pcVar2 == (code *)0x5) {
        puVar6[2] = 0;
      }
      else if (pcVar2 != (code *)0x1) {
        puVar7 = ppuVar4[1];
        ppuVar4[1] = param_2;
        if (puVar6[1] == 8) {
          for (puVar5 = puVar1 + 9; puVar5 != puVar1 + 0x24; puVar5 = puVar5 + 3) {
            puVar5[2] = 0;
          }
          puVar1 = ppuVar4[2];
          if (*puVar6 < 0xc0000092) {
            if (*puVar6 == 0xc0000091) {
              ppuVar4[2] = (uint *)0x84;
            }
            else if (*puVar6 == 0xc000008d) {
              ppuVar4[2] = (uint *)0x82;
            }
            else if (*puVar6 == 0xc000008e) {
              ppuVar4[2] = (uint *)0x83;
            }
            else if (*puVar6 == 0xc000008f) {
              ppuVar4[2] = (uint *)0x86;
            }
            else if (*puVar6 == 0xc0000090) {
              ppuVar4[2] = (uint *)0x81;
            }
          }
          else if (*puVar6 == 0xc0000092) {
            ppuVar4[2] = (uint *)0x8a;
          }
          else if (*puVar6 == 0xc0000093) {
            ppuVar4[2] = (uint *)0x85;
          }
          else if (*puVar6 == 0xc00002b4) {
            ppuVar4[2] = (uint *)0x8e;
          }
          else if (*puVar6 == 0xc00002b5) {
            ppuVar4[2] = (uint *)0x8d;
          }
          (*_DAT_1000c174)(8,ppuVar4[2]);
          (*pcVar2)();
          ppuVar4[2] = puVar1;
        }
        else {
          puVar6[2] = 0;
          (*_DAT_1000c174)(puVar6[1]);
          (*pcVar2)();
        }
        ppuVar4[1] = puVar7;
      }
    }
  }
  ___security_check_cookie_4(puVar7,uVar3);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_03b1d95aef87969028cfba75ccab2455>,class <lambda_6e4b09c48022b2350581041d5f6b0c4c>&,class
// <lambda_22bdf7517842c4b3e53723af5aa32b9e>>(class
// <lambda_03b1d95aef87969028cfba75ccab2455>&&,class
// <lambda_6e4b09c48022b2350581041d5f6b0c4c>&,class <lambda_22bdf7517842c4b3e53723af5aa32b9e>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_03b1d95aef87969028cfba75ccab2455__class__lambda_6e4b09c48022b2350581041d5f6b0c4c___class__lambda_22bdf7517842c4b3e53723af5aa32b9e___
          (__crt_seh_guarded_call_void_ *this,_lambda_03b1d95aef87969028cfba75ccab2455_ *param_1,
          _lambda_6e4b09c48022b2350581041d5f6b0c4c_ *param_2,
          _lambda_22bdf7517842c4b3e53723af5aa32b9e_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  FUN_004225b4();
  FUN_004225a8();
  return;
}



void FUN_004225a8(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_004225b4(int **param_1)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  undefined4 uVar4;
  
  if (DAT_10012bfc != '\0') goto LAB_00422671;
  _DAT_10012bf4 = 1;
  if (**param_1 == 0) {
    bVar2 = (byte)_DAT_10012000 & 0x1f;
    bVar1 = 0x20 - bVar2 & 0x1f;
    if (_DAT_10012bf8 != ((0U >> bVar1 | 0 << 0x20 - bVar1) ^ _DAT_10012000)) {
      uVar3 = _DAT_10012000 ^ _DAT_10012bf8;
      (*_DAT_1000c174)(0,0,0);
      (*(code *)(uVar3 >> bVar2 | uVar3 << 0x20 - bVar2))();
    }
    uVar4 = 0x10012d18;
LAB_00422628:
    __execute_onexit_table(uVar4);
  }
  else if (**param_1 == 1) {
    uVar4 = 0x10012d24;
    goto LAB_00422628;
  }
  if (**param_1 == 0) {
    __initterm(0x1000c194,0x1000c1a4);
  }
  __initterm(0x1000c1a8,0x1000c1ac);
  if (*param_1[1] == 0) {
    DAT_10012bfc = '\x01';
    *(undefined *)param_1[2] = 1;
  }
LAB_00422671:
  FUN_00429d47();
  return;
}



bool FUN_00422690(int param_1)

{
  return param_1 == -0x1f928c9d;
}



// Library Function - Single Match
//  void __cdecl common_exit(int,enum _crt_exit_cleanup_mode,enum _crt_exit_return_mode)
// 
// Library: Visual Studio 2017 Release

void __cdecl common_exit(int param_1,_crt_exit_cleanup_mode param_2,_crt_exit_return_mode param_3)

{
  code *pcVar1;
  char cVar2;
  _crt_exit_cleanup_mode *local_1c;
  _crt_exit_return_mode *local_18;
  undefined *local_14;
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_6;
  undefined local_5;
  
  if (param_3 == 0) {
    cVar2 = ___scrt_is_managed_app();
    if (cVar2 != '\0') {
      try_cor_exit_process(param_1);
    }
  }
  local_1c = &param_2;
  local_5 = 0;
  local_18 = &param_3;
  local_14 = &local_5;
  local_c = 2;
  local_10 = 2;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_03b1d95aef87969028cfba75ccab2455__class__lambda_6e4b09c48022b2350581041d5f6b0c4c___class__lambda_22bdf7517842c4b3e53723af5aa32b9e___
            (&local_6,(_lambda_03b1d95aef87969028cfba75ccab2455_ *)&local_10,
             (_lambda_6e4b09c48022b2350581041d5f6b0c4c_ *)&local_1c,
             (_lambda_22bdf7517842c4b3e53723af5aa32b9e_ *)&local_c);
  if (param_3 != 0) {
    return;
  }
  exit_or_terminate_process(param_1);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl exit_or_terminate_process(unsigned int)
// 
// Library: Visual Studio 2017 Release

void __cdecl exit_or_terminate_process(uint param_1)

{
  code *pcVar1;
  int iVar2;
  undefined4 uVar3;
  int in_FS_OFFSET;
  
  iVar2 = ___acrt_get_process_end_policy();
  if ((iVar2 != 1) && ((*(uint *)(*(int *)(in_FS_OFFSET + 0x30) + 0x68) >> 8 & 1) == 0)) {
    uVar3 = (*_DAT_1000c088)(param_1);
    (*_DAT_1000c08c)(uVar3);
  }
  try_cor_exit_process(param_1);
  (*_DAT_1000c0f0)(param_1);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_is_managed_app
// 
// Library: Visual Studio 2015 Release

uint ___scrt_is_managed_app(void)

{
  int *piVar1;
  int *piVar2;
  
  piVar1 = (int *)(*_DAT_1000c0b0)(0);
  piVar2 = piVar1;
  if ((((piVar1 != (int *)0x0) && (piVar2 = (int *)0x5a4d, *(short *)piVar1 == 0x5a4d)) &&
      (piVar2 = (int *)(piVar1[0xf] + (int)piVar1), *piVar2 == 0x4550)) &&
     ((*(short *)(piVar2 + 6) == 0x10b && (0xe < (uint)piVar2[0x1d])))) {
    return (uint)piVar2 & 0xffffff00 | (uint)(piVar2[0x3a] != 0);
  }
  return (uint)piVar2 & 0xffffff00;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl try_cor_exit_process(unsigned int)
// 
// Library: Visual Studio 2015 Release

void __cdecl try_cor_exit_process(uint param_1)

{
  int iVar1;
  code *pcVar2;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_c = 0;
  iVar1 = (*_DAT_1000c0f4)(0,0x1000cb8c,&local_c);
  if ((iVar1 != 0) && (pcVar2 = (code *)(*_DAT_1000c058)(local_c,0x1000cba4), pcVar2 != (code *)0x0)
     ) {
    (*_DAT_1000c174)(param_1);
    (*pcVar2)();
  }
  if (local_c != 0) {
    (*_DAT_1000c0e8)(local_c);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_004227f9(undefined4 param_1)

{
  _DAT_10012bf8 = param_1;
  return;
}



// Library Function - Single Match
//  __exit
// 
// Library: Visual Studio 2017 Release

void __exit(int param_1)

{
  common_exit(param_1,2,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0042282d(void)

{
  return _DAT_10012bf4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_00422833(int param_1)

{
  int iVar1;
  undefined4 *puVar2;
  int *piVar3;
  int *piVar4;
  char *local_14;
  undefined4 local_10;
  int *local_c;
  int local_8;
  
  if (param_1 == 0) {
    iVar1 = 0;
  }
  else if ((param_1 == 2) || (param_1 == 1)) {
    ___acrt_initialize_multibyte();
    iVar1 = 0;
    (*_DAT_1000c0f8)(0,0x10012c00,0x104);
    _DAT_10012f8c = 0x10012c00;
    local_14 = _DAT_10012f84;
    if ((_DAT_10012f84 == (char *)0x0) || (*_DAT_10012f84 == '\0')) {
      local_14 = (char *)0x10012c00;
    }
    local_8 = 0;
    local_10 = 0;
    FUN_00422969(local_14,0,0,&local_8,&local_10);
    piVar3 = (int *)FUN_00422add(local_8,local_10,1);
    piVar4 = piVar3;
    if (piVar3 == (int *)0x0) {
      puVar2 = (undefined4 *)FUN_00423633();
      iVar1 = 0xc;
      *puVar2 = 0xc;
    }
    else {
      FUN_00422969(local_14,piVar3,piVar3 + local_8,&local_8,&local_10);
      if (param_1 == 1) {
        _DAT_10012f78 = local_8 + -1;
        piVar4 = (int *)0x0;
        _DAT_10012f7c = piVar3;
      }
      else {
        local_c = (int *)0x0;
        iVar1 = FUN_0042466e(piVar3,&local_c);
        piVar3 = local_c;
        if (iVar1 == 0) {
          _DAT_10012f78 = 0;
          iVar1 = *local_c;
          while (iVar1 != 0) {
            local_c = local_c + 1;
            _DAT_10012f78 = _DAT_10012f78 + 1;
            iVar1 = *local_c;
          }
          local_c = (int *)0x0;
          iVar1 = 0;
          _DAT_10012f7c = piVar3;
        }
        FID_conflict__free(local_c);
        local_c = (int *)0x0;
      }
    }
    FID_conflict__free(piVar4);
  }
  else {
    puVar2 = (undefined4 *)FUN_00423633();
    iVar1 = 0x16;
    *puVar2 = 0x16;
    FUN_00423576();
  }
  return iVar1;
}



void FUN_00422969(char *param_1,char **param_2,char *param_3,int *param_4,int *param_5)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  bool bVar4;
  bool bVar5;
  char *pcVar6;
  char *pcVar7;
  
  *param_5 = 0;
  *param_4 = 1;
  if (param_2 != (char **)0x0) {
    *param_2 = param_3;
    param_2 = param_2 + 1;
  }
  bVar4 = false;
  bVar5 = false;
  do {
    if (*param_1 == '\"') {
      bVar5 = !bVar4;
      cVar1 = '\"';
      pcVar6 = param_1 + 1;
      bVar4 = bVar5;
    }
    else {
      *param_5 = *param_5 + 1;
      if (param_3 != (char *)0x0) {
        *param_3 = *param_1;
        param_3 = param_3 + 1;
      }
      cVar1 = *param_1;
      pcVar6 = param_1 + 1;
      iVar3 = __ismbblead((int)cVar1);
      if (iVar3 != 0) {
        *param_5 = *param_5 + 1;
        if (param_3 != (char *)0x0) {
          *param_3 = *pcVar6;
          param_3 = param_3 + 1;
        }
        pcVar6 = param_1 + 2;
      }
      if (cVar1 == '\0') {
        pcVar6 = pcVar6 + -1;
        goto LAB_004229f9;
      }
    }
    param_1 = pcVar6;
  } while ((bVar5) || ((cVar1 != ' ' && (cVar1 != '\t'))));
  if (param_3 != (char *)0x0) {
    param_3[-1] = '\0';
  }
LAB_004229f9:
  bVar5 = false;
  while (pcVar7 = pcVar6, *pcVar6 != '\0') {
    for (; (cVar1 = *pcVar7, cVar1 == ' ' || (cVar1 == '\t')); pcVar7 = pcVar7 + 1) {
    }
    if (cVar1 == '\0') break;
    if (param_2 != (char **)0x0) {
      *param_2 = param_3;
      param_2 = param_2 + 1;
    }
    *param_4 = *param_4 + 1;
    while( true ) {
      bVar4 = true;
      uVar2 = 0;
      for (; *pcVar7 == '\\'; pcVar7 = pcVar7 + 1) {
        uVar2 = uVar2 + 1;
      }
      pcVar6 = pcVar7;
      if (*pcVar7 == '\"') {
        if (((uVar2 & 1) == 0) && ((!bVar5 || (pcVar6 = pcVar7 + 1, *pcVar6 != '\"')))) {
          bVar4 = false;
          bVar5 = !bVar5;
          pcVar6 = pcVar7;
        }
        uVar2 = uVar2 >> 1;
      }
      while (uVar2 != 0) {
        uVar2 = uVar2 - 1;
        if (param_3 != (char *)0x0) {
          *param_3 = '\\';
          param_3 = param_3 + 1;
        }
        *param_5 = *param_5 + 1;
      }
      cVar1 = *pcVar6;
      if ((cVar1 == '\0') || ((!bVar5 && ((cVar1 == ' ' || (cVar1 == '\t')))))) break;
      if (bVar4) {
        if (param_3 != (char *)0x0) {
          *param_3 = cVar1;
          param_3 = param_3 + 1;
        }
        iVar3 = __ismbblead((int)*pcVar6);
        if (iVar3 != 0) {
          pcVar6 = pcVar6 + 1;
          *param_5 = *param_5 + 1;
          if (param_3 != (char *)0x0) {
            *param_3 = *pcVar6;
            param_3 = param_3 + 1;
          }
        }
        *param_5 = *param_5 + 1;
      }
      pcVar7 = pcVar6 + 1;
    }
    if (param_3 != (char *)0x0) {
      *param_3 = '\0';
      param_3 = param_3 + 1;
    }
    *param_5 = *param_5 + 1;
  }
  if (param_2 != (char **)0x0) {
    *param_2 = (char *)0x0;
  }
  *param_4 = *param_4 + 1;
  return;
}



undefined4 FUN_00422add(uint param_1,uint param_2,uint param_3)

{
  undefined4 uVar1;
  
  if ((param_1 < 0x3fffffff) && (param_2 < (uint)(0xffffffff / (ulonglong)param_3))) {
    if (param_2 * param_3 < ~(param_1 * 4)) {
      uVar1 = __calloc_base(param_1 * 4 + param_2 * param_3,1);
      FID_conflict__free((void *)0x0);
      return uVar1;
    }
  }
  return 0;
}



void FUN_00422b2c(void)

{
  FUN_00422833();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  int __cdecl common_initialize_environment_nolock<char>(void)
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl common_initialize_environment_nolock_char_(void)

{
  char *_Memory;
  char **ppcVar1;
  int iVar2;
  
  if (_DAT_10012d08 != (char **)0x0) {
    return 0;
  }
  ___acrt_initialize_multibyte();
  _Memory = (char *)___dcrt_get_narrow_environment_from_os();
  if (_Memory == (char *)0x0) {
    iVar2 = -1;
  }
  else {
    ppcVar1 = create_environment_char_(_Memory);
    if (ppcVar1 == (char **)0x0) {
      iVar2 = -1;
    }
    else {
      iVar2 = 0;
      _DAT_10012d08 = ppcVar1;
      _DAT_10012d14 = ppcVar1;
    }
    FID_conflict__free((void *)0x0);
  }
  FID_conflict__free(_Memory);
  return iVar2;
}



// Library Function - Single Match
//  char * * __cdecl create_environment<char>(char * const)
// 
// Library: Visual Studio 2015 Release

char ** __cdecl create_environment_char_(char *param_1)

{
  code *pcVar1;
  char cVar2;
  char **ppcVar3;
  char *_Dst;
  errno_t eVar4;
  char *pcVar5;
  int iVar6;
  char **local_8;
  
  iVar6 = 0;
  cVar2 = *param_1;
  pcVar5 = param_1;
  while (cVar2 != '\0') {
    if (cVar2 != '=') {
      iVar6 = iVar6 + 1;
    }
    do {
      cVar2 = *pcVar5;
      pcVar5 = pcVar5 + 1;
    } while (cVar2 != '\0');
    cVar2 = *pcVar5;
  }
  ppcVar3 = (char **)__calloc_base(iVar6 + 1,4);
  local_8 = ppcVar3;
  if (ppcVar3 == (char **)0x0) {
LAB_00422c3b:
    ppcVar3 = (char **)0x0;
  }
  else {
    for (; *param_1 != '\0'; param_1 = param_1 + (int)pcVar5) {
      pcVar5 = param_1;
      do {
        cVar2 = *pcVar5;
        pcVar5 = pcVar5 + 1;
      } while (cVar2 != '\0');
      pcVar5 = pcVar5 + (1 - (int)(param_1 + 1));
      if (*param_1 != '=') {
        _Dst = (char *)__calloc_base(pcVar5,1);
        if (_Dst == (char *)0x0) {
          free_environment_char_(ppcVar3);
          FID_conflict__free((void *)0x0);
          goto LAB_00422c3b;
        }
        eVar4 = _strcpy_s(_Dst,(rsize_t)pcVar5,param_1);
        if (eVar4 != 0) {
          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          pcVar1 = (code *)swi(3);
          ppcVar3 = (char **)(*pcVar1)();
          return ppcVar3;
        }
        *local_8 = _Dst;
        local_8 = local_8 + 1;
        FID_conflict__free((void *)0x0);
      }
    }
  }
  FID_conflict__free((void *)0x0);
  return ppcVar3;
}



// Library Function - Single Match
//  void __cdecl free_environment<char>(char * * const)
// 
// Library: Visual Studio 2015 Release

void __cdecl free_environment_char_(char **param_1)

{
  char *_Memory;
  char **ppcVar1;
  
  if (param_1 != (char **)0x0) {
    _Memory = *param_1;
    ppcVar1 = param_1;
    while (_Memory != (char *)0x0) {
      FID_conflict__free(_Memory);
      ppcVar1 = ppcVar1 + 1;
      _Memory = *ppcVar1;
    }
    FID_conflict__free(param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall __crt_state_management::dual_state_global<char * *>::uninitialize<void
// (__cdecl&)(char * * &)>(void (__cdecl&)(char * * &))
//  public: void __thiscall __crt_state_management::dual_state_global<wchar_t *
// *>::uninitialize<void (__cdecl&)(wchar_t * * &)>(void (__cdecl&)(wchar_t * * &))
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void __thiscall uninitialize__(int param_1_00,code *param_1)

{
  int iVar1;
  uint uVar2;
  
  uVar2 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar1 = param_1_00 + 4;
  for (; param_1_00 != iVar1; param_1_00 = param_1_00 + 4) {
    (*_DAT_1000c174)(param_1_00);
    (*param_1)();
  }
  ___security_check_cookie_4(uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  void __cdecl uninitialize_environment_internal<char>(char * * &)
//  void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void uninitialize_environment_internal__(undefined4 *param_1)

{
  if ((char **)*param_1 != _DAT_10012d14) {
    free_environment_char_((char **)*param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  void __cdecl uninitialize_environment_internal<char>(char * * &)
//  void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void uninitialize_environment_internal__(undefined4 *param_1)

{
  if ((char **)*param_1 != _DAT_10012d10) {
    free_environment_char_((char **)*param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl common_initialize_environment_nolock_char_(void)

{
  char *_Memory;
  char **ppcVar1;
  int iVar2;
  
  if (_DAT_10012d08 != (char **)0x0) {
    return 0;
  }
  ___acrt_initialize_multibyte();
  _Memory = (char *)___dcrt_get_narrow_environment_from_os();
  if (_Memory == (char *)0x0) {
    iVar2 = -1;
  }
  else {
    ppcVar1 = create_environment_char_(_Memory);
    if (ppcVar1 == (char **)0x0) {
      iVar2 = -1;
    }
    else {
      iVar2 = 0;
      _DAT_10012d08 = ppcVar1;
      _DAT_10012d14 = ppcVar1;
    }
    FID_conflict__free((void *)0x0);
  }
  FID_conflict__free(_Memory);
  return iVar2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_69a2805e680e0e292e8ba93315fe43a8>,class <lambda_f03950bc5685219e0bcd2087efbe011e>&,class
// <lambda_03fcd07e894ec930e3f35da366ca99d6>>(class
// <lambda_69a2805e680e0e292e8ba93315fe43a8>&&,class
// <lambda_f03950bc5685219e0bcd2087efbe011e>&,class <lambda_03fcd07e894ec930e3f35da366ca99d6>&&)
// 
// Library: Visual Studio 2017 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_69a2805e680e0e292e8ba93315fe43a8__class__lambda_f03950bc5685219e0bcd2087efbe011e___class__lambda_03fcd07e894ec930e3f35da366ca99d6___
          (__crt_seh_guarded_call_int_ *this,_lambda_69a2805e680e0e292e8ba93315fe43a8_ *param_1,
          _lambda_f03950bc5685219e0bcd2087efbe011e_ *param_2,
          _lambda_03fcd07e894ec930e3f35da366ca99d6_ *param_3)

{
  int iVar1;
  
  ___acrt_lock(*(undefined4 *)param_1);
  iVar1 = FUN_00422d8d();
  FUN_00422d81();
  return iVar1;
}



void FUN_00422d81(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_00422d8d(int **param_1)

{
  uint *puVar1;
  byte bVar2;
  uint uVar3;
  uint *puVar4;
  sbyte sVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint *_Memory;
  uint *puVar9;
  uint *local_14;
  uint *local_10;
  
  puVar9 = (uint *)**param_1;
  if (puVar9 != (uint *)0x0) {
    uVar8 = _DAT_10012000 & 0x1f;
    sVar5 = (sbyte)uVar8;
    _Memory = (uint *)((*puVar9 ^ _DAT_10012000) >> sVar5 |
                      (*puVar9 ^ _DAT_10012000) << 0x20 - sVar5);
    puVar9 = (uint *)((puVar9[1] ^ _DAT_10012000) >> sVar5 |
                     (puVar9[1] ^ _DAT_10012000) << 0x20 - sVar5);
    if ((_Memory != (uint *)0x0) && (_Memory != (uint *)0xffffffff)) {
      bVar2 = 0x20U - sVar5 & 0x1f;
      uVar3 = (0U >> bVar2 | 0 << 0x20 - bVar2) ^ _DAT_10012000;
      uVar6 = _DAT_10012000;
      local_14 = puVar9;
      local_10 = _Memory;
      while (puVar9 = puVar9 + -1, _Memory <= puVar9) {
        if (*puVar9 != uVar3) {
          uVar6 = *puVar9 ^ uVar6;
          *puVar9 = uVar3;
          (*_DAT_1000c174)();
          (*(code *)(uVar6 >> (sbyte)uVar8 | uVar6 << 0x20 - (sbyte)uVar8))();
          uVar8 = _DAT_10012000 & 0x1f;
          uVar7 = *(uint *)**param_1 ^ _DAT_10012000;
          uVar6 = ((uint *)**param_1)[1] ^ _DAT_10012000;
          sVar5 = (sbyte)uVar8;
          puVar1 = (uint *)(uVar7 >> sVar5 | uVar7 << 0x20 - sVar5);
          puVar4 = (uint *)(uVar6 >> sVar5 | uVar6 << 0x20 - sVar5);
          uVar6 = _DAT_10012000;
          if ((puVar1 != local_10) || (puVar4 != local_14)) {
            _Memory = puVar1;
            puVar9 = puVar4;
            local_14 = puVar4;
            local_10 = puVar1;
          }
        }
      }
      if (_Memory != (uint *)0xffffffff) {
        FID_conflict__free(_Memory);
        uVar6 = _DAT_10012000;
      }
      bVar2 = 0x20 - ((byte)uVar6 & 0x1f) & 0x1f;
      uVar6 = (0U >> bVar2 | 0 << 0x20 - bVar2) ^ uVar6;
      *(uint *)**param_1 = uVar6;
      *(uint *)(**param_1 + 4) = uVar6;
      *(uint *)(**param_1 + 8) = uVar6;
    }
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  __execute_onexit_table
// 
// Library: Visual Studio 2017 Release

void __execute_onexit_table(void)

{
  undefined4 local_14;
  undefined *local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  local_10 = &stack0x00000004;
  local_c = 2;
  local_14 = 2;
  __crt_seh_guarded_call<int>::
  operator___class__lambda_69a2805e680e0e292e8ba93315fe43a8__class__lambda_f03950bc5685219e0bcd2087efbe011e___class__lambda_03fcd07e894ec930e3f35da366ca99d6___
            (&local_5,(_lambda_69a2805e680e0e292e8ba93315fe43a8_ *)&local_14,
             (_lambda_f03950bc5685219e0bcd2087efbe011e_ *)&local_10,
             (_lambda_03fcd07e894ec930e3f35da366ca99d6_ *)&local_c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __initialize_onexit_table
// 
// Library: Visual Studio 2015 Release

undefined4 __initialize_onexit_table(uint *param_1)

{
  byte bVar1;
  undefined4 uVar2;
  uint uVar3;
  
  if (param_1 == (uint *)0x0) {
    uVar2 = 0xffffffff;
  }
  else {
    if (*param_1 == param_1[2]) {
      bVar1 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
      uVar3 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ _DAT_10012000;
      *param_1 = uVar3;
      param_1[1] = uVar3;
      param_1[2] = uVar3;
    }
    uVar2 = 0;
  }
  return uVar2;
}



// Library Function - Single Match
//  _uninitialize_allocated_memory
// 
// Library: Visual Studio 2017 Release

undefined _uninitialize_allocated_memory(void)

{
  _lambda_af42a3ee9806e9a7305d451646e05244_ local_5;
  
  <lambda_af42a3ee9806e9a7305d451646e05244>::operator__
            (&local_5,(__crt_multibyte_data **)&DAT_10012f6c);
  return 1;
}



// Library Function - Single Match
//  public: void __thiscall <lambda_af42a3ee9806e9a7305d451646e05244>::operator()(struct
// __crt_multibyte_data * &)const 
// 
// Library: Visual Studio 2017 Release

void __thiscall
<lambda_af42a3ee9806e9a7305d451646e05244>::operator__
          (_lambda_af42a3ee9806e9a7305d451646e05244_ *this,__crt_multibyte_data **param_1)

{
  int iVar1;
  
  LOCK();
  iVar1 = *(int *)*param_1 + -1;
  *(int *)*param_1 = iVar1;
  if ((iVar1 == 0) && (*param_1 != (__crt_multibyte_data *)0x10012350)) {
    FID_conflict__free(*param_1);
    *param_1 = (__crt_multibyte_data *)0x10012350;
  }
  return;
}



// Library Function - Single Match
//  ___acrt_initialize
// 
// Library: Visual Studio 2015 Release

void ___acrt_initialize(void)

{
  ___acrt_execute_initializers(0x1000cbb8,&DAT_1000cc38);
  return;
}



uint FUN_0042303e(void)

{
  uint uVar1;
  
  uVar1 = FUN_00423ff0();
  return uVar1 & 0xffffff00 | (uint)(uVar1 != 0);
}



undefined FUN_00423049(void)

{
  ___acrt_freeptd();
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_uninitialize
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 ___acrt_uninitialize(char param_1)

{
  undefined4 uVar1;
  
  if (param_1 != '\0') {
    if (_DAT_100131b8 != 0) {
      __flushall();
    }
    return 1;
  }
  uVar1 = FUN_004252b5(0x1000cbb8,&DAT_1000cc38);
  return uVar1;
}



// Library Function - Single Match
//  ___acrt_uninitialize_critical
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___acrt_uninitialize_critical(undefined4 param_1)

{
  ___acrt_uninitialize_ptd(param_1);
  return 1;
}



void FUN_004230cf(void *param_1)

{
  FID_conflict__free(param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  __free_base
//  _free
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

void __cdecl FID_conflict__free(void *_Memory)

{
  int iVar1;
  int *piVar2;
  ulong uVar3;
  
  if (_Memory != (void *)0x0) {
    iVar1 = (*_DAT_1000c104)(_DAT_10012f90,0,_Memory);
    if (iVar1 == 0) {
      piVar2 = (int *)FUN_00423633();
      uVar3 = (*_DAT_1000c0c0)();
      iVar1 = FID_conflict____acrt_errno_from_os_error(uVar3);
      *piVar2 = iVar1;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __malloc_base
// 
// Library: Visual Studio 2017 Release

int __malloc_base(size_t param_1)

{
  int iVar1;
  undefined4 *puVar2;
  
  if (param_1 < 0xffffffe1) {
    if (param_1 == 0) {
      param_1 = 1;
    }
    do {
      iVar1 = (*_DAT_1000c108)(_DAT_10012f90,0,param_1);
      if (iVar1 != 0) {
        return iVar1;
      }
      iVar1 = FUN_00425a2d();
    } while ((iVar1 != 0) && (iVar1 = __callnewh(param_1), iVar1 != 0));
  }
  puVar2 = (undefined4 *)FUN_00423633();
  *puVar2 = 0xc;
  return 0;
}



// Library Function - Single Match
//  _strcpy_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl _strcpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  errno_t *peVar2;
  char *pcVar3;
  errno_t eVar4;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    if (_Src != (char *)0x0) {
      pcVar3 = _Dst;
      do {
        cVar1 = pcVar3[(int)_Src - (int)_Dst];
        *pcVar3 = cVar1;
        pcVar3 = pcVar3 + 1;
        if (cVar1 == '\0') break;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        return 0;
      }
      *_Dst = '\0';
      peVar2 = (errno_t *)FUN_00423633();
      eVar4 = 0x22;
      goto LAB_00423199;
    }
    *_Dst = '\0';
  }
  peVar2 = (errno_t *)FUN_00423633();
  eVar4 = 0x16;
LAB_00423199:
  *peVar2 = eVar4;
  FUN_00423576();
  return eVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int * __thiscall FUN_004231ce(int *param_1_00,int *param_1)

{
  uint uVar1;
  int iVar2;
  
  *(undefined *)(param_1_00 + 3) = 0;
  if (param_1 == (int *)0x0) {
    if (_DAT_100131c8 != 0) {
      iVar2 = FUN_00423ea2();
      *param_1_00 = iVar2;
      param_1_00[1] = *(int *)(iVar2 + 0x4c);
      param_1_00[2] = *(int *)(iVar2 + 0x48);
      ___acrt_update_locale_info(iVar2,param_1_00 + 1);
      ___acrt_update_multibyte_info(*param_1_00,param_1_00 + 2);
      uVar1 = *(uint *)(*param_1_00 + 0x350);
      if ((uVar1 & 2) != 0) {
        return param_1_00;
      }
      *(uint *)(*param_1_00 + 0x350) = uVar1 | 2;
      *(undefined *)(param_1_00 + 3) = 1;
      return param_1_00;
    }
    param_1_00[1] = _DAT_10012628;
    iVar2 = _DAT_1001262c;
  }
  else {
    param_1_00[1] = *param_1;
    iVar2 = param_1[1];
  }
  param_1_00[2] = iVar2;
  return param_1_00;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _abort
// 
// Library: Visual Studio 2017 Release

void __cdecl _abort(void)

{
  code *pcVar1;
  int iVar2;
  
  iVar2 = ___acrt_get_sigabrt_handler();
  if (iVar2 != 0) {
    FUN_00425411(0x16);
  }
  if ((DAT_10012040 & 2) != 0) {
    iVar2 = (*_DAT_1000c090)(0x17);
    if (iVar2 != 0) {
      pcVar1 = (code *)swi(0x29);
      (*pcVar1)();
    }
    ___acrt_call_reportfault(3,0x40000015,1);
  }
  __exit(3);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __calloc_base
// 
// Library: Visual Studio 2015 Release

int __calloc_base(uint param_1,uint param_2)

{
  int iVar1;
  undefined4 *puVar2;
  size_t _Size;
  
  if ((param_1 == 0) || (param_2 <= 0xffffffe0 / param_1)) {
    _Size = param_1 * param_2;
    if (_Size == 0) {
      _Size = 1;
    }
    do {
      iVar1 = (*_DAT_1000c108)(_DAT_10012f90,8,_Size);
      if (iVar1 != 0) {
        return iVar1;
      }
      iVar1 = FUN_00425a2d();
    } while ((iVar1 != 0) && (iVar1 = __callnewh(_Size), iVar1 != 0));
  }
  puVar2 = (undefined4 *)FUN_00423633();
  *puVar2 = 0xc;
  return 0;
}



// Library Function - Single Match
//  _wcsncmp
// 
// Library: Visual Studio 2017 Release

int __cdecl _wcsncmp(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)

{
  if (_MaxCount != 0) {
    for (; ((_MaxCount = _MaxCount - 1, _MaxCount != 0 && (*_Str1 != L'\0')) && (*_Str1 == *_Str2));
        _Str1 = _Str1 + 1) {
      _Str2 = _Str2 + 1;
    }
    return (uint)(ushort)*_Str1 - (uint)(ushort)*_Str2;
  }
  return _MaxCount;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_call_reportfault
// 
// Library: Visual Studio 2017 Release

void ___acrt_call_reportfault(int param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  undefined4 local_324;
  undefined4 local_320;
  undefined4 local_2d4 [39];
  
  if (param_1 != -1) {
    FUN_0042056d();
  }
  _memset(&local_324,0,0x50);
  _memset(local_2d4,0,0x2cc);
  local_2d4[0] = 0x10001;
  local_324 = param_2;
  local_320 = param_3;
  iVar1 = (*_DAT_1000c0a8)();
  (*_DAT_1000c084)();
  iVar2 = (*_DAT_1000c080)();
  if (((iVar2 == 0) && (iVar1 == 0)) && (param_1 != -1)) {
    FUN_0042056d();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_004234ec(undefined4 param_1)

{
  _DAT_10012d30 = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __invalid_parameter
// 
// Library: Visual Studio 2015 Release

void __invalid_parameter(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,
                        uintptr_t param_5)

{
  uint uVar1;
  int iVar2;
  byte bVar3;
  code *pcVar4;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar2 = FUN_00423ff0();
  if (((iVar2 == 0) || (pcVar4 = *(code **)(iVar2 + 0x35c), pcVar4 == (code *)0x0)) &&
     (bVar3 = (byte)_DAT_10012000 & 0x1f,
     pcVar4 = (code *)((_DAT_10012000 ^ _DAT_10012d30) >> bVar3 |
                      (_DAT_10012000 ^ _DAT_10012d30) << 0x20 - bVar3), pcVar4 == (code *)0x0)) {
    __invoke_watson(param_1,param_2,param_3,param_4,param_5);
    pcVar4 = (code *)swi(3);
    (*pcVar4)();
    return;
  }
  (*_DAT_1000c174)(param_1,param_2,param_3,param_4,param_5);
  (*pcVar4)();
  ___security_check_cookie_4(uVar1);
  return;
}



void FUN_00423576(void)

{
  __invalid_parameter(0,0,0,0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __invoke_watson
// 
// Library: Visual Studio 2017 Release

void __cdecl
__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)

{
  code *pcVar1;
  int iVar2;
  undefined4 uVar3;
  
  iVar2 = (*_DAT_1000c090)(0x17);
  if (iVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  ___acrt_call_reportfault(2,0xc0000417,1);
  uVar3 = (*_DAT_1000c088)(0xc0000417);
  (*_DAT_1000c08c)(uVar3);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___acrt_errno_from_os_error
//  __get_errno_from_oserr
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

int __cdecl FID_conflict____acrt_errno_from_os_error(ulong param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == *(ulong *)(&DAT_1000cc38 + uVar1 * 8)) {
      return *(int *)(&DAT_1000cc3c + uVar1 * 8);
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x2c);
  if (param_1 - 0x13 < 0x12) {
    return 0xd;
  }
  return (-(uint)(0xe < param_1 - 0xbc) & 0xe) + 8;
}



// Library Function - Single Match
//  ___acrt_errno_map_os_error
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_errno_map_os_error(ulong param_1)

{
  ulong *puVar1;
  int iVar2;
  int *piVar3;
  
  puVar1 = (ulong *)FUN_00423620();
  *puVar1 = param_1;
  iVar2 = FID_conflict____acrt_errno_from_os_error(param_1);
  piVar3 = (int *)FUN_00423633();
  *piVar3 = iVar2;
  return;
}



int FUN_00423620(void)

{
  int iVar1;
  
  iVar1 = FUN_00423ff0();
  if (iVar1 == 0) {
    return 0x10012048;
  }
  return iVar1 + 0x14;
}



int FUN_00423633(void)

{
  int iVar1;
  
  iVar1 = FUN_00423ff0();
  if (iVar1 == 0) {
    return 0x10012044;
  }
  return iVar1 + 0x10;
}



// Library Function - Multiple Matches With Different Base Names
//  int (__stdcall*__cdecl try_get_AreFileApisANSI(void))(void)
//  int (__stdcall*__cdecl try_get_CompareStringEx(void))(wchar_t const *,unsigned long,wchar_t
// const *,int,wchar_t const *,int,struct _nlsversioninfo *,void *,long)
//  int (__stdcall*__cdecl try_get_EnumSystemLocalesEx(void))(int (__stdcall*)(wchar_t *,unsigned
// long,long),unsigned long,long,void *)
//  int (__stdcall*__cdecl try_get_GetDateFormatEx(void))(wchar_t const *,unsigned long,struct
// _SYSTEMTIME const *,wchar_t const *,wchar_t *,int,wchar_t const *)
//   14 names - too many to list
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict_try_get_IsValidLocaleName(void)

{
  try_get_function(0x14,(char *)0x1000d254,(module_id *)0x1000d24c,(module_id *)0x1000d254);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  int (__stdcall*__cdecl try_get_AreFileApisANSI(void))(void)
//  int (__stdcall*__cdecl try_get_CompareStringEx(void))(wchar_t const *,unsigned long,wchar_t
// const *,int,wchar_t const *,int,struct _nlsversioninfo *,void *,long)
//  int (__stdcall*__cdecl try_get_EnumSystemLocalesEx(void))(int (__stdcall*)(wchar_t *,unsigned
// long,long),unsigned long,long,void *)
//  int (__stdcall*__cdecl try_get_GetDateFormatEx(void))(wchar_t const *,unsigned long,struct
// _SYSTEMTIME const *,wchar_t const *,wchar_t *,int,wchar_t const *)
//   14 names - too many to list
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict_try_get_IsValidLocaleName(void)

{
  try_get_function(0x16,(char *)0x1000d26c,(module_id *)0x1000d264,(module_id *)0x1000d26c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  struct HINSTANCE__ * __cdecl try_get_first_available_module(enum `anonymous
// namespace'::module_id const * const,enum `anonymous namespace'::module_id const * const)
// 
// Library: Visual Studio 2017 Release

HINSTANCE__ * __cdecl try_get_first_available_module(module_id *param_1,module_id *param_2)

{
  HINSTANCE__ **ppHVar1;
  wchar_t *_Str1;
  HINSTANCE__ *pHVar2;
  HINSTANCE__ *pHVar3;
  int iVar4;
  
  do {
    if (param_1 == param_2) {
      return (HINSTANCE__ *)0x0;
    }
    ppHVar1 = (HINSTANCE__ **)(&DAT_10012d38 + *param_1 * 4);
    pHVar3 = *ppHVar1;
    if (pHVar3 == (HINSTANCE__ *)0x0) {
      _Str1 = *(wchar_t **)(*param_1 * 4 + 0x1000cd98);
      pHVar3 = (HINSTANCE__ *)(*_DAT_1000c0ec)(_Str1,0,0x800);
      if (pHVar3 == (HINSTANCE__ *)0x0) {
        iVar4 = (*_DAT_1000c0c0)();
        if (((iVar4 == 0x57) && (iVar4 = _wcsncmp(_Str1,(wchar_t *)0x1000ca58,7), iVar4 != 0)) &&
           (iVar4 = _wcsncmp(_Str1,(wchar_t *)0x1000ca68,7), iVar4 != 0)) {
          pHVar3 = (HINSTANCE__ *)(*_DAT_1000c0ec)(_Str1,0,0);
        }
        else {
          pHVar3 = (HINSTANCE__ *)0x0;
        }
        if (pHVar3 == (HINSTANCE__ *)0x0) {
          *ppHVar1 = (HINSTANCE__ *)0xffffffff;
          goto LAB_00423729;
        }
      }
      pHVar2 = *ppHVar1;
      *ppHVar1 = pHVar3;
      if (pHVar2 != (HINSTANCE__ *)0x0) {
        (*_DAT_1000c0e8)(pHVar3);
      }
LAB_00423725:
      if (pHVar3 != (HINSTANCE__ *)0x0) {
        return pHVar3;
      }
    }
    else if (pHVar3 != (HINSTANCE__ *)0xffffffff) goto LAB_00423725;
LAB_00423729:
    param_1 = param_1 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void * __cdecl try_get_function(enum `anonymous namespace'::function_id,char const * const,enum
// A0x391cf84c::module_id const * const,enum A0x391cf84c::module_id const * const)
// 
// Library: Visual Studio 2017 Release

void * __cdecl
try_get_function(function_id param_1,char *param_2,module_id *param_3,module_id *param_4)

{
  void **ppvVar1;
  HINSTANCE__ *pHVar2;
  void *pvVar3;
  byte bVar4;
  void *pvVar5;
  
  ppvVar1 = (void **)(param_1 * 4 + 0x10012d88);
  bVar4 = (byte)_DAT_10012000 & 0x1f;
  pvVar5 = (void *)((_DAT_10012000 ^ (uint)*ppvVar1) >> bVar4 |
                   (_DAT_10012000 ^ (uint)*ppvVar1) << 0x20 - bVar4);
  if (pvVar5 == (void *)0xffffffff) {
    pvVar5 = (void *)0x0;
  }
  else if (pvVar5 == (void *)0x0) {
    pHVar2 = try_get_first_available_module(param_3,param_4);
    if ((pHVar2 == (HINSTANCE__ *)0x0) ||
       (pvVar5 = (void *)(*_DAT_1000c058)(pHVar2,param_2), pvVar5 == (void *)0x0)) {
      bVar4 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
      *ppvVar1 = (void *)((0xffffffffU >> bVar4 | -1 << 0x20 - bVar4) ^ _DAT_10012000);
      pvVar5 = (void *)0x0;
    }
    else {
      pvVar3 = __crt_fast_encode_pointer_void__(pvVar5);
      *ppvVar1 = pvVar3;
    }
  }
  return pvVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_004237c4(undefined4 param_1)

{
  uint uVar1;
  code *pcVar2;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)try_get_function(0x1c,(char *)0x1000d284,(module_id *)0x1000d280,
                                    (module_id *)0x1000d284);
  if (pcVar2 != (code *)0x0) {
    (*_DAT_1000c174)(0xfffffffa,param_1);
    (*pcVar2)();
  }
  ___security_check_cookie_4(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_FlsAlloc@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsAlloc_4(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(3,(char *)0x1000ca80,(module_id *)0x1000d200,
                                    (module_id *)0x1000d208);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0d8)();
  }
  else {
    (*_DAT_1000c174)(param_1);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_FlsFree@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsFree_4(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(4,(char *)0x1000ca94,(module_id *)0x1000d208,
                                    (module_id *)0x1000d210);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0e4)(param_1);
  }
  else {
    (*_DAT_1000c174)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_FlsGetValue@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsGetValue_4(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(5,(char *)0x1000caa4,(module_id *)0x1000d210,
                                    (module_id *)0x1000d218);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0dc)(param_1);
  }
  else {
    (*_DAT_1000c174)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_FlsSetValue@8
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsSetValue_8(undefined4 param_1,undefined4 param_2)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(6,(char *)0x1000cab8,(module_id *)0x1000d218,
                                    (module_id *)0x1000d220);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0e0)(param_1,param_2);
  }
  else {
    (*_DAT_1000c174)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00423976(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(0xd,(char *)0x1000d224,(module_id *)0x1000d220,
                                    (module_id *)0x1000d224);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0a0)(param_1);
  }
  else {
    (*_DAT_1000c174)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_InitializeCriticalSectionEx@12
// 
// Library: Visual Studio 2015 Release

void ___acrt_InitializeCriticalSectionEx_12
               (undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(0x12,(char *)0x1000cacc,(module_id *)0x1000d244,
                                    (module_id *)0x1000d24c);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c07c)(param_1,param_2);
  }
  else {
    (*_DAT_1000c174)(param_1,param_2,param_3);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_CompareStringEx@36
// 
// Library: Visual Studio 2015 Release

void ___acrt_CompareStringEx_36
               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
               undefined4 param_9)

{
  code *pcVar1;
  undefined4 uVar2;
  
  pcVar1 = (code *)FID_conflict_try_get_IsValidLocaleName();
  if (pcVar1 == (code *)0x0) {
    uVar2 = FUN_00423aa2(param_1,0);
    (*_DAT_1000c10c)(uVar2,param_2,param_3,param_4,param_5,param_6);
  }
  else {
    (*_DAT_1000c174)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00423aa2(undefined4 param_1,undefined4 param_2)

{
  uint uVar1;
  code *pcVar2;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)FID_conflict_try_get_IsValidLocaleName();
  if (pcVar2 == (code *)0x0) {
    ___acrt_DownlevelLocaleNameToLCID(param_1);
  }
  else {
    (*_DAT_1000c174)(param_1,param_2);
    (*pcVar2)();
  }
  ___security_check_cookie_4(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_uninitialize_winapi_thunks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___acrt_uninitialize_winapi_thunks(char param_1)

{
  int *piVar1;
  
  if (param_1 == '\0') {
    piVar1 = (int *)&DAT_10012d38;
    do {
      if (*piVar1 != 0) {
        if (*piVar1 != -1) {
          (*_DAT_1000c0e8)(*piVar1);
        }
        *piVar1 = 0;
      }
      piVar1 = piVar1 + 1;
    } while (piVar1 != (int *)0x10012d88);
  }
  return 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_15ade71b0218206bbe3333a0c9b79046>,class <lambda_da44e0f8b0f19ba52fefafb335991732>&,class
// <lambda_207f2d024fc103971653565357d6cd41>>(class
// <lambda_15ade71b0218206bbe3333a0c9b79046>&&,class
// <lambda_da44e0f8b0f19ba52fefafb335991732>&,class <lambda_207f2d024fc103971653565357d6cd41>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_15ade71b0218206bbe3333a0c9b79046__class__lambda_da44e0f8b0f19ba52fefafb335991732___class__lambda_207f2d024fc103971653565357d6cd41___
          (__crt_seh_guarded_call_void_ *this,_lambda_15ade71b0218206bbe3333a0c9b79046_ *param_1,
          _lambda_da44e0f8b0f19ba52fefafb335991732_ *param_2,
          _lambda_207f2d024fc103971653565357d6cd41_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  LOCK();
  **(int **)(**(int **)param_2 + 0x48) = **(int **)(**(int **)param_2 + 0x48) + 1;
  FUN_00423b98();
  return;
}



void FUN_00423b98(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_38edbb1296d33220d7e4dd0ed76b244a>,class <lambda_5ce1d447e08cb34b2473517608e21441>&,class
// <lambda_fb385d3da700c9147fc39e65dd577a8c>>(class
// <lambda_38edbb1296d33220d7e4dd0ed76b244a>&&,class
// <lambda_5ce1d447e08cb34b2473517608e21441>&,class <lambda_fb385d3da700c9147fc39e65dd577a8c>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_38edbb1296d33220d7e4dd0ed76b244a__class__lambda_5ce1d447e08cb34b2473517608e21441___class__lambda_fb385d3da700c9147fc39e65dd577a8c___
          (__crt_seh_guarded_call_void_ *this,_lambda_38edbb1296d33220d7e4dd0ed76b244a_ *param_1,
          _lambda_5ce1d447e08cb34b2473517608e21441_ *param_2,
          _lambda_fb385d3da700c9147fc39e65dd577a8c_ *param_3)

{
  int *_Memory;
  int iVar1;
  
  ___acrt_lock(*(undefined4 *)param_1);
  _Memory = *(int **)(**(int **)param_2 + 0x48);
  if (_Memory != (int *)0x0) {
    LOCK();
    iVar1 = *_Memory;
    *_Memory = iVar1 + -1;
    if ((iVar1 + -1 == 0) && (_Memory != (int *)0x10012350)) {
      FID_conflict__free(_Memory);
    }
  }
  FUN_00423bf9();
  return;
}



void FUN_00423bf9(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_6affb1475c98b40b75cdec977db92e3c>,class <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>&,class
// <lambda_608742c3c92a14382c1684fc64f96c88>>(class
// <lambda_6affb1475c98b40b75cdec977db92e3c>&&,class
// <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>&,class <lambda_608742c3c92a14382c1684fc64f96c88>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_6affb1475c98b40b75cdec977db92e3c__class__lambda_b8d4b9c228a6ecc3f80208dbb4b4a104___class__lambda_608742c3c92a14382c1684fc64f96c88___
          (__crt_seh_guarded_call_void_ *this,_lambda_6affb1475c98b40b75cdec977db92e3c_ *param_1,
          _lambda_b8d4b9c228a6ecc3f80208dbb4b4a104_ *param_2,
          _lambda_608742c3c92a14382c1684fc64f96c88_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  replace_current_thread_locale_nolock(**(__acrt_ptd ***)param_2,(__crt_locale_data *)0x0);
  FUN_00423c44();
  return;
}



void FUN_00423c44(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_a7e850c220f1c8d1e6efeecdedd162c6>,class <lambda_46720907175c18b6c9d2717bc0d2d362>&,class
// <lambda_9048902d66e8d99359bc9897bbb930a8>>(class
// <lambda_a7e850c220f1c8d1e6efeecdedd162c6>&&,class
// <lambda_46720907175c18b6c9d2717bc0d2d362>&,class <lambda_9048902d66e8d99359bc9897bbb930a8>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_a7e850c220f1c8d1e6efeecdedd162c6__class__lambda_46720907175c18b6c9d2717bc0d2d362___class__lambda_9048902d66e8d99359bc9897bbb930a8___
          (__crt_seh_guarded_call_void_ *this,_lambda_a7e850c220f1c8d1e6efeecdedd162c6_ *param_1,
          _lambda_46720907175c18b6c9d2717bc0d2d362_ *param_2,
          _lambda_9048902d66e8d99359bc9897bbb930a8_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  replace_current_thread_locale_nolock
            (**(__acrt_ptd ***)param_2,*(__crt_locale_data **)**(undefined4 **)(param_2 + 4));
  FUN_00423c94();
  return;
}



void FUN_00423c94(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  void __cdecl construct_ptd(struct __acrt_ptd * const,struct __crt_locale_data * * const)
// 
// Library: Visual Studio 2017 Release

void __cdecl construct_ptd(__acrt_ptd *param_1,__crt_locale_data **param_2)

{
  undefined4 local_18;
  __acrt_ptd **local_14;
  __acrt_ptd **local_10;
  __crt_locale_data ***local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  *(undefined4 *)(param_1 + 0x18) = 1;
  *(undefined4 *)param_1 = 0x1000caf0;
  *(undefined4 *)(param_1 + 0x350) = 1;
  *(undefined4 *)(param_1 + 0x48) = 0x10012350;
  *(undefined2 *)(param_1 + 0x6c) = 0x43;
  *(undefined2 *)(param_1 + 0x172) = 0x43;
  *(undefined4 *)(param_1 + 0x34c) = 0;
  local_14 = &param_1;
  local_c = (__crt_locale_data ***)0x5;
  local_18 = 5;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_15ade71b0218206bbe3333a0c9b79046__class__lambda_da44e0f8b0f19ba52fefafb335991732___class__lambda_207f2d024fc103971653565357d6cd41___
            (&local_5,(_lambda_15ade71b0218206bbe3333a0c9b79046_ *)&local_18,
             (_lambda_da44e0f8b0f19ba52fefafb335991732_ *)&local_14,
             (_lambda_207f2d024fc103971653565357d6cd41_ *)&local_c);
  local_10 = &param_1;
  local_c = &param_2;
  local_18 = 4;
  local_14 = (__acrt_ptd **)0x4;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_a7e850c220f1c8d1e6efeecdedd162c6__class__lambda_46720907175c18b6c9d2717bc0d2d362___class__lambda_9048902d66e8d99359bc9897bbb930a8___
            (&local_5,(_lambda_a7e850c220f1c8d1e6efeecdedd162c6_ *)&local_14,
             (_lambda_46720907175c18b6c9d2717bc0d2d362_ *)&local_10,
             (_lambda_9048902d66e8d99359bc9897bbb930a8_ *)&local_18);
  return;
}



// Library Function - Single Match
//  void __stdcall destroy_fls(void *)
// 
// Library: Visual Studio 2017 Release

void destroy_fls(void *param_1)

{
  if (param_1 != (void *)0x0) {
    destroy_ptd((__acrt_ptd *)param_1);
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Single Match
//  void __cdecl destroy_ptd(struct __acrt_ptd * const)
// 
// Library: Visual Studio 2017 Release

void __cdecl destroy_ptd(__acrt_ptd *param_1)

{
  undefined4 local_14;
  __acrt_ptd **local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  if (*(void **)param_1 != (void *)0x1000caf0) {
    FID_conflict__free(*(void **)param_1);
  }
  FID_conflict__free(*(void **)(param_1 + 0x3c));
  FID_conflict__free(*(void **)(param_1 + 0x30));
  FID_conflict__free(*(void **)(param_1 + 0x34));
  FID_conflict__free(*(void **)(param_1 + 0x38));
  FID_conflict__free(*(void **)(param_1 + 0x28));
  FID_conflict__free(*(void **)(param_1 + 0x2c));
  FID_conflict__free(*(void **)(param_1 + 0x40));
  FID_conflict__free(*(void **)(param_1 + 0x44));
  FID_conflict__free(*(void **)(param_1 + 0x360));
  local_10 = &param_1;
  local_c = 5;
  local_14 = 5;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_38edbb1296d33220d7e4dd0ed76b244a__class__lambda_5ce1d447e08cb34b2473517608e21441___class__lambda_fb385d3da700c9147fc39e65dd577a8c___
            (&local_5,(_lambda_38edbb1296d33220d7e4dd0ed76b244a_ *)&local_14,
             (_lambda_5ce1d447e08cb34b2473517608e21441_ *)&local_10,
             (_lambda_fb385d3da700c9147fc39e65dd577a8c_ *)&local_c);
  local_10 = &param_1;
  local_14 = 4;
  local_c = 4;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_6affb1475c98b40b75cdec977db92e3c__class__lambda_b8d4b9c228a6ecc3f80208dbb4b4a104___class__lambda_608742c3c92a14382c1684fc64f96c88___
            (&local_5,(_lambda_6affb1475c98b40b75cdec977db92e3c_ *)&local_c,
             (_lambda_b8d4b9c228a6ecc3f80208dbb4b4a104_ *)&local_10,
             (_lambda_608742c3c92a14382c1684fc64f96c88_ *)&local_14);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl replace_current_thread_locale_nolock(struct __acrt_ptd * const,struct
// __crt_locale_data * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl replace_current_thread_locale_nolock(__acrt_ptd *param_1,__crt_locale_data *param_2)

{
  int iVar1;
  
  if (*(int *)(param_1 + 0x4c) != 0) {
    ___acrt_release_locale_ref(*(undefined4 *)(param_1 + 0x4c));
    iVar1 = *(int *)(param_1 + 0x4c);
    if (((iVar1 != _DAT_100131b0) && (iVar1 != 0x10012570)) && (*(int *)(iVar1 + 0xc) == 0)) {
      ___acrt_free_locale(iVar1);
    }
  }
  *(__crt_locale_data **)(param_1 + 0x4c) = param_2;
  if (param_2 != (__crt_locale_data *)0x0) {
    ___acrt_add_locale_ref(param_2);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_freeptd
// 
// Library: Visual Studio 2015 Release

void ___acrt_freeptd(void)

{
  void *pvVar1;
  
  if ((_DAT_1001204c != -1) &&
     (pvVar1 = (void *)___acrt_FlsGetValue_4(_DAT_1001204c), pvVar1 != (void *)0x0)) {
    ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    destroy_fls(pvVar1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

__acrt_ptd * FUN_00423ea2(void)

{
  code *pcVar1;
  undefined4 uVar2;
  __acrt_ptd *p_Var3;
  int iVar4;
  
  uVar2 = (*_DAT_1000c0c0)();
  if ((_DAT_1001204c == -1) ||
     (p_Var3 = (__acrt_ptd *)___acrt_FlsGetValue_4(_DAT_1001204c), p_Var3 == (__acrt_ptd *)0x0)) {
    iVar4 = ___acrt_FlsSetValue_8(_DAT_1001204c,0xffffffff);
    if (iVar4 == 0) goto LAB_00423f49;
    p_Var3 = (__acrt_ptd *)__calloc_base(1,0x364);
    if (p_Var3 == (__acrt_ptd *)0x0) {
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    else {
      iVar4 = ___acrt_FlsSetValue_8(_DAT_1001204c,p_Var3);
      if (iVar4 != 0) {
        construct_ptd(p_Var3,(__crt_locale_data **)&DAT_100131b0);
        FID_conflict__free((void *)0x0);
        goto LAB_00423f39;
      }
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    FID_conflict__free(p_Var3);
  }
  else {
    if (p_Var3 == (__acrt_ptd *)0xffffffff) goto LAB_00423f49;
LAB_00423f39:
    if (p_Var3 != (__acrt_ptd *)0x0) {
      (*_DAT_1000c0c4)(uVar2);
      return p_Var3;
    }
  }
LAB_00423f49:
  (*_DAT_1000c0c4)(uVar2);
  _abort();
  pcVar1 = (code *)swi(3);
  p_Var3 = (__acrt_ptd *)(*pcVar1)();
  return p_Var3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

__acrt_ptd * FUN_00423f56(void)

{
  code *pcVar1;
  __acrt_ptd *p_Var2;
  int iVar3;
  
  if ((_DAT_1001204c == -1) ||
     (p_Var2 = (__acrt_ptd *)___acrt_FlsGetValue_4(_DAT_1001204c), p_Var2 == (__acrt_ptd *)0x0)) {
    iVar3 = ___acrt_FlsSetValue_8(_DAT_1001204c,0xffffffff);
    if (iVar3 == 0) goto LAB_00423fea;
    p_Var2 = (__acrt_ptd *)__calloc_base(1,0x364);
    if (p_Var2 == (__acrt_ptd *)0x0) {
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    else {
      iVar3 = ___acrt_FlsSetValue_8(_DAT_1001204c,p_Var2);
      if (iVar3 != 0) {
        construct_ptd(p_Var2,(__crt_locale_data **)&DAT_100131b0);
        FID_conflict__free((void *)0x0);
        goto LAB_00423fe2;
      }
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    FID_conflict__free(p_Var2);
  }
  else {
    if (p_Var2 == (__acrt_ptd *)0xffffffff) goto LAB_00423fea;
LAB_00423fe2:
    if (p_Var2 != (__acrt_ptd *)0x0) {
      return p_Var2;
    }
  }
LAB_00423fea:
  _abort();
  pcVar1 = (code *)swi(3);
  p_Var2 = (__acrt_ptd *)(*pcVar1)();
  return p_Var2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

__acrt_ptd * FUN_00423ff0(void)

{
  undefined4 uVar1;
  __acrt_ptd *_Memory;
  int iVar2;
  
  uVar1 = (*_DAT_1000c0c0)();
  if ((_DAT_1001204c == -1) ||
     (_Memory = (__acrt_ptd *)___acrt_FlsGetValue_4(_DAT_1001204c), _Memory == (__acrt_ptd *)0x0)) {
    iVar2 = ___acrt_FlsSetValue_8(_DAT_1001204c,0xffffffff);
    if (iVar2 == 0) goto LAB_0042401a;
    _Memory = (__acrt_ptd *)__calloc_base(1,0x364);
    if (_Memory == (__acrt_ptd *)0x0) {
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
      _Memory = (__acrt_ptd *)0x0;
    }
    else {
      iVar2 = ___acrt_FlsSetValue_8(_DAT_1001204c,_Memory);
      if (iVar2 != 0) {
        construct_ptd(_Memory,(__crt_locale_data **)&DAT_100131b0);
        FID_conflict__free((void *)0x0);
        goto LAB_00424096;
      }
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    FID_conflict__free(_Memory);
  }
  else {
    if (_Memory == (__acrt_ptd *)0xffffffff) goto LAB_0042401a;
LAB_00424096:
    if (_Memory != (__acrt_ptd *)0x0) {
      (*_DAT_1000c0c4)(uVar1);
      return _Memory;
    }
  }
LAB_0042401a:
  (*_DAT_1000c0c4)(uVar1);
  return (__acrt_ptd *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_uninitialize_ptd
// 
// Library: Visual Studio 2015 Release

undefined4 ___acrt_uninitialize_ptd(void)

{
  if (_DAT_1001204c != -1) {
    ___acrt_FlsFree_4(_DAT_1001204c);
    _DAT_1001204c = -1;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lock
// 
// Library: Visual Studio 2017 Release

void ___acrt_lock(int param_1)

{
  (*_DAT_1000c0c8)(param_1 * 0x18 + 0x10012e10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_unlock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_unlock(int param_1)

{
  (*_DAT_1000c0cc)(param_1 * 0x18 + 0x10012e10);
  return;
}



// Library Function - Single Match
//  ___acrt_get_process_end_policy
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_get_process_end_policy(void)

{
  int in_FS_OFFSET;
  int local_8;
  
  local_8 = 0;
  if ((-1 < *(int *)(*(int *)(*(int *)(in_FS_OFFSET + 0x30) + 0x10) + 8)) &&
     (FUN_004237c4(&local_8), local_8 == 1)) {
    return 0;
  }
  return 1;
}



uint FUN_004241bc(uint param_1,uint param_2)

{
  if (param_2 >= param_1 && param_2 != param_1) {
    return 0xffffffff;
  }
  return (uint)(param_2 < param_1);
}



// WARNING: Type propagation algorithm not settling

int FUN_004241d4(char **param_1,int *param_2)

{
  char cVar1;
  code *pcVar2;
  undefined4 *puVar3;
  char *pcVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  char **ppcVar10;
  char **_Memory;
  char **local_2c;
  char **local_28;
  undefined4 local_24;
  uint local_20;
  char **local_1c;
  char *local_18;
  char *local_14;
  char *local_10;
  char *local_c;
  undefined4 local_8;
  
  if (param_2 == (int *)0x0) {
    puVar3 = (undefined4 *)FUN_00423633();
    iVar8 = 0x16;
    *puVar3 = 0x16;
    FUN_00423576();
  }
  else {
    uVar7 = 0;
    *param_2 = 0;
    local_2c = (char **)0x0;
    local_28 = (char **)0x0;
    local_24 = 0;
    pcVar4 = *param_1;
    ppcVar10 = local_2c;
    while (local_2c = ppcVar10, pcVar4 != (char *)0x0) {
      local_8 = (char **)CONCAT13((char)((uint)local_8 >> 0x18),0x3f2a);
      pcVar4 = _strpbrk(*param_1,(char *)&local_8);
      if (pcVar4 == (char *)0x0) {
        iVar8 = FUN_004243b4(*param_1,0,0,&local_2c);
      }
      else {
        iVar8 = FUN_00424467(*param_1,pcVar4,&local_2c);
      }
      ppcVar10 = local_2c;
      local_c = (char *)iVar8;
      if (iVar8 != 0) goto LAB_00424362;
      param_1 = param_1 + 1;
      pcVar4 = *param_1;
    }
    local_c = (char *)0x0;
    local_10 = (char *)(((int)local_28 - (int)ppcVar10 >> 2) + 1);
    uVar9 = ~-(uint)(local_28 < ppcVar10) & ((int)local_28 - (int)ppcVar10) + 3U >> 2;
    local_8 = ppcVar10;
    if (uVar9 != 0) {
      uVar6 = 0;
      do {
        pcVar4 = *local_8;
        local_14 = pcVar4 + 1;
        do {
          cVar1 = *pcVar4;
          pcVar4 = pcVar4 + 1;
        } while (cVar1 != '\0');
        local_c = pcVar4 + (int)(local_c + (1 - (int)local_14));
        local_8 = local_8 + 1;
        uVar6 = uVar6 + 1;
      } while (uVar6 != uVar9);
    }
    iVar8 = FUN_00422add(local_10,local_c,1);
    if (iVar8 == 0) {
      iVar8 = -1;
      local_c = (char *)0xffffffff;
    }
    else {
      local_10 = (char *)(iVar8 + (int)local_10 * 4);
      local_1c = (char **)local_10;
      local_8 = ppcVar10;
      if (ppcVar10 != local_28) {
        local_20 = iVar8 - (int)ppcVar10;
        do {
          local_18 = *local_8;
          local_14 = local_18;
          do {
            cVar1 = *local_14;
            local_14 = local_14 + 1;
          } while (cVar1 != '\0');
          local_14 = local_14 + (1 - (int)(local_18 + 1));
          iVar5 = FUN_00426633(local_10,local_c + ((int)local_1c - (int)local_10),local_18,local_14)
          ;
          if (iVar5 != 0) {
            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
            pcVar2 = (code *)swi(3);
            iVar8 = (*pcVar2)();
            return iVar8;
          }
          *(char **)(local_20 + (int)local_8) = local_10;
          local_8 = local_8 + 1;
          local_10 = local_10 + (int)local_14;
        } while (local_8 != local_28);
      }
      local_c = (char *)0x0;
      *param_2 = iVar8;
      iVar8 = 0;
    }
    FID_conflict__free((void *)0x0);
LAB_00424362:
    uVar9 = ~-(uint)(local_28 < ppcVar10) & (uint)((int)local_28 + (3 - (int)ppcVar10)) >> 2;
    _Memory = ppcVar10;
    local_20 = uVar9;
    local_1c = ppcVar10;
    if (uVar9 != 0) {
      do {
        FID_conflict__free(*ppcVar10);
        uVar7 = uVar7 + 1;
        ppcVar10 = ppcVar10 + 1;
        iVar8 = (int)local_c;
        _Memory = local_2c;
      } while (uVar7 != uVar9);
    }
    FID_conflict__free(_Memory);
  }
  return iVar8;
}



int FUN_004243b4(char *param_1,undefined4 param_2,uint param_3,int param_4)

{
  char cVar1;
  code *pcVar2;
  int iVar3;
  void *_Memory;
  char *pcVar4;
  char *pcVar5;
  
  pcVar4 = param_1;
  do {
    cVar1 = *pcVar4;
    pcVar4 = pcVar4 + 1;
  } while (cVar1 != '\0');
  pcVar4 = pcVar4 + (1 - (int)(param_1 + 1));
  if ((char *)~param_3 < pcVar4) {
    iVar3 = 0xc;
  }
  else {
    pcVar5 = pcVar4 + param_3 + 1;
    _Memory = (void *)__calloc_base(pcVar5,1);
    if (param_3 != 0) {
      iVar3 = FUN_00426633(_Memory,pcVar5,param_2,param_3);
      if (iVar3 != 0) goto LAB_0042445a;
    }
    iVar3 = FUN_00426633((int)_Memory + param_3,(int)pcVar5 - param_3,param_1,pcVar4);
    if (iVar3 != 0) {
LAB_0042445a:
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar2 = (code *)swi(3);
      iVar3 = (*pcVar2)();
      return iVar3;
    }
    iVar3 = expand_if_necessary();
    if (iVar3 == 0) {
      **(void ***)(param_4 + 4) = _Memory;
      iVar3 = 0;
      *(int *)(param_4 + 4) = *(int *)(param_4 + 4) + 4;
    }
    else {
      FID_conflict__free(_Memory);
    }
    FID_conflict__free((void *)0x0);
  }
  return iVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00424467(char *param_1,char *param_2,int *param_3)

{
  char cVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  undefined local_148 [44];
  char local_11c;
  char local_11b;
  char local_11a;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  for (; (((param_2 != param_1 && (cVar1 = *param_2, cVar1 != '/')) && (cVar1 != '\\')) &&
         (cVar1 != ':')); param_2 = (char *)FUN_0042667e(param_1,param_2)) {
  }
  cVar1 = *param_2;
  if ((cVar1 == ':') && (param_2 != param_1 + 1)) {
    FUN_004243b4(param_1,0,0,param_3);
  }
  else {
    if ((cVar1 == '/') || ((cVar1 == '\\' || (bVar2 = 0, cVar1 == ':')))) {
      bVar2 = 1;
    }
    _memset(local_148,0,0x140);
    iVar3 = (*_DAT_1000c114)(param_1,0,local_148,0,0,0);
    if (iVar3 == -1) {
      FUN_004243b4(param_1,0,0,param_3);
    }
    else {
      iVar5 = param_3[1] - *param_3 >> 2;
      do {
        if (((local_11c != '.') ||
            ((local_11b != '\0' && ((local_11b != '.' || (local_11a != '\0')))))) &&
           (iVar4 = FUN_004243b4(&local_11c,param_1,
                                 -(uint)bVar2 & (uint)(param_2 + (1 - (int)param_1)),param_3),
           iVar4 != 0)) goto LAB_00424534;
        iVar4 = (*_DAT_1000c118)(iVar3,local_148);
      } while (iVar4 != 0);
      iVar4 = param_3[1] - *param_3 >> 2;
      if (iVar5 != iVar4) {
        FUN_0042613e(*param_3 + iVar5 * 4,iVar4 - iVar5,4,0x10005d5e);
      }
    }
LAB_00424534:
    if (iVar3 != -1) {
      (*_DAT_1000c110)(iVar3);
    }
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall expand_if_necessary(int *param_1)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  
  if (param_1[1] == param_1[2]) {
    if (*param_1 == 0) {
      iVar2 = __calloc_base(4,4);
      *param_1 = iVar2;
      FID_conflict__free((void *)0x0);
      iVar2 = *param_1;
      if (iVar2 != 0) {
        param_1[1] = iVar2;
        param_1[2] = iVar2 + 0x10;
        goto LAB_004245f5;
      }
    }
    else {
      uVar3 = param_1[2] - *param_1 >> 2;
      if (uVar3 < 0x80000000) {
        iVar2 = FUN_00424fb1(*param_1,uVar3 * 2,4);
        if (iVar2 == 0) {
          uVar1 = 0xc;
        }
        else {
          *param_1 = iVar2;
          param_1[1] = iVar2 + uVar3 * 4;
          param_1[2] = iVar2 + uVar3 * 8;
          uVar1 = 0;
        }
        FID_conflict__free((void *)0x0);
        return uVar1;
      }
    }
    uVar1 = 0xc;
  }
  else {
LAB_004245f5:
    uVar1 = 0;
  }
  return uVar1;
}



void FUN_0042466e(void)

{
  FUN_004241d4();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_ceb1ee4838e85a9d631eb091e2fbe199>,class <lambda_ae742caa10f662c28703da3d2ea5e57e>&,class
// <lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>>(class
// <lambda_ceb1ee4838e85a9d631eb091e2fbe199>&&,class
// <lambda_ae742caa10f662c28703da3d2ea5e57e>&,class <lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_ceb1ee4838e85a9d631eb091e2fbe199__class__lambda_ae742caa10f662c28703da3d2ea5e57e___class__lambda_cd08b5d6af4937fe54fc07d0c9bf6b37___
          (__crt_seh_guarded_call_void_ *this,_lambda_ceb1ee4838e85a9d631eb091e2fbe199_ *param_1,
          _lambda_ae742caa10f662c28703da3d2ea5e57e_ *param_2,
          _lambda_cd08b5d6af4937fe54fc07d0c9bf6b37_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  <lambda_ae742caa10f662c28703da3d2ea5e57e>::operator__(param_2);
  FUN_004246b0();
  return;
}



void FUN_004246b0(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  public: void __thiscall <lambda_ae742caa10f662c28703da3d2ea5e57e>::operator()(void)const 
// 
// Library: Visual Studio 2017 Release

void __thiscall
<lambda_ae742caa10f662c28703da3d2ea5e57e>::operator__
          (_lambda_ae742caa10f662c28703da3d2ea5e57e_ *this)

{
  int iVar1;
  
  _memcpy_s(_DAT_10012f64,0x101,(void *)(*(int *)(**(int **)this + 0x48) + 0x18),0x101);
  _memcpy_s(_DAT_10012f68,0x100,(void *)(*(int *)(**(int **)this + 0x48) + 0x119),0x100);
  LOCK();
  iVar1 = **(int **)**(undefined4 **)(this + 4) + -1;
  **(int **)**(undefined4 **)(this + 4) = iVar1;
  if ((iVar1 == 0) && (*(void **)**(undefined4 **)(this + 4) != (void *)0x10012350)) {
    FID_conflict__free(*(void **)**(undefined4 **)(this + 4));
  }
  *(undefined4 *)**(undefined4 **)(this + 4) = *(undefined4 *)(**(int **)this + 0x48);
  LOCK();
  **(int **)(**(int **)this + 0x48) = **(int **)(**(int **)this + 0x48) + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  wchar_t const * __cdecl CPtoLocaleName(int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

wchar_t * __cdecl CPtoLocaleName(int param_1)

{
  if (param_1 == 0x3a4) {
    return _DAT_1000d2ac;
  }
  if (param_1 == 0x3a8) {
    return _DAT_1000d2b0;
  }
  if (param_1 == 0x3b5) {
    return _DAT_1000d2b4;
  }
  if (param_1 != 0x3b6) {
    return (wchar_t *)0x0;
  }
  return _DAT_1000d2b8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  int __cdecl getSystemCP(int)
// 
// Library: Visual Studio 2017 Release

int __cdecl getSystemCP(int param_1)

{
  int local_14;
  int local_10;
  char local_8;
  
  FUN_004231ce(0);
  _DAT_10012f70 = 0;
  if (param_1 == -2) {
    _DAT_10012f70 = 1;
    param_1 = (*_DAT_1000c124)();
  }
  else if (param_1 == -3) {
    _DAT_10012f70 = 1;
    param_1 = (*_DAT_1000c120)();
  }
  else if (param_1 == -4) {
    _DAT_10012f70 = 1;
    param_1 = *(int *)(local_10 + 8);
  }
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return param_1;
}



// Library Function - Single Match
//  void __cdecl setSBCS(struct __crt_multibyte_data *)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl setSBCS(__crt_multibyte_data *param_1)

{
  int iVar1;
  __crt_multibyte_data *p_Var2;
  
  p_Var2 = param_1 + 0x18;
  _memset(p_Var2,0,0x101);
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  *(undefined4 *)(param_1 + 0x21c) = 0;
  iVar1 = 0x101;
  *(undefined4 *)(param_1 + 0xc) = 0;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  do {
    *p_Var2 = p_Var2[0x10012350 - (int)param_1];
    p_Var2 = p_Var2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  p_Var2 = param_1 + 0x119;
  iVar1 = 0x100;
  do {
    *p_Var2 = p_Var2[0x10012350 - (int)param_1];
    p_Var2 = p_Var2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl setSBUpLow(struct __crt_multibyte_data *)
// 
// Library: Visual Studio 2015 Release

void __cdecl setSBUpLow(__crt_multibyte_data *param_1)

{
  byte bVar1;
  __crt_multibyte_data _Var2;
  int iVar3;
  uint uVar4;
  byte *pbVar5;
  __crt_multibyte_data *p_Var6;
  undefined local_71c [6];
  byte local_716;
  byte local_715 [13];
  ushort local_708 [512];
  __crt_multibyte_data local_308 [256];
  __crt_multibyte_data local_208 [256];
  undefined local_108 [256];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar3 = (*_DAT_1000c128)(*(undefined4 *)(param_1 + 4),local_71c);
  if (iVar3 == 0) {
    uVar4 = 0;
    do {
      p_Var6 = param_1 + uVar4 + 0x119;
      if (p_Var6 + (-0x61 - (int)(param_1 + 0x119)) + 0x20 < (__crt_multibyte_data *)0x1a) {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = (__crt_multibyte_data)((char)uVar4 + ' ');
LAB_004249c1:
        *p_Var6 = _Var2;
      }
      else {
        if (p_Var6 + (-0x61 - (int)(param_1 + 0x119)) < (__crt_multibyte_data *)0x1a) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = (__crt_multibyte_data)((char)uVar4 + -0x20);
          goto LAB_004249c1;
        }
        *p_Var6 = (__crt_multibyte_data)0x0;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  else {
    uVar4 = 0;
    do {
      local_108[uVar4] = (char)uVar4;
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
    pbVar5 = &local_716;
    local_108[0] = 0x20;
    while (local_716 != 0) {
      bVar1 = pbVar5[1];
      for (uVar4 = (uint)local_716; (uVar4 <= bVar1 && (uVar4 < 0x100)); uVar4 = uVar4 + 1) {
        local_108[uVar4] = 0x20;
      }
      pbVar5 = pbVar5 + 2;
      local_716 = *pbVar5;
    }
    FUN_0042671b(0,1,local_108,0x100,local_708,*(undefined4 *)(param_1 + 4),0);
    ___acrt_LCMapStringA
              (0,*(undefined4 *)(param_1 + 0x21c),0x100,local_108,0x100,local_208,0x100,
               *(undefined4 *)(param_1 + 4),0);
    ___acrt_LCMapStringA
              (0,*(undefined4 *)(param_1 + 0x21c),0x200,local_108,0x100,local_308,0x100,
               *(undefined4 *)(param_1 + 4),0);
    uVar4 = 0;
    do {
      if ((local_708[uVar4] & 1) == 0) {
        if ((local_708[uVar4] & 2) != 0) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = local_308[uVar4];
          goto LAB_00424968;
        }
        param_1[uVar4 + 0x119] = (__crt_multibyte_data)0x0;
      }
      else {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = local_208[uVar4];
LAB_00424968:
        param_1[uVar4 + 0x119] = _Var2;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  int __cdecl setmbcp_internal(int,bool,struct __acrt_ptd * const,struct __crt_multibyte_data * *
// const)
// 
// Library: Visual Studio 2017 Release

int __cdecl
setmbcp_internal(int param_1,bool param_2,__acrt_ptd *param_3,__crt_multibyte_data **param_4)

{
  int *piVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int iVar5;
  undefined4 *puVar6;
  __acrt_ptd **local_18;
  __crt_multibyte_data ***local_14;
  int local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  FUN_00424b04(param_3,param_4);
  local_10 = getSystemCP(param_1);
  if (local_10 == *(int *)(*(int *)(param_3 + 0x48) + 4)) {
    return 0;
  }
  puVar3 = (undefined4 *)__malloc_base(0x220);
  if (puVar3 != (undefined4 *)0x0) {
    puVar4 = *(undefined4 **)(param_3 + 0x48);
    puVar6 = puVar3;
    for (iVar5 = 0x88; iVar5 != 0; iVar5 = iVar5 + -1) {
      *puVar6 = *puVar4;
      puVar4 = puVar4 + 1;
      puVar6 = puVar6 + 1;
    }
    *puVar3 = 0;
    iVar5 = FUN_00424bf2(local_10,puVar3);
    if (iVar5 != -1) {
      if (param_2 == false) {
        ___acrt_set_locale_changed();
      }
      piVar1 = *(int **)(param_3 + 0x48);
      LOCK();
      iVar2 = *piVar1;
      *piVar1 = *piVar1 + -1;
      if ((iVar2 == 1) && (*(int *)(param_3 + 0x48) != 0x10012350)) {
        FID_conflict__free(*(void **)(param_3 + 0x48));
      }
      *puVar3 = 1;
      puVar4 = (undefined4 *)0x0;
      *(undefined4 **)(param_3 + 0x48) = puVar3;
      if ((((byte)param_3[0x350] & 2) == 0) && ((DAT_100126e0 & 1) == 0)) {
        local_18 = &param_3;
        local_14 = &param_4;
        local_10 = 5;
        local_c = 5;
        __crt_seh_guarded_call<void>::
        operator___class__lambda_ceb1ee4838e85a9d631eb091e2fbe199__class__lambda_ae742caa10f662c28703da3d2ea5e57e___class__lambda_cd08b5d6af4937fe54fc07d0c9bf6b37___
                  (&local_5,(_lambda_ceb1ee4838e85a9d631eb091e2fbe199_ *)&local_c,
                   (_lambda_ae742caa10f662c28703da3d2ea5e57e_ *)&local_18,
                   (_lambda_cd08b5d6af4937fe54fc07d0c9bf6b37_ *)&local_10);
        if (param_2 != false) {
          _DAT_1001262c = *param_4;
        }
      }
      goto LAB_00424a60;
    }
    puVar4 = (undefined4 *)FUN_00423633();
    *puVar4 = 0x16;
  }
  iVar5 = -1;
  puVar4 = puVar3;
LAB_00424a60:
  FID_conflict__free(puVar4);
  return iVar5;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int * FUN_00424b04(int param_1,int **param_2)

{
  int iVar1;
  int *_Memory;
  
  if ((*(uint *)(param_1 + 0x350) & _DAT_100126e0) == 0) goto LAB_00424b36;
  if (*(int *)(param_1 + 0x4c) == 0) goto LAB_00424b36;
  _Memory = *(int **)(param_1 + 0x48);
  while (_Memory == (int *)0x0) {
    _abort();
LAB_00424b36:
    ___acrt_lock(5);
    _Memory = *(int **)(param_1 + 0x48);
    if (_Memory != *param_2) {
      if (_Memory != (int *)0x0) {
        LOCK();
        iVar1 = *_Memory;
        *_Memory = iVar1 + -1;
        if ((iVar1 + -1 == 0) && (_Memory != (int *)0x10012350)) {
          FID_conflict__free(_Memory);
        }
      }
      _Memory = *param_2;
      *(int **)(param_1 + 0x48) = _Memory;
      LOCK();
      *_Memory = *_Memory + 1;
    }
    FUN_00424b86();
  }
  return _Memory;
}



void FUN_00424b86(void)

{
  ___acrt_unlock(5);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_initialize_multibyte
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_initialize_multibyte(void)

{
  __acrt_ptd *p_Var1;
  
  if (DAT_10012f74 == '\0') {
    _DAT_10012f6c = 0x10012350;
    _DAT_10012f68 = 0x10012158;
    _DAT_10012f64 = 0x10012050;
    p_Var1 = (__acrt_ptd *)FUN_00423f56();
    setmbcp_internal(-3,true,p_Var1,(__crt_multibyte_data **)&DAT_10012f6c);
    DAT_10012f74 = '\x01';
  }
  return 1;
}



// Library Function - Single Match
//  ___acrt_update_thread_multibyte_data
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_update_thread_multibyte_data(void)

{
  undefined4 uVar1;
  
  uVar1 = FUN_00423ea2(&DAT_10012f6c);
  FUN_00424b04(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00424bf2(int param_1,__crt_multibyte_data *param_2)

{
  byte bVar1;
  undefined2 uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  byte *pbVar6;
  __crt_multibyte_data *p_Var7;
  wchar_t *pwVar8;
  byte *pbVar9;
  undefined2 *puVar10;
  undefined2 *puVar11;
  uint uVar12;
  int local_20;
  int local_1c;
  byte local_16 [14];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar3 = getSystemCP(param_1);
  if (uVar3 != 0) {
    uVar12 = 0;
    uVar4 = 0;
    local_20 = 0;
LAB_00424c33:
    if (*(uint *)(&DAT_10012260 + uVar4) != uVar3) goto code_r0x00424c3f;
    _memset(param_2 + 0x18,0,0x101);
    pbVar6 = (byte *)(local_20 * 0x30 + 0x10012270);
    do {
      bVar1 = *pbVar6;
      pbVar9 = pbVar6;
      while ((bVar1 != 0 && (bVar1 = pbVar9[1], bVar1 != 0))) {
        for (uVar4 = (uint)*pbVar9; (uVar4 <= bVar1 && (uVar4 < 0x100)); uVar4 = uVar4 + 1) {
          param_2[uVar4 + 0x19] =
               (__crt_multibyte_data)((byte)param_2[uVar4 + 0x19] | (&DAT_10012258)[uVar12]);
          bVar1 = pbVar9[1];
        }
        pbVar9 = pbVar9 + 2;
        bVar1 = *pbVar9;
      }
      uVar12 = uVar12 + 1;
      pbVar6 = pbVar6 + 8;
    } while (uVar12 < 4);
    *(uint *)(param_2 + 4) = uVar3;
    *(undefined4 *)(param_2 + 8) = 1;
    pwVar8 = CPtoLocaleName(uVar3);
    *(wchar_t **)(param_2 + 0x21c) = pwVar8;
    puVar10 = (undefined2 *)(param_2 + 0xc);
    puVar11 = (undefined2 *)(local_20 * 0x30 + 0x10012264);
    iVar5 = 6;
    do {
      uVar2 = *puVar11;
      puVar11 = puVar11 + 1;
      *puVar10 = uVar2;
      puVar10 = puVar10 + 1;
      iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    goto LAB_00424dd2;
  }
  setSBCS(param_2);
LAB_00424ddc:
  ___security_check_cookie_4();
  return;
code_r0x00424c3f:
  local_20 = local_20 + 1;
  uVar4 = uVar4 + 0x30;
  if (0xef < uVar4) goto code_r0x00424c4d;
  goto LAB_00424c33;
code_r0x00424c4d:
  if ((uVar3 != 65000) &&
     (((uVar3 != 0xfde9 || (iVar5 = (*_DAT_1000c120)(), iVar5 == 0xfde9)) &&
      (iVar5 = (*_DAT_1000c11c)(uVar3 & 0xffff), iVar5 != 0)))) {
    iVar5 = (*_DAT_1000c128)(uVar3,&local_1c);
    if (iVar5 == 0) {
      if (_DAT_10012f70 != 0) {
        setSBCS(param_2);
      }
    }
    else {
      _memset(param_2 + 0x18,0,0x101);
      *(uint *)(param_2 + 4) = uVar3;
      *(undefined4 *)(param_2 + 0x21c) = 0;
      if (local_1c == 2) {
        pbVar6 = local_16;
        while ((local_16[0] != 0 && (bVar1 = pbVar6[1], bVar1 != 0))) {
          for (uVar3 = (uint)*pbVar6; uVar3 <= bVar1; uVar3 = uVar3 + 1) {
            param_2[uVar3 + 0x19] = (__crt_multibyte_data)((byte)param_2[uVar3 + 0x19] | 4);
          }
          pbVar6 = pbVar6 + 2;
          local_16[0] = *pbVar6;
        }
        p_Var7 = param_2 + 0x1a;
        iVar5 = 0xfe;
        do {
          *p_Var7 = (__crt_multibyte_data)((byte)*p_Var7 | 8);
          p_Var7 = p_Var7 + 1;
          iVar5 = iVar5 + -1;
        } while (iVar5 != 0);
        pwVar8 = CPtoLocaleName(*(int *)(param_2 + 4));
        *(wchar_t **)(param_2 + 0x21c) = pwVar8;
        *(undefined4 *)(param_2 + 8) = 1;
      }
      else {
        *(undefined4 *)(param_2 + 8) = 0;
      }
      *(undefined4 *)(param_2 + 0xc) = 0;
      *(undefined4 *)(param_2 + 0x10) = 0;
      *(undefined4 *)(param_2 + 0x14) = 0;
LAB_00424dd2:
      setSBUpLow(param_2);
    }
  }
  goto LAB_00424ddc;
}



// Library Function - Single Match
//  _memcpy_s
// 
// Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

errno_t __cdecl _memcpy_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)

{
  errno_t eVar1;
  undefined4 *puVar2;
  errno_t *peVar3;
  
  if (_MaxCount == 0) {
    eVar1 = 0;
  }
  else if (_Dst == (void *)0x0) {
    puVar2 = (undefined4 *)FUN_00423633();
    eVar1 = 0x16;
    *puVar2 = 0x16;
    FUN_00423576();
  }
  else if ((_Src == (void *)0x0) || (_DstSize < _MaxCount)) {
    _memset(_Dst,0,_DstSize);
    if (_Src == (void *)0x0) {
      peVar3 = (errno_t *)FUN_00423633();
      eVar1 = 0x16;
    }
    else {
      if (_MaxCount <= _DstSize) {
        return 0x16;
      }
      peVar3 = (errno_t *)FUN_00423633();
      eVar1 = 0x22;
    }
    *peVar3 = eVar1;
    FUN_00423576();
  }
  else {
    FUN_004215ae(_Dst,_Src,_MaxCount);
    eVar1 = 0;
  }
  return eVar1;
}



// Library Function - Single Match
//  int __cdecl x_ismbbtype_l(struct __crt_locale_pointers *,unsigned int,int,int)
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release, Visual Studio 2017 Debug, Visual
// Studio 2017 Release

int __cdecl x_ismbbtype_l(__crt_locale_pointers *param_1,uint param_2,int param_3,int param_4)

{
  uint uVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  char local_8;
  
  FUN_004231ce(param_1);
  if ((*(byte *)(local_c + 0x19 + (param_2 & 0xff)) & (byte)param_4) == 0) {
    iVar2 = 0;
    if (param_3 == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = (uint)*(ushort *)(*local_10 + (param_2 & 0xff) * 2) & param_3;
    }
    if (uVar1 == 0) goto LAB_00424eaf;
  }
  iVar2 = 1;
LAB_00424eaf:
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return iVar2;
}



// Library Function - Single Match
//  __ismbblead
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release, Visual Studio 2017 Debug, Visual
// Studio 2017 Release

int __cdecl __ismbblead(uint _C)

{
  int iVar1;
  
  iVar1 = x_ismbbtype_l((__crt_locale_pointers *)0x0,_C,0,4);
  return iVar1;
}



// Library Function - Single Match
//  wchar_t const * __cdecl find_end_of_double_null_terminated_sequence(wchar_t const * const)
// 
// Library: Visual Studio 2015 Release

wchar_t * __cdecl find_end_of_double_null_terminated_sequence(wchar_t *param_1)

{
  short sVar1;
  short *psVar2;
  
  sVar1 = *(short *)param_1;
  while (sVar1 != 0) {
    psVar2 = (short *)param_1;
    do {
      sVar1 = *psVar2;
      psVar2 = psVar2 + 1;
    } while (sVar1 != 0);
    param_1 = (wchar_t *)((int)param_1 + (((int)psVar2 - (int)((int)param_1 + 2) >> 1) + 1) * 2);
    sVar1 = *(short *)param_1;
  }
  return (wchar_t *)(short *)((int)param_1 + 2);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___dcrt_get_narrow_environment_from_os
// 
// Library: Visual Studio 2015 Release

void * ___dcrt_get_narrow_environment_from_os(void)

{
  wchar_t *pwVar1;
  wchar_t *pwVar2;
  int iVar3;
  void *_Memory;
  int iVar4;
  void *pvVar5;
  
  pwVar1 = (wchar_t *)(*_DAT_1000c134)();
  if (pwVar1 != (wchar_t *)0x0) {
    pwVar2 = find_end_of_double_null_terminated_sequence(pwVar1);
    iVar4 = (int)pwVar2 - (int)pwVar1 >> 1;
    iVar3 = (*_DAT_1000c100)(0,0,pwVar1,iVar4,0,0,0,0);
    if (iVar3 != 0) {
      _Memory = (void *)__malloc_base(iVar3);
      if (_Memory == (void *)0x0) {
LAB_00424f90:
        pvVar5 = (void *)0x0;
      }
      else {
        iVar3 = (*_DAT_1000c100)(0,0,pwVar1,iVar4,_Memory,iVar3,0,0);
        if (iVar3 == 0) goto LAB_00424f90;
        pvVar5 = _Memory;
        _Memory = (void *)0x0;
      }
      FID_conflict__free(_Memory);
      goto LAB_00424f9d;
    }
  }
  pvVar5 = (void *)0x0;
LAB_00424f9d:
  if (pwVar1 != (wchar_t *)0x0) {
    (*_DAT_1000c138)(pwVar1);
  }
  return pvVar5;
}



void FUN_00424fb1(void)

{
  __recalloc_base();
  return;
}



// Library Function - Single Match
//  __recalloc_base
// 
// Library: Visual Studio 2019 Release

int __recalloc_base(int param_1,uint param_2,uint param_3)

{
  undefined4 *puVar1;
  int iVar2;
  uint uVar3;
  
  if ((param_2 == 0) || (param_3 <= 0xffffffe0 / param_2)) {
    if (param_1 == 0) {
      uVar3 = 0;
    }
    else {
      uVar3 = FUN_00426a70(param_1);
    }
    param_2 = param_2 * param_3;
    iVar2 = __realloc_base(param_1,param_2);
    if ((iVar2 != 0) && (uVar3 < param_2)) {
      _memset((void *)(iVar2 + uVar3),0,param_2 - uVar3);
    }
  }
  else {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 0xc;
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl initialize_inherited_file_handles_nolock(void)
// 
// Library: Visual Studio 2017 Release

void __cdecl initialize_inherited_file_handles_nolock(void)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  undefined local_4c [50];
  short local_1a;
  uint *local_18;
  int *local_8;
  
  (*_DAT_1000c0ac)(local_4c);
  if ((local_1a != 0) && (local_18 != (uint *)0x0)) {
    uVar3 = *local_18;
    local_8 = (int *)((int)local_18 + uVar3 + 4);
    if (0x1fff < (int)uVar3) {
      uVar3 = 0x2000;
    }
    ___acrt_lowio_ensure_fh_exists(uVar3);
    if ((int)_DAT_10013198 < (int)uVar3) {
      uVar3 = _DAT_10013198;
    }
    uVar4 = 0;
    if (uVar3 != 0) {
      do {
        iVar2 = *local_8;
        if ((((iVar2 != -1) && (iVar2 != -2)) &&
            (bVar1 = *(byte *)(uVar4 + 4 + (int)local_18), (bVar1 & 1) != 0)) &&
           (((bVar1 & 8) != 0 || (iVar2 = (*_DAT_1000c04c)(iVar2), iVar2 != 0)))) {
          iVar2 = (uVar4 & 0x3f) * 0x30 + *(int *)(&DAT_10012f98 + ((int)uVar4 >> 6) * 4);
          *(int *)(iVar2 + 0x18) = *local_8;
          *(undefined *)(iVar2 + 0x28) = *(undefined *)(uVar4 + 4 + (int)local_18);
        }
        uVar4 = uVar4 + 1;
        local_8 = local_8 + 1;
      } while (uVar4 != uVar3);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_execute_initializers
// 
// Library: Visual Studio 2015 Release

void ___acrt_execute_initializers(code **param_1,code **param_2)

{
  code **ppcVar1;
  code *pcVar2;
  char cVar3;
  uint uVar4;
  code **ppcVar5;
  
  uVar4 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  ppcVar5 = param_1;
  if (param_1 != param_2) {
    do {
      pcVar2 = *ppcVar5;
      if (pcVar2 != (code *)0x0) {
        (*_DAT_1000c174)();
        cVar3 = (*pcVar2)();
        if (cVar3 == '\0') break;
      }
      ppcVar5 = ppcVar5 + 2;
    } while (ppcVar5 != param_2);
    if ((ppcVar5 != param_2) && (ppcVar5 != param_1)) {
      ppcVar5 = ppcVar5 + -1;
      do {
        if ((ppcVar5[-1] != (code *)0x0) && (pcVar2 = *ppcVar5, pcVar2 != (code *)0x0)) {
          (*_DAT_1000c174)(0);
          (*pcVar2)();
        }
        ppcVar1 = ppcVar5 + -1;
        ppcVar5 = ppcVar5 + -2;
      } while (ppcVar1 != param_1);
    }
  }
  ___security_check_cookie_4(uVar4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_004252b5(int param_1,int param_2)

{
  code *pcVar1;
  uint uVar2;
  
  uVar2 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  if (param_1 != param_2) {
    do {
      pcVar1 = *(code **)(param_2 + -4);
      if (pcVar1 != (code *)0x0) {
        (*_DAT_1000c174)(0);
        (*pcVar1)();
      }
      param_2 = param_2 + -8;
    } while (param_2 != param_1);
  }
  ___security_check_cookie_4(uVar2);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  public: void (__cdecl*__thiscall __crt_seh_guarded_call<void (__cdecl*)(int)>::operator()<class
// <lambda_cbab9ec6f41b0180b23cc171c22676b0>,class <lambda_44731a7d0e6d81c3e6aa82d741081786>&,class
// <lambda_4b292cb8dd18144e164572427af410ab>>(class
// <lambda_cbab9ec6f41b0180b23cc171c22676b0>&&,class
// <lambda_44731a7d0e6d81c3e6aa82d741081786>&,class
// <lambda_4b292cb8dd18144e164572427af410ab>&&))(int)
// 
// Library: Visual Studio 2017 Release

FuncDef282 * __thiscall
__crt_seh_guarded_call<void_(__cdecl*)(int)>::
operator___class__lambda_cbab9ec6f41b0180b23cc171c22676b0__class__lambda_44731a7d0e6d81c3e6aa82d741081786___class__lambda_4b292cb8dd18144e164572427af410ab___
          (__crt_seh_guarded_call_void____cdecl___int__ *this,
          _lambda_cbab9ec6f41b0180b23cc171c22676b0_ *param_1,
          _lambda_44731a7d0e6d81c3e6aa82d741081786_ *param_2,
          _lambda_4b292cb8dd18144e164572427af410ab_ *param_3)

{
  byte bVar1;
  uint uVar2;
  
  ___acrt_lock(*(undefined4 *)param_1);
  bVar1 = (byte)_DAT_10012000 & 0x1f;
  uVar2 = _DAT_10012000 ^ _DAT_100131a4;
  FUN_0042534b();
  return (FuncDef282 *)(uVar2 >> bVar1 | uVar2 << 0x20 - bVar1);
}



void FUN_0042534b(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  void (__cdecl** __cdecl get_global_action_nolock(int))(int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void____cdecl____int_ * __cdecl get_global_action_nolock(int param_1)

{
  if (param_1 == 2) {
    return (void____cdecl____int_ *)&DAT_1001319c;
  }
  if (param_1 != 6) {
    if (param_1 == 0xf) {
      return (void____cdecl____int_ *)&DAT_100131a8;
    }
    if (param_1 == 0x15) {
      return (void____cdecl____int_ *)&DAT_100131a0;
    }
    if (param_1 != 0x16) {
      return (void____cdecl____int_ *)0x0;
    }
  }
  return (void____cdecl____int_ *)&DAT_100131a4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  struct __crt_signal_action_t * __cdecl siglookup(int,struct __crt_signal_action_t * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

__crt_signal_action_t * __cdecl siglookup(int param_1,__crt_signal_action_t *param_2)

{
  __crt_signal_action_t *p_Var1;
  
  p_Var1 = param_2 + _DAT_1000cb80 * 0xc;
  if (param_2 != p_Var1) {
    do {
      if (*(int *)(param_2 + 4) == param_1) {
        return param_2;
      }
      param_2 = param_2 + 0xc;
    } while (param_2 != p_Var1);
  }
  return (__crt_signal_action_t *)0x0;
}



// Library Function - Single Match
//  ___acrt_get_sigabrt_handler
// 
// Library: Visual Studio 2017 Release

void ___acrt_get_sigabrt_handler(void)

{
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void____cdecl___int__ local_5;
  
  local_c = 3;
  local_10 = 3;
  __crt_seh_guarded_call<void_(__cdecl*)(int)>::
  operator___class__lambda_cbab9ec6f41b0180b23cc171c22676b0__class__lambda_44731a7d0e6d81c3e6aa82d741081786___class__lambda_4b292cb8dd18144e164572427af410ab___
            (&local_5,(_lambda_cbab9ec6f41b0180b23cc171c22676b0_ *)&local_10,
             (_lambda_44731a7d0e6d81c3e6aa82d741081786_ *)&local_5,
             (_lambda_4b292cb8dd18144e164572427af410ab_ *)&local_c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_004253ea(undefined4 param_1)

{
  _DAT_1001319c = param_1;
  _DAT_100131a0 = param_1;
  _DAT_100131a4 = param_1;
  _DAT_100131a8 = param_1;
  return;
}



int FUN_00425408(void)

{
  int iVar1;
  
  iVar1 = FUN_00423ea2();
  return iVar1 + 8;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00425411(int param_1)

{
  code **ppcVar1;
  undefined4 *puVar2;
  __crt_signal_action_t *p_Var3;
  int iVar4;
  char extraout_CL;
  byte bVar5;
  char cVar6;
  __crt_signal_action_t *p_Var7;
  code *pcVar8;
  __crt_signal_action_t **pp_Var9;
  undefined4 local_38;
  __crt_signal_action_t *local_34;
  char local_21;
  
  pp_Var9 = (__crt_signal_action_t **)0x0;
  local_38 = 0;
  local_21 = '\x01';
  if (8 < param_1) {
    if (param_1 == 0xb) goto LAB_0042546b;
    if ((param_1 == 0xf) || ((0x14 < param_1 && (param_1 < 0x17)))) goto LAB_00425460;
LAB_0042548f:
    puVar2 = (undefined4 *)FUN_00423633();
    *puVar2 = 0x16;
    FUN_00423576();
    goto LAB_00425601;
  }
  if (param_1 == 8) {
LAB_0042546b:
    pp_Var9 = (__crt_signal_action_t **)FUN_00423ff0();
    if (pp_Var9 == (__crt_signal_action_t **)0x0) goto LAB_00425601;
    p_Var3 = siglookup(param_1,*pp_Var9);
    if (p_Var3 == (__crt_signal_action_t *)0x0) goto LAB_0042548f;
    ppcVar1 = (code **)(p_Var3 + 8);
    cVar6 = '\0';
    local_21 = '\0';
  }
  else {
    if (param_1 != 2) {
      if (param_1 == 4) goto LAB_0042546b;
      if (param_1 != 6) goto LAB_0042548f;
    }
LAB_00425460:
    ppcVar1 = (code **)get_global_action_nolock(param_1);
    cVar6 = extraout_CL;
  }
  local_34 = (__crt_signal_action_t *)0x0;
  if (cVar6 != '\0') {
    ___acrt_lock(3);
    cVar6 = local_21;
  }
  if (cVar6 == '\0') {
    pcVar8 = *ppcVar1;
  }
  else {
    bVar5 = (byte)_DAT_10012000 & 0x1f;
    pcVar8 = (code *)((_DAT_10012000 ^ (uint)*ppcVar1) >> bVar5 |
                     (_DAT_10012000 ^ (uint)*ppcVar1) << 0x20 - bVar5);
    cVar6 = local_21;
  }
  if (pcVar8 != (code *)0x1) {
    if (pcVar8 == (code *)0x0) {
      if (cVar6 != '\0') {
        ___acrt_unlock(3);
      }
      __exit(3);
    }
    if (((param_1 == 8) || (param_1 == 0xb)) || (param_1 == 4)) {
      local_34 = pp_Var9[1];
      pp_Var9[1] = (__crt_signal_action_t *)0x0;
      if (param_1 == 8) {
        puVar2 = (undefined4 *)FUN_00425408();
        local_38 = *puVar2;
        puVar2 = (undefined4 *)FUN_00425408();
        *puVar2 = 0x8c;
        goto LAB_00425546;
      }
    }
    else {
LAB_00425546:
      if (param_1 == 8) {
        p_Var3 = *pp_Var9 + _DAT_1000cb84 * 0xc;
        p_Var7 = p_Var3 + _DAT_1000cb88 * 0xc;
        for (; p_Var3 != p_Var7; p_Var3 = p_Var3 + 0xc) {
          *(undefined4 *)(p_Var3 + 8) = 0;
        }
        goto LAB_00425588;
      }
    }
    bVar5 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
    *ppcVar1 = (code *)((0U >> bVar5 | 0 << 0x20 - bVar5) ^ _DAT_10012000);
  }
LAB_00425588:
  FUN_004255bf();
  if (pcVar8 != (code *)0x1) {
    if (param_1 == 8) {
      iVar4 = FUN_00423ea2();
      (*_DAT_1000c174)(8,*(undefined4 *)(iVar4 + 8));
      (*pcVar8)();
    }
    else {
      (*_DAT_1000c174)(param_1);
      (*pcVar8)();
      if ((param_1 != 0xb) && (param_1 != 4)) goto LAB_00425601;
    }
    pp_Var9[1] = local_34;
    if (param_1 == 8) {
      iVar4 = FUN_00423ea2();
      *(undefined4 *)(iVar4 + 8) = local_38;
    }
  }
LAB_00425601:
  FUN_00429d47();
  return;
}



void FUN_004255bf(void)

{
  int unaff_EBP;
  
  if (*(char *)(unaff_EBP + -0x1d) != '\0') {
    ___acrt_unlock(3);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_has_user_matherr
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

uint ___acrt_has_user_matherr(void)

{
  uint uVar1;
  byte bVar2;
  
  bVar2 = (byte)_DAT_10012000 & 0x1f;
  uVar1 = (_DAT_10012000 ^ _DAT_100131ac) >> bVar2 | (_DAT_10012000 ^ _DAT_100131ac) << 0x20 - bVar2
  ;
  return uVar1 & 0xffffff00 | (uint)(uVar1 != 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0042561f(undefined4 param_1)

{
  _DAT_100131ac = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_invoke_user_matherr
// 
// Library: Visual Studio 2015 Release

void ___acrt_invoke_user_matherr(undefined4 param_1)

{
  uint uVar1;
  byte bVar2;
  code *pcVar3;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  bVar2 = (byte)_DAT_10012000 & 0x1f;
  pcVar3 = (code *)((_DAT_10012000 ^ _DAT_100131ac) >> bVar2 |
                   (_DAT_10012000 ^ _DAT_100131ac) << 0x20 - bVar2);
  if (pcVar3 != (code *)0x0) {
    (*_DAT_1000c174)(param_1);
    (*pcVar3)();
  }
  ___security_check_cookie_4(uVar1);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_2866be3712abc81a800a822484c830d8>,class <lambda_39ca0ed439415581b5b15c265174cece>&,class
// <lambda_2b24c74d71094a6cd0cb82e44167d71b>>(class
// <lambda_2866be3712abc81a800a822484c830d8>&&,class
// <lambda_39ca0ed439415581b5b15c265174cece>&,class <lambda_2b24c74d71094a6cd0cb82e44167d71b>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_2866be3712abc81a800a822484c830d8__class__lambda_39ca0ed439415581b5b15c265174cece___class__lambda_2b24c74d71094a6cd0cb82e44167d71b___
          (__crt_seh_guarded_call_void_ *this,_lambda_2866be3712abc81a800a822484c830d8_ *param_1,
          _lambda_39ca0ed439415581b5b15c265174cece_ *param_2,
          _lambda_2b24c74d71094a6cd0cb82e44167d71b_ *param_3)

{
  char cVar1;
  int iVar2;
  
  __lock_file(*(FILE **)param_1);
  cVar1 = FUN_004257e9(**(undefined4 **)param_2,*(undefined4 *)(param_2 + 4));
  if ((cVar1 != '\0') &&
     ((**(char **)(param_2 + 8) != '\0' || ((*(uint *)(**(int **)param_2 + 0xc) >> 1 & 1) != 0)))) {
    iVar2 = __fflush_nolock(**(FILE ***)param_2);
    if (iVar2 == -1) {
      **(undefined4 **)(param_2 + 0xc) = 0xffffffff;
    }
    else {
      **(int **)(param_2 + 4) = **(int **)(param_2 + 4) + 1;
    }
  }
  FUN_004256ec();
  return;
}



void FUN_004256ec(void)

{
  int unaff_EBP;
  
  FUN_00425a19(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_2cc53f568c5a2bb6f192f930a45d44ea>,class <lambda_ab61a845afdef5b7c387490eaf3616ee>&,class
// <lambda_c2ffc0b7726aa6be21d5f0026187e748>>(class
// <lambda_2cc53f568c5a2bb6f192f930a45d44ea>&&,class
// <lambda_ab61a845afdef5b7c387490eaf3616ee>&,class <lambda_c2ffc0b7726aa6be21d5f0026187e748>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_2cc53f568c5a2bb6f192f930a45d44ea__class__lambda_ab61a845afdef5b7c387490eaf3616ee___class__lambda_c2ffc0b7726aa6be21d5f0026187e748___
          (__crt_seh_guarded_call_void_ *this,_lambda_2cc53f568c5a2bb6f192f930a45d44ea_ *param_1,
          _lambda_ab61a845afdef5b7c387490eaf3616ee_ *param_2,
          _lambda_c2ffc0b7726aa6be21d5f0026187e748_ *param_3)

{
  undefined4 *puVar1;
  char cVar2;
  undefined4 *puVar3;
  undefined4 *local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 *local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  __crt_seh_guarded_call_void_ local_1d [17];
  undefined4 uStack12;
  undefined4 local_8;
  
  local_8 = 0x10011400;
  uStack12 = 0x425704;
  ___acrt_lock(*(undefined4 *)param_1);
  local_8 = 0;
  puVar1 = _DAT_100131b8 + _DAT_100131b4;
  for (puVar3 = _DAT_100131b8; local_30 = puVar3, puVar3 != puVar1; puVar3 = puVar3 + 1) {
    local_24 = *puVar3;
    cVar2 = FUN_004257e9(local_24,*(undefined4 *)param_2);
    if (cVar2 != '\0') {
      local_34 = *(undefined4 *)(param_2 + 8);
      local_38 = *(undefined4 *)(param_2 + 4);
      local_3c = *(undefined4 *)param_2;
      local_40 = &local_24;
      local_28 = local_24;
      local_2c = local_24;
      operator___class__lambda_2866be3712abc81a800a822484c830d8__class__lambda_39ca0ed439415581b5b15c265174cece___class__lambda_2b24c74d71094a6cd0cb82e44167d71b___
                (local_1d,(_lambda_2866be3712abc81a800a822484c830d8_ *)&local_2c,
                 (_lambda_39ca0ed439415581b5b15c265174cece_ *)&local_40,
                 (_lambda_2b24c74d71094a6cd0cb82e44167d71b_ *)&local_28);
    }
  }
  local_8 = 0xfffffffe;
  FUN_0042578e();
  return;
}



void FUN_0042578e(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  int __cdecl common_flush_all(bool)
// 
// Library: Visual Studio 2017 Release

int __cdecl common_flush_all(bool param_1)

{
  int *local_24;
  bool *local_20;
  int *local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  int local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  local_c = 0;
  local_24 = &local_c;
  local_10 = 0;
  local_20 = &param_1;
  local_1c = &local_10;
  local_14 = 8;
  local_18 = 8;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_2cc53f568c5a2bb6f192f930a45d44ea__class__lambda_ab61a845afdef5b7c387490eaf3616ee___class__lambda_c2ffc0b7726aa6be21d5f0026187e748___
            (&local_5,(_lambda_2cc53f568c5a2bb6f192f930a45d44ea_ *)&local_18,
             (_lambda_ab61a845afdef5b7c387490eaf3616ee_ *)&local_24,
             (_lambda_c2ffc0b7726aa6be21d5f0026187e748_ *)&local_14);
  if (param_1 == false) {
    local_c = local_10;
  }
  return local_c;
}



undefined4 FUN_004257e9(int param_1,int *param_2)

{
  char cVar1;
  
  if (param_1 != 0) {
    if ((*(uint *)(param_1 + 0xc) >> 0xd & 1) != 0) {
      cVar1 = FUN_0042581b(*(uint *)(param_1 + 0xc));
      if (cVar1 != '\0') {
        return 1;
      }
      *param_2 = *param_2 + 1;
    }
  }
  return 0;
}



uint FUN_0042581b(uint param_1)

{
  if ((((byte)param_1 & 3) == 2) && ((param_1 & 0xc0) != 0)) {
    return param_1 & 0xffffff00 | 1;
  }
  return param_1 & 0xffffff00 | (uint)((byte)(param_1 >> 0xb) & 1);
}



// Library Function - Single Match
//  ___acrt_stdio_flush_nolock
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_stdio_flush_nolock(FILE *param_1)

{
  int *piVar1;
  int _FileHandle;
  uint uVar2;
  uint uVar3;
  char *_Buf;
  
  piVar1 = &param_1->_flag;
  if ((((byte)*piVar1 & 3) == 2) && ((*piVar1 & 0xc0U) != 0)) {
    _Buf = (char *)param_1->_cnt;
    uVar3 = (int)param_1->_ptr - (int)_Buf;
    param_1->_ptr = _Buf;
    param_1->_base = (char *)0x0;
    if (0 < (int)uVar3) {
      uVar2 = uVar3;
      _FileHandle = __fileno(param_1);
      uVar2 = __write(_FileHandle,_Buf,uVar2);
      if (uVar3 != uVar2) {
        LOCK();
        *piVar1 = *piVar1 | 0x10;
        return 0xffffffff;
      }
      if (((uint)*piVar1 >> 2 & 1) != 0) {
        LOCK();
        *piVar1 = *piVar1 & 0xfffffffd;
      }
    }
  }
  return 0;
}



// Library Function - Single Match
//  __fflush_nolock
// 
// Library: Visual Studio 2015 Release

int __cdecl __fflush_nolock(FILE *_File)

{
  int iVar1;
  
  if (_File == (FILE *)0x0) {
    iVar1 = common_flush_all(false);
    return iVar1;
  }
  iVar1 = ___acrt_stdio_flush_nolock(_File);
  if (iVar1 == 0) {
    if (((uint)_File->_flag >> 0xb & 1) != 0) {
      iVar1 = __fileno(_File);
      iVar1 = __commit(iVar1);
      if (iVar1 != 0) goto LAB_004258c2;
    }
    iVar1 = 0;
  }
  else {
LAB_004258c2:
    iVar1 = -1;
  }
  return iVar1;
}



// Library Function - Single Match
//  __flushall
// 
// Library: Visual Studio 2017 Release

int __cdecl __flushall(void)

{
  int iVar1;
  
  iVar1 = common_flush_all(true);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __lock_file
// 
// Library: Visual Studio 2017 Release

void __cdecl __lock_file(FILE *_File)

{
  (*_DAT_1000c0c8)(_File + 1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00425a19(int param_1)

{
  (*_DAT_1000c0cc)(param_1 + 0x20);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00425a2d(void)

{
  return _DAT_100131c4;
}



undefined4 FUN_00425a33(ushort *param_1,byte *param_2,uint param_3,undefined4 param_4)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  int local_14;
  localeinfo_struct local_10;
  char local_8;
  
  if ((param_2 == (byte *)0x0) || (param_3 == 0)) {
    return 0;
  }
  if (*param_2 == 0) {
    if (param_1 == (ushort *)0x0) {
      return 0;
    }
    *param_1 = 0;
    return 0;
  }
  FUN_004231ce(param_4);
  if ((local_10.locinfo)->locale_name[2] == (wchar_t *)0x0) {
    if (param_1 != (ushort *)0x0) {
      *param_1 = (ushort)*param_2;
    }
    uVar3 = 1;
    goto LAB_00425b19;
  }
  iVar1 = __isleadbyte_l((uint)*param_2,&local_10);
  if (iVar1 == 0) {
    uVar3 = 1;
    iVar1 = FUN_004278ba((local_10.locinfo)->lc_collate_cp,9,param_2,1,param_1,
                         param_1 != (ushort *)0x0);
    if (iVar1 != 0) goto LAB_00425b19;
LAB_00425b0b:
    puVar2 = (undefined4 *)FUN_00423633();
    uVar3 = 0xffffffff;
    *puVar2 = 0x2a;
  }
  else {
    if ((int)(local_10.locinfo)->lc_codepage < 2) {
LAB_00425ad6:
      uVar3 = (local_10.locinfo)->lc_codepage;
LAB_00425ad9:
      if ((param_3 < uVar3) || (param_2[1] == 0)) goto LAB_00425b0b;
    }
    else {
      uVar3 = (local_10.locinfo)->lc_codepage;
      if ((int)param_3 < (int)(local_10.locinfo)->lc_codepage) goto LAB_00425ad9;
      iVar1 = FUN_004278ba((local_10.locinfo)->lc_collate_cp,9,param_2,
                           (local_10.locinfo)->lc_codepage,param_1,param_1 != (ushort *)0x0);
      if (iVar1 == 0) goto LAB_00425ad6;
    }
    uVar3 = (local_10.locinfo)->lc_codepage;
  }
LAB_00425b19:
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
    return uVar3;
  }
  return uVar3;
}



void FUN_00425b31(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_00425a33(param_1,param_2,param_3,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_update_locale_info
// 
// Library: Visual Studio 2015 Release

void ___acrt_update_locale_info(int param_1,int *param_2)

{
  int iVar1;
  
  if ((*param_2 != _DAT_100131b0) && ((*(uint *)(param_1 + 0x350) & _DAT_100126e0) == 0)) {
    iVar1 = ___acrt_update_thread_locale_data();
    *param_2 = iVar1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_update_multibyte_info
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_update_multibyte_info(int param_1,int *param_2)

{
  int iVar1;
  
  if ((*param_2 != _DAT_10012f6c) && ((*(uint *)(param_1 + 0x350) & _DAT_100126e0) == 0)) {
    iVar1 = ___acrt_update_thread_multibyte_data();
    *param_2 = iVar1;
  }
  return;
}



// Library Function - Single Match
//  __fileno
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __fileno(FILE *_File)

{
  undefined4 *puVar1;
  
  if (_File == (FILE *)0x0) {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 0x16;
    FUN_00423576();
    return -1;
  }
  return _File->_file;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_e5124f882df8998aaf41531e079ba474>,class <lambda_3e16ef9562a7dcce91392c22ab16ea36>&,class
// <lambda_e25ca0880e6ef98be67edffd8c599615>>(class
// <lambda_e5124f882df8998aaf41531e079ba474>&&,class
// <lambda_3e16ef9562a7dcce91392c22ab16ea36>&,class <lambda_e25ca0880e6ef98be67edffd8c599615>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_e5124f882df8998aaf41531e079ba474__class__lambda_3e16ef9562a7dcce91392c22ab16ea36___class__lambda_e25ca0880e6ef98be67edffd8c599615___
          (__crt_seh_guarded_call_void_ *this,_lambda_e5124f882df8998aaf41531e079ba474_ *param_1,
          _lambda_3e16ef9562a7dcce91392c22ab16ea36_ *param_2,
          _lambda_e25ca0880e6ef98be67edffd8c599615_ *param_3)

{
  int iVar1;
  int *piVar2;
  
  ___acrt_lock(*(undefined4 *)param_1);
  for (piVar2 = (int *)&DAT_100131b0; piVar2 != (int *)&DAT_100131b4; piVar2 = piVar2 + 1) {
    if (*piVar2 != 0x10012570) {
      iVar1 = __updatetlocinfoEx_nolock(piVar2,0x10012570);
      *piVar2 = iVar1;
    }
  }
  FUN_00425c23();
  return;
}



void FUN_00425c23(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_set_locale_changed
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_set_locale_changed(void)

{
  undefined4 uVar1;
  
  uVar1 = _DAT_100131c8;
  _DAT_100131c8 = 1;
  return uVar1;
}



// Library Function - Single Match
//  ___acrt_uninitialize_locale
// 
// Library: Visual Studio 2017 Release

void ___acrt_uninitialize_locale(void)

{
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  local_c = 4;
  local_10 = 4;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_e5124f882df8998aaf41531e079ba474__class__lambda_3e16ef9562a7dcce91392c22ab16ea36___class__lambda_e25ca0880e6ef98be67edffd8c599615___
            (&local_5,(_lambda_e5124f882df8998aaf41531e079ba474_ *)&local_10,
             (_lambda_3e16ef9562a7dcce91392c22ab16ea36_ *)&local_5,
             (_lambda_e25ca0880e6ef98be67edffd8c599615_ *)&local_c);
  return;
}



// Library Function - Single Match
//  ___pctype_func
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

ushort * __cdecl ___pctype_func(void)

{
  int iVar1;
  ushort **local_8;
  
  iVar1 = FUN_00423ea2();
  local_8 = *(ushort ***)(iVar1 + 0x4c);
  ___acrt_update_locale_info(iVar1,&local_8);
  return *local_8;
}



// Library Function - Single Match
//  int __cdecl GetTableIndexFromLocaleName(wchar_t const *)
// 
// Library: Visual Studio 2017 Release

int __cdecl GetTableIndexFromLocaleName(wchar_t *param_1)

{
  ushort uVar1;
  int iVar2;
  int iVar3;
  ushort uVar4;
  ushort *puVar5;
  int local_10;
  int local_c;
  int local_8;
  
  local_c = 0;
  local_10 = 0xe3;
  while( true ) {
    local_8 = 0x55;
    iVar2 = (local_10 + local_c) / 2;
    puVar5 = *(ushort **)(iVar2 * 8 + 0x1000eed8);
    iVar3 = (int)param_1 - (int)puVar5;
    do {
      uVar4 = *(ushort *)(iVar3 + (int)puVar5);
      if ((ushort)(uVar4 - 0x41) < 0x1a) {
        uVar4 = uVar4 + 0x20;
      }
      uVar1 = *puVar5;
      if ((ushort)(uVar1 - 0x41) < 0x1a) {
        uVar1 = uVar1 + 0x20;
      }
      puVar5 = puVar5 + 1;
      local_8 = local_8 + -1;
    } while (((local_8 != 0) && (uVar4 != 0)) && (uVar4 == uVar1));
    if ((uint)uVar4 == (uint)uVar1) break;
    if ((int)((uint)uVar4 - (uint)uVar1) < 0) {
      local_10 = iVar2 + -1;
    }
    else {
      local_c = iVar2 + 1;
    }
    if (local_10 < local_c) {
      return -1;
    }
  }
  return *(int *)(iVar2 * 8 + 0x1000eedc);
}



// Library Function - Single Match
//  ___acrt_DownlevelLocaleNameToLCID
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_DownlevelLocaleNameToLCID(wchar_t *param_1)

{
  uint uVar1;
  
  if (param_1 != (wchar_t *)0x0) {
    uVar1 = GetTableIndexFromLocaleName(param_1);
    if ((-1 < (int)uVar1) && (uVar1 < 0xe4)) {
      return *(undefined4 *)(uVar1 * 8 + 0x1000ddb0);
    }
  }
  return 0;
}



// Library Function - Single Match
//  ___acrt_add_locale_ref
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_add_locale_ref(int param_1)

{
  int *piVar1;
  int **ppiVar2;
  int iVar3;
  
  LOCK();
  *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + 1;
  piVar1 = *(int **)(param_1 + 0x7c);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x84);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x80);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x8c);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  ppiVar2 = (int **)(param_1 + 0x28);
  iVar3 = 6;
  do {
    if ((ppiVar2[-2] != (int *)0x10012630) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    ppiVar2 = ppiVar2 + 4;
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  ___acrt_locale_add_lc_time_reference(*(undefined4 *)(param_1 + 0x9c));
  return;
}



// Library Function - Single Match
//  ___acrt_free_locale
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_free_locale(void *param_1)

{
  int *piVar1;
  void **ppvVar2;
  int **ppiVar3;
  int local_8;
  
  if ((((*(undefined **)((int)param_1 + 0x88) != (undefined *)0x0) &&
       (*(undefined **)((int)param_1 + 0x88) != &DAT_100126f0)) &&
      (*(int **)((int)param_1 + 0x7c) != (int *)0x0)) && (**(int **)((int)param_1 + 0x7c) == 0)) {
    piVar1 = *(int **)((int)param_1 + 0x84);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      ___acrt_locale_free_monetary(*(undefined4 *)((int)param_1 + 0x88));
    }
    piVar1 = *(int **)((int)param_1 + 0x80);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      ___acrt_locale_free_numeric(*(undefined4 *)((int)param_1 + 0x88));
    }
    FID_conflict__free(*(void **)((int)param_1 + 0x7c));
    FID_conflict__free(*(void **)((int)param_1 + 0x88));
  }
  if ((*(int **)((int)param_1 + 0x8c) != (int *)0x0) && (**(int **)((int)param_1 + 0x8c) == 0)) {
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x90) + -0xfe));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x94) + -0x80));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x98) + -0x80));
    FID_conflict__free(*(void **)((int)param_1 + 0x8c));
  }
  ___acrt_locale_free_lc_time_if_unreferenced(*(undefined4 *)((int)param_1 + 0x9c));
  ppvVar2 = (void **)((int)param_1 + 0xa0);
  local_8 = 6;
  ppiVar3 = (int **)((int)param_1 + 0x28);
  do {
    if (((ppiVar3[-2] != (int *)0x10012630) && (piVar1 = *ppiVar3, piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      FID_conflict__free(*ppvVar2);
    }
    if (((ppiVar3[-3] != (int *)0x0) && (piVar1 = ppiVar3[-1], piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
    }
    ppvVar2 = ppvVar2 + 1;
    ppiVar3 = ppiVar3 + 4;
    local_8 = local_8 + -1;
  } while (local_8 != 0);
  FID_conflict__free(param_1);
  return;
}



// Library Function - Single Match
//  ___acrt_locale_add_lc_time_reference
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int ___acrt_locale_add_lc_time_reference(int param_1)

{
  int *piVar1;
  int iVar2;
  
  if ((param_1 != 0) && (param_1 != 0x1000d648)) {
    LOCK();
    piVar1 = (int *)(param_1 + 0xb0);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + 1;
    return iVar2 + 1;
  }
  return 0x7fffffff;
}



// Library Function - Single Match
//  ___acrt_locale_free_lc_time_if_unreferenced
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_locale_free_lc_time_if_unreferenced(void *param_1)

{
  if (((param_1 != (void *)0x0) && (param_1 != (void *)0x1000d648)) &&
     (*(int *)((int)param_1 + 0xb0) == 0)) {
    ___acrt_locale_free_time(param_1);
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_release_lc_time_reference
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int ___acrt_locale_release_lc_time_reference(int param_1)

{
  int *piVar1;
  int iVar2;
  
  if ((param_1 != 0) && (param_1 != 0x1000d648)) {
    LOCK();
    piVar1 = (int *)(param_1 + 0xb0);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + -1;
    return iVar2 + -1;
  }
  return 0x7fffffff;
}



// Library Function - Single Match
//  ___acrt_release_locale_ref
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_release_locale_ref(int param_1)

{
  int *piVar1;
  int **ppiVar2;
  int iVar3;
  
  if (param_1 != 0) {
    LOCK();
    *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + -1;
    piVar1 = *(int **)(param_1 + 0x7c);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x84);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x80);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x8c);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    ppiVar2 = (int **)(param_1 + 0x28);
    iVar3 = 6;
    do {
      if ((ppiVar2[-2] != (int *)0x10012630) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      ppiVar2 = ppiVar2 + 4;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    ___acrt_locale_release_lc_time_reference(*(undefined4 *)(param_1 + 0x9c));
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_update_thread_locale_data
// 
// Library: Visual Studio 2015 Release

int ___acrt_update_thread_locale_data(void)

{
  int iVar1;
  int iVar2;
  
  iVar1 = FUN_00423ea2();
  if (((*(uint *)(iVar1 + 0x350) & _DAT_100126e0) == 0) ||
     (iVar2 = *(int *)(iVar1 + 0x4c), iVar2 == 0)) {
    ___acrt_lock(4);
    iVar2 = __updatetlocinfoEx_nolock(iVar1 + 0x4c,_DAT_100131b0);
    FUN_00426099();
    if (iVar2 == 0) {
      _abort();
      iVar1 = ___acrt_unlock(4);
      return iVar1;
    }
  }
  return iVar2;
}



void FUN_00426099(void)

{
  ___acrt_unlock(4);
  return;
}



// Library Function - Single Match
//  __updatetlocinfoEx_nolock
// 
// Library: Visual Studio 2015 Release

int __updatetlocinfoEx_nolock(int *param_1,int param_2)

{
  int iVar1;
  
  if ((param_2 == 0) || (param_1 == (int *)0x0)) {
    param_2 = 0;
  }
  else {
    iVar1 = *param_1;
    if (iVar1 != param_2) {
      *param_1 = param_2;
      ___acrt_add_locale_ref(param_2);
      if (((iVar1 != 0) && (___acrt_release_locale_ref(iVar1), *(int *)(iVar1 + 0xc) == 0)) &&
         (iVar1 != 0x10012570)) {
        ___acrt_free_locale(iVar1);
      }
    }
  }
  return param_2;
}



// Library Function - Multiple Matches With Different Base Names
//  void __cdecl swap(char *,char *,unsigned int)
//  _swap
//  _swap_c
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict__swap(undefined *param_1,undefined *param_2,int param_3)

{
  undefined *puVar1;
  undefined uVar2;
  undefined *puVar3;
  
  if ((param_1 != param_2) && (puVar3 = param_2, param_3 != 0)) {
    do {
      puVar1 = puVar3 + 1;
      uVar2 = puVar1[(int)(param_1 + (-1 - (int)param_2))];
      puVar1[(int)(param_1 + (-1 - (int)param_2))] = *puVar3;
      *puVar3 = uVar2;
      param_3 = param_3 + -1;
      puVar3 = puVar1;
    } while (param_3 != 0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0042613e(undefined *param_1,uint param_2,uint param_3,code *param_4)

{
  undefined *puVar1;
  undefined uVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined *puVar5;
  undefined *puVar6;
  uint uVar7;
  undefined *puVar8;
  undefined *puVar9;
  undefined *local_114;
  int local_110;
  undefined *local_108;
  undefined *local_fc;
  undefined4 auStack248 [30];
  undefined4 auStack128 [30];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_108 = param_1;
  if ((((param_1 == (undefined *)0x0) && (param_2 != 0)) || (param_3 == 0)) ||
     (param_4 == (code *)0x0)) {
    puVar3 = (undefined4 *)FUN_00423633();
    *puVar3 = 0x16;
    FUN_00423576();
  }
  else {
    local_110 = 0;
    if (1 < param_2) {
      puVar5 = param_1 + (param_2 - 1) * param_3;
LAB_004261c0:
      while (uVar7 = (uint)((int)puVar5 - (int)local_108) / param_3 + 1, 8 < uVar7) {
        puVar9 = local_108 + (uVar7 >> 1) * param_3;
        (*_DAT_1000c174)(local_108,puVar9);
        iVar4 = (*param_4)();
        if (0 < iVar4) {
          FID_conflict__swap(local_108,puVar9,param_3);
        }
        (*_DAT_1000c174)(local_108,puVar5);
        iVar4 = (*param_4)();
        if (0 < iVar4) {
          FID_conflict__swap(local_108,puVar5,param_3);
        }
        (*_DAT_1000c174)(puVar9,puVar5);
        iVar4 = (*param_4)();
        local_114 = local_108;
        local_fc = puVar5;
        if (0 < iVar4) {
          FID_conflict__swap(puVar9,puVar5,param_3);
        }
LAB_0042635e:
        if (local_114 < puVar9) {
          do {
            local_114 = local_114 + param_3;
            if (puVar9 <= local_114) goto LAB_0042639f;
            (*_DAT_1000c174)(local_114,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 < 1);
          puVar8 = local_fc;
          if (puVar9 <= local_114) goto LAB_0042639f;
        }
        else {
LAB_0042639f:
          do {
            local_114 = local_114 + param_3;
            puVar8 = local_fc;
            if (puVar5 < local_114) break;
            (*_DAT_1000c174)(local_114,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 < 1);
        }
        do {
          local_fc = puVar8;
          puVar8 = local_fc + -param_3;
          if (puVar8 <= puVar9) break;
          (*_DAT_1000c174)(puVar8,puVar9);
          iVar4 = (*param_4)();
        } while (0 < iVar4);
        if (local_114 <= puVar8) {
          puVar6 = puVar8;
          uVar7 = param_3;
          if (local_114 != puVar8) {
            do {
              puVar1 = puVar6 + 1;
              uVar2 = puVar1[(int)(local_114 + (-1 - (int)puVar8))];
              puVar1[(int)(local_114 + (-1 - (int)puVar8))] = *puVar6;
              *puVar6 = uVar2;
              uVar7 = uVar7 - 1;
              puVar6 = puVar1;
            } while (uVar7 != 0);
          }
          local_fc = puVar8;
          if (puVar9 == puVar8) {
            puVar9 = local_114;
          }
          goto LAB_0042635e;
        }
        if (puVar9 < local_fc) {
          do {
            local_fc = local_fc + -param_3;
            if (local_fc <= puVar9) goto LAB_004264bf;
            (*_DAT_1000c174)(local_fc,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 == 0);
          if (local_fc <= puVar9) goto LAB_004264bf;
        }
        else {
LAB_004264bf:
          do {
            local_fc = local_fc + -param_3;
            if (local_fc <= local_108) break;
            (*_DAT_1000c174)(local_fc,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 == 0);
        }
        if ((int)local_fc - (int)local_108 < (int)puVar5 - (int)local_114) goto LAB_00426545;
        if (local_108 < local_fc) {
          auStack128[local_110] = local_108;
          auStack248[local_110] = local_fc;
          local_110 = local_110 + 1;
        }
        local_108 = local_114;
        if (puVar5 <= local_114) goto LAB_00426283;
      }
      for (; puVar8 = local_108, puVar9 = local_108, local_108 < puVar5; puVar5 = puVar5 + -param_3)
      {
        while (puVar9 = puVar9 + param_3, puVar9 <= puVar5) {
          (*_DAT_1000c174)(puVar9,puVar8);
          iVar4 = (*param_4)();
          if (0 < iVar4) {
            puVar8 = puVar9;
          }
        }
        if (puVar8 != puVar5) {
          puVar9 = puVar5;
          uVar7 = param_3;
          do {
            uVar2 = puVar9[(int)puVar8 - (int)puVar5];
            (puVar9 + 1)[((int)puVar8 - (int)puVar5) + -1] = *puVar9;
            *puVar9 = uVar2;
            uVar7 = uVar7 - 1;
            puVar9 = puVar9 + 1;
          } while (uVar7 != 0);
        }
      }
      goto LAB_00426283;
    }
  }
LAB_0042618c:
  ___security_check_cookie_4();
  return;
LAB_00426545:
  if (local_114 < puVar5) {
    auStack128[local_110] = local_114;
    auStack248[local_110] = puVar5;
    local_110 = local_110 + 1;
  }
  puVar5 = local_fc;
  if (local_fc <= local_108) {
LAB_00426283:
    local_110 = local_110 + -1;
    if (-1 < local_110) {
      local_108 = (undefined *)auStack128[local_110];
      puVar5 = (undefined *)auStack248[local_110];
      goto LAB_004261c0;
    }
    goto LAB_0042618c;
  }
  goto LAB_004261c0;
}



undefined4 FUN_00426582(char *param_1,int param_2,int param_3,int param_4)

{
  char cVar1;
  undefined4 *puVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  undefined4 uVar6;
  
  if (param_4 == 0) {
    if (param_1 == (char *)0x0) {
      if (param_2 == 0) {
        return 0;
      }
    }
    else {
LAB_004265a4:
      if (param_2 != 0) {
        if (param_4 == 0) {
          *param_1 = '\0';
          return 0;
        }
        if (param_3 != 0) {
          iVar3 = param_4;
          iVar4 = param_2;
          pcVar5 = param_1;
          if (param_4 == -1) {
            do {
              cVar1 = pcVar5[param_3 - (int)param_1];
              *pcVar5 = cVar1;
              pcVar5 = pcVar5 + 1;
              if (cVar1 == '\0') break;
              iVar4 = iVar4 + -1;
            } while (iVar4 != 0);
          }
          else {
            do {
              cVar1 = pcVar5[param_3 - (int)param_1];
              *pcVar5 = cVar1;
              pcVar5 = pcVar5 + 1;
              if ((cVar1 == '\0') || (iVar4 = iVar4 + -1, iVar4 == 0)) break;
              iVar3 = iVar3 + -1;
            } while (iVar3 != 0);
            if (iVar3 == 0) {
              *pcVar5 = '\0';
            }
          }
          if (iVar4 != 0) {
            return 0;
          }
          if (param_4 == -1) {
            param_1[param_2 + -1] = '\0';
            return 0x50;
          }
          *param_1 = '\0';
          puVar2 = (undefined4 *)FUN_00423633();
          uVar6 = 0x22;
          goto LAB_004265c4;
        }
        *param_1 = '\0';
      }
    }
  }
  else if (param_1 != (char *)0x0) goto LAB_004265a4;
  puVar2 = (undefined4 *)FUN_00423633();
  uVar6 = 0x16;
LAB_004265c4:
  *puVar2 = uVar6;
  FUN_00423576();
  return uVar6;
}



void FUN_00426633(void)

{
  FUN_00426582();
  return;
}



// Library Function - Single Match
//  _strpbrk
// 
// Library: Visual Studio

char * __cdecl _strpbrk(char *_Str,char *_Control)

{
  byte bVar1;
  char *pcVar2;
  byte *pbVar3;
  undefined4 uStack40;
  undefined4 uStack36;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  
  uStack12 = 0;
  uStack16 = 0;
  uStack20 = 0;
  uStack24 = 0;
  uStack28 = 0;
  uStack32 = 0;
  uStack36 = 0;
  uStack40 = 0;
  for (; bVar1 = *_Control, bVar1 != 0; _Control = (char *)((byte *)_Control + 1)) {
    pbVar3 = (byte *)((int)&uStack40 + ((int)(uint)bVar1 >> 3));
    *pbVar3 = *pbVar3 | '\x01' << (bVar1 & 7);
  }
  do {
    pbVar3 = (byte *)_Str;
    pcVar2 = (char *)(uint)*pbVar3;
    if (*pbVar3 == 0) {
      return pcVar2;
    }
    _Str = (char *)(pbVar3 + 1);
  } while ((*(byte *)((int)&uStack40 + ((int)pcVar2 >> 3)) >> ((uint)pcVar2 & 7) & 1) == 0);
  return (char *)pbVar3;
}



void FUN_0042667e(undefined4 param_1,undefined4 param_2)

{
  FUN_00426695(param_1,param_2,0);
  return;
}



byte * FUN_00426695(byte *param_1,byte *param_2,undefined4 param_3)

{
  undefined4 *puVar1;
  byte *pbVar2;
  int local_14;
  int local_c;
  char local_8;
  
  if ((param_1 == (byte *)0x0) || (param_2 == (byte *)0x0)) {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 0x16;
    FUN_00423576();
  }
  else if (param_1 < param_2) {
    FUN_004231ce(param_3);
    if (*(int *)(local_c + 8) != 0) {
      pbVar2 = param_2 + -1;
      do {
        pbVar2 = pbVar2 + -1;
        if (pbVar2 < param_1) break;
      } while ((*(byte *)(*pbVar2 + 0x19 + local_c) & 4) != 0);
      param_2 = param_2 + -((int)param_2 - (int)pbVar2 & 1U);
    }
    if (local_8 == '\0') {
      return param_2 + -1;
    }
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
    return param_2 + -1;
  }
  return (byte *)0x0;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0042671b(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,int param_6,int param_7)

{
  uint _Size;
  int iVar1;
  uint uVar2;
  int *_Dst;
  int iStack68;
  int iStack64;
  undefined4 uStack60;
  undefined4 uStack56;
  undefined4 uStack52;
  undefined4 uStack48;
  int local_20;
  int local_1c;
  char local_14;
  
  uStack48 = param_1;
  uStack52 = 0x42673b;
  FUN_004231ce();
  if (param_6 == 0) {
    param_6 = *(int *)(local_1c + 8);
  }
  uStack48 = 0;
  uStack52 = 0;
  uStack56 = param_4;
  uStack60 = param_3;
  iStack64 = (uint)(param_7 != 0) * 8 + 1;
  iStack68 = param_6;
  iVar1 = (*_DAT_1000c0fc)();
  if (iVar1 == 0) goto LAB_004267f9;
  _Size = iVar1 * 2;
  uVar2 = -(uint)(_Size < _Size + 8) & _Size + 8;
  if (uVar2 == 0) {
    _Dst = (undefined4 *)0x0;
  }
  else if (uVar2 < 0x401) {
    _Dst = &iStack68;
    if (&stack0x00000000 != (undefined *)0x44) {
      iStack68 = 0xcccc;
      _Dst = &iStack68;
LAB_004267b2:
      _Dst = _Dst + 2;
    }
  }
  else {
    _Dst = (int *)__malloc_base(uVar2);
    if (_Dst != (undefined4 *)0x0) {
      *_Dst = 0xdddd;
      goto LAB_004267b2;
    }
  }
  if (_Dst != (undefined4 *)0x0) {
    _memset(_Dst,0,_Size);
    iVar1 = (*_DAT_1000c0fc)(param_6,1,param_3,param_4,_Dst,iVar1);
    if (iVar1 != 0) {
      (*_DAT_1000c048)(param_2,_Dst,iVar1,param_5);
    }
  }
  FUN_0042681f(_Dst);
LAB_004267f9:
  if (local_14 != '\0') {
    *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
  }
  ___security_check_cookie_4();
  return;
}



void FUN_0042681f(int param_1)

{
  if ((param_1 != 0) && (*(int *)(param_1 + -8) == 0xdddd)) {
    FID_conflict__free((int *)(param_1 + -8));
  }
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0042683f(int *param_1,undefined4 param_2,uint param_3,undefined4 param_4,int param_5,
                 undefined4 param_6,int param_7,int param_8,int param_9)

{
  int iVar1;
  uint uVar2;
  int *piVar3;
  int iVar4;
  int *piVar5;
  int iStack48;
  int iStack44;
  undefined4 uStack40;
  int iStack36;
  undefined4 uStack32;
  int iStack28;
  
  iVar4 = param_5;
  if (0 < param_5) {
    iStack28 = param_5;
    uStack32 = param_4;
    iStack36 = 0x426863;
    iVar1 = ___strncnt();
    iVar4 = iVar1 + 1;
    if (param_5 <= iVar1) {
      iVar4 = iVar1;
    }
  }
  if (param_8 == 0) {
    param_8 = *(int *)(*param_1 + 8);
  }
  iStack28 = 0;
  uStack32 = 0;
  uStack40 = param_4;
  iStack44 = (uint)(param_9 != 0) * 8 + 1;
  iStack48 = param_8;
  iStack36 = iVar4;
  iVar1 = (*_DAT_1000c0fc)();
  if (iVar1 == 0) goto LAB_00426a00;
  uVar2 = iVar1 * 2 + 8;
  uVar2 = -(uint)((uint)(iVar1 * 2) < uVar2) & uVar2;
  if (uVar2 == 0) {
    piVar3 = (undefined4 *)0x0;
  }
  else if (uVar2 < 0x401) {
    piVar3 = &iStack48;
    if (&stack0x00000000 != (undefined *)0x30) {
      iStack48 = 0xcccc;
      piVar3 = &iStack48;
LAB_004268e7:
      piVar3 = piVar3 + 2;
    }
  }
  else {
    piVar3 = (int *)__malloc_base(uVar2);
    if (piVar3 != (undefined4 *)0x0) {
      *piVar3 = 0xdddd;
      goto LAB_004268e7;
    }
  }
  if (((piVar3 != (undefined4 *)0x0) &&
      (iVar4 = (*_DAT_1000c0fc)(param_8,1,param_4,iVar4,piVar3,iVar1), iVar4 != 0)) &&
     (iVar4 = ___acrt_CompareStringEx_36(param_2,param_3,piVar3,iVar1,0,0,0,0,0), iVar4 != 0)) {
    if ((param_3 & 0x400) == 0) {
      uVar2 = iVar4 * 2 + 8;
      uVar2 = -(uint)((uint)(iVar4 * 2) < uVar2) & uVar2;
      if (uVar2 == 0) {
        piVar5 = (undefined4 *)0x0;
LAB_004269b2:
        if ((piVar5 != (undefined4 *)0x0) &&
           (iVar1 = ___acrt_CompareStringEx_36(param_2,param_3,piVar3,iVar1,piVar5,iVar4,0,0,0),
           iVar1 != 0)) {
          if (param_7 == 0) {
            param_7 = 0;
            param_6 = 0;
          }
          iVar4 = (*_DAT_1000c100)(param_8,0,piVar5,iVar4,param_6,param_7,0,0);
          if (iVar4 != 0) {
            FUN_0042681f(piVar5);
            goto LAB_004269f7;
          }
        }
      }
      else if (uVar2 < 0x401) {
        piVar5 = &iStack48;
        if (&stack0x00000000 != (undefined *)0x30) {
          iStack48 = 0xcccc;
          piVar5 = &iStack48;
LAB_004269ab:
          piVar5 = piVar5 + 2;
          goto LAB_004269b2;
        }
      }
      else {
        piVar5 = (int *)__malloc_base(uVar2);
        if (piVar5 != (undefined4 *)0x0) {
          *piVar5 = 0xdddd;
          goto LAB_004269ab;
        }
      }
      FUN_0042681f(piVar5);
    }
    else if ((param_7 != 0) && (iVar4 <= param_7)) {
      ___acrt_CompareStringEx_36(param_2,param_3,piVar3,iVar1,param_6,param_7,0,0,0);
    }
  }
LAB_004269f7:
  FUN_0042681f(piVar3);
LAB_00426a00:
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_LCMapStringA
// 
// Library: Visual Studio 2015 Release

void ___acrt_LCMapStringA
               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
               undefined4 param_9)

{
  int local_14;
  undefined local_10 [8];
  char local_8;
  
  FUN_004231ce(param_1);
  FUN_0042683f(local_10,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return;
}



void FUN_00426a70(void)

{
  __msize_base();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __msize_base
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 __msize_base(int param_1)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  
  if (param_1 == 0) {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 0x16;
    FUN_00423576();
    return 0xffffffff;
  }
  uVar2 = (*_DAT_1000c044)(_DAT_10012f90,0,param_1);
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __realloc_base
// 
// Library: Visual Studio 2015 Release

int __realloc_base(void *param_1,uint param_2)

{
  int iVar1;
  undefined4 *puVar2;
  
  if (param_1 == (void *)0x0) {
    iVar1 = __malloc_base(param_2);
  }
  else {
    if (param_2 == 0) {
      FID_conflict__free(param_1);
    }
    else {
      if (param_2 < 0xffffffe1) {
        do {
          iVar1 = (*_DAT_1000c078)(_DAT_10012f90,0,param_1,param_2);
          if (iVar1 != 0) {
            return iVar1;
          }
          iVar1 = FUN_00425a2d();
        } while ((iVar1 != 0) && (iVar1 = __callnewh(param_2), iVar1 != 0));
      }
      puVar2 = (undefined4 *)FUN_00423633();
      *puVar2 = 0xc;
    }
    iVar1 = 0;
  }
  return iVar1;
}



// Library Function - Single Match
//  ___acrt_lowio_create_handle_array
// 
// Library: Visual Studio 2015 Release

undefined4 * ___acrt_lowio_create_handle_array(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  
  puVar2 = (undefined4 *)__calloc_base(0x40,0x30);
  if (puVar2 == (undefined4 *)0x0) {
    puVar2 = (undefined4 *)0x0;
  }
  else if (puVar2 != puVar2 + 0x300) {
    puVar3 = puVar2 + 8;
    do {
      ___acrt_InitializeCriticalSectionEx_12(puVar3 + -8,4000,0);
      puVar3[-2] = 0xffffffff;
      *puVar3 = 0;
      puVar3[1] = 0;
      puVar1 = puVar3 + 4;
      puVar3[2] = 0xa0a0000;
      *(undefined *)(puVar3 + 3) = 10;
      *(byte *)((int)puVar3 + 0xd) = *(byte *)((int)puVar3 + 0xd) & 0xf8;
      *(undefined *)((int)puVar3 + 0xe) = 0;
      puVar3 = puVar3 + 0xc;
    } while (puVar1 != puVar2 + 0x300);
  }
  FID_conflict__free((void *)0x0);
  return puVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lowio_destroy_handle_array
// 
// Library: Visual Studio 2015 Release

void ___acrt_lowio_destroy_handle_array(void *param_1)

{
  void *pvVar1;
  
  if (param_1 != (void *)0x0) {
    pvVar1 = param_1;
    if (param_1 != (void *)((int)param_1 + 0xc00)) {
      do {
        (*_DAT_1000c0d0)(pvVar1);
        pvVar1 = (void *)((int)pvVar1 + 0x30);
      } while (pvVar1 != (void *)((int)param_1 + 0xc00));
    }
    FID_conflict__free(param_1);
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lowio_ensure_fh_exists
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_lowio_ensure_fh_exists(uint param_1)

{
  undefined4 *puVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  
  if (param_1 < 0x2000) {
    uVar3 = 0;
    ___acrt_lock(7);
    iVar4 = 0;
    iVar2 = _DAT_10013198;
    while (iVar2 <= (int)param_1) {
      if (*(int *)(&DAT_10012f98 + iVar4 * 4) == 0) {
        iVar2 = ___acrt_lowio_create_handle_array();
        *(int *)(&DAT_10012f98 + iVar4 * 4) = iVar2;
        if (iVar2 == 0) {
          uVar3 = 0xc;
          break;
        }
        iVar2 = _DAT_10013198 + 0x40;
        _DAT_10013198 = iVar2;
      }
      iVar4 = iVar4 + 1;
    }
    FUN_00426c51();
  }
  else {
    puVar1 = (undefined4 *)FUN_00423633();
    uVar3 = 9;
    *puVar1 = 9;
    FUN_00423576();
  }
  return uVar3;
}



void FUN_00426c51(void)

{
  ___acrt_unlock(7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lowio_lock_fh
// 
// Library: Visual Studio 2017 Release

void ___acrt_lowio_lock_fh(uint param_1)

{
  (*_DAT_1000c0c8)((param_1 & 0x3f) * 0x30 + *(int *)(&DAT_10012f98 + ((int)param_1 >> 6) * 4));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lowio_unlock_fh
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_lowio_unlock_fh(uint param_1)

{
  (*_DAT_1000c0cc)((param_1 & 0x3f) * 0x30 + *(int *)(&DAT_10012f98 + ((int)param_1 >> 6) * 4));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __free_osfhnd
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __free_osfhnd(int param_1)

{
  int iVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 uVar4;
  
  if ((-1 < param_1) && ((uint)param_1 < _DAT_10013198)) {
    iVar3 = (param_1 & 0x3fU) * 0x30;
    if (((*(byte *)(iVar3 + 0x28 + *(int *)(&DAT_10012f98 + (param_1 >> 6) * 4)) & 1) != 0) &&
       (*(int *)(iVar3 + 0x18 + *(int *)(&DAT_10012f98 + (param_1 >> 6) * 4)) != -1)) {
      iVar1 = FUN_00427b78();
      if (iVar1 == 1) {
        if (param_1 == 0) {
          uVar4 = 0xfffffff6;
        }
        else if (param_1 == 1) {
          uVar4 = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_00426d06;
          uVar4 = 0xfffffff4;
        }
        (*_DAT_1000c03c)(uVar4,0);
      }
LAB_00426d06:
      *(undefined4 *)(iVar3 + 0x18 + *(int *)(&DAT_10012f98 + (param_1 >> 6) * 4)) = 0xffffffff;
      return 0;
    }
  }
  puVar2 = (undefined4 *)FUN_00423633();
  *puVar2 = 9;
  puVar2 = (undefined4 *)FUN_00423620();
  *puVar2 = 0;
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __get_osfhandle
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

intptr_t __cdecl __get_osfhandle(int _FileHandle)

{
  undefined4 *puVar1;
  int iVar2;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_00423620();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) {
      iVar2 = (_FileHandle & 0x3fU) * 0x30;
      if ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 + iVar2) & 1) != 0) {
        return *(intptr_t *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x18 + iVar2);
      }
    }
    puVar1 = (undefined4 *)FUN_00423620();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
    FUN_00423576();
  }
  return -1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_9e9de3de5fa147e2223d7db92bc10aa6>,class <lambda_38ce7e780aa69e748d6df282ebc68efe>&,class
// <lambda_8ca6da459f0f6780f1cff60fdc3d00e5>>(class
// <lambda_9e9de3de5fa147e2223d7db92bc10aa6>&&,class
// <lambda_38ce7e780aa69e748d6df282ebc68efe>&,class <lambda_8ca6da459f0f6780f1cff60fdc3d00e5>&&)
// 
// Library: Visual Studio 2017 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_9e9de3de5fa147e2223d7db92bc10aa6__class__lambda_38ce7e780aa69e748d6df282ebc68efe___class__lambda_8ca6da459f0f6780f1cff60fdc3d00e5___
          (__crt_seh_guarded_call_int_ *this,_lambda_9e9de3de5fa147e2223d7db92bc10aa6_ *param_1,
          _lambda_38ce7e780aa69e748d6df282ebc68efe_ *param_2,
          _lambda_8ca6da459f0f6780f1cff60fdc3d00e5_ *param_3)

{
  uint _FileHandle;
  intptr_t iVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  int iVar5;
  
  iVar5 = 0;
  ___acrt_lowio_lock_fh(*(undefined4 *)param_1);
  _FileHandle = **(uint **)param_2;
  if ((*(byte *)(*(int *)(&DAT_10012f98 + ((int)_FileHandle >> 6) * 4) + 0x28 +
                (_FileHandle & 0x3f) * 0x30) & 1) != 0) {
    iVar1 = __get_osfhandle(_FileHandle);
    iVar2 = (*_DAT_1000c038)(iVar1);
    if (iVar2 != 0) goto LAB_00426e0b;
    puVar3 = (undefined4 *)FUN_00423620();
    uVar4 = (*_DAT_1000c0c0)();
    *puVar3 = uVar4;
  }
  puVar3 = (undefined4 *)FUN_00423633();
  *puVar3 = 9;
  iVar5 = -1;
LAB_00426e0b:
  FUN_00426e27();
  return iVar5;
}



void FUN_00426e27(void)

{
  int unaff_EBP;
  
  ___acrt_lowio_unlock_fh(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __commit
// 
// Library: Visual Studio 2017 Release

int __cdecl __commit(int _FileHandle)

{
  undefined4 *puVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
  }
  else {
    if (((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) &&
       ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 +
                  (_FileHandle & 0x3fU) * 0x30) & 1) != 0)) {
      local_10 = &_FileHandle;
      local_c = _FileHandle;
      local_14 = _FileHandle;
      iVar2 = __crt_seh_guarded_call<int>::
              operator___class__lambda_9e9de3de5fa147e2223d7db92bc10aa6__class__lambda_38ce7e780aa69e748d6df282ebc68efe___class__lambda_8ca6da459f0f6780f1cff60fdc3d00e5___
                        (&local_5,(_lambda_9e9de3de5fa147e2223d7db92bc10aa6_ *)&local_14,
                         (_lambda_38ce7e780aa69e748d6df282ebc68efe_ *)&local_10,
                         (_lambda_8ca6da459f0f6780f1cff60fdc3d00e5_ *)&local_c);
      return iVar2;
    }
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
    FUN_00423576();
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00426eb2(undefined4 *param_1,uint param_2,byte *param_3,int param_4)

{
  byte bVar1;
  byte *pbVar2;
  undefined4 uVar3;
  ushort *puVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  int iVar8;
  int iVar9;
  byte *pbVar10;
  byte *pbVar11;
  undefined4 uVar12;
  uint local_28;
  byte *local_24;
  undefined2 local_20;
  undefined2 local_1c [2];
  undefined local_18 [8];
  byte local_10;
  undefined local_f;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar8 = (int)param_2 >> 6;
  iVar9 = (param_2 & 0x3f) * 0x30;
  uVar7 = *(undefined4 *)(*(int *)(&DAT_10012f98 + iVar8 * 4) + 0x18 + iVar9);
  pbVar2 = param_3 + param_4;
  uVar3 = (*_DAT_1000c034)();
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  if (param_3 < pbVar2) {
    local_24 = param_3 + 1;
    pbVar10 = param_3;
    do {
      local_1c[0] = 0;
      local_20 = local_20 & 0xff | (ushort)*pbVar10 << 8;
      iVar5 = *(int *)(&DAT_10012f98 + iVar8 * 4);
      bVar1 = *(byte *)(iVar5 + 0x2d + iVar9);
      if ((bVar1 & 4) == 0) {
        puVar4 = ___pctype_func();
        if (-1 < (short)puVar4[*pbVar10]) {
          uVar12 = 1;
          pbVar11 = pbVar10;
          goto LAB_00426f8e;
        }
        if (pbVar2 <= local_24) {
          *(byte *)(*(int *)(&DAT_10012f98 + iVar8 * 4) + 0x2e + iVar9) = *pbVar10;
          pbVar2 = (byte *)(*(int *)(&DAT_10012f98 + iVar8 * 4) + 0x2d + iVar9);
          *pbVar2 = *pbVar2 | 4;
          param_1[1] = param_1[1] + 1;
          break;
        }
        iVar5 = FUN_00425b31(local_1c,pbVar10,2);
        if (iVar5 == -1) break;
        pbVar10 = pbVar10 + 1;
        local_24 = local_24 + 1;
      }
      else {
        local_10 = *(byte *)(iVar5 + 0x2e + iVar9);
        uVar6 = CONCAT11(*pbVar10,bVar1) & 0xfffffffb;
        uVar12 = 2;
        local_f = (undefined)(uVar6 >> 8);
        *(char *)(iVar5 + 0x2d + iVar9) = (char)uVar6;
        pbVar11 = &local_10;
LAB_00426f8e:
        iVar5 = FUN_00425b31(local_1c,pbVar11,uVar12);
        if (iVar5 == -1) break;
      }
      pbVar10 = pbVar10 + 1;
      local_24 = local_24 + 1;
      uVar6 = (*_DAT_1000c100)(uVar3,0,local_1c,1,local_18,5,0,0);
      if (uVar6 == 0) break;
      iVar5 = (*_DAT_1000c064)(uVar7,local_18,uVar6,&local_28,0);
      if (iVar5 == 0) {
LAB_0042705b:
        uVar7 = (*_DAT_1000c0c0)();
        *param_1 = uVar7;
        break;
      }
      param_1[1] = pbVar10 + (param_1[2] - (int)param_3);
      if (local_28 < uVar6) break;
      if (local_20._1_1_ == '\n') {
        local_20 = 0xd;
        iVar5 = (*_DAT_1000c064)(uVar7,&local_20,1,&local_28,0);
        if (iVar5 == 0) goto LAB_0042705b;
        if (local_28 == 0) break;
        param_1[2] = param_1[2] + 1;
        param_1[1] = param_1[1] + 1;
      }
    } while (pbVar10 < pbVar2);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  struct `anonymous namespace'::write_result __cdecl write_double_translated_unicode_nolock(char
// const * const,unsigned int)
//  struct `anonymous namespace'::write_result __cdecl write_double_translated_unicode_nolock(char
// const * const,unsigned int)
// 
// Library: Visual Studio 2015 Release

undefined4 * write_double_translated_unicode_nolock(undefined4 *param_1,short *param_2,int param_3)

{
  short sVar1;
  short sVar2;
  short *psVar3;
  undefined4 uVar4;
  
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  psVar3 = (short *)(param_3 + (int)param_2);
  if (param_2 < psVar3) {
    do {
      sVar2 = *param_2;
      sVar1 = FUN_00427c17(sVar2);
      if (sVar1 != sVar2) {
LAB_004270d2:
        uVar4 = (*_DAT_1000c0c0)();
        *param_1 = uVar4;
        return param_1;
      }
      param_1[1] = param_1[1] + 2;
      if (sVar2 == 10) {
        sVar2 = FUN_00427c17(0xd);
        if (sVar2 != 0xd) goto LAB_004270d2;
        param_1[1] = param_1[1] + 1;
        param_1[2] = param_1[2] + 1;
      }
      param_2 = param_2 + 1;
    } while (param_2 < psVar3);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_004270e3(uint param_1)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  undefined local_8 [4];
  
  iVar1 = __isatty(param_1);
  if (iVar1 == 0) {
    uVar3 = 0;
  }
  else {
    iVar4 = (int)param_1 >> 6;
    iVar1 = (param_1 & 0x3f) * 0x30;
    uVar3 = *(uint *)(&DAT_10012f98 + iVar4 * 4);
    if ((*(char *)(uVar3 + 0x28 + iVar1) < '\0') &&
       ((iVar2 = FUN_00423ea2(), *(int *)(*(int *)(iVar2 + 0x4c) + 0xa8) != 0 ||
        (uVar3 = *(uint *)(&DAT_10012f98 + iVar4 * 4), *(char *)(uVar3 + 0x29 + iVar1) != '\0')))) {
      uVar3 = (*_DAT_1000c030)(*(undefined4 *)(*(int *)(&DAT_10012f98 + iVar4 * 4) + 0x18 + iVar1),
                               local_8);
      uVar3 = uVar3 & 0xffffff00 | (uint)(uVar3 != 0);
    }
    else {
      uVar3 = uVar3 & 0xffffff00;
    }
  }
  return uVar3;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  struct `anonymous namespace'::write_result __cdecl write_text_ansi_nolock(int,char const *
// const,unsigned int)
//  struct `anonymous namespace'::write_result __cdecl write_text_ansi_nolock(int,char const *
// const,unsigned int)
// 
// Library: Visual Studio 2015 Release

void write_text_ansi_nolock(undefined4 *param_1,uint param_2,char *param_3,int param_4)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  char *pcVar4;
  uint local_1410;
  char *local_140c;
  char local_1408 [5120];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar3 = *(undefined4 *)
           (*(int *)(&DAT_10012f98 + ((int)param_2 >> 6) * 4) + 0x18 + (param_2 & 0x3f) * 0x30);
  *param_1 = 0;
  local_140c = param_3 + param_4;
  param_1[1] = 0;
  param_1[2] = 0;
  do {
    if (local_140c <= param_3) break;
    pcVar4 = local_1408;
    do {
      if (local_140c <= param_3) break;
      cVar1 = *param_3;
      param_3 = param_3 + 1;
      if (cVar1 == '\n') {
        param_1[2] = param_1[2] + 1;
        *pcVar4 = '\r';
        pcVar4 = pcVar4 + 1;
      }
      *pcVar4 = cVar1;
      pcVar4 = pcVar4 + 1;
    } while (pcVar4 < local_1408 + 0x13ff);
    iVar2 = (*_DAT_1000c064)(uVar3,local_1408,(int)pcVar4 - (int)local_1408,&local_1410,0);
    if (iVar2 == 0) {
      uVar3 = (*_DAT_1000c0c0)();
      *param_1 = uVar3;
      break;
    }
    param_1[1] = param_1[1] + local_1410;
  } while ((uint)((int)pcVar4 - (int)local_1408) <= local_1410);
  ___security_check_cookie_4();
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00427238(undefined4 *param_1,uint param_2,short *param_3,int param_4)

{
  short sVar1;
  int iVar2;
  undefined4 uVar3;
  short *psVar4;
  uint local_1410;
  short *local_140c;
  short local_1408 [2560];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar3 = *(undefined4 *)
           (*(int *)(&DAT_10012f98 + ((int)param_2 >> 6) * 4) + 0x18 + (param_2 & 0x3f) * 0x30);
  local_140c = (short *)(param_4 + (int)param_3);
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  do {
    if (local_140c <= param_3) break;
    psVar4 = local_1408;
    do {
      if (local_140c <= param_3) break;
      sVar1 = *param_3;
      param_3 = param_3 + 1;
      if (sVar1 == 10) {
        param_1[2] = param_1[2] + 2;
        *psVar4 = 0xd;
        psVar4 = psVar4 + 1;
      }
      *psVar4 = sVar1;
      psVar4 = psVar4 + 1;
    } while (psVar4 < local_1408 + 0x9ff);
    iVar2 = (*_DAT_1000c064)(uVar3,local_1408,(int)psVar4 - (int)local_1408,&local_1410,0);
    if (iVar2 == 0) {
      uVar3 = (*_DAT_1000c0c0)();
      *param_1 = uVar3;
      break;
    }
    param_1[1] = param_1[1] + local_1410;
  } while ((uint)((int)psVar4 - (int)local_1408) <= local_1410);
  ___security_check_cookie_4();
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  struct `anonymous namespace'::write_result __cdecl write_text_utf8_nolock(int,char const *
// const,unsigned int)
//  struct `anonymous namespace'::write_result __cdecl write_text_utf8_nolock(int,char const *
// const,unsigned int)
// 
// Library: Visual Studio 2015 Release

void write_text_utf8_nolock(undefined4 *param_1,uint param_2,short *param_3,int param_4)

{
  short sVar1;
  short *psVar2;
  uint uVar3;
  int iVar4;
  undefined4 uVar5;
  uint uVar6;
  short *psVar7;
  int local_1418;
  undefined4 local_1414;
  short *local_1410;
  undefined local_140c [3416];
  short local_6b4 [854];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_1414 = *(undefined4 *)
                (*(int *)(&DAT_10012f98 + ((int)param_2 >> 6) * 4) + 0x18 + (param_2 & 0x3f) * 0x30)
  ;
  local_1410 = (short *)(param_4 + (int)param_3);
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  psVar7 = param_3;
  if (param_3 < local_1410) {
    do {
      uVar6 = 0;
      psVar2 = local_6b4;
      do {
        if (local_1410 <= psVar7) break;
        sVar1 = *psVar7;
        psVar7 = psVar7 + 1;
        if (sVar1 == 10) {
          *psVar2 = 0xd;
          psVar2 = psVar2 + 1;
        }
        *psVar2 = sVar1;
        psVar2 = psVar2 + 1;
      } while (psVar2 < local_6b4 + 0x354);
      uVar3 = (*_DAT_1000c100)(0xfde9,0,local_6b4,(int)psVar2 - (int)local_6b4 >> 1,local_140c,0xd55
                               ,0,0);
      if (uVar3 == 0) {
LAB_00427438:
        uVar5 = (*_DAT_1000c0c0)();
        *param_1 = uVar5;
        break;
      }
      do {
        iVar4 = (*_DAT_1000c064)(local_1414,local_140c + uVar6,uVar3 - uVar6,&local_1418,0);
        if (iVar4 == 0) goto LAB_00427438;
        uVar6 = uVar6 + local_1418;
      } while (uVar6 < uVar3);
      param_1[1] = (int)psVar7 - (int)param_3;
    } while (psVar7 < local_1410);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __write
// 
// Library: Visual Studio 2017 Release

int __cdecl __write(int _FileHandle,void *_Buf,uint _MaxCharCount)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_00423620();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) {
      iVar2 = (_FileHandle & 0x3fU) * 0x30;
      if ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 + iVar2) & 1) != 0) {
        ___acrt_lowio_lock_fh(_FileHandle);
        iVar3 = -1;
        if ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 + iVar2) & 1) == 0) {
          puVar1 = (undefined4 *)FUN_00423633();
          *puVar1 = 9;
          puVar1 = (undefined4 *)FUN_00423620();
          *puVar1 = 0;
        }
        else {
          iVar3 = FUN_0042753b(_FileHandle,_Buf,_MaxCharCount);
        }
        FUN_00427512();
        return iVar3;
      }
    }
    puVar1 = (undefined4 *)FUN_00423620();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
    FUN_00423576();
  }
  return -1;
}



void FUN_00427512(void)

{
  ___acrt_lowio_unlock_fh();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0042753b(uint param_1,char *param_2,uint param_3)

{
  char cVar1;
  char *pcVar2;
  char cVar3;
  undefined4 *puVar4;
  int *piVar5;
  int iVar6;
  int local_30;
  undefined4 local_2c;
  undefined4 uStack40;
  int local_24;
  int local_20;
  int local_1c;
  uint local_18;
  int local_14;
  int local_10;
  char *local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_c = param_2;
  local_18 = param_3;
  if (param_3 == 0) goto LAB_0042773e;
  if (param_2 == (char *)0x0) {
    puVar4 = (undefined4 *)FUN_00423620();
    *puVar4 = 0;
    puVar4 = (undefined4 *)FUN_00423633();
    *puVar4 = 0x16;
    FUN_00423576();
    goto LAB_0042773e;
  }
  local_10 = (int)param_1 >> 6;
  local_14 = (param_1 & 0x3f) * 0x30;
  cVar1 = *(char *)(*(int *)(&DAT_10012f98 + local_10 * 4) + 0x29 + local_14);
  if (((cVar1 == '\x02') || (cVar1 == '\x01')) && ((~param_3 & 1) == 0)) {
    puVar4 = (undefined4 *)FUN_00423620();
    *puVar4 = 0;
    puVar4 = (undefined4 *)FUN_00423633();
    *puVar4 = 0x16;
    FUN_00423576();
    goto LAB_0042773e;
  }
  if ((*(byte *)(*(int *)(&DAT_10012f98 + local_10 * 4) + 0x28 + local_14) & 0x20) != 0) {
    __lseeki64_nolock(param_1,0,2);
  }
  local_24 = 0;
  local_20 = 0;
  local_1c = 0;
  cVar3 = FUN_004270e3(param_1);
  pcVar2 = local_c;
  if (cVar3 == '\0') {
    if (*(char *)(*(int *)(&DAT_10012f98 + local_10 * 4) + 0x28 + local_14) < '\0') {
      if (cVar1 == '\0') {
        piVar5 = (int *)write_text_ansi_nolock(&local_30,param_1,local_c,local_18);
      }
      else if (cVar1 == '\x01') {
        piVar5 = (int *)write_text_utf8_nolock(&local_30,param_1,local_c,local_18);
      }
      else {
        if (cVar1 != '\x02') goto LAB_004276d8;
        piVar5 = (int *)FUN_00427238(&local_30,param_1,local_c,local_18);
      }
    }
    else {
      local_30 = 0;
      local_2c = 0;
      uStack40 = 0;
      iVar6 = (*_DAT_1000c064)(*(undefined4 *)
                                (*(int *)(&DAT_10012f98 + local_10 * 4) + 0x18 + local_14),local_c,
                               local_18,&local_2c,0);
      if (iVar6 == 0) {
        local_30 = (*_DAT_1000c0c0)();
      }
      piVar5 = &local_30;
    }
LAB_004276cc:
    local_24 = *piVar5;
    local_20 = piVar5[1];
    local_1c = piVar5[2];
  }
  else {
    if (cVar1 == '\0') {
      piVar5 = (int *)FUN_00426eb2(&local_30,param_1,local_c,local_18);
      goto LAB_004276cc;
    }
    if ((byte)(cVar1 - 1U) < 2) {
      piVar5 = (int *)write_double_translated_unicode_nolock(&local_30,local_c,local_18);
      goto LAB_004276cc;
    }
  }
LAB_004276d8:
  if (local_20 == 0) {
    if (local_24 == 0) {
      if (((*(byte *)(*(int *)(&DAT_10012f98 + local_10 * 4) + 0x28 + local_14) & 0x40) == 0) ||
         (*pcVar2 != '\x1a')) {
        puVar4 = (undefined4 *)FUN_00423633();
        *puVar4 = 0x1c;
        puVar4 = (undefined4 *)FUN_00423620();
        *puVar4 = 0;
      }
    }
    else if (local_24 == 5) {
      puVar4 = (undefined4 *)FUN_00423633();
      *puVar4 = 9;
      puVar4 = (undefined4 *)FUN_00423620();
      *puVar4 = 5;
    }
    else {
      ___acrt_errno_map_os_error(local_24);
    }
  }
LAB_0042773e:
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_stdio_free_buffer_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_stdio_free_buffer_nolock(undefined4 *param_1)

{
  uint *puVar1;
  
  puVar1 = param_1 + 3;
  if (((*puVar1 >> 0xd & 1) != 0) && ((*puVar1 >> 6 & 1) != 0)) {
    FID_conflict__free((void *)param_1[1]);
    LOCK();
    *puVar1 = *puVar1 & 0xfffffebf;
    param_1[1] = 0;
    *param_1 = 0;
    param_1[2] = 0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __isatty
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __isatty(int _FileHandle)

{
  undefined4 *puVar1;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) {
      return *(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 +
                      (_FileHandle & 0x3fU) * 0x30) & 0x40;
    }
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
    FUN_00423576();
  }
  return 0;
}



// Library Function - Single Match
//  __isleadbyte_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __isleadbyte_l(int _C,_locale_t _Locale)

{
  ushort uVar1;
  int local_14;
  int *local_10;
  char local_8;
  
  FUN_004231ce(_Locale);
  uVar1 = *(ushort *)(*local_10 + (_C & 0xffU) * 2);
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return uVar1 & 0x8000;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_004278ba(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,undefined4 param_6)

{
  (*_DAT_1000c0fc)(param_1,param_2,param_3,param_4,param_5,param_6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_locale_free_monetary
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_locale_free_monetary(int param_1)

{
  if (param_1 != 0) {
    if (*(void **)(param_1 + 0xc) != _DAT_100126fc) {
      FID_conflict__free(*(void **)(param_1 + 0xc));
    }
    if (*(void **)(param_1 + 0x10) != _DAT_10012700) {
      FID_conflict__free(*(void **)(param_1 + 0x10));
    }
    if (*(void **)(param_1 + 0x14) != _DAT_10012704) {
      FID_conflict__free(*(void **)(param_1 + 0x14));
    }
    if (*(void **)(param_1 + 0x18) != _DAT_10012708) {
      FID_conflict__free(*(void **)(param_1 + 0x18));
    }
    if (*(void **)(param_1 + 0x1c) != _DAT_1001270c) {
      FID_conflict__free(*(void **)(param_1 + 0x1c));
    }
    if (*(void **)(param_1 + 0x20) != _DAT_10012710) {
      FID_conflict__free(*(void **)(param_1 + 0x20));
    }
    if (*(void **)(param_1 + 0x24) != _DAT_10012714) {
      FID_conflict__free(*(void **)(param_1 + 0x24));
    }
    if (*(void **)(param_1 + 0x38) != _DAT_10012728) {
      FID_conflict__free(*(void **)(param_1 + 0x38));
    }
    if (*(void **)(param_1 + 0x3c) != _DAT_1001272c) {
      FID_conflict__free(*(void **)(param_1 + 0x3c));
    }
    if (*(void **)(param_1 + 0x40) != _DAT_10012730) {
      FID_conflict__free(*(void **)(param_1 + 0x40));
    }
    if (*(void **)(param_1 + 0x44) != _DAT_10012734) {
      FID_conflict__free(*(void **)(param_1 + 0x44));
    }
    if (*(void **)(param_1 + 0x48) != _DAT_10012738) {
      FID_conflict__free(*(void **)(param_1 + 0x48));
    }
    if (*(void **)(param_1 + 0x4c) != _DAT_1001273c) {
      FID_conflict__free(*(void **)(param_1 + 0x4c));
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_locale_free_numeric
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_locale_free_numeric(void **param_1)

{
  if (param_1 != (void **)0x0) {
    if (*param_1 != _DAT_100126f0) {
      FID_conflict__free(*param_1);
    }
    if (param_1[1] != _DAT_100126f4) {
      FID_conflict__free(param_1[1]);
    }
    if (param_1[2] != _DAT_100126f8) {
      FID_conflict__free(param_1[2]);
    }
    if (param_1[0xc] != _DAT_10012720) {
      FID_conflict__free(param_1[0xc]);
    }
    if (param_1[0xd] != _DAT_10012724) {
      FID_conflict__free(param_1[0xd]);
    }
  }
  return;
}



void FUN_00427a40(void **param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  
  uVar2 = 0;
  uVar1 = ~-(uint)(param_1 + param_2 < param_1) & param_2 & 0x3fffffff;
  if (uVar1 != 0) {
    do {
      FID_conflict__free(*param_1);
      uVar2 = uVar2 + 1;
      param_1 = param_1 + 1;
    } while (uVar2 != uVar1);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_free_time
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_locale_free_time(int param_1)

{
  if (param_1 != 0) {
    FUN_00427a40(param_1,7);
    FUN_00427a40(param_1 + 0x1c,7);
    FUN_00427a40(param_1 + 0x38,0xc);
    FUN_00427a40(param_1 + 0x68,0xc);
    FUN_00427a40(param_1 + 0x98,2);
    FID_conflict__free(*(void **)(param_1 + 0xa0));
    FID_conflict__free(*(void **)(param_1 + 0xa4));
    FID_conflict__free(*(void **)(param_1 + 0xa8));
    FUN_00427a40(param_1 + 0xb4,7);
    FUN_00427a40(param_1 + 0xd0,7);
    FUN_00427a40(param_1 + 0xec,0xc);
    FUN_00427a40(param_1 + 0x11c,0xc);
    FUN_00427a40(param_1 + 0x14c,2);
    FID_conflict__free(*(void **)(param_1 + 0x154));
    FID_conflict__free(*(void **)(param_1 + 0x158));
    FID_conflict__free(*(void **)(param_1 + 0x15c));
    FID_conflict__free(*(void **)(param_1 + 0x160));
  }
  return;
}



// Library Function - Single Match
//  ___strncnt
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___strncnt(char *param_1,int param_2)

{
  char cVar1;
  int iVar2;
  
  iVar2 = 0;
  cVar1 = *param_1;
  while ((cVar1 != '\0' && (iVar2 != param_2))) {
    iVar2 = iVar2 + 1;
    cVar1 = param_1[iVar2];
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00427b78(void)

{
  return _DAT_100131d4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __int64 __cdecl common_lseek_nolock<__int64>(int,__int64,int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

__int64 __cdecl common_lseek_nolock___int64_(int param_1,__int64 param_2,int param_3)

{
  byte *pbVar1;
  intptr_t iVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined4 uVar5;
  uint local_c;
  uint local_8;
  
  iVar2 = __get_osfhandle(param_1);
  if (iVar2 == -1) {
    puVar3 = (undefined4 *)FUN_00423633();
    *puVar3 = 9;
  }
  else {
    iVar4 = (*_DAT_1000c040)(iVar2,param_2,&local_c,param_3);
    if (iVar4 == 0) {
      uVar5 = (*_DAT_1000c0c0)();
      ___acrt_errno_map_os_error(uVar5);
    }
    else if ((local_c & local_8) != 0xffffffff) {
      pbVar1 = (byte *)(*(int *)(&DAT_10012f98 + (param_1 >> 6) * 4) + 0x28 +
                       (param_1 & 0x3fU) * 0x30);
      *pbVar1 = *pbVar1 & 0xfd;
      goto LAB_00427bf6;
    }
  }
  local_c = 0xffffffff;
  local_8 = 0xffffffff;
LAB_00427bf6:
  return CONCAT44(local_8,local_c);
}



// Library Function - Single Match
//  __lseeki64_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

longlong __cdecl __lseeki64_nolock(int _FileHandle,longlong _Offset,int _Origin)

{
  __int64 _Var1;
  
  _Var1 = common_lseek_nolock___int64_(_FileHandle,_Offset,_Origin);
  return _Var1;
}



uint FUN_00427c17(ushort param_1)

{
  int iVar1;
  uint uVar2;
  undefined local_8 [4];
  
  iVar1 = FUN_00427fee();
  if ((iVar1 != 0) && (uVar2 = FID_conflict____dcrt_read_console(&param_1,1,local_8), uVar2 != 0)) {
    return uVar2 & 0xffff0000 | (uint)param_1;
  }
  return 0xffff;
}



// Library Function - Single Match
//  __fclose_nolock
// 
// Library: Visual Studio 2017 Release

int __cdecl __fclose_nolock(FILE *_File)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  
  if (_File == (FILE *)0x0) {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 0x16;
    FUN_00423576();
    iVar2 = -1;
  }
  else {
    iVar2 = -1;
    if (((uint)_File->_flag >> 0xd & 1) != 0) {
      iVar2 = ___acrt_stdio_flush_nolock(_File);
      ___acrt_stdio_free_buffer_nolock(_File);
      iVar3 = __fileno(_File);
      iVar3 = __close(iVar3);
      if (iVar3 < 0) {
        iVar2 = -1;
      }
      else if (_File->_tmpfname != (char *)0x0) {
        FID_conflict__free(_File->_tmpfname);
        _File->_tmpfname = (char *)0x0;
      }
    }
    __acrt_stdio_free_stream(SUB41(_File,0));
  }
  return iVar2;
}



// Library Function - Single Match
//  ___ascii_strnicmp
// 
// Library: Visual Studio

int __cdecl ___ascii_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  
  if (_MaxCount != 0) {
    do {
      bVar2 = *_Str1;
      bVar1 = *_Str2;
      if ((bVar2 == 0) || (bVar1 == 0)) break;
      _Str1 = (char *)((byte *)_Str1 + 1);
      _Str2 = (char *)((byte *)_Str2 + 1);
      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
        bVar2 = bVar2 + 0x20;
      }
      if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
        bVar1 = bVar1 + 0x20;
      }
      bVar3 = bVar2 < bVar1;
      if (bVar2 != bVar1) goto LAB_00427fbf;
      _MaxCount = _MaxCount - 1;
    } while (_MaxCount != 0);
    _MaxCount = 0;
    bVar3 = bVar2 < bVar1;
    if (bVar2 != bVar1) {
LAB_00427fbf:
      _MaxCount = 0xffffffff;
      if (!bVar3) {
        _MaxCount = 1;
      }
    }
  }
  return _MaxCount;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  void __cdecl __dcrt_lowio_initialize_console_input(void)
//  void __cdecl __dcrt_lowio_initialize_console_output(void)
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void FID_conflict___dcrt_lowio_initialize_console_input(void)

{
  _DAT_10012740 = (*_DAT_1000c070)(0x1000fe88,0x40000000,3,0,3,0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool FUN_00427fee(void)

{
  if (_DAT_10012740 == -2) {
    FID_conflict___dcrt_lowio_initialize_console_input();
  }
  return _DAT_10012740 != -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  ___dcrt_terminate_console_input
//  ___dcrt_terminate_console_output
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void FID_conflict____dcrt_terminate_console_output(void)

{
  if ((_DAT_10012740 != -1) && (_DAT_10012740 != -2)) {
    (*_DAT_1000c060)(_DAT_10012740);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  ___dcrt_read_console
//  ___dcrt_write_console
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

int FID_conflict____dcrt_read_console(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  
  iVar1 = (*_DAT_1000c074)(_DAT_10012740,param_1,param_2,param_3,0);
  if (iVar1 == 0) {
    iVar2 = (*_DAT_1000c0c0)();
    if (iVar2 == 6) {
      FID_conflict____dcrt_terminate_console_output();
      FID_conflict___dcrt_lowio_initialize_console_input();
      iVar1 = (*_DAT_1000c074)(_DAT_10012740,param_1,param_2,param_3,0);
    }
  }
  return iVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_218ce3db14220d0be481dae8ef3383b6>,class <lambda_628dfdc04ba53c8bfc02c9951375f3f5>&,class
// <lambda_57dc472bd5c9d5f3b2cbca59b8a843ae>>(class
// <lambda_218ce3db14220d0be481dae8ef3383b6>&&,class
// <lambda_628dfdc04ba53c8bfc02c9951375f3f5>&,class <lambda_57dc472bd5c9d5f3b2cbca59b8a843ae>&&)
// 
// Library: Visual Studio 2017 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_218ce3db14220d0be481dae8ef3383b6__class__lambda_628dfdc04ba53c8bfc02c9951375f3f5___class__lambda_57dc472bd5c9d5f3b2cbca59b8a843ae___
          (__crt_seh_guarded_call_int_ *this,_lambda_218ce3db14220d0be481dae8ef3383b6_ *param_1,
          _lambda_628dfdc04ba53c8bfc02c9951375f3f5_ *param_2,
          _lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_ *param_3)

{
  uint _FileHandle;
  int iVar1;
  undefined4 *puVar2;
  
  ___acrt_lowio_lock_fh(*(undefined4 *)param_1);
  _FileHandle = **(uint **)param_2;
  if ((*(byte *)(*(int *)(&DAT_10012f98 + ((int)_FileHandle >> 6) * 4) + 0x28 +
                (_FileHandle & 0x3f) * 0x30) & 1) == 0) {
    puVar2 = (undefined4 *)FUN_00423633();
    *puVar2 = 9;
    iVar1 = -1;
  }
  else {
    iVar1 = __close_nolock(_FileHandle);
  }
  FUN_004280ef();
  return iVar1;
}



void FUN_004280ef(void)

{
  int unaff_EBP;
  
  ___acrt_lowio_unlock_fh(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __close
// 
// Library: Visual Studio 2017 Release

int __cdecl __close(int _FileHandle)

{
  undefined4 *puVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_00423620();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
  }
  else {
    if (((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) &&
       ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 +
                  (_FileHandle & 0x3fU) * 0x30) & 1) != 0)) {
      local_10 = &_FileHandle;
      local_c = _FileHandle;
      local_14 = _FileHandle;
      iVar2 = __crt_seh_guarded_call<int>::
              operator___class__lambda_218ce3db14220d0be481dae8ef3383b6__class__lambda_628dfdc04ba53c8bfc02c9951375f3f5___class__lambda_57dc472bd5c9d5f3b2cbca59b8a843ae___
                        (&local_5,(_lambda_218ce3db14220d0be481dae8ef3383b6_ *)&local_14,
                         (_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ *)&local_10,
                         (_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_ *)&local_c);
      return iVar2;
    }
    puVar1 = (undefined4 *)FUN_00423620();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 9;
    FUN_00423576();
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __close_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int __cdecl __close_nolock(int _FileHandle)

{
  intptr_t iVar1;
  intptr_t iVar2;
  int iVar3;
  
  iVar1 = __get_osfhandle(_FileHandle);
  if (iVar1 != -1) {
    if (((_FileHandle == 1) && ((*(byte *)(_DAT_10012f98 + 0x88) & 1) != 0)) ||
       ((_FileHandle == 2 && ((*(byte *)(_DAT_10012f98 + 0x58) & 1) != 0)))) {
      iVar1 = __get_osfhandle(2);
      iVar2 = __get_osfhandle(1);
      if (iVar2 == iVar1) goto LAB_004281a0;
    }
    iVar1 = __get_osfhandle(_FileHandle);
    iVar3 = (*_DAT_1000c060)(iVar1);
    if (iVar3 == 0) {
      iVar3 = (*_DAT_1000c0c0)();
      goto LAB_004281f2;
    }
  }
LAB_004281a0:
  iVar3 = 0;
LAB_004281f2:
  __free_osfhnd(_FileHandle);
  *(undefined *)
   (*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 + (_FileHandle & 0x3fU) * 0x30) = 0;
  if (iVar3 == 0) {
    iVar3 = 0;
  }
  else {
    ___acrt_errno_map_os_error(iVar3);
    iVar3 = -1;
  }
  return iVar3;
}



// Library Function - Single Match
//  void __cdecl __acrt_stdio_free_stream(class __crt_stdio_stream)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl __acrt_stdio_free_stream(__crt_stdio_stream param_1)

{
  undefined3 in_stack_00000005;
  
  *_param_1 = 0;
  _param_1[1] = 0;
  _param_1[2] = 0;
  _param_1[4] = 0xffffffff;
  _param_1[5] = 0;
  _param_1[6] = 0;
  _param_1[7] = 0;
  _param_1[3] = 0;
  return;
}



// Library Function - Single Match
//  __CIlog10_pentium4
// 
// Library: Visual Studio

void __CIlog10_pentium4(void)

{
  float10 in_ST0;
  
  start((double)in_ST0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  start
// 
// Library: Visual Studio 2015 Release

float10 start(double param_1)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  double dVar7;
  double dVar8;
  undefined in_XMM0 [16];
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double local_c;
  
  iVar4 = 0;
  while( true ) {
    uVar2 = (uint)(ushort)(SUB162(in_XMM0 >> 0x30,0) >> 4);
    dVar7 = (double)(SUB168(in_XMM0,0) & (ulonglong)_DAT_1000fea0 | (ulonglong)_DAT_1000ff10);
    dVar8 = (double)(SUB168(in_XMM0,0) & uRam1000fea8 | uRam1000ff18);
    uVar1 = SUB82(_DAT_1000fec0 + dVar7,0) & 0x7f0;
    dVar12 = (double)(uRam1000fed8 & (ulonglong)dVar8);
    dVar10 = (double)(_DAT_1000fed0 & (ulonglong)dVar7) * *(double *)(uVar1 + 0x100104e0) -
             _DAT_1000feb0;
    dVar7 = (dVar7 - (double)(_DAT_1000fed0 & (ulonglong)dVar7)) * *(double *)(uVar1 + 0x100104e0);
    dVar9 = (dVar8 - dVar12) * *(double *)(uVar1 + 0x100104e8);
    dVar8 = dVar7 + dVar10;
    dVar12 = dVar9 + (dVar12 * *(double *)(uVar1 + 0x100104e8) - dRam1000feb8);
    uVar3 = uVar2 - 1;
    if (uVar3 < 0x7fe) {
      iVar4 = (uVar2 - 0x3ff) + iVar4;
      dVar11 = (double)iVar4;
      iVar5 = 0;
      if (uVar1 + iVar4 * 0x400 == 0) {
        iVar5 = 0x10;
      }
      return (float10)(((dRam1000ff68 * dVar12 + dRam1000ff78) * dVar12 + dRam1000ff88) *
                       dVar12 * dVar12 +
                       ((_DAT_1000ff60 * dVar8 + _DAT_1000ff70) * dVar8 + _DAT_1000ff80) *
                       dVar8 * dVar8 * dVar8 * dVar8 * dVar8 + _DAT_1000ff90 * dVar8 +
                       *(double *)(uVar1 + 0x100100d8) + dVar11 * dRam1000fee8 +
                       (double)((ulonglong)dVar9 & *(ulonglong *)(iVar5 + 0x1000fef8)) +
                      *(double *)(uVar1 + 0x100100d0) + dVar10 + dVar11 * _DAT_1000fee0 +
                      (double)((ulonglong)dVar7 & *(ulonglong *)(iVar5 + 0x1000fef0)));
    }
    local_c = (double)-(ulonglong)(_DAT_1000ff20 == param_1);
    if (SUB82(local_c,0) != 0) break;
    if (uVar3 != 0xffffffff) {
      if (uVar3 < 0x7ff) {
        if (_DAT_1000ff10 ==
            (double)((ulonglong)param_1 & (ulonglong)_DAT_1000fea0 | (ulonglong)_DAT_1000ff10)) {
          return (float10)_DAT_1000ff48;
        }
        uVar6 = 0x3e9;
        local_c = _DAT_1000fea0;
      }
      else if (((uVar2 & 0x7ff) < 0x7ff) ||
              ((SUB84(param_1,0) | (uint)((ulonglong)param_1 >> 0x20) & 0xfffff) == 0)) {
        local_c = -NAN;
        uVar6 = 9;
      }
      else {
        uVar6 = 0x3e9;
      }
      goto LAB_004284c8;
    }
    in_XMM0 = CONCAT88(dVar12,param_1 * _DAT_1000ff30);
    iVar4 = -0x34;
  }
  uVar6 = 8;
  local_c = _DAT_1000ff40;
LAB_004284c8:
  ___libm_error_support(&param_1,&param_1,&local_c,uVar6);
  return (float10)local_c;
}



float10 __fastcall
FUN_00428abe(undefined4 param_1_00,undefined4 param_2_00,undefined2 param_1,undefined4 param_2,
            undefined4 param_3,undefined4 param_4,undefined4 param_5,undefined4 param_6)

{
  float10 in_ST0;
  undefined local_24 [8];
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  double local_c;
  
  local_14 = param_5;
  local_10 = param_6;
  local_c = (double)in_ST0;
  local_1c = param_3;
  local_18 = param_4;
  __87except(param_2_00,local_24,&param_1);
  return (float10)local_c;
}



float10 __fastcall
FUN_00428ad5(undefined4 param_1,undefined4 param_2,undefined2 param_3,undefined4 param_4,
            undefined4 param_5,undefined4 param_6)

{
  float10 in_ST0;
  undefined local_24 [8];
  undefined4 uStack28;
  undefined4 uStack24;
  double dStack12;
  
  dStack12 = (double)in_ST0;
  uStack28 = param_5;
  uStack24 = param_6;
  __87except(param_2,local_24,&param_3);
  return (float10)dStack12;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___libm_error_support
// 
// Library: Visual Studio 2015 Release

void ___libm_error_support(undefined8 *param_1,undefined8 *param_2,undefined8 *param_3,int param_4)

{
  undefined8 uVar1;
  code *pcVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 local_28;
  undefined4 local_24;
  undefined8 local_20;
  undefined8 local_18;
  undefined8 local_10;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  if (_DAT_100131dc == 0) {
    pcVar2 = (code *)0x100071d0;
  }
  else {
    pcVar2 = (code *)(*_DAT_1000c0d4)(_DAT_100131ec);
  }
  if (0x1a < param_4) {
    if (param_4 != 0x1b) {
      if (param_4 == 0x1c) {
        local_24 = 0x10010094;
      }
      else if (param_4 == 0x31) {
        local_24 = 0x100100a8;
      }
      else if (param_4 == 0x3a) {
        local_24 = 0x100100a0;
      }
      else {
        if (param_4 != 0x3d) {
          if ((param_4 != 1000) && (param_4 != 0x3e9)) goto LAB_00428d19;
          uVar1 = *param_1;
          goto LAB_00428c66;
        }
        local_24 = 0x10010098;
      }
      goto LAB_00428b85;
    }
    local_28 = 2;
LAB_00428cd7:
    local_24 = 0x10010094;
    goto LAB_00428cde;
  }
  if (param_4 == 0x1a) {
    uVar1 = 0x3ff0000000000000;
LAB_00428c66:
    *param_3 = uVar1;
    goto LAB_00428d19;
  }
  if (param_4 < 0xf) {
    if (param_4 == 0xe) {
      local_28 = 3;
      local_24 = 0x10010090;
    }
    else {
      if (param_4 != 2) {
        if (param_4 == 3) {
          local_24 = 0x10010084;
        }
        else {
          if (param_4 == 8) {
            local_28 = 2;
            local_24 = 0x10010088;
            goto LAB_00428cde;
          }
          if (param_4 != 9) goto LAB_00428d19;
          local_24 = 0x10010088;
        }
LAB_00428b85:
        local_28 = 1;
        local_20 = *param_1;
        local_18 = *param_2;
        local_10 = *param_3;
        (*_DAT_1000c174)(&local_28);
        iVar3 = (*pcVar2)();
        if (iVar3 == 0) {
          puVar4 = (undefined4 *)FUN_00423633();
          *puVar4 = 0x21;
        }
        goto LAB_00428d14;
      }
      local_28 = 2;
      local_24 = 0x10010084;
    }
LAB_00428cde:
    local_20 = *param_1;
    local_18 = *param_2;
    local_10 = *param_3;
    (*_DAT_1000c174)(&local_28);
    iVar3 = (*pcVar2)();
    if (iVar3 == 0) {
      puVar4 = (undefined4 *)FUN_00423633();
      *puVar4 = 0x22;
    }
  }
  else {
    if (param_4 == 0xf) {
      local_24 = 0x10010090;
    }
    else {
      if (param_4 == 0x18) {
        local_28 = 3;
        goto LAB_00428cd7;
      }
      if (param_4 != 0x19) goto LAB_00428d19;
      local_24 = 0x10010094;
    }
    local_28 = 4;
    local_20 = *param_1;
    local_18 = *param_2;
    local_10 = *param_3;
    (*_DAT_1000c174)(&local_28);
    (*pcVar2)();
  }
LAB_00428d14:
  *param_3 = local_10;
LAB_00428d19:
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __ceil_default
// 
// Library: Visual Studio 2015 Release

float10 __ceil_default(double param_1)

{
  uint uVar1;
  int iVar2;
  float10 fVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  
  uVar1 = __ctrlfp(0x1b3f,0xffff);
  if ((param_1._6_2_ & 0x7ff0) == 0x7ff0) {
    iVar2 = __sptype();
    if (iVar2 - 1U < 3) {
      __ctrlfp(uVar1,0xffff);
      return (float10)param_1;
    }
    uVar5 = SUB84(_DAT_100100b0 + param_1,0);
    uVar6 = (undefined4)((ulonglong)(_DAT_100100b0 + param_1) >> 0x20);
    uVar4 = 8;
  }
  else {
    fVar3 = (float10)__frnd(SUB84(param_1,0),(int)((ulonglong)param_1 >> 0x20));
    if (((float10)param_1 == fVar3) || ((uVar1 & 0x20) != 0)) {
      __ctrlfp(uVar1,0xffff);
      return (float10)(double)fVar3;
    }
    uVar5 = SUB84((double)fVar3,0);
    uVar6 = (undefined4)((ulonglong)(double)fVar3 >> 0x20);
    uVar4 = 0x10;
  }
  fVar3 = (float10)__except1(uVar4,0xc,param_1,uVar5,uVar6,uVar1);
  return fVar3;
}



// Library Function - Single Match
//  __clrfp
// 
// Library: Visual Studio 2015 Release

int __clrfp(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// Library Function - Single Match
//  __ctrlfp
// 
// Library: Visual Studio 2015 Release

int __ctrlfp(void)

{
  short in_FPUControlWord;
  
  return (int)in_FPUControlWord;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __set_statfp
// 
// Library: Visual Studio 2017 Release

void __set_statfp(void)

{
  return;
}



// Library Function - Single Match
//  __statfp
// 
// Library: Visual Studio 2015 Release

int __statfp(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __d_inttype
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 __d_inttype(double param_1)

{
  uint uVar1;
  float10 fVar2;
  undefined8 extraout_var;
  double dVar3;
  
  uVar1 = __fpclass(param_1);
  if ((uVar1 & 0x90) == 0) {
    fVar2 = (float10)__frnd(param_1,extraout_var);
    if ((float10)param_1 == fVar2) {
      dVar3 = (double)((float10)param_1 * (float10)_DAT_100108f0);
      fVar2 = (float10)__frnd();
      if ((float10)dVar3 == fVar2) {
        return 2;
      }
      return 1;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __powhlp
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 __powhlp(int param_1,int param_2_00,int param_2,int param_4,double *param_3)

{
  double dVar1;
  double dVar2;
  int iVar3;
  
  dVar1 = ABS((double)CONCAT44(param_2_00,param_1));
  dVar2 = _DAT_10010a80;
  if (param_4 == 0x7ff00000) {
    if (param_2 == 0) {
      if ((dVar1 <= 1.0) &&
         (dVar2 = 1.0, (ushort)((ushort)(1.0 < dVar1) << 8 | (ushort)(dVar1 == 1.0) << 0xe) == 0)) {
        dVar2 = 0.0;
      }
      goto LAB_0042901d;
    }
  }
  else if ((param_4 == -0x100000) && (param_2 == 0)) {
    if (dVar1 <= 1.0) {
      dVar2 = 1.0;
      if ((ushort)((ushort)(1.0 < dVar1) << 8 | (ushort)(dVar1 == 1.0) << 0xe) == 0) {
        dVar2 = _DAT_10010a80;
      }
    }
    else {
      dVar2 = 0.0;
    }
    goto LAB_0042901d;
  }
  if (param_2_00 == 0x7ff00000) {
    if (param_1 != 0) {
      return 0;
    }
    dVar1 = (double)CONCAT44(param_4,param_2);
    if (((ushort)((ushort)(dVar1 < 0.0) << 8 | (ushort)(dVar1 == 0.0) << 0xe) != 0) &&
       (dVar2 = 0.0, 0.0 <= dVar1)) {
      dVar2 = 1.0;
    }
  }
  else {
    if (param_2_00 != -0x100000) {
      return 0;
    }
    if (param_1 != 0) {
      return 0;
    }
    iVar3 = __d_inttype(CONCAT44(param_4,param_2));
    dVar1 = (double)CONCAT44(param_4,param_2);
    if ((ushort)((ushort)(dVar1 < 0.0) << 8 | (ushort)(dVar1 == 0.0) << 0xe) == 0) {
      dVar2 = _DAT_10010a80;
      if (iVar3 == 1) {
        dVar2 = -_DAT_10010a80;
      }
    }
    else if (0.0 <= dVar1) {
      dVar2 = 1.0;
    }
    else {
      dVar2 = 0.0;
      if (iVar3 == 1) {
        dVar2 = _DAT_10010a90;
      }
    }
  }
LAB_0042901d:
  *param_3 = dVar2;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __87except
// 
// Library: Visual Studio 2015 Release

void __87except(int param_1,int *param_2,ushort *param_3)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  uint local_94;
  undefined local_90 [48];
  undefined8 local_60;
  uint local_50;
  uint local_14;
  
  local_14 = _DAT_10012000 ^ (uint)&stack0xfffffff0;
  local_94 = (uint)*param_3;
  iVar2 = *param_2;
  if (iVar2 == 1) {
LAB_0042908b:
    uVar3 = 8;
  }
  else if (iVar2 == 2) {
    uVar3 = 4;
  }
  else if (iVar2 == 3) {
    uVar3 = 0x11;
  }
  else if (iVar2 == 4) {
    uVar3 = 0x12;
  }
  else {
    if (iVar2 == 5) goto LAB_0042908b;
    if (iVar2 != 8) goto LAB_004290ed;
    uVar3 = 0x10;
  }
  iVar2 = __handle_exc(uVar3,param_2 + 6,local_94);
  if (iVar2 == 0) {
    if (((param_1 == 0x10) || (param_1 == 0x16)) || (param_1 == 0x1d)) {
      local_60 = *(undefined8 *)(param_2 + 4);
      local_50 = local_50 & 0xffffffe3 | 3;
    }
    else {
      local_50 = local_50 & 0xfffffffe;
    }
    __raise_exc(local_90,&local_94,uVar3,param_1,param_2 + 2,param_2 + 6);
  }
LAB_004290ed:
  __ctrlfp(local_94,0xffff);
  if (((*param_2 == 8) || (cVar1 = ___acrt_has_user_matherr(), cVar1 == '\0')) ||
     (iVar2 = ___acrt_invoke_user_matherr(param_2), iVar2 == 0)) {
    __set_errno_from_matherr(*param_2);
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  __frnd
// 
// Library: Visual Studio 2015 Release

float10 __frnd(double param_1)

{
  return (float10)ROUND(param_1);
}



// Library Function - Single Match
//  __errcode
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __errcode(uint param_1)

{
  int iStack8;
  
  if ((param_1 & 0x20) == 0) {
    if ((param_1 & 8) != 0) {
      return 1;
    }
    if ((param_1 & 4) == 0) {
      if ((param_1 & 1) == 0) {
        return (param_1 & 2) * 2;
      }
      iStack8 = 3;
    }
    else {
      iStack8 = 2;
    }
  }
  else {
    iStack8 = 5;
  }
  return iStack8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __except1
// 
// Library: Visual Studio 2015 Release

void __except1(undefined4 param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,
              undefined4 param_5)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  undefined local_90 [64];
  uint local_50;
  uint local_14;
  
  uVar3 = param_5;
  local_14 = _DAT_10012000 ^ (uint)&stack0xfffffff0;
  iVar2 = __handle_exc(param_1,&param_4,param_5);
  if (iVar2 == 0) {
    local_50 = local_50 & 0xfffffffe;
    __raise_exc_ex(local_90,&param_5,param_1,param_2,&param_3,&param_4,0);
    uVar3 = param_5;
  }
  iVar2 = __errcode(param_1);
  cVar1 = ___acrt_has_user_matherr();
  if ((cVar1 == '\0') || (iVar2 == 0)) {
    __set_errno_from_matherr(iVar2);
    __ctrlfp();
  }
  else {
    __umatherr(iVar2,param_2,param_3,0,param_4,uVar3);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __handle_exc
// 
// Library: Visual Studio 2017 Release

bool __handle_exc(uint param_1,double *param_2,uint param_3)

{
  double dVar1;
  double dVar2;
  double dVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  float10 fVar8;
  float10 fVar9;
  uint local_14;
  byte bStack16;
  undefined uStack15;
  ushort uStack14;
  uint local_8;
  
  uVar7 = param_1 & 0x1f;
  if (((param_1 & 8) != 0) && ((param_3 & 1) != 0)) {
    __set_statfp(1);
    uVar7 = param_1 & 0x17;
    goto LAB_00429410;
  }
  if ((param_1 & param_3 & 4) != 0) {
    __set_statfp(4);
    uVar7 = param_1 & 0x1b;
    goto LAB_00429410;
  }
  if (((param_1 & 1) == 0) || ((param_3 & 8) == 0)) {
    if (((param_1 & 2) != 0) && ((param_3 & 0x10) != 0)) {
      uVar7 = param_1 >> 4 & 1;
      if (*param_2 == 0.0) {
        uVar7 = 1;
      }
      else {
        fVar8 = (float10)__decomp(*param_2,&local_8);
        iVar4 = local_8 - 0x600;
        dVar2 = (double)fVar8;
        local_14 = SUB84(dVar2,0);
        bStack16 = (byte)((ulonglong)dVar2 >> 0x20);
        uStack15 = (undefined)((ulonglong)dVar2 >> 0x28);
        uStack14 = (ushort)((ulonglong)dVar2 >> 0x30);
        fVar9 = (float10)0;
        if (iVar4 < -0x432) {
          fVar9 = fVar9 * fVar8;
          uVar7 = 1;
        }
        else {
          local_8 = (uint)((ushort)((ushort)(fVar9 < fVar8) << 8 | (ushort)(fVar9 == fVar8) << 0xe)
                          == 0);
          uStack14 = uStack14 & 0xf | 0x10;
          if (iVar4 < -0x3fd) {
            iVar4 = -0x3fd - iVar4;
            uVar5 = (uint)((ulonglong)dVar2 >> 0x20) & 0xfffff | 0x100000;
            do {
              if (((local_14 & 1) != 0) && (uVar7 == 0)) {
                uVar7 = 1;
              }
              local_14 = local_14 >> 1;
              if ((bStack16 & 1) != 0) {
                local_14 = local_14 | 0x80000000;
              }
              uVar6 = uVar5 >> 1;
              bStack16 = (byte)uVar6;
              uStack15 = (undefined)(uVar6 >> 8);
              uStack14 = (ushort)(uVar5 >> 0x11);
              iVar4 = iVar4 + -1;
              uVar5 = uVar6;
            } while (iVar4 != 0);
          }
          fVar9 = (float10)(double)CONCAT26(uStack14,CONCAT15(uStack15,CONCAT14(bStack16,local_14)))
          ;
          if (local_8 != 0) {
            fVar9 = -fVar9;
          }
        }
        *param_2 = (double)fVar9;
      }
      if (uVar7 != 0) {
        __set_statfp(0x10);
      }
      uVar7 = param_1 & 0x1d;
    }
    goto LAB_00429410;
  }
  __set_statfp(8);
  uVar7 = param_3 & 0xc00;
  dVar2 = _DAT_10010a80;
  dVar3 = _DAT_10010a80;
  if (uVar7 == 0) {
    dVar1 = *param_2;
joined_r0x004292e7:
    if (dVar1 <= 0.0) {
      dVar2 = -dVar3;
    }
    *param_2 = dVar2;
  }
  else {
    if (uVar7 == 0x400) {
      dVar1 = *param_2;
      dVar2 = _DAT_10010a88;
      goto joined_r0x004292e7;
    }
    dVar3 = _DAT_10010a88;
    if (uVar7 == 0x800) {
      dVar1 = *param_2;
      goto joined_r0x004292e7;
    }
    if (uVar7 == 0xc00) {
      dVar1 = *param_2;
      dVar2 = _DAT_10010a88;
      goto joined_r0x004292e7;
    }
  }
  uVar7 = param_1 & 0x1e;
LAB_00429410:
  if (((param_1 & 0x10) != 0) && ((param_3 & 0x20) != 0)) {
    __set_statfp(0x20);
    uVar7 = uVar7 & 0xffffffef;
  }
  return uVar7 == 0;
}



// Library Function - Single Match
//  __raise_exc
// 
// Library: Visual Studio 2015 Release

void __raise_exc(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                undefined4 param_5,undefined4 param_6)

{
  __raise_exc_ex(param_1,param_2,param_3,param_4,param_5,param_6,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __raise_exc_ex
// 
// Library: Visual Studio 2015 Release

void __raise_exc_ex(uint *param_1,uint *param_2,uint param_3,int param_4,undefined8 *param_5,
                   undefined8 *param_6,int param_7)

{
  uint *puVar1;
  undefined8 *puVar2;
  uint uVar3;
  undefined4 uVar4;
  
  puVar1 = param_2;
  param_1[1] = 0;
  uVar4 = 0xc000000d;
  param_1[2] = 0;
  param_1[3] = 0;
  if ((param_3 & 0x10) != 0) {
    uVar4 = 0xc000008f;
    param_1[1] = param_1[1] | 1;
  }
  if ((param_3 & 2) != 0) {
    uVar4 = 0xc0000093;
    param_1[1] = param_1[1] | 2;
  }
  if ((param_3 & 1) != 0) {
    uVar4 = 0xc0000091;
    param_1[1] = param_1[1] | 4;
  }
  if ((param_3 & 4) != 0) {
    uVar4 = 0xc000008e;
    param_1[1] = param_1[1] | 8;
  }
  if ((param_3 & 8) != 0) {
    uVar4 = 0xc0000090;
    param_1[1] = param_1[1] | 0x10;
  }
  param_1[2] = param_1[2] ^ (~(*param_2 << 4) ^ param_1[2]) & 0x10;
  param_1[2] = param_1[2] ^ (~(*param_2 * 2) ^ param_1[2]) & 8;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 1) ^ param_1[2]) & 4;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 3) ^ param_1[2]) & 2;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 5) ^ param_1[2]) & 1;
  uVar3 = __statfp();
  puVar2 = param_6;
  if ((uVar3 & 1) != 0) {
    param_1[3] = param_1[3] | 0x10;
  }
  if ((uVar3 & 4) != 0) {
    param_1[3] = param_1[3] | 8;
  }
  if ((uVar3 & 8) != 0) {
    param_1[3] = param_1[3] | 4;
  }
  if ((uVar3 & 0x10) != 0) {
    param_1[3] = param_1[3] | 2;
  }
  if ((uVar3 & 0x20) != 0) {
    param_1[3] = param_1[3] | 1;
  }
  uVar3 = *puVar1 & 0xc00;
  if (uVar3 == 0) {
    *param_1 = *param_1 & 0xfffffffc;
  }
  else {
    if (uVar3 == 0x400) {
      uVar3 = *param_1 & 0xfffffffd | 1;
    }
    else {
      if (uVar3 != 0x800) {
        if (uVar3 == 0xc00) {
          *param_1 = *param_1 | 3;
        }
        goto LAB_004295b8;
      }
      uVar3 = *param_1 & 0xfffffffe | 2;
    }
    *param_1 = uVar3;
  }
LAB_004295b8:
  uVar3 = *puVar1 & 0x300;
  if (uVar3 == 0) {
    uVar3 = *param_1 & 0xffffffeb | 8;
LAB_004295ee:
    *param_1 = uVar3;
  }
  else {
    if (uVar3 == 0x200) {
      uVar3 = *param_1 & 0xffffffe7 | 4;
      goto LAB_004295ee;
    }
    if (uVar3 == 0x300) {
      *param_1 = *param_1 & 0xffffffe3;
    }
  }
  *param_1 = *param_1 ^ (param_4 << 5 ^ *param_1) & 0x1ffe0;
  param_1[8] = param_1[8] | 1;
  if (param_7 == 0) {
    param_1[8] = param_1[8] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 4) = *param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 0x14) = *param_6;
  }
  else {
    param_1[8] = param_1[8] & 0xffffffe1;
    param_1[4] = *(uint *)param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe1;
    param_1[0x14] = *(uint *)param_6;
  }
  __clrfp();
  (*_DAT_1000c0b8)(uVar4,0,1,&param_1);
  if ((*(byte *)(param_1 + 2) & 0x10) != 0) {
    *puVar1 = *puVar1 & 0xfffffffe;
  }
  if ((*(byte *)(param_1 + 2) & 8) != 0) {
    *puVar1 = *puVar1 & 0xfffffffb;
  }
  if ((*(byte *)(param_1 + 2) & 4) != 0) {
    *puVar1 = *puVar1 & 0xfffffff7;
  }
  if ((*(byte *)(param_1 + 2) & 2) != 0) {
    *puVar1 = *puVar1 & 0xffffffef;
  }
  if ((*(byte *)(param_1 + 2) & 1) != 0) {
    *puVar1 = *puVar1 & 0xffffffdf;
  }
  uVar3 = *param_1 & 3;
  if (uVar3 == 0) {
    *puVar1 = *puVar1 & 0xfffff3ff;
  }
  else {
    if (uVar3 == 1) {
      uVar3 = *puVar1 & 0xfffff7ff | 0x400;
    }
    else {
      if (uVar3 != 2) {
        if (uVar3 == 3) {
          *puVar1 = *puVar1 | 0xc00;
        }
        goto LAB_004296ff;
      }
      uVar3 = *puVar1 & 0xfffffbff | 0x800;
    }
    *puVar1 = uVar3;
  }
LAB_004296ff:
  uVar3 = *param_1 >> 2 & 7;
  if (uVar3 == 0) {
    uVar3 = *puVar1 & 0xfffff3ff | 0x300;
  }
  else {
    if (uVar3 != 1) {
      if (uVar3 == 2) {
        *puVar1 = *puVar1 & 0xfffff3ff;
      }
      goto LAB_00429730;
    }
    uVar3 = *puVar1 & 0xfffff3ff | 0x200;
  }
  *puVar1 = uVar3;
LAB_00429730:
  if (param_7 == 0) {
    *puVar2 = *(undefined8 *)(param_1 + 0x14);
  }
  else {
    *(uint *)puVar2 = param_1[0x14];
  }
  return;
}



// Library Function - Single Match
//  __set_errno_from_matherr
// 
// Library: Visual Studio 2015 Release

void __set_errno_from_matherr(int param_1)

{
  undefined4 *puVar1;
  
  if (param_1 == 1) {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 0x21;
  }
  else if (param_1 - 2U < 2) {
    puVar1 = (undefined4 *)FUN_00423633();
    *puVar1 = 0x22;
    return;
  }
  return;
}



// Library Function - Single Match
//  __umatherr
// 
// Library: Visual Studio 2015 Release

float10 __umatherr(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4,
                  undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8_00,
                  undefined4 param_8)

{
  double dVar1;
  int iVar2;
  undefined4 local_24;
  int local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 uStack8;
  
  local_20 = 0;
  iVar2 = 0;
  do {
    if (*(int *)(&DAT_100108f8 + iVar2 * 8) == param_2) {
      local_20 = *(int *)(&DAT_100108fc + iVar2 * 8);
      break;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 < 0x1d);
  if (local_20 == 0) {
    __ctrlfp(param_8,0xffff);
    __set_errno_from_matherr(param_1);
    dVar1 = (double)CONCAT44(param_8_00,param_7);
  }
  else {
    local_1c = param_3;
    local_18 = param_4;
    local_14 = param_5;
    local_10 = param_6;
    local_c = param_7;
    local_24 = param_1;
    uStack8 = param_8_00;
    __ctrlfp(param_8,0xffff);
    iVar2 = ___acrt_invoke_user_matherr(&local_24);
    if (iVar2 == 0) {
      __set_errno_from_matherr(param_1);
    }
    dVar1 = (double)CONCAT44(uStack8,local_c);
  }
  return (float10)dVar1;
}



// Library Function - Single Match
//  __decomp
// 
// Library: Visual Studio 2015 Release

void __decomp(int param_1,uint param_2_00,int *param_2)

{
  uint uVar1;
  double dVar2;
  ushort uVar3;
  int iVar4;
  
  dVar2 = (double)CONCAT17(param_2_00._3_1_,
                           CONCAT16(param_2_00._2_1_,CONCAT24((undefined2)param_2_00,param_1)));
  if (dVar2 == 0.0) {
    iVar4 = 0;
  }
  else {
    uVar3 = (ushort)(param_2_00 >> 0x10);
    if (((param_2_00 & 0x7ff00000) == 0) && (((param_2_00 & 0xfffff) != 0 || (param_1 != 0)))) {
      iVar4 = -0x3fd;
      if ((param_2_00 & 0x100000) == 0) {
        do {
          uVar1 = param_2_00 * 2;
          param_2_00._0_2_ = (undefined2)uVar1;
          param_2_00 = uVar1;
          if (param_1 < 0) {
            param_2_00 = uVar1 | 1;
          }
          param_1 = param_1 * 2;
          iVar4 = iVar4 + -1;
        } while ((uVar1 & 0x100000) == 0);
        uVar3 = (ushort)(uVar1 >> 0x10);
      }
      param_2_00._2_1_ = (undefined)(uVar3 & 0xffef);
      param_2_00._3_1_ = (byte)((uVar3 & 0xffef) >> 8);
      if ((ushort)((ushort)(0.0 < dVar2) << 8 | (ushort)(dVar2 == 0.0) << 0xe) == 0) {
        param_2_00._3_1_ = param_2_00._3_1_ | 0x80;
      }
      __set_exp(CONCAT17(param_2_00._3_1_,
                         CONCAT16(param_2_00._2_1_,CONCAT24((undefined2)param_2_00,param_1))),0);
    }
    else {
      __set_exp(dVar2,0);
      iVar4 = (uVar3 >> 4 & 0x7ff) - 0x3fe;
    }
  }
  *param_2 = iVar4;
  return;
}



// Library Function - Single Match
//  __set_exp
// 
// Library: Visual Studio 2015 Release

float10 __set_exp(ulonglong param_1,short param_2)

{
  double local_c;
  
  local_c = (double)(param_1 & 0xffffffffffff |
                    (ulonglong)(ushort)((param_2 + 0x3fe) * 0x10 | param_1._6_2_ & 0x800f) << 0x30);
  return (float10)local_c;
}



// Library Function - Single Match
//  __sptype
// 
// Library: Visual Studio 2015 Release

undefined4 __sptype(int param_1,uint param_2)

{
  undefined4 uStack8;
  
  if (param_2 == 0x7ff00000) {
    if (param_1 == 0) {
      return 1;
    }
  }
  else if ((param_2 == 0xfff00000) && (param_1 == 0)) {
    return 2;
  }
  if ((param_2._2_2_ & 0x7ff8) == 0x7ff8) {
    uStack8 = 3;
  }
  else {
    if (((param_2._2_2_ & 0x7ff8) != 0x7ff0) || (((param_2 & 0x7ffff) == 0 && (param_1 == 0)))) {
      return 0;
    }
    uStack8 = 4;
  }
  return uStack8;
}



// Library Function - Single Match
//  __fpclass
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __fpclass(double _X)

{
  int iVar1;
  int iStack8;
  
  if ((_X._6_2_ & 0x7ff0) == 0x7ff0) {
    iVar1 = __sptype();
    if (iVar1 == 1) {
      return 0x200;
    }
    if (iVar1 == 2) {
      iStack8 = 4;
    }
    else {
      if (iVar1 != 3) {
        return 1;
      }
      iStack8 = 2;
    }
    return iStack8;
  }
  if ((((ulonglong)_X & 0x7ff0000000000000) == 0) &&
     ((((ulonglong)_X & 0xfffff00000000) != 0 || (_X._0_4_ != 0)))) {
    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff90) + 0x80;
  }
  if (_X == 0.0) {
    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffffe0) + 0x40;
  }
  return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff08) + 0x100;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00429a1d(void)

{
                    // WARNING: Could not recover jumptable at 0x00429a1d. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_1000c090)();
  return;
}



// Library Function - Single Match
//  __FindPESection
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase,DWORD_PTR rva)

{
  int iVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  uint uVar3;
  
  uVar3 = 0;
  iVar1 = *(int *)(pImageBase + 0x3c);
  p_Var2 = (PIMAGE_SECTION_HEADER)
           (pImageBase + *(ushort *)(pImageBase + iVar1 + 0x14) + 0x18 + iVar1);
  if (*(ushort *)(pImageBase + iVar1 + 6) != 0) {
    do {
      if ((p_Var2->VirtualAddress <= rva) && (rva < p_Var2->Misc + p_Var2->VirtualAddress)) {
        return p_Var2;
      }
      uVar3 = uVar3 + 1;
      p_Var2 = p_Var2 + 1;
    } while (uVar3 < *(ushort *)(pImageBase + iVar1 + 6));
  }
  return (PIMAGE_SECTION_HEADER)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __IsNonwritableInCurrentImage
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2019 Release

BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)

{
  uint uVar1;
  BOOL BVar2;
  PIMAGE_SECTION_HEADER p_Var3;
  int **in_FS_OFFSET;
  int *local_14;
  undefined4 uStack16;
  uint local_c;
  undefined4 local_8;
  
  uStack16 = 0x10002520;
  local_14 = *in_FS_OFFSET;
  local_c = _DAT_10012000 ^ 0x10011520;
  *in_FS_OFFSET = (int *)&local_14;
  local_8 = 0;
  BVar2 = __ValidateImageBase(&DAT_10000000);
  if (BVar2 != 0) {
    p_Var3 = __FindPESection(&DAT_10000000,(DWORD_PTR)(pTarget + -0x10000000));
    if (p_Var3 != (PIMAGE_SECTION_HEADER)0x0) {
      uVar1 = p_Var3->Characteristics;
      *in_FS_OFFSET = local_14;
      return ~(uVar1 >> 0x1f) & 1;
    }
  }
  *in_FS_OFFSET = local_14;
  return 0;
}



// Library Function - Single Match
//  __ValidateImageBase
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release

BOOL __cdecl __ValidateImageBase(PBYTE pImageBase)

{
  uint uVar1;
  
  if (*(short *)pImageBase != 0x5a4d) {
    return 0;
  }
  uVar1 = 0;
  if (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550) {
    uVar1 = (uint)(*(short *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b);
  }
  return uVar1;
}



// Library Function - Single Match
//  __alldvrm
// 
// Library: Visual Studio

undefined8 __alldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT44(uVar3,iVar4);
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __SEH_prolog4_GS
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __SEH_prolog4_GS(undefined4 param_1,int param_2)

{
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  param_2 = -param_2;
  *(undefined4 *)((int)auStack28 + param_2 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + param_2 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + param_2 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + param_2 + 4) = _DAT_10012000 ^ (uint)&stack0x00000008;
  *(undefined4 *)((int)auStack28 + param_2) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

void FUN_00429d47(void)

{
  ___security_check_cookie_4();
  return;
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

uint __alloca_probe_16(void)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 0xf;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

uint __alloca_probe_8(void)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 7;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __alloca_probe
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __alloca_probe(void)

{
  undefined *in_EAX;
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 unaff_retaddr;
  undefined auStack4 [4];
  
  puVar2 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX))
  ;
  for (puVar1 = (undefined4 *)((uint)auStack4 & 0xfffff000); puVar2 < puVar1;
      puVar1 = puVar1 + -0x400) {
  }
  *puVar2 = unaff_retaddr;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _strrchr
// 
// Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

char * __cdecl _strrchr(char *_Str,int _Ch)

{
  uint uVar1;
  undefined (*pauVar2) [16];
  uint uVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  undefined (*pauVar7) [16];
  undefined auVar8 [16];
  undefined auVar10 [16];
  char cVar13;
  char cVar14;
  char cVar15;
  char cVar16;
  char cVar17;
  char cVar18;
  char cVar19;
  undefined auVar12 [16];
  byte bVar9;
  byte bVar11;
  
  if (_DAT_10012b40 != 0) {
    if (_DAT_10012b40 < 2) {
      auVar12 = pshuflw(ZEXT216(CONCAT11((char)_Ch,(char)_Ch)),
                        ZEXT216(CONCAT11((char)_Ch,(char)_Ch)),0);
      uVar1 = -1 << (sbyte)((uint)_Str & 0xf);
      pcVar6 = _Str + -((uint)_Str & 0xf);
      pcVar5 = (char *)0x0;
      while( true ) {
        bVar11 = -(pcVar6[0xf] == '\0');
        auVar10 = CONCAT115(bVar11,CONCAT114(-(pcVar6[0xe] == '\0'),
                                             CONCAT113(-(pcVar6[0xd] == '\0'),
                                                       CONCAT112(-(pcVar6[0xc] == '\0'),
                                                                 CONCAT111(-(pcVar6[0xb] == '\0'),
                                                                           CONCAT110(-(pcVar6[10] ==
                                                                                      '\0'),CONCAT19
                                                  (-(pcVar6[9] == '\0'),
                                                   CONCAT18(-(pcVar6[8] == '\0'),
                                                            CONCAT17(-(pcVar6[7] == '\0'),
                                                                     CONCAT16(-(pcVar6[6] == '\0'),
                                                                              CONCAT15(-(pcVar6[5]
                                                                                        == '\0'),
                                                                                       CONCAT14(-(
                                                  pcVar6[4] == '\0'),
                                                  CONCAT13(-(pcVar6[3] == '\0'),
                                                           CONCAT12(-(pcVar6[2] == '\0'),
                                                                    CONCAT11(-(pcVar6[1] == '\0'),
                                                                             -(*pcVar6 == '\0'))))))
                                                  ))))))))));
        cVar13 = SUB161(auVar12 >> 8,0);
        cVar14 = SUB161(auVar12 >> 0x10,0);
        cVar15 = SUB161(auVar12 >> 0x18,0);
        cVar16 = SUB161(auVar12 >> 0x20,0);
        cVar17 = SUB161(auVar12 >> 0x28,0);
        cVar18 = SUB161(auVar12 >> 0x30,0);
        cVar19 = SUB161(auVar12 >> 0x38,0);
        bVar9 = -(pcVar6[0xf] == cVar19);
        auVar8 = CONCAT115(bVar9,CONCAT114(-(pcVar6[0xe] == cVar18),
                                           CONCAT113(-(pcVar6[0xd] == cVar17),
                                                     CONCAT112(-(pcVar6[0xc] == cVar16),
                                                               CONCAT111(-(pcVar6[0xb] == cVar15),
                                                                         CONCAT110(-(pcVar6[10] ==
                                                                                    cVar14),CONCAT19
                                                  (-(pcVar6[9] == cVar13),
                                                   CONCAT18(-(pcVar6[8] == SUB161(auVar12,0)),
                                                            CONCAT17(-(pcVar6[7] == cVar19),
                                                                     CONCAT16(-(pcVar6[6] == cVar18)
                                                                              ,CONCAT15(-(pcVar6[5]
                                                                                         == cVar17),
                                                                                        CONCAT14(-(
                                                  pcVar6[4] == cVar16),
                                                  CONCAT13(-(pcVar6[3] == cVar15),
                                                           CONCAT12(-(pcVar6[2] == cVar14),
                                                                    CONCAT11(-(pcVar6[1] == cVar13),
                                                                             -(*pcVar6 ==
                                                                              SUB161(auVar12,0))))))
                                                  )))))))))));
        uVar3 = (ushort)((ushort)(SUB161(auVar10 >> 7,0) & 1) |
                         (ushort)(SUB161(auVar10 >> 0xf,0) & 1) << 1 |
                         (ushort)(SUB161(auVar10 >> 0x17,0) & 1) << 2 |
                         (ushort)(SUB161(auVar10 >> 0x1f,0) & 1) << 3 |
                         (ushort)(SUB161(auVar10 >> 0x27,0) & 1) << 4 |
                         (ushort)(SUB161(auVar10 >> 0x2f,0) & 1) << 5 |
                         (ushort)(SUB161(auVar10 >> 0x37,0) & 1) << 6 |
                         (ushort)(SUB161(auVar10 >> 0x3f,0) & 1) << 7 |
                         (ushort)(SUB161(auVar10 >> 0x47,0) & 1) << 8 |
                         (ushort)(SUB161(auVar10 >> 0x4f,0) & 1) << 9 |
                         (ushort)(SUB161(auVar10 >> 0x57,0) & 1) << 10 |
                         (ushort)(SUB161(auVar10 >> 0x5f,0) & 1) << 0xb |
                         (ushort)(SUB161(auVar10 >> 0x67,0) & 1) << 0xc |
                         (ushort)(SUB161(auVar10 >> 0x6f,0) & 1) << 0xd |
                         (ushort)(SUB161(auVar10 >> 0x77,0) & 1) << 0xe |
                        (ushort)(bVar11 >> 7) << 0xf) & uVar1;
        if (uVar3 != 0) break;
        uVar1 = (ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                         (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                         (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                         (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                         (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                         (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                         (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                         (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                         (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                         (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                         (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                         (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                         (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                         (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                         (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe | (ushort)(bVar9 >> 7) << 0xf
                        ) & uVar1;
        iVar4 = 0x1f;
        if (uVar1 != 0) {
          for (; uVar1 >> iVar4 == 0; iVar4 = iVar4 + -1) {
          }
        }
        if (uVar1 != 0) {
          pcVar5 = pcVar6 + iVar4;
        }
        uVar1 = 0xffffffff;
        pcVar6 = pcVar6 + 0x10;
      }
      uVar1 = (uVar3 * 2 & uVar3 * -2) - 1 &
              (ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                       (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                       (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                       (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                       (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                       (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                       (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                       (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                       (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                       (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                       (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                       (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                       (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                       (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                       (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe | (ushort)(bVar9 >> 7) << 0xf)
              & uVar1;
      iVar4 = 0x1f;
      if (uVar1 != 0) {
        for (; uVar1 >> iVar4 == 0; iVar4 = iVar4 + -1) {
        }
      }
      pcVar6 = pcVar6 + iVar4;
      if (uVar1 == 0) {
        pcVar6 = pcVar5;
      }
      return pcVar6;
    }
    uVar1 = _Ch & 0xff;
    if (uVar1 == 0) {
      pcVar5 = (char *)((uint)_Str & 0xfffffff0);
      auVar12 = CONCAT115(-(pcVar5[0xf] == '\0'),
                          CONCAT114(-(pcVar5[0xe] == '\0'),
                                    CONCAT113(-(pcVar5[0xd] == '\0'),
                                              CONCAT112(-(pcVar5[0xc] == '\0'),
                                                        CONCAT111(-(pcVar5[0xb] == '\0'),
                                                                  CONCAT110(-(pcVar5[10] == '\0'),
                                                                            CONCAT19(-(pcVar5[9] ==
                                                                                      '\0'),CONCAT18
                                                  (-(pcVar5[8] == '\0'),
                                                   CONCAT17(-(pcVar5[7] == '\0'),
                                                            CONCAT16(-(pcVar5[6] == '\0'),
                                                                     CONCAT15(-(pcVar5[5] == '\0'),
                                                                              CONCAT14(-(pcVar5[4]
                                                                                        == '\0'),
                                                                                       CONCAT13(-(
                                                  pcVar5[3] == '\0'),
                                                  CONCAT12(-(pcVar5[2] == '\0'),
                                                           CONCAT11(-(pcVar5[1] == '\0'),
                                                                    -(*pcVar5 == '\0')))))))))))))))
                         );
      uVar1 = (uint)(ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |
                             (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |
                             (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |
                             (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |
                             (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |
                             (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |
                             (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |
                             (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |
                             (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |
                             (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |
                             (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |
                             (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |
                             (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |
                             (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |
                             (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |
                            (ushort)((byte)-(pcVar5[0xf] == '\0') >> 7) << 0xf) &
              -1 << ((byte)_Str & 0xf);
      while (uVar1 == 0) {
        pcVar6 = pcVar5 + 0x1f;
        auVar12 = CONCAT115(-(*pcVar6 == '\0'),
                            CONCAT114(-(pcVar5[0x1e] == '\0'),
                                      CONCAT113(-(pcVar5[0x1d] == '\0'),
                                                CONCAT112(-(pcVar5[0x1c] == '\0'),
                                                          CONCAT111(-(pcVar5[0x1b] == '\0'),
                                                                    CONCAT110(-(pcVar5[0x1a] == '\0'
                                                                               ),CONCAT19(-(pcVar5[
                                                  0x19] == '\0'),
                                                  CONCAT18(-(pcVar5[0x18] == '\0'),
                                                           CONCAT17(-(pcVar5[0x17] == '\0'),
                                                                    CONCAT16(-(pcVar5[0x16] == '\0')
                                                                             ,CONCAT15(-(pcVar5[0x15
                                                  ] == '\0'),
                                                  CONCAT14(-(pcVar5[0x14] == '\0'),
                                                           CONCAT13(-(pcVar5[0x13] == '\0'),
                                                                    CONCAT12(-(pcVar5[0x12] == '\0')
                                                                             ,CONCAT11(-(pcVar5[0x11
                                                  ] == '\0'),-(pcVar5[0x10] == '\0'))))))))))))))));
        pcVar5 = pcVar5 + 0x10;
        uVar1 = (uint)(ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |
                               (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |
                               (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |
                               (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |
                               (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |
                               (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |
                               (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |
                               (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |
                               (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |
                               (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |
                               (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |
                               (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |
                               (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |
                               (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |
                               (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |
                              (ushort)((byte)-(*pcVar6 == '\0') >> 7) << 0xf);
      }
      iVar4 = 0;
      if (uVar1 != 0) {
        for (; (uVar1 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
        }
      }
      pauVar2 = (undefined (*) [16])(pcVar5 + iVar4);
    }
    else {
      pauVar2 = (undefined (*) [16])0x0;
      uVar3 = (uint)_Str & 0xf;
      while (uVar3 != 0) {
        if ((byte)*_Str == uVar1) {
          pauVar2 = (undefined (*) [16])_Str;
        }
        if ((byte)*_Str == 0) {
          return (char *)pauVar2;
        }
        _Str = _Str + 1;
        uVar3 = (uint)_Str & 0xf;
      }
      do {
        pauVar7 = (undefined (*) [16])((int)_Str + 0x10);
        iVar4 = pcmpistri(ZEXT416(uVar1),*(undefined (*) [16])_Str,0x40);
        if ((undefined (*) [16])0xffffffef < _Str) {
          pauVar2 = (undefined (*) [16])(pauVar7[-1] + iVar4);
        }
        _Str = (char *)pauVar7;
      } while (pauVar7 != (undefined (*) [16])0x0);
    }
    return (char *)pauVar2;
  }
  iVar4 = -1;
  do {
    pcVar5 = _Str;
    if (iVar4 == 0) break;
    iVar4 = iVar4 + -1;
    pcVar5 = _Str + 1;
    cVar13 = *_Str;
    _Str = pcVar5;
  } while (cVar13 != '\0');
  iVar4 = -(iVar4 + 1);
  pcVar5 = pcVar5 + -1;
  do {
    pcVar6 = pcVar5;
    if (iVar4 == 0) break;
    iVar4 = iVar4 + -1;
    pcVar6 = pcVar5 + -1;
    cVar13 = *pcVar5;
    pcVar5 = pcVar6;
  } while ((char)_Ch != cVar13);
  pcVar6 = pcVar6 + 1;
  if (*pcVar6 != (char)_Ch) {
    pcVar6 = (char *)0x0;
  }
  return pcVar6;
}



undefined4 FUN_00670f6d(void)

{
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00670f7d(void)

{
  code *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined local_c [4];
  uint local_8;
  
  pcVar1 = _DAT_1000c070;
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar2 = (*_DAT_1000c070)(0x10010ad4,0x10000000,3,0,3,0,0);
  uVar3 = (*pcVar1)(0x10010a98,0x80000000,0,0,3,0,0);
  uVar4 = (*_DAT_1000c06c)(uVar3,0);
  uVar5 = FUN_00671700(uVar4);
  (*_DAT_1000c068)(uVar3,uVar5,uVar4,local_c,0);
  (*_DAT_1000c064)(uVar2,uVar5,uVar4,local_c,0);
  (*_DAT_1000c060)(uVar2);
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067101d(void)

{
  undefined4 uVar1;
  code *pcVar2;
  code *pcVar3;
  undefined local_10 [7];
  undefined local_9;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_1000c05c)(0x10010afc);
  pcVar3 = _DAT_1000c058;
  pcVar2 = (code *)(*_DAT_1000c058)(uVar1,0x10010b04);
  pcVar3 = (code *)(*pcVar3)(uVar1,0x10010b18);
  if ((pcVar2 != (code *)0x0) && (pcVar3 != (code *)0x0)) {
    (*pcVar2)(0x13,1,0,&local_9);
    (*pcVar3)(0xc0000022,0,0,0,6,local_10);
  }
  (*_DAT_1000c164)(6,0x5000f);
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_006710ad(void)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  __time64_t _Var4;
  undefined local_18 [8];
  int local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar1,local_18);
  uVar1 = (*_DAT_1000c158)(0);
  iVar2 = 0x1d4c;
  do {
    do {
      iVar3 = iVar2;
      (*_DAT_1000c054)(iVar3);
      _Var4 = FID_conflict___time64((__time64_t *)0x0);
      FUN_00673d8a((int)_Var4);
      iVar2 = FUN_00673d69(0x8800c6);
      iVar2 = FUN_00673d69(local_c + 0xf + iVar2 % 0xf);
      iVar2 = FUN_00673d69(uVar1,0,0,local_10 + 0xf + iVar2 % 0xf);
      iVar2 = FUN_00673d69((local_c - iVar2 % 0xf) + 0xf);
      iVar2 = FUN_00673d69((local_10 - iVar2 % 0xf) + 0xf);
      iVar2 = FUN_00673d69(iVar2 % 0xf + 0xf);
      (*_DAT_1000c028)(uVar1,iVar2 % 0xf + 0xf);
      iVar2 = FUN_00673d69(0xee0086);
      iVar2 = FUN_00673d69(local_c + 0xf + iVar2 % 0xf);
      iVar2 = FUN_00673d69(uVar1,0,0,local_10 + 0xf + iVar2 % 0xf);
      iVar2 = FUN_00673d69((local_c - iVar2 % 0xf) + 0xf);
      iVar2 = FUN_00673d69((local_10 - iVar2 % 0xf) + 0xf);
      iVar2 = FUN_00673d69(iVar2 % 0xf + 0xf);
      (*_DAT_1000c028)(uVar1,iVar2 % 0xf + 0xf);
      iVar2 = iVar3 + -0x2ee;
    } while (0x2ee < iVar3);
    iVar2 = iVar3;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067121d(void)

{
  undefined4 uVar1;
  int iVar2;
  undefined local_18 [12];
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar1,local_18);
  uVar1 = (*_DAT_1000c158)(0);
  iVar2 = 0;
  if (local_c != 0) {
    do {
      (*_DAT_1000c028)(uVar1,iVar2,0,10,local_c,uVar1,iVar2,0,10,local_c,0x550009);
      iVar2 = iVar2 + 1;
    } while (iVar2 != local_c);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067128d(void)

{
  code *pcVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  undefined local_18 [8];
  int local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar8 = 0;
  iVar7 = 0;
  uVar2 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar2,local_18);
  pcVar1 = _DAT_1000c154;
  iVar3 = (*_DAT_1000c154)(0xb);
  iVar4 = (*pcVar1)(0xc);
  if (0 < local_c) {
    do {
      (*_DAT_1000c054)(5);
      uVar2 = (*_DAT_1000c14c)(0,0x7f02);
      uVar2 = (*_DAT_1000c158)(0,iVar7,iVar8,uVar2);
      (*_DAT_1000c150)(uVar2);
      iVar6 = iVar4 + iVar7;
      iVar5 = iVar3 + iVar8;
      if (iVar6 != local_10) {
        iVar5 = iVar8;
      }
      iVar7 = 0;
      if (iVar6 != local_10) {
        iVar7 = iVar6;
      }
      iVar8 = iVar5;
    } while (iVar5 < local_c);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067132d(void)

{
  undefined local_1c [16];
  undefined4 local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_c = 0;
  local_1c = ZEXT1216(ZEXT412(0x204) << 0x40);
  (*_DAT_1000c16c)(0,0x803,0x3000,local_1c);
  (*_DAT_1000c16c)(local_1c._4_4_,0x80d,0x100,0);
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067138d(void)

{
  code *pcVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  short local_10 [2];
  short local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar2 = (*_DAT_1000c050)(0x10010b2c);
  if (iVar2 != 0) {
    do {
      pcVar1 = _DAT_1000c154;
      (*_DAT_1000c054)(0x68);
      uVar3 = (*_DAT_1000c158)(0);
      (*_DAT_1000c024)(uVar3,1);
      (*_DAT_1000c148)(local_10);
      iVar4 = (*pcVar1)(0xb);
      iVar5 = (*pcVar1)(0xc);
      uVar6 = (*_DAT_1000c14c)(iVar2,0x67);
      (*_DAT_1000c150)(uVar3,(int)local_10[0] - iVar4 / 2,(int)local_c - iVar5 / 2,uVar6);
    } while( true );
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067142d(void)

{
  undefined4 uVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  __time64_t _Var9;
  int local_28;
  int local_20;
  int local_1c;
  undefined local_18 [8];
  int local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar1 = (*_DAT_1000c158)(0);
  uVar2 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar2,local_18);
  uVar6 = local_10 >> 0x1f;
  local_1c = 0;
  local_20 = 0;
  iVar3 = (int)(local_10 + (uVar6 & 3)) >> 2;
  iVar5 = iVar3;
  iVar8 = iVar3;
  do {
    (*_DAT_1000c054)(0x10);
    _Var9 = FID_conflict___time64((__time64_t *)0x0);
    FUN_00673d8a((int)_Var9);
    local_1c = local_1c + iVar5;
    iVar7 = iVar5;
    if (local_10 / 2 <= local_1c) {
      iVar7 = -((int)((uVar6 & 3) + local_10) >> 2);
    }
    iVar5 = iVar3;
    if (SBORROW4(local_1c,-(local_10 / 2)) == local_1c + local_10 / 2 < 0) {
      iVar5 = iVar7;
    }
    local_20 = local_20 + iVar8;
    local_28 = iVar8;
    if (local_c / 2 <= local_20) {
      local_28 = -((int)(local_10 + (uVar6 & 3)) >> 2);
    }
    uVar2 = (*_DAT_1000c020)(uVar1,local_10,local_c);
    uVar4 = (*_DAT_1000c01c)(uVar1);
    (*_DAT_1000c018)(uVar4,uVar2);
    (*_DAT_1000c014)(uVar4,0,0,local_10,local_c,uVar1,0,0,0xcc0020);
    (*_DAT_1000c014)(uVar1,0,0,local_10,local_c,uVar4,local_1c,local_20,0xcc0020);
    (*_DAT_1000c010)(uVar4);
    (*_DAT_1000c00c)(uVar2);
    iVar8 = iVar3;
    if (SBORROW4(local_20,-(local_c / 2)) == local_20 + local_c / 2 < 0) {
      iVar8 = local_28;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067157d(void)

{
  code *pcVar1;
  undefined4 uVar2;
  undefined local_18 [8];
  undefined4 local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar2 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar2,local_18);
  pcVar1 = _DAT_1000c054;
  do {
    (*pcVar1)(1000);
    uVar2 = (*_DAT_1000c158)(0);
    (*_DAT_1000c028)(uVar2,0,local_c,local_10,-local_c,uVar2,0,0,local_10,local_c,0xcc0020);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_006715dd(void)

{
  code *pcVar1;
  undefined4 uVar2;
  bool bVar3;
  int iVar4;
  int iVar5;
  undefined local_28 [8];
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  int local_10;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar2 = (*_DAT_1000c15c)();
  (*_DAT_1000c160)(uVar2,local_28);
  uVar2 = (*_DAT_1000c158)(0);
  (*_DAT_1000c008)(uVar2,0xff);
  (*_DAT_1000c024)(uVar2,0);
  (*_DAT_1000c004)(uVar2,0x10010b48,0x18,&local_10);
  iVar4 = 0;
  iVar5 = -local_c;
  if (0 < local_20) {
    do {
      (*_DAT_1000c054)(2);
      iVar5 = iVar5 + local_c;
      (*_DAT_1000c000)(uVar2,iVar4,iVar5,0x10010b48,0x18);
      if (local_1c <= iVar5) {
        iVar5 = -local_c;
        iVar4 = iVar4 + local_10;
      }
    } while (iVar4 < local_20);
  }
  (*_DAT_1000c004)(uVar2,0x10010b78,0x10,&local_18);
  pcVar1 = _DAT_1000c008;
  bVar3 = false;
  do {
    if (bVar3) {
      (*pcVar1)(uVar2,0);
      (*_DAT_1000c024)(uVar2,0xff);
    }
    (*_DAT_1000c054)(0x68);
    (*_DAT_1000c000)(uVar2,local_20 / 2 - local_18 / 2,local_1c / 2 - local_14 / 2,0x10010b78,0x10);
    (*pcVar1)(uVar2,0xff);
    (*_DAT_1000c024)(uVar2,0);
    bVar3 = (bool)(bVar3 ^ 1);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  @__security_check_cookie@4
// 
// Library: Visual Studio 2015 Release

void __fastcall ___security_check_cookie_4(int param_1)

{
  if (param_1 == _DAT_10012000) {
    return;
  }
  ___report_gsfailure();
  return;
}



void FUN_00671700(uint param_1)

{
  operator_new(param_1);
  return;
}



// Library Function - Single Match
//  int __stdcall dllmain_crt_dispatch(struct HINSTANCE__ * const,unsigned long,void * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int dllmain_crt_dispatch(HINSTANCE__ *param_1,ulong param_2,void *param_3)

{
  uint uVar1;
  
  if (param_2 == 0) {
    uVar1 = FUN_0067185b(param_3 != (void *)0x0);
  }
  else if (param_2 == 1) {
    uVar1 = FUN_0067175c(param_1,param_3);
  }
  else {
    if (param_2 == 2) {
      uVar1 = ___scrt_dllmain_crt_thread_attach();
    }
    else {
      if (param_2 != 3) {
        return 1;
      }
      uVar1 = ___scrt_dllmain_crt_thread_detach();
    }
    uVar1 = uVar1 & 0xff;
  }
  return uVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0067175c(undefined4 param_1,undefined4 param_2)

{
  code *pcVar1;
  bool bVar2;
  char cVar3;
  int iVar4;
  code **ppcVar5;
  undefined4 uVar6;
  
  cVar3 = ___scrt_initialize_crt(0);
  if (cVar3 != '\0') {
    ___scrt_acquire_startup_lock();
    bVar2 = true;
    if (_DAT_10012b18 != 0) {
      FUN_00671f60(7);
      pcVar1 = (code *)swi(3);
      uVar6 = (*pcVar1)();
      return uVar6;
    }
    _DAT_10012b18 = 1;
    cVar3 = FUN_00671d0b();
    if (cVar3 != '\0') {
      FUN_00672084();
      FUN_00671c26();
      FUN_00671c4a();
      iVar4 = __initterm_e(0x1000c180,0x1000c190);
      if ((iVar4 == 0) && (cVar3 = ___scrt_dllmain_after_initialize_c(), cVar3 != '\0')) {
        __initterm(0x1000c178,0x1000c17c);
        _DAT_10012b18 = 2;
        bVar2 = false;
      }
    }
    FUN_00671849();
    if (!bVar2) {
      ppcVar5 = (code **)FUN_00671f5a();
      if ((*ppcVar5 != (code *)0x0) &&
         (cVar3 = ___scrt_is_nonwritable_in_current_image(ppcVar5), cVar3 != '\0')) {
        pcVar1 = *ppcVar5;
        FUN_006720da(param_1,2,param_2);
        (*pcVar1)();
      }
      _DAT_100127d8 = _DAT_100127d8 + 1;
      return 1;
    }
  }
  return 0;
}



void FUN_00671849(void)

{
  int unaff_EBP;
  
  ___scrt_release_startup_lock(*(undefined4 *)(unaff_EBP + -0x1d));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_0067185b(undefined4 param_1)

{
  code *pcVar1;
  char cVar2;
  uint uVar3;
  
  if (_DAT_100127d8 < 1) {
    uVar3 = 0;
  }
  else {
    _DAT_100127d8 = _DAT_100127d8 + -1;
    ___scrt_acquire_startup_lock();
    if (_DAT_10012b18 != 2) {
      FUN_00671f60(7);
      pcVar1 = (code *)swi(3);
      uVar3 = (*pcVar1)();
      return uVar3;
    }
    FUN_00671d78();
    __scrt_uninitialize_type_info();
    FUN_006720af();
    _DAT_10012b18 = 0;
    FUN_006718cc();
    cVar2 = ___scrt_uninitialize_crt(param_1,0);
    uVar3 = (uint)(cVar2 != '\0');
  }
  return uVar3;
}



void FUN_006718cc(void)

{
  int unaff_EBP;
  
  FUN_00671d9b();
  ___scrt_release_startup_lock(*(undefined4 *)(unaff_EBP + -0x1c));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_006718e3(HINSTANCE__ *param_1,ulong param_2,void *param_3)

{
  code *pcVar1;
  int iVar2;
  
  pcVar1 = _DAT_1000c1b0;
  if ((param_2 == 0) && (_DAT_100127d8 < 1)) {
    iVar2 = 0;
  }
  else {
    if ((param_2 == 1) || (param_2 == 2)) {
      if (_DAT_1000c1b0 != (code *)0x0) {
        FUN_006720da(param_1,param_2,param_3);
        iVar2 = (*pcVar1)();
        if (iVar2 == 0) {
          return 0;
        }
      }
      iVar2 = dllmain_crt_dispatch(param_1,param_2,param_3);
      if (iVar2 == 0) {
        return 0;
      }
    }
    iVar2 = FUN_00670f6d(param_1,param_2,param_3);
    if ((param_2 == 1) && (iVar2 == 0)) {
      FUN_00670f6d(param_1,0,param_3);
      dllmain_crt_dispatch(param_1,0,param_3);
      pcVar1 = _DAT_1000c1b0;
      if (_DAT_1000c1b0 != (code *)0x0) {
        FUN_006720da(param_1,0,param_3);
        (*pcVar1)();
      }
    }
    if (((param_2 == 0) || (param_2 == 3)) &&
       (iVar2 = dllmain_crt_dispatch(param_1,param_2,param_3), pcVar1 = _DAT_1000c1b0, iVar2 != 0))
    {
      if (_DAT_1000c1b0 == (code *)0x0) {
        iVar2 = 1;
      }
      else {
        FUN_006720da(param_1,param_2,param_3);
        iVar2 = (*pcVar1)();
      }
    }
  }
  return iVar2;
}



// Library Function - Single Match
//  __DllMainCRTStartup@12
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void __DllMainCRTStartup_12(undefined4 param_1,int param_2,undefined4 param_3)

{
  if (param_2 == 1) {
    ___security_init_cookie();
  }
  FUN_006718e3(param_1,param_2,param_3);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___raise_securityfailure
// 
// Library: Visual Studio 2015 Release

void ___raise_securityfailure(undefined4 param_1)

{
  undefined4 uVar1;
  
  (*_DAT_1000c084)(0);
  (*_DAT_1000c080)(param_1);
  uVar1 = (*_DAT_1000c088)(0xc0000409);
  (*_DAT_1000c08c)(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___report_gsfailure
// 
// Library: Visual Studio 2015 Release

void __cdecl ___report_gsfailure(void)

{
  code *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 uVar5;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte bVar6;
  byte bVar7;
  byte in_AF;
  byte bVar8;
  byte bVar9;
  byte in_TF;
  byte in_IF;
  byte bVar10;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined8 uVar11;
  undefined4 unaff_retaddr;
  
  uVar11 = FUN_0067b52c(0x17);
  uVar4 = (uint)uVar11;
  bVar6 = 0;
  bVar10 = 0;
  bVar9 = (int)uVar4 < 0;
  bVar8 = uVar4 == 0;
  bVar7 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;
  uVar5 = extraout_ECX;
  uVar2 = unaff_retaddr;
  uVar3 = unaff_EBP;
  if (!(bool)bVar8) {
    pcVar1 = (code *)swi(0x29);
    uVar11 = (*pcVar1)();
    uVar5 = extraout_ECX_00;
    uVar2 = unaff_retaddr;
    uVar3 = unaff_EBP;
  }
  _DAT_100128e4 = uVar3;
  _DAT_100127ec = uVar2;
  _DAT_100128f0 =
       (uint)(in_NT & 1) * 0x4000 | (uint)(bVar10 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200 |
       (uint)(in_TF & 1) * 0x100 | (uint)(bVar9 & 1) * 0x80 | (uint)(bVar8 & 1) * 0x40 |
       (uint)(in_AF & 1) * 0x10 | (uint)(bVar7 & 1) * 4 | (uint)(bVar6 & 1) |
       (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 |
       (uint)(in_AC & 1) * 0x40000;
  _DAT_100128f4 = &stack0x00000004;
  _DAT_10012830 = 0x10001;
  _DAT_100127e0 = 0xc0000409;
  _DAT_100127e4 = 1;
  _DAT_100127f0 = 1;
  uRam100127f4 = 2;
  _DAT_100128bc = in_GS;
  _DAT_100128c0 = in_FS;
  _DAT_100128c4 = in_ES;
  _DAT_100128c8 = in_DS;
  _DAT_100128cc = unaff_EDI;
  _DAT_100128d0 = unaff_ESI;
  _DAT_100128d4 = unaff_EBX;
  _DAT_100128dc = uVar5;
  _DAT_100128e8 = _DAT_100127ec;
  _DAT_100128ec = in_CS;
  _DAT_100128f8 = in_SS;
  ___raise_securityfailure(0x1000c1b4);
  _DAT_100128d8 = (undefined4)((ulonglong)uVar11 >> 0x20);
  _DAT_100128e0 = (undefined4)uVar11;
  return;
}



// Library Function - Single Match
//  void * __cdecl operator new(unsigned int)
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void * __cdecl operator_new(uint param_1)

{
  code *pcVar1;
  void *pvVar2;
  undefined auStack20 [8];
  undefined4 uStack12;
  
  do {
    uStack12 = 0x671b76;
    pvVar2 = (void *)FUN_00673ee2();
    if (pvVar2 != (void *)0x0) {
      return pvVar2;
    }
    uStack12 = 0x671b69;
    pvVar2 = (void *)__callnewh(param_1);
  } while (pvVar2 != (void *)0x0);
  if (param_1 != 0xffffffff) {
    __scrt_throw_std_bad_alloc();
    return pvVar2;
  }
  FUN_00672196();
  __CxxThrowException_8(auStack20,0x100111c0);
  pcVar1 = (code *)swi(3);
  pvVar2 = (void *)(*pcVar1)();
  return pvVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_00671b8c(void)

{
  uint uVar1;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  uint local_8;
  
  local_10 = 0;
  local_c = 0;
  (*_DAT_1000c0a0)(&local_10);
  local_8 = local_c ^ local_10;
  uVar1 = (*_DAT_1000c09c)();
  local_8 = local_8 ^ uVar1;
  uVar1 = (*_DAT_1000c098)();
  local_8 = local_8 ^ uVar1;
  (*_DAT_1000c094)(&local_18);
  return local_14 ^ local_18 ^ local_8 ^ (uint)&local_8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___security_init_cookie
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl ___security_init_cookie(void)

{
  if ((_DAT_10012000 == 0xbb40e64e) || ((_DAT_10012000 & 0xffff0000) == 0)) {
    _DAT_10012000 = FUN_00671b8c();
    if (_DAT_10012000 == 0xbb40e64e) {
      _DAT_10012000 = 0xbb40e64f;
    }
    else if ((_DAT_10012000 & 0xffff0000) == 0) {
      _DAT_10012000 = _DAT_10012000 | (_DAT_10012000 | 0x4711) << 0x10;
    }
  }
  _DAT_10012004 = ~_DAT_10012000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00671c26(void)

{
  (*_DAT_1000c0a4)(0x10012b00);
  return;
}



// Library Function - Single Match
//  void __cdecl __scrt_uninitialize_type_info(void)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl __scrt_uninitialize_type_info(void)

{
  ___std_type_info_destroy_list(0x10012b00);
  return;
}



undefined4 FUN_00671c3e(void)

{
  return 0x10012b08;
}



undefined4 FUN_00671c44(void)

{
  return 0x10012b10;
}



void FUN_00671c4a(void)

{
  uint *puVar1;
  
  puVar1 = (uint *)FUN_00671c3e();
  *puVar1 = *puVar1 | 4;
  puVar1[1] = puVar1[1];
  puVar1 = (uint *)FUN_00671c44();
  *puVar1 = *puVar1 | 2;
  puVar1[1] = puVar1[1];
  return;
}



// Library Function - Single Match
//  struct _IMAGE_SECTION_HEADER * __cdecl find_pe_section(unsigned char * const,unsigned int)
// 
// Library: Visual Studio 2015 Release

_IMAGE_SECTION_HEADER * __cdecl find_pe_section(uchar *param_1,uint param_2)

{
  int iVar1;
  _IMAGE_SECTION_HEADER *p_Var2;
  _IMAGE_SECTION_HEADER *p_Var3;
  
  iVar1 = *(int *)(param_1 + 0x3c);
  p_Var2 = (_IMAGE_SECTION_HEADER *)
           (param_1 + (uint)*(ushort *)(param_1 + iVar1 + 0x14) + iVar1 + 0x18);
  p_Var3 = p_Var2 + *(ushort *)(param_1 + iVar1 + 6);
  while( true ) {
    if (p_Var2 == p_Var3) {
      return (_IMAGE_SECTION_HEADER *)0x0;
    }
    if ((p_Var2->VirtualAddress <= param_2) && (param_2 < p_Var2->Misc + p_Var2->VirtualAddress))
    break;
    p_Var2 = p_Var2 + 1;
  }
  return p_Var2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_acquire_startup_lock
// 
// Library: Visual Studio 2015 Release

undefined4 ___scrt_acquire_startup_lock(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int in_FS_OFFSET;
  
  iVar2 = ___scrt_is_ucrt_dll_in_use();
  if (iVar2 == 0) {
    return 0;
  }
  iVar2 = *(int *)(*(int *)(in_FS_OFFSET + 0x18) + 4);
  while( true ) {
    iVar3 = 0;
    LOCK();
    iVar1 = iVar2;
    if (_DAT_10012b1c != 0) {
      iVar3 = _DAT_10012b1c;
      iVar1 = _DAT_10012b1c;
    }
    _DAT_10012b1c = iVar1;
    if (iVar3 == 0) break;
    if (iVar2 == iVar3) {
      return 1;
    }
  }
  return 0;
}



// Library Function - Single Match
//  ___scrt_dllmain_after_initialize_c
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 ___scrt_dllmain_after_initialize_c(void)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = ___scrt_is_ucrt_dll_in_use();
  if (iVar1 == 0) {
    uVar2 = FUN_006723f8();
    iVar1 = FUN_0067463b(uVar2);
    if (iVar1 != 0) {
      return 0;
    }
    common_initialize_environment_nolock_char_();
  }
  else {
    FUN_0067225f();
  }
  return 1;
}



bool FUN_00671d0b(void)

{
  char cVar1;
  
  cVar1 = FUN_00671de1(0);
  return cVar1 != '\0';
}



// Library Function - Single Match
//  ___scrt_dllmain_crt_thread_attach
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___scrt_dllmain_crt_thread_attach(void)

{
  char cVar1;
  
  cVar1 = ___vcrt_thread_attach();
  if (cVar1 != '\0') {
    cVar1 = FUN_00674b4d();
    if (cVar1 != '\0') {
      return 1;
    }
    ___vcrt_thread_detach();
  }
  return 0;
}



// Library Function - Single Match
//  ___scrt_dllmain_crt_thread_detach
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___scrt_dllmain_crt_thread_detach(void)

{
  FUN_00674b58();
  ___vcrt_thread_detach();
  return 1;
}



// Library Function - Single Match
//  ___scrt_dllmain_exception_filter
// 
// Library: Visual Studio 2015 Release

void ___scrt_dllmain_exception_filter
               (undefined4 param_1,int param_2,undefined4 param_3,code *param_4,undefined4 param_5,
               undefined4 param_6)

{
  int iVar1;
  
  iVar1 = ___scrt_is_ucrt_dll_in_use();
  if ((iVar1 == 0) && (param_2 == 1)) {
    FUN_006720da(param_1,0,param_3);
    (*param_4)();
  }
  __seh_filter_dll(param_5,param_6);
  return;
}



void FUN_00671d78(void)

{
  int iVar1;
  
  iVar1 = ___scrt_is_ucrt_dll_in_use();
  if (iVar1 != 0) {
    __execute_onexit_table(&DAT_10012b20);
    return;
  }
  iVar1 = FUN_0067433c();
  if (iVar1 != 0) {
    return;
  }
  common_exit(0,0,1);
  return;
}



undefined FUN_00671d9b(void)

{
  ___acrt_uninitialize_critical(0);
  ___vcrt_uninitialize_ptd();
  return 1;
}



// Library Function - Single Match
//  ___scrt_initialize_crt
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined ___scrt_initialize_crt(int param_1)

{
  char cVar1;
  
  if (param_1 == 0) {
    DAT_10012b39 = 1;
  }
  FUN_0067225f();
  cVar1 = ___vcrt_initialize();
  if (cVar1 != '\0') {
    cVar1 = ___acrt_initialize();
    if (cVar1 != '\0') {
      return 1;
    }
    ___vcrt_uninitialize(0);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00671de1(int param_1)

{
  code *pcVar1;
  byte bVar2;
  int iVar3;
  undefined4 uVar4;
  
  if (DAT_10012b38 == '\0') {
    if ((param_1 != 0) && (param_1 != 1)) {
      FUN_00671f60(5);
      pcVar1 = (code *)swi(3);
      uVar4 = (*pcVar1)();
      return uVar4;
    }
    iVar3 = ___scrt_is_ucrt_dll_in_use();
    if ((iVar3 == 0) || (param_1 != 0)) {
      bVar2 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
      _DAT_10012b20 = (0xffffffffU >> bVar2 | -1 << 0x20 - bVar2) ^ _DAT_10012000;
      _DAT_10012b24 = _DAT_10012b20;
      _DAT_10012b28 = _DAT_10012b20;
      _DAT_10012b2c = _DAT_10012b20;
      _DAT_10012b30 = _DAT_10012b20;
      _DAT_10012b34 = _DAT_10012b20;
    }
    else {
      iVar3 = __initialize_onexit_table(&DAT_10012b20);
      if ((iVar3 != 0) || (iVar3 = __initialize_onexit_table(&DAT_10012b2c), iVar3 != 0)) {
        return 0;
      }
    }
    DAT_10012b38 = '\x01';
  }
  return 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_is_nonwritable_in_current_image
// 
// Library: Visual Studio 2015 Release

undefined4 ___scrt_is_nonwritable_in_current_image(int param_1)

{
  _IMAGE_SECTION_HEADER *p_Var1;
  
  if ((((_DAT_10000000 == 0x5a4d) && (*(int *)(_DAT_1000003c + 0x10000000) == 0x4550)) &&
      (*(short *)(_DAT_1000003c + 0x10000018) == 0x10b)) &&
     ((p_Var1 = find_pe_section(&DAT_10000000,param_1 + 0xf0000000),
      p_Var1 != (_IMAGE_SECTION_HEADER *)0x0 && (-1 < (int)p_Var1->Characteristics)))) {
    return 1;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_release_startup_lock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int ___scrt_release_startup_lock(char param_1)

{
  int iVar1;
  int iVar2;
  
  iVar2 = ___scrt_is_ucrt_dll_in_use();
  iVar1 = _DAT_10012b1c;
  if ((iVar2 != 0) && (param_1 == '\0')) {
    _DAT_10012b1c = 0;
    iVar2 = iVar1;
  }
  return iVar2;
}



// Library Function - Single Match
//  ___scrt_uninitialize_crt
// 
// Library: Visual Studio 2017 Release

undefined ___scrt_uninitialize_crt(undefined4 param_1,char param_2)

{
  if ((DAT_10012b39 == '\0') || (param_2 == '\0')) {
    ___acrt_uninitialize(param_1);
    ___vcrt_uninitialize(param_1);
  }
  return 1;
}



undefined4 FUN_00671f5a(void)

{
  return 0x100131e8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00671f60(void)

{
  code *pcVar1;
  int iVar2;
  int iVar3;
  undefined4 local_328 [39];
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 *local_c;
  undefined4 *local_8;
  
  iVar2 = FUN_0067b52c();
  if (iVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  FUN_0067207c();
  _memset(local_328,0,0x2cc);
  local_328[0] = 0x10001;
  _memset(&local_5c,0,0x50);
  local_5c = 0x40000015;
  local_58 = 1;
  iVar2 = (*_DAT_1000c0a8)();
  local_c = &local_5c;
  local_8 = local_328;
  (*_DAT_1000c084)();
  iVar3 = (*_DAT_1000c080)();
  if ((iVar3 == 0) && (iVar2 != 1)) {
    FUN_0067207c();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067207c(void)

{
  _DAT_10012b3c = 0;
  return;
}



// WARNING: Removing unreachable block (ram,0x00672094)
// WARNING: Removing unreachable block (ram,0x00672095)
// WARNING: Removing unreachable block (ram,0x0067209b)
// WARNING: Removing unreachable block (ram,0x006720a4)
// WARNING: Removing unreachable block (ram,0x006720ab)

void FUN_00672084(void)

{
  return;
}



// WARNING: Removing unreachable block (ram,0x006720bf)
// WARNING: Removing unreachable block (ram,0x006720c0)
// WARNING: Removing unreachable block (ram,0x006720c6)
// WARNING: Removing unreachable block (ram,0x006720cf)
// WARNING: Removing unreachable block (ram,0x006720d6)

void FUN_006720af(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_006720da(void)

{
                    // WARNING: Could not recover jumptable at 0x006720da. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_1000c174)();
  return;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __SEH_prolog4
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __SEH_prolog4(undefined4 param_1,int param_2)

{
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  param_2 = -param_2;
  *(undefined4 *)((int)auStack28 + param_2 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + param_2 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + param_2 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + param_2 + 4) = _DAT_10012000 ^ (uint)&stack0x00000008;
  *(undefined4 *)((int)auStack28 + param_2) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __SEH_epilog4
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __SEH_epilog4(void)

{
  undefined4 *unaff_EBP;
  undefined4 *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  *in_FS_OFFSET = unaff_EBP[-4];
  *unaff_EBP = unaff_retaddr;
  return;
}



undefined4 * __thiscall FUN_00672148(undefined4 *param_1_00,exception *param_1)

{
  std::exception::exception((exception *)param_1_00,param_1);
  *param_1_00 = 0x1000c1e0;
  return param_1_00;
}



undefined4 * __fastcall FUN_00672163(undefined4 *param_1)

{
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[1] = 0x1000c1e8;
  *param_1 = 0x1000c1e0;
  return param_1;
}



undefined4 * __thiscall FUN_0067217b(undefined4 *param_1_00,exception *param_1)

{
  std::exception::exception((exception *)param_1_00,param_1);
  *param_1_00 = 0x1000c1fc;
  return param_1_00;
}



undefined4 * __fastcall FUN_00672196(undefined4 *param_1)

{
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[1] = 0x1000c204;
  *param_1 = 0x1000c1fc;
  return param_1;
}



// Library Function - Single Match
//  public: __thiscall std::exception::exception(class std::exception const &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

exception * __thiscall std::exception::exception(exception *this,exception *param_1)

{
  *(undefined4 *)this = 0x1000c1c0;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 0;
  ___std_exception_copy(param_1 + 4,this + 4);
  return this;
}



undefined4 * __thiscall FUN_006721eb(undefined4 *param_1_00,byte param_1)

{
  *param_1_00 = 0x1000c1c0;
  ___std_exception_destroy(param_1_00 + 1);
  if ((param_1 & 1) != 0) {
    FUN_00672409(param_1_00,0xc);
  }
  return param_1_00;
}



// Library Function - Single Match
//  void __cdecl __scrt_throw_std_bad_alloc(void)
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl __scrt_throw_std_bad_alloc(void)

{
  code *pcVar1;
  undefined local_10 [12];
  
  FUN_00672163();
  __CxxThrowException_8(local_10,0x1001116c);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_00672235(void)

{
  code *pcVar1;
  undefined local_10 [12];
  
  FUN_00672196();
  __CxxThrowException_8(local_10,0x100111c0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Removing unreachable block (ram,0x006722db)
// WARNING: Removing unreachable block (ram,0x006722a0)
// WARNING: Removing unreachable block (ram,0x00672353)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0067225f(void)

{
  int *piVar1;
  uint *puVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint in_XCR0;
  
  _DAT_10012b40 = 0;
  _DAT_10012010 = _DAT_10012010 | 1;
  iVar4 = FUN_0067b52c(10);
  uVar3 = _DAT_10012010;
  if (iVar4 != 0) {
    _DAT_10012010 = _DAT_10012010 | 2;
    _DAT_10012b40 = 1;
    piVar1 = (int *)cpuid_basic_info(0);
    puVar2 = (uint *)cpuid_Version_info(1);
    uVar6 = puVar2[3];
    if (((piVar1[1] ^ 0x756e6547U | piVar1[3] ^ 0x6c65746eU | piVar1[2] ^ 0x49656e69U) == 0) &&
       (((((uVar5 = *puVar2 & 0xfff3ff0, uVar5 == 0x106c0 || (uVar5 == 0x20660)) ||
          (uVar5 == 0x20670)) || ((uVar5 == 0x30650 || (uVar5 == 0x30660)))) || (uVar5 == 0x30670)))
       ) {
      _DAT_10012b44 = _DAT_10012b44 | 1;
    }
    if (*piVar1 < 7) {
      uVar5 = 0;
    }
    else {
      iVar4 = cpuid_Extended_Feature_Enumeration_info(7);
      uVar5 = *(uint *)(iVar4 + 4);
      if ((uVar5 & 0x200) != 0) {
        _DAT_10012b44 = _DAT_10012b44 | 2;
      }
    }
    if ((uVar6 & 0x100000) != 0) {
      _DAT_10012010 = uVar3 | 6;
      _DAT_10012b40 = 2;
      if ((((uVar6 & 0x8000000) != 0) && ((uVar6 & 0x10000000) != 0)) && ((in_XCR0 & 6) == 6)) {
        _DAT_10012010 = uVar3 | 0xe;
        _DAT_10012b40 = 3;
        if ((uVar5 & 0x20) != 0) {
          _DAT_10012010 = uVar3 | 0x2e;
          _DAT_10012b40 = 5;
        }
      }
    }
  }
  return 0;
}



undefined4 FUN_006723f8(void)

{
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_is_ucrt_dll_in_use
// 
// Library: Visual Studio 2015 Release

bool ___scrt_is_ucrt_dll_in_use(void)

{
  return _DAT_100131e4 != 0;
}



void FUN_00672409(undefined4 param_1)

{
  thunk_FUN_00674bde(param_1);
  return;
}



undefined4 * __thiscall FUN_00672417(undefined4 *param_1_00,byte param_1)

{
  *param_1_00 = 0x1000c220;
  if ((param_1 & 1) != 0) {
    FUN_00672409(param_1_00,0xc);
  }
  return param_1_00;
}



void thunk_FUN_00674bde(void *param_1)

{
  FID_conflict__free(param_1);
  return;
}



// Library Function - Single Match
//  _ValidateLocalCookies
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void _ValidateLocalCookies(int *param_1)

{
  if (*param_1 != -2) {
    ___security_check_cookie_4();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0067248d(int *param_1,int param_2,undefined4 param_3)

{
  int iVar1;
  code *pcVar2;
  int iVar3;
  BOOL BVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  int *local_20;
  undefined4 local_1c;
  int local_18;
  int local_14;
  undefined4 local_10;
  uint local_c;
  char local_5;
  
  local_5 = '\0';
  iVar6 = param_2 + 0x10;
  local_c = *(uint *)(param_2 + 8) ^ _DAT_10012000;
  local_10 = 1;
  local_14 = iVar6;
  _ValidateLocalCookies(local_c,iVar6);
  ___except_validate_context_record(param_3);
  iVar7 = *(int *)(param_2 + 0xc);
  if ((*(byte *)(param_1 + 1) & 0x66) == 0) {
    local_20 = param_1;
    local_1c = param_3;
    *(int ***)(param_2 + -4) = &local_20;
    if (iVar7 == -2) {
      return local_10;
    }
    do {
      iVar3 = iVar7 * 3 + 4;
      iVar1 = *(int *)(local_c + iVar3 * 4);
      local_18 = local_c + iVar3 * 4;
      if (*(int *)(local_18 + 4) != 0) {
        iVar3 = __EH4_CallFilterFunc_8();
        local_5 = '\x01';
        if (iVar3 < 0) {
          local_10 = 0;
          goto LAB_006725a5;
        }
        if (0 < iVar3) {
          if (((*param_1 == -0x1f928c9d) && (_DAT_1000cae8 != (code *)0x0)) &&
             (BVar4 = __IsNonwritableInCurrentImage(&DAT_1000cae8), pcVar2 = _DAT_1000cae8,
             BVar4 != 0)) {
            FUN_006720da(param_1,1);
            (*pcVar2)();
            iVar6 = local_14;
          }
          FUN_00672a01();
          if (*(int *)(param_2 + 0xc) != iVar7) {
            __EH4_LocalUnwind_16(iVar6,&DAT_10012000);
          }
          *(int *)(param_2 + 0xc) = iVar1;
          _ValidateLocalCookies(local_c,iVar6);
          __EH4_TransferToHandler_8();
          pcVar2 = (code *)swi(3);
          uVar5 = (*pcVar2)();
          return uVar5;
        }
      }
      iVar7 = iVar1;
    } while (iVar1 != -2);
    if (local_5 == '\0') {
      return local_10;
    }
  }
  else {
    if (iVar7 == -2) {
      return local_10;
    }
    __EH4_LocalUnwind_16(iVar6,&DAT_10012000);
  }
LAB_006725a5:
  _ValidateLocalCookies(local_c,iVar6);
  return local_10;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___std_type_info_destroy_list
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___std_type_info_destroy_list(undefined4 param_1)

{
  undefined4 *puVar1;
  undefined4 *_Memory;
  
  _Memory = (undefined4 *)(*_DAT_1000c0b4)(param_1);
  while (_Memory != (undefined4 *)0x0) {
    puVar1 = (undefined4 *)*_Memory;
    FID_conflict__free(_Memory);
    _Memory = puVar1;
  }
  return;
}



// Library Function - Single Match
//  ___vcrt_initialize
// 
// Library: Visual Studio 2015 Release

undefined ___vcrt_initialize(void)

{
  char cVar1;
  
  ___vcrt_initialize_pure_virtual_call_handler();
  ___vcrt_initialize_winapi_thunks();
  cVar1 = ___vcrt_initialize_locks();
  if (cVar1 != '\0') {
    cVar1 = FUN_00672b82();
    if (cVar1 != '\0') {
      return 1;
    }
    ___vcrt_uninitialize_locks();
  }
  return 0;
}



// Library Function - Single Match
//  ___vcrt_thread_attach
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

uint ___vcrt_thread_attach(void)

{
  uint uVar1;
  
  uVar1 = ___vcrt_getptd_noexit();
  return uVar1 & 0xffffff00 | (uint)(uVar1 != 0);
}



// Library Function - Single Match
//  ___vcrt_thread_detach
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___vcrt_thread_detach(void)

{
  FUN_00672aad(0);
  return 1;
}



// Library Function - Single Match
//  ___vcrt_uninitialize
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined ___vcrt_uninitialize(char param_1)

{
  if (param_1 == '\0') {
    ___vcrt_uninitialize_ptd();
    ___vcrt_uninitialize_locks();
    ___vcrt_uninitialize_winapi_thunks(0);
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _memset
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void * __cdecl _memset(void *_Dst,int _Val,size_t _Size)

{
  int iVar1;
  undefined *puVar2;
  int *piVar3;
  
  if (_Size == 0) {
    return _Dst;
  }
  iVar1 = (_Val & 0xffU) * 0x1010101;
  piVar3 = (int *)_Dst;
  if (0x20 < (int)_Size) {
    if (0x7f < (int)_Size) {
      puVar2 = (undefined *)_Dst;
      if ((_DAT_10012b44 >> 1 & 1) != 0) {
        for (; _Size != 0; _Size = _Size - 1) {
          *puVar2 = (char)iVar1;
          puVar2 = puVar2 + 1;
        }
        return _Dst;
      }
      if ((_DAT_10012010 >> 1 & 1) == 0) goto joined_r0x00672788;
      *(int *)_Dst = iVar1;
      *(int *)((int)_Dst + 4) = iVar1;
      *(int *)((int)_Dst + 8) = iVar1;
      *(int *)((int)_Dst + 0xc) = iVar1;
      piVar3 = (int *)((int)_Dst + 0x10U & 0xfffffff0);
      _Size = (int)_Dst + (_Size - (int)piVar3);
      if (0x80 < (int)_Size) {
        do {
          *piVar3 = iVar1;
          piVar3[1] = iVar1;
          piVar3[2] = iVar1;
          piVar3[3] = iVar1;
          piVar3[4] = iVar1;
          piVar3[5] = iVar1;
          piVar3[6] = iVar1;
          piVar3[7] = iVar1;
          piVar3[8] = iVar1;
          piVar3[9] = iVar1;
          piVar3[10] = iVar1;
          piVar3[0xb] = iVar1;
          piVar3[0xc] = iVar1;
          piVar3[0xd] = iVar1;
          piVar3[0xe] = iVar1;
          piVar3[0xf] = iVar1;
          piVar3[0x10] = iVar1;
          piVar3[0x11] = iVar1;
          piVar3[0x12] = iVar1;
          piVar3[0x13] = iVar1;
          piVar3[0x14] = iVar1;
          piVar3[0x15] = iVar1;
          piVar3[0x16] = iVar1;
          piVar3[0x17] = iVar1;
          piVar3[0x18] = iVar1;
          piVar3[0x19] = iVar1;
          piVar3[0x1a] = iVar1;
          piVar3[0x1b] = iVar1;
          piVar3[0x1c] = iVar1;
          piVar3[0x1d] = iVar1;
          piVar3[0x1e] = iVar1;
          piVar3[0x1f] = iVar1;
          piVar3 = piVar3 + 0x20;
          _Size = _Size - 0x80;
        } while ((_Size & 0xffffff00) != 0);
        goto LAB_0067274d;
      }
    }
    if ((_DAT_10012010 >> 1 & 1) != 0) {
LAB_0067274d:
      if (0x1f < _Size) {
        do {
          *piVar3 = iVar1;
          piVar3[1] = iVar1;
          piVar3[2] = iVar1;
          piVar3[3] = iVar1;
          piVar3[4] = iVar1;
          piVar3[5] = iVar1;
          piVar3[6] = iVar1;
          piVar3[7] = iVar1;
          piVar3 = piVar3 + 8;
          _Size = _Size - 0x20;
        } while (0x1f < _Size);
        if ((_Size & 0x1f) == 0) {
          return _Dst;
        }
      }
      piVar3 = (int *)((int)piVar3 + (_Size - 0x20));
      *piVar3 = iVar1;
      piVar3[1] = iVar1;
      piVar3[2] = iVar1;
      piVar3[3] = iVar1;
      piVar3[4] = iVar1;
      piVar3[5] = iVar1;
      piVar3[6] = iVar1;
      piVar3[7] = iVar1;
      return _Dst;
    }
  }
joined_r0x00672788:
  for (; (_Size & 3) != 0; _Size = _Size - 1) {
    *(char *)piVar3 = (char)iVar1;
    piVar3 = (int *)((int)piVar3 + 1);
  }
  if ((_Size & 4) != 0) {
    *piVar3 = iVar1;
    piVar3 = piVar3 + 1;
    _Size = _Size - 4;
  }
  for (; (_Size & 0xfffffff8) != 0; _Size = _Size - 8) {
    *piVar3 = iVar1;
    piVar3[1] = iVar1;
    piVar3 = piVar3 + 2;
  }
  return _Dst;
}



// Library Function - Single Match
//  ___std_exception_copy
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___std_exception_copy(char **param_1,char **param_2)

{
  char *pcVar1;
  char cVar2;
  char *_Dst;
  char *pcVar3;
  char *pcVar4;
  
  if ((*(char *)(param_1 + 1) == '\0') || (pcVar3 = *param_1, pcVar3 == (char *)0x0)) {
    *param_2 = *param_1;
    *(undefined *)(param_2 + 1) = 0;
  }
  else {
    pcVar1 = pcVar3 + 1;
    do {
      cVar2 = *pcVar3;
      pcVar3 = pcVar3 + 1;
    } while (cVar2 != '\0');
    _Dst = (char *)FUN_00673ee2(pcVar3 + (1 - (int)pcVar1));
    pcVar4 = _Dst;
    if (_Dst != (char *)0x0) {
      _strcpy_s(_Dst,(rsize_t)(pcVar3 + (1 - (int)pcVar1)),*param_1);
      pcVar4 = (char *)0x0;
      *param_2 = _Dst;
      *(undefined *)(param_2 + 1) = 1;
    }
    FUN_00674bde(pcVar4);
  }
  return;
}



// Library Function - Single Match
//  ___std_exception_destroy
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___std_exception_destroy(undefined4 *param_1)

{
  if (*(char *)(param_1 + 1) != '\0') {
    FUN_00674bde(*param_1);
  }
  *param_1 = 0;
  *(undefined *)(param_1 + 1) = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __CxxThrowException@8
// 
// Library: Visual Studio 2015 Release

void __CxxThrowException_8(int *param_1,byte *param_2)

{
  code *pcVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  undefined4 local_24 [4];
  undefined4 local_14;
  undefined4 local_10;
  int *local_c;
  byte *local_8;
  
  puVar3 = (undefined4 *)&DAT_1000c224;
  puVar4 = local_24;
  for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {
    *puVar4 = *puVar3;
    puVar3 = puVar3 + 1;
    puVar4 = puVar4 + 1;
  }
  if ((param_2 != (byte *)0x0) && ((*param_2 & 0x10) != 0)) {
    iVar2 = *(int *)(*param_1 + -4);
    pcVar1 = *(code **)(iVar2 + 0x20);
    param_2 = *(byte **)(iVar2 + 0x18);
    FUN_006720da((int *)(*param_1 + -4));
    (*pcVar1)();
  }
  local_c = param_1;
  if ((param_2 != (byte *)0x0) && ((*param_2 & 8) != 0)) {
    local_10 = 0x1994000;
  }
  local_8 = param_2;
  (*_DAT_1000c0b8)(local_24[0],local_24[1],local_14,&local_10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __local_unwind4
// 
// Library: Visual Studio

void __local_unwind4(uint *param_1,int param_2,uint param_3)

{
  undefined4 *puVar1;
  uint uVar2;
  undefined4 *in_FS_OFFSET;
  undefined4 uStack40;
  undefined4 uStack36;
  uint local_20;
  uint uStack28;
  int iStack24;
  uint *puStack20;
  
  puStack20 = param_1;
  iStack24 = param_2;
  uStack28 = param_3;
  uStack36 = 0x100029f0;
  uStack40 = *in_FS_OFFSET;
  local_20 = _DAT_10012000 ^ (uint)&uStack40;
  *in_FS_OFFSET = &uStack40;
  while( true ) {
    uVar2 = *(uint *)(param_2 + 0xc);
    if ((uVar2 == 0xfffffffe) || ((param_3 != 0xfffffffe && (uVar2 <= param_3)))) break;
    puVar1 = (undefined4 *)((*(uint *)(param_2 + 8) ^ *param_1) + 0x10 + uVar2 * 0xc);
    *(undefined4 *)(param_2 + 0xc) = *puVar1;
    if (puVar1[1] == 0) {
      __NLG_Notify(0x101);
      FUN_006730b8();
    }
  }
  *in_FS_OFFSET = uStack40;
  return;
}



// Library Function - Single Match
//  @_EH4_CallFilterFunc@8
// 
// Library: Visual Studio

void __fastcall __EH4_CallFilterFunc_8(code *param_1)

{
  (*param_1)();
  return;
}



// Library Function - Single Match
//  @_EH4_TransferToHandler@8
// 
// Library: Visual Studio

void __fastcall __EH4_TransferToHandler_8(code *UNRECOVERED_JUMPTABLE)

{
  __NLG_Notify(1);
                    // WARNING: Could not recover jumptable at 0x006729fc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_00672a01(undefined4 param_1,undefined4 param_2)

{
  (*_DAT_1000c0bc)(param_1,0x10002aa9,param_2,0);
  return;
}



// Library Function - Single Match
//  @_EH4_LocalUnwind@16
// 
// Library: Visual Studio

void __fastcall
__EH4_LocalUnwind_16
          (undefined4 param_1_00,undefined4 param_2_00,undefined4 param_1,undefined4 param_2)

{
  __local_unwind4(param_2,param_1_00,param_2_00);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___except_validate_context_record
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___except_validate_context_record(int param_1)

{
  uint *puVar1;
  uint uVar2;
  code *pcVar3;
  int in_FS_OFFSET;
  
  if (_DAT_1000c174 != 0x1000249b) {
    uVar2 = *(uint *)(param_1 + 0xc4);
    if ((uVar2 < *(uint *)(*(int *)(in_FS_OFFSET + 0x18) + 8)) ||
       (puVar1 = (uint *)(*(int *)(in_FS_OFFSET + 0x18) + 4), *puVar1 <= uVar2 && uVar2 != *puVar1))
    {
      pcVar3 = (code *)swi(0x29);
      (*pcVar3)();
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___except_validate_jump_buffer
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___except_validate_jump_buffer(int param_1)

{
  uint *puVar1;
  uint uVar2;
  code *pcVar3;
  int in_FS_OFFSET;
  
  if (_DAT_1000c174 != 0x1000249b) {
    uVar2 = *(uint *)(param_1 + 0x10);
    if ((uVar2 < *(uint *)(*(int *)(in_FS_OFFSET + 0x18) + 8)) ||
       (puVar1 = (uint *)(*(int *)(in_FS_OFFSET + 0x18) + 4), *puVar1 <= uVar2 && uVar2 != *puVar1))
    {
      pcVar3 = (code *)swi(0x29);
      (*pcVar3)();
    }
  }
  return;
}



void FUN_00672a91(void *param_1)

{
  if ((param_1 != (void *)0x0) && (param_1 != (void *)0x10012b84)) {
    FID_conflict__free(param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00672aad(void *param_1)

{
  if (_DAT_10012020 != -1) {
    if (param_1 == (void *)0x0) {
      param_1 = (void *)___vcrt_FlsGetValue(_DAT_10012020);
    }
    ___vcrt_FlsSetValue(_DAT_10012020,0);
    if ((param_1 != (void *)0x0) && (param_1 != (void *)0x10012b84)) {
      FID_conflict__free(param_1);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_getptd_noexit
// 
// Library: Visual Studio 2015 Release

void * ___vcrt_getptd_noexit(void)

{
  undefined4 uVar1;
  void *pvVar2;
  int iVar3;
  void *pvVar4;
  void *_Memory;
  
  if (_DAT_10012020 == -1) {
    return (void *)0x0;
  }
  uVar1 = (*_DAT_1000c0c0)();
  pvVar2 = (void *)___vcrt_FlsGetValue(_DAT_10012020);
  if (pvVar2 == (void *)0xffffffff) {
LAB_00672b30:
    pvVar2 = (void *)0x0;
    goto LAB_00672b76;
  }
  if (pvVar2 != (void *)0x0) goto LAB_00672b76;
  iVar3 = ___vcrt_FlsSetValue(_DAT_10012020,0xffffffff);
  if (iVar3 == 0) goto LAB_00672b30;
  pvVar4 = (void *)__calloc_base(1,0x28);
  if (pvVar4 == (void *)0x0) {
LAB_00672b58:
    ___vcrt_FlsSetValue(_DAT_10012020,0);
    pvVar2 = (void *)0x0;
    _Memory = pvVar4;
  }
  else {
    iVar3 = ___vcrt_FlsSetValue(_DAT_10012020,pvVar4);
    if (iVar3 == 0) goto LAB_00672b58;
    _Memory = (void *)0x0;
    pvVar2 = pvVar4;
  }
  FID_conflict__free(_Memory);
LAB_00672b76:
  (*_DAT_1000c0c4)(uVar1);
  return pvVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00672b82(void)

{
  int iVar1;
  
  _DAT_10012020 = ___vcrt_FlsAlloc(0x10002b24);
  if (_DAT_10012020 != -1) {
    iVar1 = ___vcrt_FlsSetValue(_DAT_10012020,0x10012b84);
    if (iVar1 != 0) {
      return 1;
    }
    if (_DAT_10012020 != -1) {
      ___vcrt_FlsFree(_DAT_10012020);
      _DAT_10012020 = -1;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_uninitialize_ptd
// 
// Library: Visual Studio 2015 Release

undefined4 ___vcrt_uninitialize_ptd(void)

{
  if (_DAT_10012020 != -1) {
    ___vcrt_FlsFree(_DAT_10012020);
    _DAT_10012020 = -1;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_initialize_locks
// 
// Library: Visual Studio 2015 Release

undefined4 ___vcrt_initialize_locks(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  
  iVar3 = 0x10012bac;
  uVar2 = 0;
  do {
    iVar1 = ___vcrt_InitializeCriticalSectionEx(iVar3,4000,0);
    if (iVar1 == 0) {
      ___vcrt_uninitialize_locks();
      return 0;
    }
    _DAT_10012bc4 = _DAT_10012bc4 + 1;
    uVar2 = uVar2 + 0x18;
    iVar3 = iVar3 + 0x18;
  } while (uVar2 < 0x18);
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_uninitialize_locks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 ___vcrt_uninitialize_locks(void)

{
  int iVar1;
  int iVar2;
  
  if (_DAT_10012bc4 != 0) {
    iVar2 = _DAT_10012bc4 * 0x18 + 0x10012b94;
    iVar1 = _DAT_10012bc4;
    do {
      (*_DAT_1000c0d0)(iVar2);
      _DAT_10012bc4 = _DAT_10012bc4 + -1;
      iVar2 = iVar2 + -0x18;
      iVar1 = iVar1 + -1;
    } while (iVar1 != 0);
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void * __cdecl __crt_fast_encode_pointer<void *>(void * const)
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void * __cdecl __crt_fast_encode_pointer_void__(void *param_1)

{
  byte bVar1;
  
  bVar1 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
  return (void *)(((uint)param_1 >> bVar1 | (int)param_1 << 0x20 - bVar1) ^ _DAT_10012000);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  struct HINSTANCE__ * __cdecl try_get_first_available_module(enum `anonymous
// namespace'::module_id const * const,enum `anonymous namespace'::module_id const * const)
// 
// Library: Visual Studio 2017 Release

HINSTANCE__ * __cdecl try_get_first_available_module(module_id *param_1,module_id *param_2)

{
  HINSTANCE__ **ppHVar1;
  wchar_t *_Str1;
  HINSTANCE__ *pHVar2;
  HINSTANCE__ *pHVar3;
  int iVar4;
  
  do {
    if (param_1 == param_2) {
      return (HINSTANCE__ *)0x0;
    }
    ppHVar1 = (HINSTANCE__ **)(&DAT_10012bc8 + *param_1 * 4);
    pHVar3 = *ppHVar1;
    if (pHVar3 == (HINSTANCE__ *)0x0) {
      _Str1 = *(wchar_t **)(*param_1 * 4 + 0x1000c9c0);
      pHVar3 = (HINSTANCE__ *)(*_DAT_1000c0ec)(_Str1,0,0x800);
      if (pHVar3 == (HINSTANCE__ *)0x0) {
        iVar4 = (*_DAT_1000c0c0)();
        if (((iVar4 == 0x57) && (iVar4 = _wcsncmp(_Str1,(wchar_t *)0x1000ca58,7), iVar4 != 0)) &&
           (iVar4 = _wcsncmp(_Str1,(wchar_t *)0x1000ca68,7), iVar4 != 0)) {
          pHVar3 = (HINSTANCE__ *)(*_DAT_1000c0ec)(_Str1,0,0);
        }
        else {
          pHVar3 = (HINSTANCE__ *)0x0;
        }
        if (pHVar3 == (HINSTANCE__ *)0x0) {
          *ppHVar1 = (HINSTANCE__ *)0xffffffff;
          goto LAB_00672d18;
        }
      }
      pHVar2 = *ppHVar1;
      *ppHVar1 = pHVar3;
      if (pHVar2 != (HINSTANCE__ *)0x0) {
        (*_DAT_1000c0e8)(pHVar3);
      }
LAB_00672d14:
      if (pHVar3 != (HINSTANCE__ *)0x0) {
        return pHVar3;
      }
    }
    else if (pHVar3 != (HINSTANCE__ *)0xffffffff) goto LAB_00672d14;
LAB_00672d18:
    param_1 = param_1 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_00672d31(int param_1,undefined4 param_2,module_id *param_3,module_id *param_4)

{
  uint *puVar1;
  HINSTANCE__ *pHVar2;
  byte bVar3;
  uint uVar4;
  
  puVar1 = (uint *)(&DAT_10012bd4 + param_1 * 4);
  bVar3 = (byte)_DAT_10012000 & 0x1f;
  uVar4 = (_DAT_10012000 ^ *puVar1) >> bVar3 | (_DAT_10012000 ^ *puVar1) << 0x20 - bVar3;
  if (uVar4 != 0xffffffff) {
    if (uVar4 != 0) {
      return uVar4;
    }
    pHVar2 = try_get_first_available_module(param_3,param_4);
    if ((pHVar2 != (HINSTANCE__ *)0x0) && (uVar4 = (*_DAT_1000c058)(pHVar2,param_2), uVar4 != 0)) {
      bVar3 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
      *puVar1 = (uVar4 >> bVar3 | uVar4 << 0x20 - bVar3) ^ _DAT_10012000;
      return uVar4;
    }
    bVar3 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
    *puVar1 = (0xffffffffU >> bVar3 | -1 << 0x20 - bVar3) ^ _DAT_10012000;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_FlsAlloc
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsAlloc(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00672d31(0,0x1000ca80,0x1000ca78,0x1000ca80);
  if (pcVar1 != (code *)0x0) {
    FUN_006720da(param_1);
    (*pcVar1)();
    return;
  }
                    // WARNING: Could not recover jumptable at 0x00672dec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_1000c0d8)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_FlsFree
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsFree(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00672d31(1,0x1000ca94,0x1000ca8c,0x1000ca94);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0e4)(param_1);
  }
  else {
    FUN_006720da();
    (*pcVar1)();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_FlsGetValue
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsGetValue(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00672d31(2,0x1000caa4,0x1000ca9c,0x1000caa4);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0dc)(param_1);
  }
  else {
    FUN_006720da();
    (*pcVar1)();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_FlsSetValue
// 
// Library: Visual Studio 2015 Release

void ___vcrt_FlsSetValue(undefined4 param_1,undefined4 param_2)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00672d31(3,0x1000cab8,0x1000cab0,0x1000cab8);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0e0)(param_1,param_2);
  }
  else {
    FUN_006720da();
    (*pcVar1)();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_InitializeCriticalSectionEx
// 
// Library: Visual Studio 2015 Release

void ___vcrt_InitializeCriticalSectionEx(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)FUN_00672d31(4,0x1000cacc,0x1000cac4,0x1000cacc);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c07c)(param_1,param_2);
  }
  else {
    FUN_006720da(param_1,param_2,param_3);
    (*pcVar1)();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_initialize_winapi_thunks
// 
// Library: Visual Studio 2015 Release

void ___vcrt_initialize_winapi_thunks(void)

{
  byte bVar1;
  uint *puVar2;
  int iVar3;
  uint uVar4;
  
  puVar2 = (uint *)&DAT_10012bd4;
  bVar1 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
  iVar3 = 0;
  uVar4 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ _DAT_10012000;
  do {
    iVar3 = iVar3 + 1;
    *puVar2 = uVar4;
    puVar2 = puVar2 + 1;
  } while (iVar3 != 5);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_uninitialize_winapi_thunks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___vcrt_uninitialize_winapi_thunks(char param_1)

{
  int *piVar1;
  
  if (param_1 == '\0') {
    piVar1 = (int *)&DAT_10012bc8;
    do {
      if (*piVar1 != 0) {
        if (*piVar1 != -1) {
          (*_DAT_1000c0e8)(*piVar1);
        }
        *piVar1 = 0;
      }
      piVar1 = piVar1 + 1;
    } while (piVar1 != (int *)&DAT_10012bd4);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___vcrt_initialize_pure_virtual_call_handler
// 
// Library: Visual Studio 2015 Release

void ___vcrt_initialize_pure_virtual_call_handler(void)

{
  byte bVar1;
  
  bVar1 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
  _DAT_10012be8 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ _DAT_10012000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __global_unwind2
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __global_unwind2(undefined4 param_1)

{
  (*_DAT_1000c0bc)(param_1,0x10003029,0,0,&stack0xfffffffc);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __local_unwind2
// 
// Library: Visual Studio

void __local_unwind2(int param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  undefined4 *in_FS_OFFSET;
  undefined4 local_20;
  undefined4 uStack28;
  undefined4 local_18;
  int iStack20;
  
  iStack20 = param_1;
  uStack28 = 0x10003031;
  local_20 = *in_FS_OFFSET;
  uVar2 = _DAT_10012000 ^ (uint)&local_20;
  *in_FS_OFFSET = &local_20;
  while( true ) {
    uVar1 = *(uint *)(param_1 + 0xc);
    if ((uVar1 == 0xffffffff) || ((param_2 != 0xffffffff && (uVar1 <= param_2)))) break;
    local_18 = *(undefined4 *)(*(int *)(param_1 + 8) + uVar1 * 0xc);
    *(undefined4 *)(param_1 + 0xc) = local_18;
    if (*(int *)(*(int *)(param_1 + 8) + 4 + uVar1 * 0xc) == 0) {
      __NLG_Notify(0x101);
      FUN_006730b8(uVar2);
    }
  }
  *in_FS_OFFSET = local_20;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __NLG_Notify1
// 
// Library: Visual Studio

undefined4 __fastcall __NLG_Notify1(undefined4 param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  _DAT_10012034 = in_EAX;
  _DAT_10012038 = param_1;
  _DAT_1001203c = unaff_EBP;
  return in_EAX;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __NLG_Notify
// 
// Library: Visual Studio

void __NLG_Notify(ulong param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  _DAT_10012034 = in_EAX;
  _DAT_10012038 = param_1;
  _DAT_1001203c = unaff_EBP;
  return;
}



void FUN_006730b8(void)

{
  code *in_EAX;
  
  (*in_EAX)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 FUN_006730bd(undefined8 *param_1,undefined8 *param_2,uint param_3)

{
  undefined auVar1 [32];
  undefined auVar2 [32];
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  undefined4 uVar19;
  undefined4 uVar20;
  undefined4 uVar21;
  undefined4 uVar22;
  undefined4 uVar23;
  undefined4 uVar24;
  undefined4 uVar25;
  undefined4 uVar26;
  undefined4 uVar27;
  undefined4 uVar28;
  undefined4 uVar29;
  undefined4 uVar30;
  int iVar31;
  uint uVar32;
  uint uVar33;
  int iVar34;
  undefined8 *puVar35;
  undefined4 *puVar36;
  undefined4 *puVar37;
  undefined8 *puVar38;
  undefined4 *puVar39;
  undefined4 *puVar40;
  undefined4 uVar41;
  undefined4 uVar42;
  undefined4 uVar43;
  undefined8 uVar44;
  
  if ((param_2 < param_1) && (param_1 < (undefined8 *)(param_3 + (int)param_2))) {
    puVar36 = (undefined4 *)((int)param_2 + param_3);
    puVar39 = (undefined4 *)((int)param_1 + param_3);
    uVar32 = param_3;
    if (0x1f < param_3) {
      if ((_DAT_10012010 >> 1 & 1) == 0) {
        if (((uint)puVar39 & 3) != 0) {
          uVar32 = (uint)puVar39 & 3;
          param_3 = param_3 - uVar32;
          do {
            *(undefined *)((int)puVar39 - 1) = *(undefined *)((int)puVar36 + -1);
            puVar36 = (undefined4 *)((int)puVar36 + -1);
            puVar39 = (undefined4 *)((int)puVar39 - 1);
            uVar32 = uVar32 - 1;
          } while (uVar32 != 0);
        }
        if (0x1f < param_3) {
          uVar32 = param_3 >> 2;
          while( true ) {
            puVar39 = puVar39 + -1;
            puVar36 = puVar36 + -1;
            if (uVar32 == 0) break;
            uVar32 = uVar32 - 1;
            *puVar39 = *puVar36;
          }
                    // WARNING: Could not emulate address calculation at 0x006733c5
                    // WARNING: Treating indirect jump as call
          uVar44 = (**(code **)(&DAT_10003460 + (param_3 & 3) * 4))();
          return uVar44;
        }
      }
      else {
        while (puVar37 = puVar36, puVar40 = puVar39, ((uint)puVar39 & 0xf) != 0) {
          puVar36 = (undefined4 *)((int)puVar36 + -1);
          puVar39 = (undefined4 *)((int)puVar39 + -1);
          *(undefined *)puVar39 = *(undefined *)puVar36;
          param_3 = param_3 - 1;
        }
        do {
          puVar36 = puVar37;
          puVar39 = puVar40;
          if (param_3 < 0x80) break;
          puVar36 = puVar37 + -0x20;
          puVar39 = puVar40 + -0x20;
          uVar41 = puVar37[-0x1f];
          uVar42 = puVar37[-0x1e];
          uVar43 = puVar37[-0x1d];
          uVar3 = puVar37[-0x1c];
          uVar4 = puVar37[-0x1b];
          uVar5 = puVar37[-0x1a];
          uVar6 = puVar37[-0x19];
          uVar7 = puVar37[-0x18];
          uVar8 = puVar37[-0x17];
          uVar9 = puVar37[-0x16];
          uVar10 = puVar37[-0x15];
          uVar11 = puVar37[-0x14];
          uVar12 = puVar37[-0x13];
          uVar13 = puVar37[-0x12];
          uVar14 = puVar37[-0x11];
          uVar15 = puVar37[-0x10];
          uVar16 = puVar37[-0xf];
          uVar17 = puVar37[-0xe];
          uVar18 = puVar37[-0xd];
          uVar19 = puVar37[-0xc];
          uVar20 = puVar37[-0xb];
          uVar21 = puVar37[-10];
          uVar22 = puVar37[-9];
          uVar23 = puVar37[-8];
          uVar24 = puVar37[-7];
          uVar25 = puVar37[-6];
          uVar26 = puVar37[-5];
          uVar27 = puVar37[-4];
          uVar28 = puVar37[-3];
          uVar29 = puVar37[-2];
          uVar30 = puVar37[-1];
          *puVar39 = *puVar36;
          puVar40[-0x1f] = uVar41;
          puVar40[-0x1e] = uVar42;
          puVar40[-0x1d] = uVar43;
          puVar40[-0x1c] = uVar3;
          puVar40[-0x1b] = uVar4;
          puVar40[-0x1a] = uVar5;
          puVar40[-0x19] = uVar6;
          puVar40[-0x18] = uVar7;
          puVar40[-0x17] = uVar8;
          puVar40[-0x16] = uVar9;
          puVar40[-0x15] = uVar10;
          puVar40[-0x14] = uVar11;
          puVar40[-0x13] = uVar12;
          puVar40[-0x12] = uVar13;
          puVar40[-0x11] = uVar14;
          puVar40[-0x10] = uVar15;
          puVar40[-0xf] = uVar16;
          puVar40[-0xe] = uVar17;
          puVar40[-0xd] = uVar18;
          puVar40[-0xc] = uVar19;
          puVar40[-0xb] = uVar20;
          puVar40[-10] = uVar21;
          puVar40[-9] = uVar22;
          puVar40[-8] = uVar23;
          puVar40[-7] = uVar24;
          puVar40[-6] = uVar25;
          puVar40[-5] = uVar26;
          puVar40[-4] = uVar27;
          puVar40[-3] = uVar28;
          puVar40[-2] = uVar29;
          puVar40[-1] = uVar30;
          param_3 = param_3 - 0x80;
          puVar37 = puVar36;
          puVar40 = puVar39;
        } while ((param_3 & 0xffffff80) != 0);
        puVar37 = puVar36;
        puVar40 = puVar39;
        if (0x1f < param_3) {
          do {
            puVar36 = puVar37 + -8;
            puVar39 = puVar40 + -8;
            uVar41 = puVar37[-7];
            uVar42 = puVar37[-6];
            uVar43 = puVar37[-5];
            uVar3 = puVar37[-4];
            uVar4 = puVar37[-3];
            uVar5 = puVar37[-2];
            uVar6 = puVar37[-1];
            *puVar39 = *puVar36;
            puVar40[-7] = uVar41;
            puVar40[-6] = uVar42;
            puVar40[-5] = uVar43;
            puVar40[-4] = uVar3;
            puVar40[-3] = uVar4;
            puVar40[-2] = uVar5;
            puVar40[-1] = uVar6;
            param_3 = param_3 - 0x20;
            puVar37 = puVar36;
            puVar40 = puVar39;
          } while ((param_3 & 0xffffffe0) != 0);
        }
      }
    }
    for (; (param_3 & 0xfffffffc) != 0; param_3 = param_3 - 4) {
      puVar39 = puVar39 + -1;
      puVar36 = puVar36 + -1;
      *puVar39 = *puVar36;
    }
    for (; param_3 != 0; param_3 = param_3 - 1) {
      puVar39 = (undefined4 *)((int)puVar39 - 1);
      puVar36 = (undefined4 *)((int)puVar36 + -1);
      *(undefined *)puVar39 = *(undefined *)puVar36;
    }
    return CONCAT44(uVar32,param_1);
  }
  uVar32 = param_3;
  puVar38 = param_1;
  if (0x1f < param_3) {
    if (param_3 < 0x80) {
      if ((_DAT_10012010 >> 1 & 1) != 0) {
LAB_0067358a:
        if (uVar32 == 0) goto LAB_006735ed;
        for (param_3 = uVar32 >> 5; param_3 != 0; param_3 = param_3 - 1) {
          uVar41 = *(undefined4 *)((int)param_2 + 4);
          uVar42 = *(undefined4 *)(param_2 + 1);
          uVar43 = *(undefined4 *)((int)param_2 + 0xc);
          uVar3 = *(undefined4 *)(param_2 + 2);
          uVar4 = *(undefined4 *)((int)param_2 + 0x14);
          uVar5 = *(undefined4 *)(param_2 + 3);
          uVar6 = *(undefined4 *)((int)param_2 + 0x1c);
          *(undefined4 *)puVar38 = *(undefined4 *)param_2;
          *(undefined4 *)((int)puVar38 + 4) = uVar41;
          *(undefined4 *)(puVar38 + 1) = uVar42;
          *(undefined4 *)((int)puVar38 + 0xc) = uVar43;
          *(undefined4 *)(puVar38 + 2) = uVar3;
          *(undefined4 *)((int)puVar38 + 0x14) = uVar4;
          *(undefined4 *)(puVar38 + 3) = uVar5;
          *(undefined4 *)((int)puVar38 + 0x1c) = uVar6;
          param_2 = param_2 + 4;
          puVar38 = puVar38 + 4;
        }
        goto LAB_006735b8;
      }
LAB_006732e4:
      uVar32 = (uint)param_1 & 3;
      while (uVar32 != 0) {
        *(undefined *)puVar38 = *(undefined *)param_2;
        param_3 = param_3 - 1;
        param_2 = (undefined8 *)((int)param_2 + 1);
        puVar38 = (undefined8 *)((int)puVar38 + 1);
        uVar32 = (uint)puVar38 & 3;
      }
    }
    else {
      if ((_DAT_10012b44 >> 1 & 1) != 0) {
        for (; uVar32 != 0; uVar32 = uVar32 - 1) {
          *(undefined *)puVar38 = *(undefined *)param_2;
          param_2 = (undefined8 *)((int)param_2 + 1);
          puVar38 = (undefined8 *)((int)puVar38 + 1);
        }
        return CONCAT44(param_3,param_1);
      }
      if (((((uint)param_1 ^ (uint)param_2) & 0xf) == 0) && ((_DAT_10012010 >> 1 & 1) != 0)) {
        if (((uint)param_2 & 0xf) != 0) {
          uVar33 = 0x10 - ((uint)param_2 & 0xf);
          param_3 = param_3 - uVar33;
          for (uVar32 = uVar33 & 3; uVar32 != 0; uVar32 = uVar32 - 1) {
            *(undefined *)puVar38 = *(undefined *)param_2;
            param_2 = (undefined8 *)((int)param_2 + 1);
            puVar38 = (undefined8 *)((int)puVar38 + 1);
          }
          for (uVar33 = uVar33 >> 2; uVar33 != 0; uVar33 = uVar33 - 1) {
            *(undefined4 *)puVar38 = *(undefined4 *)param_2;
            param_2 = (undefined8 *)((int)param_2 + 4);
            puVar38 = (undefined8 *)((int)puVar38 + 4);
          }
        }
        uVar32 = param_3 & 0x7f;
        for (param_3 = param_3 >> 7; param_3 != 0; param_3 = param_3 - 1) {
          uVar41 = *(undefined4 *)((int)param_2 + 4);
          uVar42 = *(undefined4 *)(param_2 + 1);
          uVar43 = *(undefined4 *)((int)param_2 + 0xc);
          uVar3 = *(undefined4 *)(param_2 + 2);
          uVar4 = *(undefined4 *)((int)param_2 + 0x14);
          uVar5 = *(undefined4 *)(param_2 + 3);
          uVar6 = *(undefined4 *)((int)param_2 + 0x1c);
          uVar7 = *(undefined4 *)(param_2 + 4);
          uVar8 = *(undefined4 *)((int)param_2 + 0x24);
          uVar9 = *(undefined4 *)(param_2 + 5);
          uVar10 = *(undefined4 *)((int)param_2 + 0x2c);
          uVar11 = *(undefined4 *)(param_2 + 6);
          uVar12 = *(undefined4 *)((int)param_2 + 0x34);
          uVar13 = *(undefined4 *)(param_2 + 7);
          uVar14 = *(undefined4 *)((int)param_2 + 0x3c);
          *(undefined4 *)puVar38 = *(undefined4 *)param_2;
          *(undefined4 *)((int)puVar38 + 4) = uVar41;
          *(undefined4 *)(puVar38 + 1) = uVar42;
          *(undefined4 *)((int)puVar38 + 0xc) = uVar43;
          *(undefined4 *)(puVar38 + 2) = uVar3;
          *(undefined4 *)((int)puVar38 + 0x14) = uVar4;
          *(undefined4 *)(puVar38 + 3) = uVar5;
          *(undefined4 *)((int)puVar38 + 0x1c) = uVar6;
          *(undefined4 *)(puVar38 + 4) = uVar7;
          *(undefined4 *)((int)puVar38 + 0x24) = uVar8;
          *(undefined4 *)(puVar38 + 5) = uVar9;
          *(undefined4 *)((int)puVar38 + 0x2c) = uVar10;
          *(undefined4 *)(puVar38 + 6) = uVar11;
          *(undefined4 *)((int)puVar38 + 0x34) = uVar12;
          *(undefined4 *)(puVar38 + 7) = uVar13;
          *(undefined4 *)((int)puVar38 + 0x3c) = uVar14;
          uVar41 = *(undefined4 *)((int)param_2 + 0x44);
          uVar42 = *(undefined4 *)(param_2 + 9);
          uVar43 = *(undefined4 *)((int)param_2 + 0x4c);
          uVar3 = *(undefined4 *)(param_2 + 10);
          uVar4 = *(undefined4 *)((int)param_2 + 0x54);
          uVar5 = *(undefined4 *)(param_2 + 0xb);
          uVar6 = *(undefined4 *)((int)param_2 + 0x5c);
          uVar7 = *(undefined4 *)(param_2 + 0xc);
          uVar8 = *(undefined4 *)((int)param_2 + 100);
          uVar9 = *(undefined4 *)(param_2 + 0xd);
          uVar10 = *(undefined4 *)((int)param_2 + 0x6c);
          uVar11 = *(undefined4 *)(param_2 + 0xe);
          uVar12 = *(undefined4 *)((int)param_2 + 0x74);
          uVar13 = *(undefined4 *)(param_2 + 0xf);
          uVar14 = *(undefined4 *)((int)param_2 + 0x7c);
          *(undefined4 *)(puVar38 + 8) = *(undefined4 *)(param_2 + 8);
          *(undefined4 *)((int)puVar38 + 0x44) = uVar41;
          *(undefined4 *)(puVar38 + 9) = uVar42;
          *(undefined4 *)((int)puVar38 + 0x4c) = uVar43;
          *(undefined4 *)(puVar38 + 10) = uVar3;
          *(undefined4 *)((int)puVar38 + 0x54) = uVar4;
          *(undefined4 *)(puVar38 + 0xb) = uVar5;
          *(undefined4 *)((int)puVar38 + 0x5c) = uVar6;
          *(undefined4 *)(puVar38 + 0xc) = uVar7;
          *(undefined4 *)((int)puVar38 + 100) = uVar8;
          *(undefined4 *)(puVar38 + 0xd) = uVar9;
          *(undefined4 *)((int)puVar38 + 0x6c) = uVar10;
          *(undefined4 *)(puVar38 + 0xe) = uVar11;
          *(undefined4 *)((int)puVar38 + 0x74) = uVar12;
          *(undefined4 *)(puVar38 + 0xf) = uVar13;
          *(undefined4 *)((int)puVar38 + 0x7c) = uVar14;
          param_2 = param_2 + 0x10;
          puVar38 = puVar38 + 0x10;
        }
        goto LAB_0067358a;
      }
      if (((_DAT_10012b44 & 1) == 0) || (((uint)param_1 & 3) != 0)) goto LAB_006732e4;
      if (((uint)param_2 & 3) == 0) {
        if (((uint)param_1 >> 2 & 1) != 0) {
          uVar41 = *(undefined4 *)param_2;
          param_3 = param_3 - 4;
          param_2 = (undefined8 *)((int)param_2 + 4);
          *(undefined4 *)param_1 = uVar41;
          param_1 = (undefined8 *)((int)param_1 + 4);
        }
        if (((uint)param_1 >> 3 & 1) != 0) {
          uVar44 = *param_2;
          param_3 = param_3 - 8;
          param_2 = param_2 + 1;
          *param_1 = uVar44;
          param_1 = param_1 + 1;
        }
        if (((uint)param_2 & 7) == 0) {
          puVar38 = param_2 + -1;
          uVar41 = *(undefined4 *)param_2;
          uVar42 = *(undefined4 *)((int)param_2 + 4);
          do {
            puVar35 = puVar38;
            uVar4 = *(undefined4 *)(puVar35 + 4);
            uVar5 = *(undefined4 *)((int)puVar35 + 0x24);
            param_3 = param_3 - 0x30;
            auVar1 = *(undefined (*) [32])(puVar35 + 2);
            uVar43 = *(undefined4 *)(puVar35 + 7);
            uVar3 = *(undefined4 *)((int)puVar35 + 0x3c);
            auVar2 = *(undefined (*) [32])(puVar35 + 4);
            *(undefined4 *)(param_1 + 1) = uVar41;
            *(undefined4 *)((int)param_1 + 0xc) = uVar42;
            *(undefined4 *)(param_1 + 2) = uVar4;
            *(undefined4 *)((int)param_1 + 0x14) = uVar5;
            *(undefined (*) [16])(param_1 + 2) = SUB3216(auVar1 >> 0x40,0);
            *(undefined (*) [16])(param_1 + 4) = SUB3216(auVar2 >> 0x40,0);
            param_1 = param_1 + 6;
            puVar38 = puVar35 + 6;
            uVar41 = uVar43;
            uVar42 = uVar3;
          } while (0x2f < (int)param_3);
          puVar35 = puVar35 + 7;
        }
        else if (((uint)param_2 >> 3 & 1) == 0) {
          iVar31 = (int)param_2 + -4;
          uVar41 = *(undefined4 *)param_2;
          uVar42 = *(undefined4 *)((int)param_2 + 4);
          uVar43 = *(undefined4 *)(param_2 + 1);
          do {
            iVar34 = iVar31;
            uVar6 = *(undefined4 *)(iVar34 + 0x20);
            param_3 = param_3 - 0x30;
            auVar1 = *(undefined (*) [32])(iVar34 + 0x10);
            uVar3 = *(undefined4 *)(iVar34 + 0x34);
            uVar4 = *(undefined4 *)(iVar34 + 0x38);
            uVar5 = *(undefined4 *)(iVar34 + 0x3c);
            auVar2 = *(undefined (*) [32])(iVar34 + 0x20);
            *(undefined4 *)((int)param_1 + 4) = uVar41;
            *(undefined4 *)(param_1 + 1) = uVar42;
            *(undefined4 *)((int)param_1 + 0xc) = uVar43;
            *(undefined4 *)(param_1 + 2) = uVar6;
            *(undefined (*) [16])(param_1 + 2) = SUB3216(auVar1 >> 0x20,0);
            *(undefined (*) [16])(param_1 + 4) = SUB3216(auVar2 >> 0x20,0);
            param_1 = param_1 + 6;
            iVar31 = iVar34 + 0x30;
            uVar41 = uVar3;
            uVar42 = uVar4;
            uVar43 = uVar5;
          } while (0x2f < (int)param_3);
          puVar35 = (undefined8 *)(iVar34 + 0x34);
        }
        else {
          iVar31 = (int)param_2 + -0xc;
          uVar41 = *(undefined4 *)param_2;
          do {
            iVar34 = iVar31;
            uVar43 = *(undefined4 *)(iVar34 + 0x20);
            uVar3 = *(undefined4 *)(iVar34 + 0x24);
            uVar4 = *(undefined4 *)(iVar34 + 0x28);
            param_3 = param_3 - 0x30;
            auVar1 = *(undefined (*) [32])(iVar34 + 0x10);
            uVar42 = *(undefined4 *)(iVar34 + 0x3c);
            auVar2 = *(undefined (*) [32])(iVar34 + 0x20);
            *(undefined4 *)((int)param_1 + 0xc) = uVar41;
            *(undefined4 *)(param_1 + 2) = uVar43;
            *(undefined4 *)((int)param_1 + 0x14) = uVar3;
            *(undefined4 *)(param_1 + 3) = uVar4;
            *(undefined (*) [16])(param_1 + 2) = SUB3216(auVar1 >> 0x60,0);
            *(undefined (*) [16])(param_1 + 4) = SUB3216(auVar2 >> 0x60,0);
            param_1 = param_1 + 6;
            iVar31 = iVar34 + 0x30;
            uVar41 = uVar42;
          } while (0x2f < (int)param_3);
          puVar35 = (undefined8 *)(iVar34 + 0x3c);
        }
        for (; 0xf < (int)param_3; param_3 = param_3 - 0x10) {
          uVar41 = *(undefined4 *)puVar35;
          uVar42 = *(undefined4 *)((int)puVar35 + 4);
          uVar43 = *(undefined4 *)(puVar35 + 1);
          uVar3 = *(undefined4 *)((int)puVar35 + 0xc);
          puVar35 = puVar35 + 2;
          *(undefined4 *)param_1 = uVar41;
          *(undefined4 *)((int)param_1 + 4) = uVar42;
          *(undefined4 *)(param_1 + 1) = uVar43;
          *(undefined4 *)((int)param_1 + 0xc) = uVar3;
          param_1 = param_1 + 2;
        }
        if ((param_3 >> 2 & 1) != 0) {
          uVar41 = *(undefined4 *)puVar35;
          param_3 = param_3 - 4;
          puVar35 = (undefined8 *)((int)puVar35 + 4);
          *(undefined4 *)param_1 = uVar41;
          param_1 = (undefined8 *)((int)param_1 + 4);
        }
        if ((param_3 >> 3 & 1) != 0) {
          param_3 = param_3 - 8;
          *param_1 = *puVar35;
        }
                    // WARNING: Could not recover jumptable at 0x006732e2. Too many branches
                    // WARNING: Treating indirect jump as call
        uVar44 = (**(code **)(param_3 * 4 + 0x100033b4))();
        return uVar44;
      }
    }
    uVar32 = param_3;
    if (0x1f < param_3) {
      for (uVar32 = param_3 >> 2; uVar32 != 0; uVar32 = uVar32 - 1) {
        *(undefined4 *)puVar38 = *(undefined4 *)param_2;
        param_2 = (undefined8 *)((int)param_2 + 4);
        puVar38 = (undefined8 *)((int)puVar38 + 4);
      }
                    // WARNING: Could not emulate address calculation at 0x00673312
                    // WARNING: Treating indirect jump as call
      uVar44 = (**(code **)((param_3 & 3) * 4 + 0x100033b4))();
      return uVar44;
    }
  }
LAB_006735b8:
  if ((uVar32 & 0x1f) != 0) {
    for (uVar33 = (uVar32 & 0x1f) >> 2; uVar33 != 0; uVar33 = uVar33 - 1) {
      param_3 = *(uint *)param_2;
      *(uint *)puVar38 = param_3;
      puVar38 = (undefined8 *)((int)puVar38 + 4);
      param_2 = (undefined8 *)((int)param_2 + 4);
    }
    for (uVar32 = uVar32 & 3; uVar32 != 0; uVar32 = uVar32 - 1) {
      *(undefined *)puVar38 = *(undefined *)param_2;
      param_2 = (undefined8 *)((int)param_2 + 1);
      puVar38 = (undefined8 *)((int)puVar38 + 1);
    }
  }
LAB_006735ed:
  return CONCAT44(param_3,param_1);
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// Library Function - Single Match
//  __CallSettingFrame@12
// 
// Library: Visual Studio

void __CallSettingFrame_12(undefined4 param_1,undefined4 param_2,int param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)__NLG_Notify1(param_3);
  (*pcVar1)();
  if (param_3 == 0x100) {
    param_3 = 2;
  }
  __NLG_Notify1(param_3);
  return;
}



void FUN_00673c96(undefined4 param_1,code *param_2)

{
  (*param_2)();
  return;
}



undefined4 FUN_00673ca3(undefined4 *param_1,int param_2)

{
  undefined4 *puVar1;
  int extraout_ECX;
  undefined8 uVar2;
  uint local_c;
  int iVar3;
  
  if (param_1 == (undefined4 *)0x0) {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 0x16;
    FUN_00675085();
  }
  else if (param_2 == 1) {
    local_c = 0;
    iVar3 = 0;
    FUN_00675485(&local_c);
    iVar3 = (iVar3 + -0x19db1de) - (uint)(local_c < 0xd53e8000);
    if ((iVar3 < 0x483f078) || ((iVar3 < 0x483f079 && (local_c + 0x2ac18000 < 0xdd478000)))) {
      uVar2 = __alldvrm(local_c + 0x2ac18000,iVar3,10000000,0);
      *param_1 = (int)uVar2;
      param_1[1] = (int)((ulonglong)uVar2 >> 0x20);
      param_1[2] = extraout_ECX * 100;
      return 1;
    }
  }
  return 0;
}



// Library Function - Multiple Matches With Different Base Names
//  __int64 __cdecl common_time<__int64>(__int64 * const)
//  __time64
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

__time64_t __cdecl FID_conflict___time64(__time64_t *_Time)

{
  int iVar1;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 uStack12;
  undefined4 uStack8;
  
  local_14 = 0;
  local_10 = 0;
  uStack12 = 0;
  uStack8 = 0;
  iVar1 = FUN_00673ca3(&local_14,1);
  if (iVar1 != 1) {
    local_14 = 0xffffffff;
    local_10 = 0xffffffff;
  }
  if (_Time != (__time64_t *)0x0) {
    *(undefined4 *)_Time = local_14;
    *(undefined4 *)((int)_Time + 4) = local_10;
  }
  return CONCAT44(local_10,local_14);
}



uint FUN_00673d69(void)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = FUN_006759b1();
  uVar2 = *(int *)(iVar1 + 0x18) * 0x343fd + 0x269ec3;
  *(uint *)(iVar1 + 0x18) = uVar2;
  return uVar2 >> 0x10 & 0x7fff;
}



void FUN_00673d8a(undefined4 param_1)

{
  int iVar1;
  
  iVar1 = FUN_006759b1();
  *(undefined4 *)(iVar1 + 0x18) = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __initterm
// 
// Library: Visual Studio 2015 Release

void __thiscall __initterm(code *param_1_00,code **param_1,code **param_2)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar3 = 0;
  uVar2 = ~-(uint)(param_2 < param_1) & (uint)((int)param_2 + (3 - (int)param_1)) >> 2;
  if (uVar2 != 0) {
    do {
      param_1_00 = *param_1;
      if (param_1_00 != (code *)0x0) {
        (*_DAT_1000c174)();
        (*param_1_00)();
      }
      param_1 = param_1 + 1;
      uVar3 = uVar3 + 1;
    } while (uVar3 != uVar2);
  }
  ___security_check_cookie_4(param_1_00,uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __initterm_e
// 
// Library: Visual Studio 2015 Release

void __initterm_e(code **param_1,code **param_2)

{
  code *pcVar1;
  uint uVar2;
  int iVar3;
  
  uVar2 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  for (; param_1 != param_2; param_1 = param_1 + 1) {
    pcVar1 = *param_1;
    if (pcVar1 != (code *)0x0) {
      (*_DAT_1000c174)();
      iVar3 = (*pcVar1)();
      if (iVar3 != 0) break;
    }
  }
  ___security_check_cookie_4(uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00673e3d(undefined4 param_1)

{
  _DAT_10012bf0 = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __callnewh
// 
// Library: Visual Studio 2015 Release

int __cdecl __callnewh(size_t _Size)

{
  uint uVar1;
  code *pcVar2;
  int iVar3;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)__query_new_handler();
  if (pcVar2 != (code *)0x0) {
    (*_DAT_1000c174)(_Size);
    (*pcVar2)();
  }
  iVar3 = ___security_check_cookie_4(uVar1);
  return iVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __query_new_handler
// 
// Library: Visual Studio 2015 Release

uint __query_new_handler(void)

{
  byte bVar1;
  uint uVar2;
  
  ___acrt_lock(0);
  bVar1 = (byte)_DAT_10012000 & 0x1f;
  uVar2 = _DAT_10012000 ^ _DAT_10012bf0;
  FUN_00673ed9();
  return uVar2 >> bVar1 | uVar2 << 0x20 - bVar1;
}



void FUN_00673ed9(void)

{
  ___acrt_unlock(0);
  return;
}



void FUN_00673ee2(void)

{
  __malloc_base();
  return;
}



// Library Function - Single Match
//  __seh_filter_dll
// 
// Library: Visual Studio 2015 Release

undefined4 __seh_filter_dll(int param_1,undefined4 param_2)

{
  undefined4 uVar1;
  
  if (param_1 != -0x1f928c9d) {
    return 0;
  }
  uVar1 = __seh_filter_exe(0xe06d7363,param_2);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __seh_filter_exe
// 
// Library: Visual Studio 2015 Release

void __seh_filter_exe(uint param_1,uint *param_2)

{
  uint *puVar1;
  code *pcVar2;
  uint uVar3;
  uint **ppuVar4;
  uint *puVar5;
  uint *puVar6;
  uint *extraout_var;
  uint *puVar7;
  
  uVar3 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  ppuVar4 = (uint **)FUN_00675aff();
  puVar7 = extraout_var;
  if (ppuVar4 != (uint **)0x0) {
    puVar1 = *ppuVar4;
    for (puVar6 = puVar1; puVar6 != puVar1 + 0x24; puVar6 = puVar6 + 3) {
      if (*puVar6 == param_1) goto LAB_00673f50;
    }
    puVar6 = (uint *)0x0;
LAB_00673f50:
    if ((puVar6 != (uint *)0x0) && (pcVar2 = (code *)puVar6[2], pcVar2 != (code *)0x0)) {
      if (pcVar2 == (code *)0x5) {
        puVar6[2] = 0;
      }
      else if (pcVar2 != (code *)0x1) {
        puVar7 = ppuVar4[1];
        ppuVar4[1] = param_2;
        if (puVar6[1] == 8) {
          for (puVar5 = puVar1 + 9; puVar5 != puVar1 + 0x24; puVar5 = puVar5 + 3) {
            puVar5[2] = 0;
          }
          puVar1 = ppuVar4[2];
          if (*puVar6 < 0xc0000092) {
            if (*puVar6 == 0xc0000091) {
              ppuVar4[2] = (uint *)0x84;
            }
            else if (*puVar6 == 0xc000008d) {
              ppuVar4[2] = (uint *)0x82;
            }
            else if (*puVar6 == 0xc000008e) {
              ppuVar4[2] = (uint *)0x83;
            }
            else if (*puVar6 == 0xc000008f) {
              ppuVar4[2] = (uint *)0x86;
            }
            else if (*puVar6 == 0xc0000090) {
              ppuVar4[2] = (uint *)0x81;
            }
          }
          else if (*puVar6 == 0xc0000092) {
            ppuVar4[2] = (uint *)0x8a;
          }
          else if (*puVar6 == 0xc0000093) {
            ppuVar4[2] = (uint *)0x85;
          }
          else if (*puVar6 == 0xc00002b4) {
            ppuVar4[2] = (uint *)0x8e;
          }
          else if (*puVar6 == 0xc00002b5) {
            ppuVar4[2] = (uint *)0x8d;
          }
          (*_DAT_1000c174)(8,ppuVar4[2]);
          (*pcVar2)();
          ppuVar4[2] = puVar1;
        }
        else {
          puVar6[2] = 0;
          (*_DAT_1000c174)(puVar6[1]);
          (*pcVar2)();
        }
        ppuVar4[1] = puVar7;
      }
    }
  }
  ___security_check_cookie_4(puVar7,uVar3);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_03b1d95aef87969028cfba75ccab2455>,class <lambda_6e4b09c48022b2350581041d5f6b0c4c>&,class
// <lambda_22bdf7517842c4b3e53723af5aa32b9e>>(class
// <lambda_03b1d95aef87969028cfba75ccab2455>&&,class
// <lambda_6e4b09c48022b2350581041d5f6b0c4c>&,class <lambda_22bdf7517842c4b3e53723af5aa32b9e>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_03b1d95aef87969028cfba75ccab2455__class__lambda_6e4b09c48022b2350581041d5f6b0c4c___class__lambda_22bdf7517842c4b3e53723af5aa32b9e___
          (__crt_seh_guarded_call_void_ *this,_lambda_03b1d95aef87969028cfba75ccab2455_ *param_1,
          _lambda_6e4b09c48022b2350581041d5f6b0c4c_ *param_2,
          _lambda_22bdf7517842c4b3e53723af5aa32b9e_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  FUN_006740c3();
  FUN_006740b7();
  return;
}



void FUN_006740b7(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_006740c3(int **param_1)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  undefined4 uVar4;
  
  if (DAT_10012bfc != '\0') goto LAB_00674180;
  _DAT_10012bf4 = 1;
  if (**param_1 == 0) {
    bVar2 = (byte)_DAT_10012000 & 0x1f;
    bVar1 = 0x20 - bVar2 & 0x1f;
    if (_DAT_10012bf8 != ((0U >> bVar1 | 0 << 0x20 - bVar1) ^ _DAT_10012000)) {
      uVar3 = _DAT_10012000 ^ _DAT_10012bf8;
      (*_DAT_1000c174)(0,0,0);
      (*(code *)(uVar3 >> bVar2 | uVar3 << 0x20 - bVar2))();
    }
    uVar4 = 0x10012d18;
LAB_00674137:
    __execute_onexit_table(uVar4);
  }
  else if (**param_1 == 1) {
    uVar4 = 0x10012d24;
    goto LAB_00674137;
  }
  if (**param_1 == 0) {
    __initterm(0x1000c194,0x1000c1a4);
  }
  __initterm(0x1000c1a8,0x1000c1ac);
  if (*param_1[1] == 0) {
    DAT_10012bfc = '\x01';
    *(undefined *)param_1[2] = 1;
  }
LAB_00674180:
  FUN_0067b856();
  return;
}



bool FUN_0067419f(int param_1)

{
  return param_1 == -0x1f928c9d;
}



// Library Function - Single Match
//  void __cdecl common_exit(int,enum _crt_exit_cleanup_mode,enum _crt_exit_return_mode)
// 
// Library: Visual Studio 2017 Release

void __cdecl common_exit(int param_1,_crt_exit_cleanup_mode param_2,_crt_exit_return_mode param_3)

{
  code *pcVar1;
  char cVar2;
  _crt_exit_cleanup_mode *local_1c;
  _crt_exit_return_mode *local_18;
  undefined *local_14;
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_6;
  undefined local_5;
  
  if (param_3 == 0) {
    cVar2 = ___scrt_is_managed_app();
    if (cVar2 != '\0') {
      try_cor_exit_process(param_1);
    }
  }
  local_1c = &param_2;
  local_5 = 0;
  local_18 = &param_3;
  local_14 = &local_5;
  local_c = 2;
  local_10 = 2;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_03b1d95aef87969028cfba75ccab2455__class__lambda_6e4b09c48022b2350581041d5f6b0c4c___class__lambda_22bdf7517842c4b3e53723af5aa32b9e___
            (&local_6,(_lambda_03b1d95aef87969028cfba75ccab2455_ *)&local_10,
             (_lambda_6e4b09c48022b2350581041d5f6b0c4c_ *)&local_1c,
             (_lambda_22bdf7517842c4b3e53723af5aa32b9e_ *)&local_c);
  if (param_3 != 0) {
    return;
  }
  exit_or_terminate_process(param_1);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl exit_or_terminate_process(unsigned int)
// 
// Library: Visual Studio 2017 Release

void __cdecl exit_or_terminate_process(uint param_1)

{
  code *pcVar1;
  int iVar2;
  undefined4 uVar3;
  int in_FS_OFFSET;
  
  iVar2 = ___acrt_get_process_end_policy();
  if ((iVar2 != 1) && ((*(uint *)(*(int *)(in_FS_OFFSET + 0x30) + 0x68) >> 8 & 1) == 0)) {
    uVar3 = (*_DAT_1000c088)(param_1);
    (*_DAT_1000c08c)(uVar3);
  }
  try_cor_exit_process(param_1);
  (*_DAT_1000c0f0)(param_1);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___scrt_is_managed_app
// 
// Library: Visual Studio 2015 Release

uint ___scrt_is_managed_app(void)

{
  int *piVar1;
  int *piVar2;
  
  piVar1 = (int *)(*_DAT_1000c0b0)(0);
  piVar2 = piVar1;
  if ((((piVar1 != (int *)0x0) && (piVar2 = (int *)0x5a4d, *(short *)piVar1 == 0x5a4d)) &&
      (piVar2 = (int *)(piVar1[0xf] + (int)piVar1), *piVar2 == 0x4550)) &&
     ((*(short *)(piVar2 + 6) == 0x10b && (0xe < (uint)piVar2[0x1d])))) {
    return (uint)piVar2 & 0xffffff00 | (uint)(piVar2[0x3a] != 0);
  }
  return (uint)piVar2 & 0xffffff00;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl try_cor_exit_process(unsigned int)
// 
// Library: Visual Studio 2015 Release

void __cdecl try_cor_exit_process(uint param_1)

{
  int iVar1;
  code *pcVar2;
  int local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_c = 0;
  iVar1 = (*_DAT_1000c0f4)(0,0x1000cb8c,&local_c);
  if ((iVar1 != 0) && (pcVar2 = (code *)(*_DAT_1000c058)(local_c,0x1000cba4), pcVar2 != (code *)0x0)
     ) {
    (*_DAT_1000c174)(param_1);
    (*pcVar2)();
  }
  if (local_c != 0) {
    (*_DAT_1000c0e8)(local_c);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00674308(undefined4 param_1)

{
  _DAT_10012bf8 = param_1;
  return;
}



// Library Function - Single Match
//  __exit
// 
// Library: Visual Studio 2017 Release

void __exit(int param_1)

{
  common_exit(param_1,2,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0067433c(void)

{
  return _DAT_10012bf4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_00674342(int param_1)

{
  int iVar1;
  undefined4 *puVar2;
  int *piVar3;
  int *piVar4;
  char *local_14;
  undefined4 local_10;
  int *local_c;
  int local_8;
  
  if (param_1 == 0) {
    iVar1 = 0;
  }
  else if ((param_1 == 2) || (param_1 == 1)) {
    ___acrt_initialize_multibyte();
    iVar1 = 0;
    (*_DAT_1000c0f8)(0,0x10012c00,0x104);
    _DAT_10012f8c = 0x10012c00;
    local_14 = _DAT_10012f84;
    if ((_DAT_10012f84 == (char *)0x0) || (*_DAT_10012f84 == '\0')) {
      local_14 = (char *)0x10012c00;
    }
    local_8 = 0;
    local_10 = 0;
    FUN_00674478(local_14,0,0,&local_8,&local_10);
    piVar3 = (int *)FUN_006745ec(local_8,local_10,1);
    piVar4 = piVar3;
    if (piVar3 == (int *)0x0) {
      puVar2 = (undefined4 *)FUN_00675142();
      iVar1 = 0xc;
      *puVar2 = 0xc;
    }
    else {
      FUN_00674478(local_14,piVar3,piVar3 + local_8,&local_8,&local_10);
      if (param_1 == 1) {
        _DAT_10012f78 = local_8 + -1;
        piVar4 = (int *)0x0;
        _DAT_10012f7c = piVar3;
      }
      else {
        local_c = (int *)0x0;
        iVar1 = FUN_0067617d(piVar3,&local_c);
        piVar3 = local_c;
        if (iVar1 == 0) {
          _DAT_10012f78 = 0;
          iVar1 = *local_c;
          while (iVar1 != 0) {
            local_c = local_c + 1;
            _DAT_10012f78 = _DAT_10012f78 + 1;
            iVar1 = *local_c;
          }
          local_c = (int *)0x0;
          iVar1 = 0;
          _DAT_10012f7c = piVar3;
        }
        FID_conflict__free(local_c);
        local_c = (int *)0x0;
      }
    }
    FID_conflict__free(piVar4);
  }
  else {
    puVar2 = (undefined4 *)FUN_00675142();
    iVar1 = 0x16;
    *puVar2 = 0x16;
    FUN_00675085();
  }
  return iVar1;
}



void FUN_00674478(char *param_1,char **param_2,char *param_3,int *param_4,int *param_5)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  bool bVar4;
  bool bVar5;
  char *pcVar6;
  char *pcVar7;
  
  *param_5 = 0;
  *param_4 = 1;
  if (param_2 != (char **)0x0) {
    *param_2 = param_3;
    param_2 = param_2 + 1;
  }
  bVar4 = false;
  bVar5 = false;
  do {
    if (*param_1 == '\"') {
      bVar5 = !bVar4;
      cVar1 = '\"';
      pcVar6 = param_1 + 1;
      bVar4 = bVar5;
    }
    else {
      *param_5 = *param_5 + 1;
      if (param_3 != (char *)0x0) {
        *param_3 = *param_1;
        param_3 = param_3 + 1;
      }
      cVar1 = *param_1;
      pcVar6 = param_1 + 1;
      iVar3 = __ismbblead((int)cVar1);
      if (iVar3 != 0) {
        *param_5 = *param_5 + 1;
        if (param_3 != (char *)0x0) {
          *param_3 = *pcVar6;
          param_3 = param_3 + 1;
        }
        pcVar6 = param_1 + 2;
      }
      if (cVar1 == '\0') {
        pcVar6 = pcVar6 + -1;
        goto LAB_00674508;
      }
    }
    param_1 = pcVar6;
  } while ((bVar5) || ((cVar1 != ' ' && (cVar1 != '\t'))));
  if (param_3 != (char *)0x0) {
    param_3[-1] = '\0';
  }
LAB_00674508:
  bVar5 = false;
  while (pcVar7 = pcVar6, *pcVar6 != '\0') {
    for (; (cVar1 = *pcVar7, cVar1 == ' ' || (cVar1 == '\t')); pcVar7 = pcVar7 + 1) {
    }
    if (cVar1 == '\0') break;
    if (param_2 != (char **)0x0) {
      *param_2 = param_3;
      param_2 = param_2 + 1;
    }
    *param_4 = *param_4 + 1;
    while( true ) {
      bVar4 = true;
      uVar2 = 0;
      for (; *pcVar7 == '\\'; pcVar7 = pcVar7 + 1) {
        uVar2 = uVar2 + 1;
      }
      pcVar6 = pcVar7;
      if (*pcVar7 == '\"') {
        if (((uVar2 & 1) == 0) && ((!bVar5 || (pcVar6 = pcVar7 + 1, *pcVar6 != '\"')))) {
          bVar4 = false;
          bVar5 = !bVar5;
          pcVar6 = pcVar7;
        }
        uVar2 = uVar2 >> 1;
      }
      while (uVar2 != 0) {
        uVar2 = uVar2 - 1;
        if (param_3 != (char *)0x0) {
          *param_3 = '\\';
          param_3 = param_3 + 1;
        }
        *param_5 = *param_5 + 1;
      }
      cVar1 = *pcVar6;
      if ((cVar1 == '\0') || ((!bVar5 && ((cVar1 == ' ' || (cVar1 == '\t')))))) break;
      if (bVar4) {
        if (param_3 != (char *)0x0) {
          *param_3 = cVar1;
          param_3 = param_3 + 1;
        }
        iVar3 = __ismbblead((int)*pcVar6);
        if (iVar3 != 0) {
          pcVar6 = pcVar6 + 1;
          *param_5 = *param_5 + 1;
          if (param_3 != (char *)0x0) {
            *param_3 = *pcVar6;
            param_3 = param_3 + 1;
          }
        }
        *param_5 = *param_5 + 1;
      }
      pcVar7 = pcVar6 + 1;
    }
    if (param_3 != (char *)0x0) {
      *param_3 = '\0';
      param_3 = param_3 + 1;
    }
    *param_5 = *param_5 + 1;
  }
  if (param_2 != (char **)0x0) {
    *param_2 = (char *)0x0;
  }
  *param_4 = *param_4 + 1;
  return;
}



undefined4 FUN_006745ec(uint param_1,uint param_2,uint param_3)

{
  undefined4 uVar1;
  
  if ((param_1 < 0x3fffffff) && (param_2 < (uint)(0xffffffff / (ulonglong)param_3))) {
    if (param_2 * param_3 < ~(param_1 * 4)) {
      uVar1 = __calloc_base(param_1 * 4 + param_2 * param_3,1);
      FID_conflict__free((void *)0x0);
      return uVar1;
    }
  }
  return 0;
}



void FUN_0067463b(void)

{
  FUN_00674342();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  int __cdecl common_initialize_environment_nolock<char>(void)
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl common_initialize_environment_nolock_char_(void)

{
  char *_Memory;
  char **ppcVar1;
  int iVar2;
  
  if (_DAT_10012d08 != (char **)0x0) {
    return 0;
  }
  ___acrt_initialize_multibyte();
  _Memory = (char *)___dcrt_get_narrow_environment_from_os();
  if (_Memory == (char *)0x0) {
    iVar2 = -1;
  }
  else {
    ppcVar1 = create_environment_char_(_Memory);
    if (ppcVar1 == (char **)0x0) {
      iVar2 = -1;
    }
    else {
      iVar2 = 0;
      _DAT_10012d08 = ppcVar1;
      _DAT_10012d14 = ppcVar1;
    }
    FID_conflict__free((void *)0x0);
  }
  FID_conflict__free(_Memory);
  return iVar2;
}



// Library Function - Single Match
//  char * * __cdecl create_environment<char>(char * const)
// 
// Library: Visual Studio 2015 Release

char ** __cdecl create_environment_char_(char *param_1)

{
  code *pcVar1;
  char cVar2;
  char **ppcVar3;
  char *_Dst;
  errno_t eVar4;
  char *pcVar5;
  int iVar6;
  char **local_8;
  
  iVar6 = 0;
  cVar2 = *param_1;
  pcVar5 = param_1;
  while (cVar2 != '\0') {
    if (cVar2 != '=') {
      iVar6 = iVar6 + 1;
    }
    do {
      cVar2 = *pcVar5;
      pcVar5 = pcVar5 + 1;
    } while (cVar2 != '\0');
    cVar2 = *pcVar5;
  }
  ppcVar3 = (char **)__calloc_base(iVar6 + 1,4);
  local_8 = ppcVar3;
  if (ppcVar3 == (char **)0x0) {
LAB_0067474a:
    ppcVar3 = (char **)0x0;
  }
  else {
    for (; *param_1 != '\0'; param_1 = param_1 + (int)pcVar5) {
      pcVar5 = param_1;
      do {
        cVar2 = *pcVar5;
        pcVar5 = pcVar5 + 1;
      } while (cVar2 != '\0');
      pcVar5 = pcVar5 + (1 - (int)(param_1 + 1));
      if (*param_1 != '=') {
        _Dst = (char *)__calloc_base(pcVar5,1);
        if (_Dst == (char *)0x0) {
          free_environment_char_(ppcVar3);
          FID_conflict__free((void *)0x0);
          goto LAB_0067474a;
        }
        eVar4 = _strcpy_s(_Dst,(rsize_t)pcVar5,param_1);
        if (eVar4 != 0) {
          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          pcVar1 = (code *)swi(3);
          ppcVar3 = (char **)(*pcVar1)();
          return ppcVar3;
        }
        *local_8 = _Dst;
        local_8 = local_8 + 1;
        FID_conflict__free((void *)0x0);
      }
    }
  }
  FID_conflict__free((void *)0x0);
  return ppcVar3;
}



// Library Function - Single Match
//  void __cdecl free_environment<char>(char * * const)
// 
// Library: Visual Studio 2015 Release

void __cdecl free_environment_char_(char **param_1)

{
  char *_Memory;
  char **ppcVar1;
  
  if (param_1 != (char **)0x0) {
    _Memory = *param_1;
    ppcVar1 = param_1;
    while (_Memory != (char *)0x0) {
      FID_conflict__free(_Memory);
      ppcVar1 = ppcVar1 + 1;
      _Memory = *ppcVar1;
    }
    FID_conflict__free(param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall __crt_state_management::dual_state_global<char * *>::uninitialize<void
// (__cdecl&)(char * * &)>(void (__cdecl&)(char * * &))
//  public: void __thiscall __crt_state_management::dual_state_global<wchar_t *
// *>::uninitialize<void (__cdecl&)(wchar_t * * &)>(void (__cdecl&)(wchar_t * * &))
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void __thiscall uninitialize__(int param_1_00,code *param_1)

{
  int iVar1;
  uint uVar2;
  
  uVar2 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar1 = param_1_00 + 4;
  for (; param_1_00 != iVar1; param_1_00 = param_1_00 + 4) {
    (*_DAT_1000c174)(param_1_00);
    (*param_1)();
  }
  ___security_check_cookie_4(uVar2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  void __cdecl uninitialize_environment_internal<char>(char * * &)
//  void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void uninitialize_environment_internal__(undefined4 *param_1)

{
  if ((char **)*param_1 != _DAT_10012d14) {
    free_environment_char_((char **)*param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  void __cdecl uninitialize_environment_internal<char>(char * * &)
//  void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void uninitialize_environment_internal__(undefined4 *param_1)

{
  if ((char **)*param_1 != _DAT_10012d10) {
    free_environment_char_((char **)*param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl common_initialize_environment_nolock_char_(void)

{
  char *_Memory;
  char **ppcVar1;
  int iVar2;
  
  if (_DAT_10012d08 != (char **)0x0) {
    return 0;
  }
  ___acrt_initialize_multibyte();
  _Memory = (char *)___dcrt_get_narrow_environment_from_os();
  if (_Memory == (char *)0x0) {
    iVar2 = -1;
  }
  else {
    ppcVar1 = create_environment_char_(_Memory);
    if (ppcVar1 == (char **)0x0) {
      iVar2 = -1;
    }
    else {
      iVar2 = 0;
      _DAT_10012d08 = ppcVar1;
      _DAT_10012d14 = ppcVar1;
    }
    FID_conflict__free((void *)0x0);
  }
  FID_conflict__free(_Memory);
  return iVar2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_69a2805e680e0e292e8ba93315fe43a8>,class <lambda_f03950bc5685219e0bcd2087efbe011e>&,class
// <lambda_03fcd07e894ec930e3f35da366ca99d6>>(class
// <lambda_69a2805e680e0e292e8ba93315fe43a8>&&,class
// <lambda_f03950bc5685219e0bcd2087efbe011e>&,class <lambda_03fcd07e894ec930e3f35da366ca99d6>&&)
// 
// Library: Visual Studio 2017 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_69a2805e680e0e292e8ba93315fe43a8__class__lambda_f03950bc5685219e0bcd2087efbe011e___class__lambda_03fcd07e894ec930e3f35da366ca99d6___
          (__crt_seh_guarded_call_int_ *this,_lambda_69a2805e680e0e292e8ba93315fe43a8_ *param_1,
          _lambda_f03950bc5685219e0bcd2087efbe011e_ *param_2,
          _lambda_03fcd07e894ec930e3f35da366ca99d6_ *param_3)

{
  int iVar1;
  
  ___acrt_lock(*(undefined4 *)param_1);
  iVar1 = FUN_0067489c();
  FUN_00674890();
  return iVar1;
}



void FUN_00674890(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0067489c(int **param_1)

{
  uint *puVar1;
  byte bVar2;
  uint uVar3;
  uint *puVar4;
  sbyte sVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint *_Memory;
  uint *puVar9;
  uint *local_14;
  uint *local_10;
  
  puVar9 = (uint *)**param_1;
  if (puVar9 != (uint *)0x0) {
    uVar8 = _DAT_10012000 & 0x1f;
    sVar5 = (sbyte)uVar8;
    _Memory = (uint *)((*puVar9 ^ _DAT_10012000) >> sVar5 |
                      (*puVar9 ^ _DAT_10012000) << 0x20 - sVar5);
    puVar9 = (uint *)((puVar9[1] ^ _DAT_10012000) >> sVar5 |
                     (puVar9[1] ^ _DAT_10012000) << 0x20 - sVar5);
    if ((_Memory != (uint *)0x0) && (_Memory != (uint *)0xffffffff)) {
      bVar2 = 0x20U - sVar5 & 0x1f;
      uVar3 = (0U >> bVar2 | 0 << 0x20 - bVar2) ^ _DAT_10012000;
      uVar6 = _DAT_10012000;
      local_14 = puVar9;
      local_10 = _Memory;
      while (puVar9 = puVar9 + -1, _Memory <= puVar9) {
        if (*puVar9 != uVar3) {
          uVar6 = *puVar9 ^ uVar6;
          *puVar9 = uVar3;
          (*_DAT_1000c174)();
          (*(code *)(uVar6 >> (sbyte)uVar8 | uVar6 << 0x20 - (sbyte)uVar8))();
          uVar8 = _DAT_10012000 & 0x1f;
          uVar7 = *(uint *)**param_1 ^ _DAT_10012000;
          uVar6 = ((uint *)**param_1)[1] ^ _DAT_10012000;
          sVar5 = (sbyte)uVar8;
          puVar1 = (uint *)(uVar7 >> sVar5 | uVar7 << 0x20 - sVar5);
          puVar4 = (uint *)(uVar6 >> sVar5 | uVar6 << 0x20 - sVar5);
          uVar6 = _DAT_10012000;
          if ((puVar1 != local_10) || (puVar4 != local_14)) {
            _Memory = puVar1;
            puVar9 = puVar4;
            local_14 = puVar4;
            local_10 = puVar1;
          }
        }
      }
      if (_Memory != (uint *)0xffffffff) {
        FID_conflict__free(_Memory);
        uVar6 = _DAT_10012000;
      }
      bVar2 = 0x20 - ((byte)uVar6 & 0x1f) & 0x1f;
      uVar6 = (0U >> bVar2 | 0 << 0x20 - bVar2) ^ uVar6;
      *(uint *)**param_1 = uVar6;
      *(uint *)(**param_1 + 4) = uVar6;
      *(uint *)(**param_1 + 8) = uVar6;
    }
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  __execute_onexit_table
// 
// Library: Visual Studio 2017 Release

void __execute_onexit_table(void)

{
  undefined4 local_14;
  undefined *local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  local_10 = &stack0x00000004;
  local_c = 2;
  local_14 = 2;
  __crt_seh_guarded_call<int>::
  operator___class__lambda_69a2805e680e0e292e8ba93315fe43a8__class__lambda_f03950bc5685219e0bcd2087efbe011e___class__lambda_03fcd07e894ec930e3f35da366ca99d6___
            (&local_5,(_lambda_69a2805e680e0e292e8ba93315fe43a8_ *)&local_14,
             (_lambda_f03950bc5685219e0bcd2087efbe011e_ *)&local_10,
             (_lambda_03fcd07e894ec930e3f35da366ca99d6_ *)&local_c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __initialize_onexit_table
// 
// Library: Visual Studio 2015 Release

undefined4 __initialize_onexit_table(uint *param_1)

{
  byte bVar1;
  undefined4 uVar2;
  uint uVar3;
  
  if (param_1 == (uint *)0x0) {
    uVar2 = 0xffffffff;
  }
  else {
    if (*param_1 == param_1[2]) {
      bVar1 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
      uVar3 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ _DAT_10012000;
      *param_1 = uVar3;
      param_1[1] = uVar3;
      param_1[2] = uVar3;
    }
    uVar2 = 0;
  }
  return uVar2;
}



// Library Function - Single Match
//  _uninitialize_allocated_memory
// 
// Library: Visual Studio 2017 Release

undefined _uninitialize_allocated_memory(void)

{
  _lambda_af42a3ee9806e9a7305d451646e05244_ local_5;
  
  <lambda_af42a3ee9806e9a7305d451646e05244>::operator__
            (&local_5,(__crt_multibyte_data **)&DAT_10012f6c);
  return 1;
}



// Library Function - Single Match
//  public: void __thiscall <lambda_af42a3ee9806e9a7305d451646e05244>::operator()(struct
// __crt_multibyte_data * &)const 
// 
// Library: Visual Studio 2017 Release

void __thiscall
<lambda_af42a3ee9806e9a7305d451646e05244>::operator__
          (_lambda_af42a3ee9806e9a7305d451646e05244_ *this,__crt_multibyte_data **param_1)

{
  int iVar1;
  
  LOCK();
  iVar1 = *(int *)*param_1 + -1;
  *(int *)*param_1 = iVar1;
  if ((iVar1 == 0) && (*param_1 != (__crt_multibyte_data *)0x10012350)) {
    FID_conflict__free(*param_1);
    *param_1 = (__crt_multibyte_data *)0x10012350;
  }
  return;
}



// Library Function - Single Match
//  ___acrt_initialize
// 
// Library: Visual Studio 2015 Release

void ___acrt_initialize(void)

{
  ___acrt_execute_initializers(0x1000cbb8,&DAT_1000cc38);
  return;
}



uint FUN_00674b4d(void)

{
  uint uVar1;
  
  uVar1 = FUN_00675aff();
  return uVar1 & 0xffffff00 | (uint)(uVar1 != 0);
}



undefined FUN_00674b58(void)

{
  ___acrt_freeptd();
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_uninitialize
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 ___acrt_uninitialize(char param_1)

{
  undefined4 uVar1;
  
  if (param_1 != '\0') {
    if (_DAT_100131b8 != 0) {
      __flushall();
    }
    return 1;
  }
  uVar1 = FUN_00676dc4(0x1000cbb8,&DAT_1000cc38);
  return uVar1;
}



// Library Function - Single Match
//  ___acrt_uninitialize_critical
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___acrt_uninitialize_critical(undefined4 param_1)

{
  ___acrt_uninitialize_ptd(param_1);
  return 1;
}



void FUN_00674bde(void *param_1)

{
  FID_conflict__free(param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  __free_base
//  _free
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

void __cdecl FID_conflict__free(void *_Memory)

{
  int iVar1;
  int *piVar2;
  ulong uVar3;
  
  if (_Memory != (void *)0x0) {
    iVar1 = (*_DAT_1000c104)(_DAT_10012f90,0,_Memory);
    if (iVar1 == 0) {
      piVar2 = (int *)FUN_00675142();
      uVar3 = (*_DAT_1000c0c0)();
      iVar1 = FID_conflict____acrt_errno_from_os_error(uVar3);
      *piVar2 = iVar1;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __malloc_base
// 
// Library: Visual Studio 2017 Release

int __malloc_base(size_t param_1)

{
  int iVar1;
  undefined4 *puVar2;
  
  if (param_1 < 0xffffffe1) {
    if (param_1 == 0) {
      param_1 = 1;
    }
    do {
      iVar1 = (*_DAT_1000c108)(_DAT_10012f90,0,param_1);
      if (iVar1 != 0) {
        return iVar1;
      }
      iVar1 = FUN_0067753c();
    } while ((iVar1 != 0) && (iVar1 = __callnewh(param_1), iVar1 != 0));
  }
  puVar2 = (undefined4 *)FUN_00675142();
  *puVar2 = 0xc;
  return 0;
}



// Library Function - Single Match
//  _strcpy_s
// 
// Library: Visual Studio 2015 Release

errno_t __cdecl _strcpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  errno_t *peVar2;
  char *pcVar3;
  errno_t eVar4;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    if (_Src != (char *)0x0) {
      pcVar3 = _Dst;
      do {
        cVar1 = pcVar3[(int)_Src - (int)_Dst];
        *pcVar3 = cVar1;
        pcVar3 = pcVar3 + 1;
        if (cVar1 == '\0') break;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        return 0;
      }
      *_Dst = '\0';
      peVar2 = (errno_t *)FUN_00675142();
      eVar4 = 0x22;
      goto LAB_00674ca8;
    }
    *_Dst = '\0';
  }
  peVar2 = (errno_t *)FUN_00675142();
  eVar4 = 0x16;
LAB_00674ca8:
  *peVar2 = eVar4;
  FUN_00675085();
  return eVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int * __thiscall FUN_00674cdd(int *param_1_00,int *param_1)

{
  uint uVar1;
  int iVar2;
  
  *(undefined *)(param_1_00 + 3) = 0;
  if (param_1 == (int *)0x0) {
    if (_DAT_100131c8 != 0) {
      iVar2 = FUN_006759b1();
      *param_1_00 = iVar2;
      param_1_00[1] = *(int *)(iVar2 + 0x4c);
      param_1_00[2] = *(int *)(iVar2 + 0x48);
      ___acrt_update_locale_info(iVar2,param_1_00 + 1);
      ___acrt_update_multibyte_info(*param_1_00,param_1_00 + 2);
      uVar1 = *(uint *)(*param_1_00 + 0x350);
      if ((uVar1 & 2) != 0) {
        return param_1_00;
      }
      *(uint *)(*param_1_00 + 0x350) = uVar1 | 2;
      *(undefined *)(param_1_00 + 3) = 1;
      return param_1_00;
    }
    param_1_00[1] = _DAT_10012628;
    iVar2 = _DAT_1001262c;
  }
  else {
    param_1_00[1] = *param_1;
    iVar2 = param_1[1];
  }
  param_1_00[2] = iVar2;
  return param_1_00;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _abort
// 
// Library: Visual Studio 2017 Release

void __cdecl _abort(void)

{
  code *pcVar1;
  int iVar2;
  
  iVar2 = ___acrt_get_sigabrt_handler();
  if (iVar2 != 0) {
    FUN_00676f20(0x16);
  }
  if ((DAT_10012040 & 2) != 0) {
    iVar2 = (*_DAT_1000c090)(0x17);
    if (iVar2 != 0) {
      pcVar1 = (code *)swi(0x29);
      (*pcVar1)();
    }
    ___acrt_call_reportfault(3,0x40000015,1);
  }
  __exit(3);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __calloc_base
// 
// Library: Visual Studio 2015 Release

int __calloc_base(uint param_1,uint param_2)

{
  int iVar1;
  undefined4 *puVar2;
  size_t _Size;
  
  if ((param_1 == 0) || (param_2 <= 0xffffffe0 / param_1)) {
    _Size = param_1 * param_2;
    if (_Size == 0) {
      _Size = 1;
    }
    do {
      iVar1 = (*_DAT_1000c108)(_DAT_10012f90,8,_Size);
      if (iVar1 != 0) {
        return iVar1;
      }
      iVar1 = FUN_0067753c();
    } while ((iVar1 != 0) && (iVar1 = __callnewh(_Size), iVar1 != 0));
  }
  puVar2 = (undefined4 *)FUN_00675142();
  *puVar2 = 0xc;
  return 0;
}



// Library Function - Single Match
//  _wcsncmp
// 
// Library: Visual Studio 2017 Release

int __cdecl _wcsncmp(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)

{
  if (_MaxCount != 0) {
    for (; ((_MaxCount = _MaxCount - 1, _MaxCount != 0 && (*_Str1 != L'\0')) && (*_Str1 == *_Str2));
        _Str1 = _Str1 + 1) {
      _Str2 = _Str2 + 1;
    }
    return (uint)(ushort)*_Str1 - (uint)(ushort)*_Str2;
  }
  return _MaxCount;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_call_reportfault
// 
// Library: Visual Studio 2017 Release

void ___acrt_call_reportfault(int param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  undefined4 local_324;
  undefined4 local_320;
  undefined4 local_2d4 [39];
  
  if (param_1 != -1) {
    FUN_0067207c();
  }
  _memset(&local_324,0,0x50);
  _memset(local_2d4,0,0x2cc);
  local_2d4[0] = 0x10001;
  local_324 = param_2;
  local_320 = param_3;
  iVar1 = (*_DAT_1000c0a8)();
  (*_DAT_1000c084)();
  iVar2 = (*_DAT_1000c080)();
  if (((iVar2 == 0) && (iVar1 == 0)) && (param_1 != -1)) {
    FUN_0067207c();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00674ffb(undefined4 param_1)

{
  _DAT_10012d30 = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __invalid_parameter
// 
// Library: Visual Studio 2015 Release

void __invalid_parameter(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,
                        uintptr_t param_5)

{
  uint uVar1;
  int iVar2;
  byte bVar3;
  code *pcVar4;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar2 = FUN_00675aff();
  if (((iVar2 == 0) || (pcVar4 = *(code **)(iVar2 + 0x35c), pcVar4 == (code *)0x0)) &&
     (bVar3 = (byte)_DAT_10012000 & 0x1f,
     pcVar4 = (code *)((_DAT_10012000 ^ _DAT_10012d30) >> bVar3 |
                      (_DAT_10012000 ^ _DAT_10012d30) << 0x20 - bVar3), pcVar4 == (code *)0x0)) {
    __invoke_watson(param_1,param_2,param_3,param_4,param_5);
    pcVar4 = (code *)swi(3);
    (*pcVar4)();
    return;
  }
  (*_DAT_1000c174)(param_1,param_2,param_3,param_4,param_5);
  (*pcVar4)();
  ___security_check_cookie_4(uVar1);
  return;
}



void FUN_00675085(void)

{
  __invalid_parameter(0,0,0,0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __invoke_watson
// 
// Library: Visual Studio 2017 Release

void __cdecl
__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)

{
  code *pcVar1;
  int iVar2;
  undefined4 uVar3;
  
  iVar2 = (*_DAT_1000c090)(0x17);
  if (iVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  ___acrt_call_reportfault(2,0xc0000417,1);
  uVar3 = (*_DAT_1000c088)(0xc0000417);
  (*_DAT_1000c08c)(uVar3);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___acrt_errno_from_os_error
//  __get_errno_from_oserr
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

int __cdecl FID_conflict____acrt_errno_from_os_error(ulong param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == *(ulong *)(&DAT_1000cc38 + uVar1 * 8)) {
      return *(int *)(&DAT_1000cc3c + uVar1 * 8);
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x2c);
  if (param_1 - 0x13 < 0x12) {
    return 0xd;
  }
  return (-(uint)(0xe < param_1 - 0xbc) & 0xe) + 8;
}



// Library Function - Single Match
//  ___acrt_errno_map_os_error
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_errno_map_os_error(ulong param_1)

{
  ulong *puVar1;
  int iVar2;
  int *piVar3;
  
  puVar1 = (ulong *)FUN_0067512f();
  *puVar1 = param_1;
  iVar2 = FID_conflict____acrt_errno_from_os_error(param_1);
  piVar3 = (int *)FUN_00675142();
  *piVar3 = iVar2;
  return;
}



int FUN_0067512f(void)

{
  int iVar1;
  
  iVar1 = FUN_00675aff();
  if (iVar1 == 0) {
    return 0x10012048;
  }
  return iVar1 + 0x14;
}



int FUN_00675142(void)

{
  int iVar1;
  
  iVar1 = FUN_00675aff();
  if (iVar1 == 0) {
    return 0x10012044;
  }
  return iVar1 + 0x10;
}



// Library Function - Multiple Matches With Different Base Names
//  int (__stdcall*__cdecl try_get_AreFileApisANSI(void))(void)
//  int (__stdcall*__cdecl try_get_CompareStringEx(void))(wchar_t const *,unsigned long,wchar_t
// const *,int,wchar_t const *,int,struct _nlsversioninfo *,void *,long)
//  int (__stdcall*__cdecl try_get_EnumSystemLocalesEx(void))(int (__stdcall*)(wchar_t *,unsigned
// long,long),unsigned long,long,void *)
//  int (__stdcall*__cdecl try_get_GetDateFormatEx(void))(wchar_t const *,unsigned long,struct
// _SYSTEMTIME const *,wchar_t const *,wchar_t *,int,wchar_t const *)
//   14 names - too many to list
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict_try_get_IsValidLocaleName(void)

{
  try_get_function(0x14,(char *)0x1000d254,(module_id *)0x1000d24c,(module_id *)0x1000d254);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  int (__stdcall*__cdecl try_get_AreFileApisANSI(void))(void)
//  int (__stdcall*__cdecl try_get_CompareStringEx(void))(wchar_t const *,unsigned long,wchar_t
// const *,int,wchar_t const *,int,struct _nlsversioninfo *,void *,long)
//  int (__stdcall*__cdecl try_get_EnumSystemLocalesEx(void))(int (__stdcall*)(wchar_t *,unsigned
// long,long),unsigned long,long,void *)
//  int (__stdcall*__cdecl try_get_GetDateFormatEx(void))(wchar_t const *,unsigned long,struct
// _SYSTEMTIME const *,wchar_t const *,wchar_t *,int,wchar_t const *)
//   14 names - too many to list
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict_try_get_IsValidLocaleName(void)

{
  try_get_function(0x16,(char *)0x1000d26c,(module_id *)0x1000d264,(module_id *)0x1000d26c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  struct HINSTANCE__ * __cdecl try_get_first_available_module(enum `anonymous
// namespace'::module_id const * const,enum `anonymous namespace'::module_id const * const)
// 
// Library: Visual Studio 2017 Release

HINSTANCE__ * __cdecl try_get_first_available_module(module_id *param_1,module_id *param_2)

{
  HINSTANCE__ **ppHVar1;
  wchar_t *_Str1;
  HINSTANCE__ *pHVar2;
  HINSTANCE__ *pHVar3;
  int iVar4;
  
  do {
    if (param_1 == param_2) {
      return (HINSTANCE__ *)0x0;
    }
    ppHVar1 = (HINSTANCE__ **)(&DAT_10012d38 + *param_1 * 4);
    pHVar3 = *ppHVar1;
    if (pHVar3 == (HINSTANCE__ *)0x0) {
      _Str1 = *(wchar_t **)(*param_1 * 4 + 0x1000cd98);
      pHVar3 = (HINSTANCE__ *)(*_DAT_1000c0ec)(_Str1,0,0x800);
      if (pHVar3 == (HINSTANCE__ *)0x0) {
        iVar4 = (*_DAT_1000c0c0)();
        if (((iVar4 == 0x57) && (iVar4 = _wcsncmp(_Str1,(wchar_t *)0x1000ca58,7), iVar4 != 0)) &&
           (iVar4 = _wcsncmp(_Str1,(wchar_t *)0x1000ca68,7), iVar4 != 0)) {
          pHVar3 = (HINSTANCE__ *)(*_DAT_1000c0ec)(_Str1,0,0);
        }
        else {
          pHVar3 = (HINSTANCE__ *)0x0;
        }
        if (pHVar3 == (HINSTANCE__ *)0x0) {
          *ppHVar1 = (HINSTANCE__ *)0xffffffff;
          goto LAB_00675238;
        }
      }
      pHVar2 = *ppHVar1;
      *ppHVar1 = pHVar3;
      if (pHVar2 != (HINSTANCE__ *)0x0) {
        (*_DAT_1000c0e8)(pHVar3);
      }
LAB_00675234:
      if (pHVar3 != (HINSTANCE__ *)0x0) {
        return pHVar3;
      }
    }
    else if (pHVar3 != (HINSTANCE__ *)0xffffffff) goto LAB_00675234;
LAB_00675238:
    param_1 = param_1 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void * __cdecl try_get_function(enum `anonymous namespace'::function_id,char const * const,enum
// A0x391cf84c::module_id const * const,enum A0x391cf84c::module_id const * const)
// 
// Library: Visual Studio 2017 Release

void * __cdecl
try_get_function(function_id param_1,char *param_2,module_id *param_3,module_id *param_4)

{
  void **ppvVar1;
  HINSTANCE__ *pHVar2;
  void *pvVar3;
  byte bVar4;
  void *pvVar5;
  
  ppvVar1 = (void **)(param_1 * 4 + 0x10012d88);
  bVar4 = (byte)_DAT_10012000 & 0x1f;
  pvVar5 = (void *)((_DAT_10012000 ^ (uint)*ppvVar1) >> bVar4 |
                   (_DAT_10012000 ^ (uint)*ppvVar1) << 0x20 - bVar4);
  if (pvVar5 == (void *)0xffffffff) {
    pvVar5 = (void *)0x0;
  }
  else if (pvVar5 == (void *)0x0) {
    pHVar2 = try_get_first_available_module(param_3,param_4);
    if ((pHVar2 == (HINSTANCE__ *)0x0) ||
       (pvVar5 = (void *)(*_DAT_1000c058)(pHVar2,param_2), pvVar5 == (void *)0x0)) {
      bVar4 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
      *ppvVar1 = (void *)((0xffffffffU >> bVar4 | -1 << 0x20 - bVar4) ^ _DAT_10012000);
      pvVar5 = (void *)0x0;
    }
    else {
      pvVar3 = __crt_fast_encode_pointer_void__(pvVar5);
      *ppvVar1 = pvVar3;
    }
  }
  return pvVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_006752d3(undefined4 param_1)

{
  uint uVar1;
  code *pcVar2;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)try_get_function(0x1c,(char *)0x1000d284,(module_id *)0x1000d280,
                                    (module_id *)0x1000d284);
  if (pcVar2 != (code *)0x0) {
    (*_DAT_1000c174)(0xfffffffa,param_1);
    (*pcVar2)();
  }
  ___security_check_cookie_4(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_FlsAlloc@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsAlloc_4(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(3,(char *)0x1000ca80,(module_id *)0x1000d200,
                                    (module_id *)0x1000d208);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0d8)();
  }
  else {
    (*_DAT_1000c174)(param_1);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_FlsFree@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsFree_4(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(4,(char *)0x1000ca94,(module_id *)0x1000d208,
                                    (module_id *)0x1000d210);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0e4)(param_1);
  }
  else {
    (*_DAT_1000c174)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_FlsGetValue@4
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsGetValue_4(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(5,(char *)0x1000caa4,(module_id *)0x1000d210,
                                    (module_id *)0x1000d218);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0dc)(param_1);
  }
  else {
    (*_DAT_1000c174)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_FlsSetValue@8
// 
// Library: Visual Studio 2015 Release

void ___acrt_FlsSetValue_8(undefined4 param_1,undefined4 param_2)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(6,(char *)0x1000cab8,(module_id *)0x1000d218,
                                    (module_id *)0x1000d220);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0e0)(param_1,param_2);
  }
  else {
    (*_DAT_1000c174)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00675485(undefined4 param_1)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(0xd,(char *)0x1000d224,(module_id *)0x1000d220,
                                    (module_id *)0x1000d224);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c0a0)(param_1);
  }
  else {
    (*_DAT_1000c174)();
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_InitializeCriticalSectionEx@12
// 
// Library: Visual Studio 2015 Release

void ___acrt_InitializeCriticalSectionEx_12
               (undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)try_get_function(0x12,(char *)0x1000cacc,(module_id *)0x1000d244,
                                    (module_id *)0x1000d24c);
  if (pcVar1 == (code *)0x0) {
    (*_DAT_1000c07c)(param_1,param_2);
  }
  else {
    (*_DAT_1000c174)(param_1,param_2,param_3);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_CompareStringEx@36
// 
// Library: Visual Studio 2015 Release

void ___acrt_CompareStringEx_36
               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
               undefined4 param_9)

{
  code *pcVar1;
  undefined4 uVar2;
  
  pcVar1 = (code *)FID_conflict_try_get_IsValidLocaleName();
  if (pcVar1 == (code *)0x0) {
    uVar2 = FUN_006755b1(param_1,0);
    (*_DAT_1000c10c)(uVar2,param_2,param_3,param_4,param_5,param_6);
  }
  else {
    (*_DAT_1000c174)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
    (*pcVar1)();
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_006755b1(undefined4 param_1,undefined4 param_2)

{
  uint uVar1;
  code *pcVar2;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  pcVar2 = (code *)FID_conflict_try_get_IsValidLocaleName();
  if (pcVar2 == (code *)0x0) {
    ___acrt_DownlevelLocaleNameToLCID(param_1);
  }
  else {
    (*_DAT_1000c174)(param_1,param_2);
    (*pcVar2)();
  }
  ___security_check_cookie_4(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_uninitialize_winapi_thunks
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined ___acrt_uninitialize_winapi_thunks(char param_1)

{
  int *piVar1;
  
  if (param_1 == '\0') {
    piVar1 = (int *)&DAT_10012d38;
    do {
      if (*piVar1 != 0) {
        if (*piVar1 != -1) {
          (*_DAT_1000c0e8)(*piVar1);
        }
        *piVar1 = 0;
      }
      piVar1 = piVar1 + 1;
    } while (piVar1 != (int *)0x10012d88);
  }
  return 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_15ade71b0218206bbe3333a0c9b79046>,class <lambda_da44e0f8b0f19ba52fefafb335991732>&,class
// <lambda_207f2d024fc103971653565357d6cd41>>(class
// <lambda_15ade71b0218206bbe3333a0c9b79046>&&,class
// <lambda_da44e0f8b0f19ba52fefafb335991732>&,class <lambda_207f2d024fc103971653565357d6cd41>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_15ade71b0218206bbe3333a0c9b79046__class__lambda_da44e0f8b0f19ba52fefafb335991732___class__lambda_207f2d024fc103971653565357d6cd41___
          (__crt_seh_guarded_call_void_ *this,_lambda_15ade71b0218206bbe3333a0c9b79046_ *param_1,
          _lambda_da44e0f8b0f19ba52fefafb335991732_ *param_2,
          _lambda_207f2d024fc103971653565357d6cd41_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  LOCK();
  **(int **)(**(int **)param_2 + 0x48) = **(int **)(**(int **)param_2 + 0x48) + 1;
  FUN_006756a7();
  return;
}



void FUN_006756a7(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_38edbb1296d33220d7e4dd0ed76b244a>,class <lambda_5ce1d447e08cb34b2473517608e21441>&,class
// <lambda_fb385d3da700c9147fc39e65dd577a8c>>(class
// <lambda_38edbb1296d33220d7e4dd0ed76b244a>&&,class
// <lambda_5ce1d447e08cb34b2473517608e21441>&,class <lambda_fb385d3da700c9147fc39e65dd577a8c>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_38edbb1296d33220d7e4dd0ed76b244a__class__lambda_5ce1d447e08cb34b2473517608e21441___class__lambda_fb385d3da700c9147fc39e65dd577a8c___
          (__crt_seh_guarded_call_void_ *this,_lambda_38edbb1296d33220d7e4dd0ed76b244a_ *param_1,
          _lambda_5ce1d447e08cb34b2473517608e21441_ *param_2,
          _lambda_fb385d3da700c9147fc39e65dd577a8c_ *param_3)

{
  int *_Memory;
  int iVar1;
  
  ___acrt_lock(*(undefined4 *)param_1);
  _Memory = *(int **)(**(int **)param_2 + 0x48);
  if (_Memory != (int *)0x0) {
    LOCK();
    iVar1 = *_Memory;
    *_Memory = iVar1 + -1;
    if ((iVar1 + -1 == 0) && (_Memory != (int *)0x10012350)) {
      FID_conflict__free(_Memory);
    }
  }
  FUN_00675708();
  return;
}



void FUN_00675708(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_6affb1475c98b40b75cdec977db92e3c>,class <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>&,class
// <lambda_608742c3c92a14382c1684fc64f96c88>>(class
// <lambda_6affb1475c98b40b75cdec977db92e3c>&&,class
// <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104>&,class <lambda_608742c3c92a14382c1684fc64f96c88>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_6affb1475c98b40b75cdec977db92e3c__class__lambda_b8d4b9c228a6ecc3f80208dbb4b4a104___class__lambda_608742c3c92a14382c1684fc64f96c88___
          (__crt_seh_guarded_call_void_ *this,_lambda_6affb1475c98b40b75cdec977db92e3c_ *param_1,
          _lambda_b8d4b9c228a6ecc3f80208dbb4b4a104_ *param_2,
          _lambda_608742c3c92a14382c1684fc64f96c88_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  replace_current_thread_locale_nolock(**(__acrt_ptd ***)param_2,(__crt_locale_data *)0x0);
  FUN_00675753();
  return;
}



void FUN_00675753(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_a7e850c220f1c8d1e6efeecdedd162c6>,class <lambda_46720907175c18b6c9d2717bc0d2d362>&,class
// <lambda_9048902d66e8d99359bc9897bbb930a8>>(class
// <lambda_a7e850c220f1c8d1e6efeecdedd162c6>&&,class
// <lambda_46720907175c18b6c9d2717bc0d2d362>&,class <lambda_9048902d66e8d99359bc9897bbb930a8>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_a7e850c220f1c8d1e6efeecdedd162c6__class__lambda_46720907175c18b6c9d2717bc0d2d362___class__lambda_9048902d66e8d99359bc9897bbb930a8___
          (__crt_seh_guarded_call_void_ *this,_lambda_a7e850c220f1c8d1e6efeecdedd162c6_ *param_1,
          _lambda_46720907175c18b6c9d2717bc0d2d362_ *param_2,
          _lambda_9048902d66e8d99359bc9897bbb930a8_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  replace_current_thread_locale_nolock
            (**(__acrt_ptd ***)param_2,*(__crt_locale_data **)**(undefined4 **)(param_2 + 4));
  FUN_006757a3();
  return;
}



void FUN_006757a3(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  void __cdecl construct_ptd(struct __acrt_ptd * const,struct __crt_locale_data * * const)
// 
// Library: Visual Studio 2017 Release

void __cdecl construct_ptd(__acrt_ptd *param_1,__crt_locale_data **param_2)

{
  undefined4 local_18;
  __acrt_ptd **local_14;
  __acrt_ptd **local_10;
  __crt_locale_data ***local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  *(undefined4 *)(param_1 + 0x18) = 1;
  *(undefined4 *)param_1 = 0x1000caf0;
  *(undefined4 *)(param_1 + 0x350) = 1;
  *(undefined4 *)(param_1 + 0x48) = 0x10012350;
  *(undefined2 *)(param_1 + 0x6c) = 0x43;
  *(undefined2 *)(param_1 + 0x172) = 0x43;
  *(undefined4 *)(param_1 + 0x34c) = 0;
  local_14 = &param_1;
  local_c = (__crt_locale_data ***)0x5;
  local_18 = 5;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_15ade71b0218206bbe3333a0c9b79046__class__lambda_da44e0f8b0f19ba52fefafb335991732___class__lambda_207f2d024fc103971653565357d6cd41___
            (&local_5,(_lambda_15ade71b0218206bbe3333a0c9b79046_ *)&local_18,
             (_lambda_da44e0f8b0f19ba52fefafb335991732_ *)&local_14,
             (_lambda_207f2d024fc103971653565357d6cd41_ *)&local_c);
  local_10 = &param_1;
  local_c = &param_2;
  local_18 = 4;
  local_14 = (__acrt_ptd **)0x4;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_a7e850c220f1c8d1e6efeecdedd162c6__class__lambda_46720907175c18b6c9d2717bc0d2d362___class__lambda_9048902d66e8d99359bc9897bbb930a8___
            (&local_5,(_lambda_a7e850c220f1c8d1e6efeecdedd162c6_ *)&local_14,
             (_lambda_46720907175c18b6c9d2717bc0d2d362_ *)&local_10,
             (_lambda_9048902d66e8d99359bc9897bbb930a8_ *)&local_18);
  return;
}



// Library Function - Single Match
//  void __stdcall destroy_fls(void *)
// 
// Library: Visual Studio 2017 Release

void destroy_fls(void *param_1)

{
  if (param_1 != (void *)0x0) {
    destroy_ptd((__acrt_ptd *)param_1);
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Single Match
//  void __cdecl destroy_ptd(struct __acrt_ptd * const)
// 
// Library: Visual Studio 2017 Release

void __cdecl destroy_ptd(__acrt_ptd *param_1)

{
  undefined4 local_14;
  __acrt_ptd **local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  if (*(void **)param_1 != (void *)0x1000caf0) {
    FID_conflict__free(*(void **)param_1);
  }
  FID_conflict__free(*(void **)(param_1 + 0x3c));
  FID_conflict__free(*(void **)(param_1 + 0x30));
  FID_conflict__free(*(void **)(param_1 + 0x34));
  FID_conflict__free(*(void **)(param_1 + 0x38));
  FID_conflict__free(*(void **)(param_1 + 0x28));
  FID_conflict__free(*(void **)(param_1 + 0x2c));
  FID_conflict__free(*(void **)(param_1 + 0x40));
  FID_conflict__free(*(void **)(param_1 + 0x44));
  FID_conflict__free(*(void **)(param_1 + 0x360));
  local_10 = &param_1;
  local_c = 5;
  local_14 = 5;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_38edbb1296d33220d7e4dd0ed76b244a__class__lambda_5ce1d447e08cb34b2473517608e21441___class__lambda_fb385d3da700c9147fc39e65dd577a8c___
            (&local_5,(_lambda_38edbb1296d33220d7e4dd0ed76b244a_ *)&local_14,
             (_lambda_5ce1d447e08cb34b2473517608e21441_ *)&local_10,
             (_lambda_fb385d3da700c9147fc39e65dd577a8c_ *)&local_c);
  local_10 = &param_1;
  local_14 = 4;
  local_c = 4;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_6affb1475c98b40b75cdec977db92e3c__class__lambda_b8d4b9c228a6ecc3f80208dbb4b4a104___class__lambda_608742c3c92a14382c1684fc64f96c88___
            (&local_5,(_lambda_6affb1475c98b40b75cdec977db92e3c_ *)&local_c,
             (_lambda_b8d4b9c228a6ecc3f80208dbb4b4a104_ *)&local_10,
             (_lambda_608742c3c92a14382c1684fc64f96c88_ *)&local_14);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl replace_current_thread_locale_nolock(struct __acrt_ptd * const,struct
// __crt_locale_data * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void __cdecl replace_current_thread_locale_nolock(__acrt_ptd *param_1,__crt_locale_data *param_2)

{
  int iVar1;
  
  if (*(int *)(param_1 + 0x4c) != 0) {
    ___acrt_release_locale_ref(*(undefined4 *)(param_1 + 0x4c));
    iVar1 = *(int *)(param_1 + 0x4c);
    if (((iVar1 != _DAT_100131b0) && (iVar1 != 0x10012570)) && (*(int *)(iVar1 + 0xc) == 0)) {
      ___acrt_free_locale(iVar1);
    }
  }
  *(__crt_locale_data **)(param_1 + 0x4c) = param_2;
  if (param_2 != (__crt_locale_data *)0x0) {
    ___acrt_add_locale_ref(param_2);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_freeptd
// 
// Library: Visual Studio 2015 Release

void ___acrt_freeptd(void)

{
  void *pvVar1;
  
  if ((_DAT_1001204c != -1) &&
     (pvVar1 = (void *)___acrt_FlsGetValue_4(_DAT_1001204c), pvVar1 != (void *)0x0)) {
    ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    destroy_fls(pvVar1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

__acrt_ptd * FUN_006759b1(void)

{
  code *pcVar1;
  undefined4 uVar2;
  __acrt_ptd *p_Var3;
  int iVar4;
  
  uVar2 = (*_DAT_1000c0c0)();
  if ((_DAT_1001204c == -1) ||
     (p_Var3 = (__acrt_ptd *)___acrt_FlsGetValue_4(_DAT_1001204c), p_Var3 == (__acrt_ptd *)0x0)) {
    iVar4 = ___acrt_FlsSetValue_8(_DAT_1001204c,0xffffffff);
    if (iVar4 == 0) goto LAB_00675a58;
    p_Var3 = (__acrt_ptd *)__calloc_base(1,0x364);
    if (p_Var3 == (__acrt_ptd *)0x0) {
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    else {
      iVar4 = ___acrt_FlsSetValue_8(_DAT_1001204c,p_Var3);
      if (iVar4 != 0) {
        construct_ptd(p_Var3,(__crt_locale_data **)&DAT_100131b0);
        FID_conflict__free((void *)0x0);
        goto LAB_00675a48;
      }
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    FID_conflict__free(p_Var3);
  }
  else {
    if (p_Var3 == (__acrt_ptd *)0xffffffff) goto LAB_00675a58;
LAB_00675a48:
    if (p_Var3 != (__acrt_ptd *)0x0) {
      (*_DAT_1000c0c4)(uVar2);
      return p_Var3;
    }
  }
LAB_00675a58:
  (*_DAT_1000c0c4)(uVar2);
  _abort();
  pcVar1 = (code *)swi(3);
  p_Var3 = (__acrt_ptd *)(*pcVar1)();
  return p_Var3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

__acrt_ptd * FUN_00675a65(void)

{
  code *pcVar1;
  __acrt_ptd *p_Var2;
  int iVar3;
  
  if ((_DAT_1001204c == -1) ||
     (p_Var2 = (__acrt_ptd *)___acrt_FlsGetValue_4(_DAT_1001204c), p_Var2 == (__acrt_ptd *)0x0)) {
    iVar3 = ___acrt_FlsSetValue_8(_DAT_1001204c,0xffffffff);
    if (iVar3 == 0) goto LAB_00675af9;
    p_Var2 = (__acrt_ptd *)__calloc_base(1,0x364);
    if (p_Var2 == (__acrt_ptd *)0x0) {
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    else {
      iVar3 = ___acrt_FlsSetValue_8(_DAT_1001204c,p_Var2);
      if (iVar3 != 0) {
        construct_ptd(p_Var2,(__crt_locale_data **)&DAT_100131b0);
        FID_conflict__free((void *)0x0);
        goto LAB_00675af1;
      }
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    FID_conflict__free(p_Var2);
  }
  else {
    if (p_Var2 == (__acrt_ptd *)0xffffffff) goto LAB_00675af9;
LAB_00675af1:
    if (p_Var2 != (__acrt_ptd *)0x0) {
      return p_Var2;
    }
  }
LAB_00675af9:
  _abort();
  pcVar1 = (code *)swi(3);
  p_Var2 = (__acrt_ptd *)(*pcVar1)();
  return p_Var2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

__acrt_ptd * FUN_00675aff(void)

{
  undefined4 uVar1;
  __acrt_ptd *_Memory;
  int iVar2;
  
  uVar1 = (*_DAT_1000c0c0)();
  if ((_DAT_1001204c == -1) ||
     (_Memory = (__acrt_ptd *)___acrt_FlsGetValue_4(_DAT_1001204c), _Memory == (__acrt_ptd *)0x0)) {
    iVar2 = ___acrt_FlsSetValue_8(_DAT_1001204c,0xffffffff);
    if (iVar2 == 0) goto LAB_00675b29;
    _Memory = (__acrt_ptd *)__calloc_base(1,0x364);
    if (_Memory == (__acrt_ptd *)0x0) {
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
      _Memory = (__acrt_ptd *)0x0;
    }
    else {
      iVar2 = ___acrt_FlsSetValue_8(_DAT_1001204c,_Memory);
      if (iVar2 != 0) {
        construct_ptd(_Memory,(__crt_locale_data **)&DAT_100131b0);
        FID_conflict__free((void *)0x0);
        goto LAB_00675ba5;
      }
      ___acrt_FlsSetValue_8(_DAT_1001204c,0);
    }
    FID_conflict__free(_Memory);
  }
  else {
    if (_Memory == (__acrt_ptd *)0xffffffff) goto LAB_00675b29;
LAB_00675ba5:
    if (_Memory != (__acrt_ptd *)0x0) {
      (*_DAT_1000c0c4)(uVar1);
      return _Memory;
    }
  }
LAB_00675b29:
  (*_DAT_1000c0c4)(uVar1);
  return (__acrt_ptd *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_uninitialize_ptd
// 
// Library: Visual Studio 2015 Release

undefined4 ___acrt_uninitialize_ptd(void)

{
  if (_DAT_1001204c != -1) {
    ___acrt_FlsFree_4(_DAT_1001204c);
    _DAT_1001204c = -1;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lock
// 
// Library: Visual Studio 2017 Release

void ___acrt_lock(int param_1)

{
  (*_DAT_1000c0c8)(param_1 * 0x18 + 0x10012e10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_unlock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_unlock(int param_1)

{
  (*_DAT_1000c0cc)(param_1 * 0x18 + 0x10012e10);
  return;
}



// Library Function - Single Match
//  ___acrt_get_process_end_policy
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_get_process_end_policy(void)

{
  int in_FS_OFFSET;
  int local_8;
  
  local_8 = 0;
  if ((-1 < *(int *)(*(int *)(*(int *)(in_FS_OFFSET + 0x30) + 0x10) + 8)) &&
     (FUN_006752d3(&local_8), local_8 == 1)) {
    return 0;
  }
  return 1;
}



uint FUN_00675ccb(uint param_1,uint param_2)

{
  if (param_2 >= param_1 && param_2 != param_1) {
    return 0xffffffff;
  }
  return (uint)(param_2 < param_1);
}



// WARNING: Type propagation algorithm not settling

int FUN_00675ce3(char **param_1,int *param_2)

{
  char cVar1;
  code *pcVar2;
  undefined4 *puVar3;
  char *pcVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  char **ppcVar10;
  char **_Memory;
  char **local_2c;
  char **local_28;
  undefined4 local_24;
  uint local_20;
  char **local_1c;
  char *local_18;
  char *local_14;
  char *local_10;
  char *local_c;
  undefined4 local_8;
  
  if (param_2 == (int *)0x0) {
    puVar3 = (undefined4 *)FUN_00675142();
    iVar8 = 0x16;
    *puVar3 = 0x16;
    FUN_00675085();
  }
  else {
    uVar7 = 0;
    *param_2 = 0;
    local_2c = (char **)0x0;
    local_28 = (char **)0x0;
    local_24 = 0;
    pcVar4 = *param_1;
    ppcVar10 = local_2c;
    while (local_2c = ppcVar10, pcVar4 != (char *)0x0) {
      local_8 = (char **)CONCAT13((char)((uint)local_8 >> 0x18),0x3f2a);
      pcVar4 = _strpbrk(*param_1,(char *)&local_8);
      if (pcVar4 == (char *)0x0) {
        iVar8 = FUN_00675ec3(*param_1,0,0,&local_2c);
      }
      else {
        iVar8 = FUN_00675f76(*param_1,pcVar4,&local_2c);
      }
      ppcVar10 = local_2c;
      local_c = (char *)iVar8;
      if (iVar8 != 0) goto LAB_00675e71;
      param_1 = param_1 + 1;
      pcVar4 = *param_1;
    }
    local_c = (char *)0x0;
    local_10 = (char *)(((int)local_28 - (int)ppcVar10 >> 2) + 1);
    uVar9 = ~-(uint)(local_28 < ppcVar10) & ((int)local_28 - (int)ppcVar10) + 3U >> 2;
    local_8 = ppcVar10;
    if (uVar9 != 0) {
      uVar6 = 0;
      do {
        pcVar4 = *local_8;
        local_14 = pcVar4 + 1;
        do {
          cVar1 = *pcVar4;
          pcVar4 = pcVar4 + 1;
        } while (cVar1 != '\0');
        local_c = pcVar4 + (int)(local_c + (1 - (int)local_14));
        local_8 = local_8 + 1;
        uVar6 = uVar6 + 1;
      } while (uVar6 != uVar9);
    }
    iVar8 = FUN_006745ec(local_10,local_c,1);
    if (iVar8 == 0) {
      iVar8 = -1;
      local_c = (char *)0xffffffff;
    }
    else {
      local_10 = (char *)(iVar8 + (int)local_10 * 4);
      local_1c = (char **)local_10;
      local_8 = ppcVar10;
      if (ppcVar10 != local_28) {
        local_20 = iVar8 - (int)ppcVar10;
        do {
          local_18 = *local_8;
          local_14 = local_18;
          do {
            cVar1 = *local_14;
            local_14 = local_14 + 1;
          } while (cVar1 != '\0');
          local_14 = local_14 + (1 - (int)(local_18 + 1));
          iVar5 = FUN_00678142(local_10,local_c + ((int)local_1c - (int)local_10),local_18,local_14)
          ;
          if (iVar5 != 0) {
            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
            pcVar2 = (code *)swi(3);
            iVar8 = (*pcVar2)();
            return iVar8;
          }
          *(char **)(local_20 + (int)local_8) = local_10;
          local_8 = local_8 + 1;
          local_10 = local_10 + (int)local_14;
        } while (local_8 != local_28);
      }
      local_c = (char *)0x0;
      *param_2 = iVar8;
      iVar8 = 0;
    }
    FID_conflict__free((void *)0x0);
LAB_00675e71:
    uVar9 = ~-(uint)(local_28 < ppcVar10) & (uint)((int)local_28 + (3 - (int)ppcVar10)) >> 2;
    _Memory = ppcVar10;
    local_20 = uVar9;
    local_1c = ppcVar10;
    if (uVar9 != 0) {
      do {
        FID_conflict__free(*ppcVar10);
        uVar7 = uVar7 + 1;
        ppcVar10 = ppcVar10 + 1;
        iVar8 = (int)local_c;
        _Memory = local_2c;
      } while (uVar7 != uVar9);
    }
    FID_conflict__free(_Memory);
  }
  return iVar8;
}



int FUN_00675ec3(char *param_1,undefined4 param_2,uint param_3,int param_4)

{
  char cVar1;
  code *pcVar2;
  int iVar3;
  void *_Memory;
  char *pcVar4;
  char *pcVar5;
  
  pcVar4 = param_1;
  do {
    cVar1 = *pcVar4;
    pcVar4 = pcVar4 + 1;
  } while (cVar1 != '\0');
  pcVar4 = pcVar4 + (1 - (int)(param_1 + 1));
  if ((char *)~param_3 < pcVar4) {
    iVar3 = 0xc;
  }
  else {
    pcVar5 = pcVar4 + param_3 + 1;
    _Memory = (void *)__calloc_base(pcVar5,1);
    if (param_3 != 0) {
      iVar3 = FUN_00678142(_Memory,pcVar5,param_2,param_3);
      if (iVar3 != 0) goto LAB_00675f69;
    }
    iVar3 = FUN_00678142((int)_Memory + param_3,(int)pcVar5 - param_3,param_1,pcVar4);
    if (iVar3 != 0) {
LAB_00675f69:
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar2 = (code *)swi(3);
      iVar3 = (*pcVar2)();
      return iVar3;
    }
    iVar3 = expand_if_necessary();
    if (iVar3 == 0) {
      **(void ***)(param_4 + 4) = _Memory;
      iVar3 = 0;
      *(int *)(param_4 + 4) = *(int *)(param_4 + 4) + 4;
    }
    else {
      FID_conflict__free(_Memory);
    }
    FID_conflict__free((void *)0x0);
  }
  return iVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00675f76(char *param_1,char *param_2,int *param_3)

{
  char cVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  undefined local_148 [44];
  char local_11c;
  char local_11b;
  char local_11a;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  for (; (((param_2 != param_1 && (cVar1 = *param_2, cVar1 != '/')) && (cVar1 != '\\')) &&
         (cVar1 != ':')); param_2 = (char *)FUN_0067818d(param_1,param_2)) {
  }
  cVar1 = *param_2;
  if ((cVar1 == ':') && (param_2 != param_1 + 1)) {
    FUN_00675ec3(param_1,0,0,param_3);
  }
  else {
    if ((cVar1 == '/') || ((cVar1 == '\\' || (bVar2 = 0, cVar1 == ':')))) {
      bVar2 = 1;
    }
    _memset(local_148,0,0x140);
    iVar3 = (*_DAT_1000c114)(param_1,0,local_148,0,0,0);
    if (iVar3 == -1) {
      FUN_00675ec3(param_1,0,0,param_3);
    }
    else {
      iVar5 = param_3[1] - *param_3 >> 2;
      do {
        if (((local_11c != '.') ||
            ((local_11b != '\0' && ((local_11b != '.' || (local_11a != '\0')))))) &&
           (iVar4 = FUN_00675ec3(&local_11c,param_1,
                                 -(uint)bVar2 & (uint)(param_2 + (1 - (int)param_1)),param_3),
           iVar4 != 0)) goto LAB_00676043;
        iVar4 = (*_DAT_1000c118)(iVar3,local_148);
      } while (iVar4 != 0);
      iVar4 = param_3[1] - *param_3 >> 2;
      if (iVar5 != iVar4) {
        FUN_00677c4d(*param_3 + iVar5 * 4,iVar4 - iVar5,4,0x10005d5e);
      }
    }
LAB_00676043:
    if (iVar3 != -1) {
      (*_DAT_1000c110)(iVar3);
    }
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)
//  private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)
// 
// Library: Visual Studio 2015 Release

undefined4 __fastcall expand_if_necessary(int *param_1)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  
  if (param_1[1] == param_1[2]) {
    if (*param_1 == 0) {
      iVar2 = __calloc_base(4,4);
      *param_1 = iVar2;
      FID_conflict__free((void *)0x0);
      iVar2 = *param_1;
      if (iVar2 != 0) {
        param_1[1] = iVar2;
        param_1[2] = iVar2 + 0x10;
        goto LAB_00676104;
      }
    }
    else {
      uVar3 = param_1[2] - *param_1 >> 2;
      if (uVar3 < 0x80000000) {
        iVar2 = FUN_00676ac0(*param_1,uVar3 * 2,4);
        if (iVar2 == 0) {
          uVar1 = 0xc;
        }
        else {
          *param_1 = iVar2;
          param_1[1] = iVar2 + uVar3 * 4;
          param_1[2] = iVar2 + uVar3 * 8;
          uVar1 = 0;
        }
        FID_conflict__free((void *)0x0);
        return uVar1;
      }
    }
    uVar1 = 0xc;
  }
  else {
LAB_00676104:
    uVar1 = 0;
  }
  return uVar1;
}



void FUN_0067617d(void)

{
  FUN_00675ce3();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_ceb1ee4838e85a9d631eb091e2fbe199>,class <lambda_ae742caa10f662c28703da3d2ea5e57e>&,class
// <lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>>(class
// <lambda_ceb1ee4838e85a9d631eb091e2fbe199>&&,class
// <lambda_ae742caa10f662c28703da3d2ea5e57e>&,class <lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_ceb1ee4838e85a9d631eb091e2fbe199__class__lambda_ae742caa10f662c28703da3d2ea5e57e___class__lambda_cd08b5d6af4937fe54fc07d0c9bf6b37___
          (__crt_seh_guarded_call_void_ *this,_lambda_ceb1ee4838e85a9d631eb091e2fbe199_ *param_1,
          _lambda_ae742caa10f662c28703da3d2ea5e57e_ *param_2,
          _lambda_cd08b5d6af4937fe54fc07d0c9bf6b37_ *param_3)

{
  ___acrt_lock(*(undefined4 *)param_1);
  <lambda_ae742caa10f662c28703da3d2ea5e57e>::operator__(param_2);
  FUN_006761bf();
  return;
}



void FUN_006761bf(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  public: void __thiscall <lambda_ae742caa10f662c28703da3d2ea5e57e>::operator()(void)const 
// 
// Library: Visual Studio 2017 Release

void __thiscall
<lambda_ae742caa10f662c28703da3d2ea5e57e>::operator__
          (_lambda_ae742caa10f662c28703da3d2ea5e57e_ *this)

{
  int iVar1;
  
  _memcpy_s(_DAT_10012f64,0x101,(void *)(*(int *)(**(int **)this + 0x48) + 0x18),0x101);
  _memcpy_s(_DAT_10012f68,0x100,(void *)(*(int *)(**(int **)this + 0x48) + 0x119),0x100);
  LOCK();
  iVar1 = **(int **)**(undefined4 **)(this + 4) + -1;
  **(int **)**(undefined4 **)(this + 4) = iVar1;
  if ((iVar1 == 0) && (*(void **)**(undefined4 **)(this + 4) != (void *)0x10012350)) {
    FID_conflict__free(*(void **)**(undefined4 **)(this + 4));
  }
  *(undefined4 *)**(undefined4 **)(this + 4) = *(undefined4 *)(**(int **)this + 0x48);
  LOCK();
  **(int **)(**(int **)this + 0x48) = **(int **)(**(int **)this + 0x48) + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  wchar_t const * __cdecl CPtoLocaleName(int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

wchar_t * __cdecl CPtoLocaleName(int param_1)

{
  if (param_1 == 0x3a4) {
    return _DAT_1000d2ac;
  }
  if (param_1 == 0x3a8) {
    return _DAT_1000d2b0;
  }
  if (param_1 == 0x3b5) {
    return _DAT_1000d2b4;
  }
  if (param_1 != 0x3b6) {
    return (wchar_t *)0x0;
  }
  return _DAT_1000d2b8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  int __cdecl getSystemCP(int)
// 
// Library: Visual Studio 2017 Release

int __cdecl getSystemCP(int param_1)

{
  int local_14;
  int local_10;
  char local_8;
  
  FUN_00674cdd(0);
  _DAT_10012f70 = 0;
  if (param_1 == -2) {
    _DAT_10012f70 = 1;
    param_1 = (*_DAT_1000c124)();
  }
  else if (param_1 == -3) {
    _DAT_10012f70 = 1;
    param_1 = (*_DAT_1000c120)();
  }
  else if (param_1 == -4) {
    _DAT_10012f70 = 1;
    param_1 = *(int *)(local_10 + 8);
  }
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return param_1;
}



// Library Function - Single Match
//  void __cdecl setSBCS(struct __crt_multibyte_data *)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl setSBCS(__crt_multibyte_data *param_1)

{
  int iVar1;
  __crt_multibyte_data *p_Var2;
  
  p_Var2 = param_1 + 0x18;
  _memset(p_Var2,0,0x101);
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  *(undefined4 *)(param_1 + 0x21c) = 0;
  iVar1 = 0x101;
  *(undefined4 *)(param_1 + 0xc) = 0;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  do {
    *p_Var2 = p_Var2[0x10012350 - (int)param_1];
    p_Var2 = p_Var2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  p_Var2 = param_1 + 0x119;
  iVar1 = 0x100;
  do {
    *p_Var2 = p_Var2[0x10012350 - (int)param_1];
    p_Var2 = p_Var2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl setSBUpLow(struct __crt_multibyte_data *)
// 
// Library: Visual Studio 2015 Release

void __cdecl setSBUpLow(__crt_multibyte_data *param_1)

{
  byte bVar1;
  __crt_multibyte_data _Var2;
  int iVar3;
  uint uVar4;
  byte *pbVar5;
  __crt_multibyte_data *p_Var6;
  undefined local_71c [6];
  byte local_716;
  byte local_715 [13];
  ushort local_708 [512];
  __crt_multibyte_data local_308 [256];
  __crt_multibyte_data local_208 [256];
  undefined local_108 [256];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar3 = (*_DAT_1000c128)(*(undefined4 *)(param_1 + 4),local_71c);
  if (iVar3 == 0) {
    uVar4 = 0;
    do {
      p_Var6 = param_1 + uVar4 + 0x119;
      if (p_Var6 + (-0x61 - (int)(param_1 + 0x119)) + 0x20 < (__crt_multibyte_data *)0x1a) {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = (__crt_multibyte_data)((char)uVar4 + ' ');
LAB_006764d0:
        *p_Var6 = _Var2;
      }
      else {
        if (p_Var6 + (-0x61 - (int)(param_1 + 0x119)) < (__crt_multibyte_data *)0x1a) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = (__crt_multibyte_data)((char)uVar4 + -0x20);
          goto LAB_006764d0;
        }
        *p_Var6 = (__crt_multibyte_data)0x0;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  else {
    uVar4 = 0;
    do {
      local_108[uVar4] = (char)uVar4;
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
    pbVar5 = &local_716;
    local_108[0] = 0x20;
    while (local_716 != 0) {
      bVar1 = pbVar5[1];
      for (uVar4 = (uint)local_716; (uVar4 <= bVar1 && (uVar4 < 0x100)); uVar4 = uVar4 + 1) {
        local_108[uVar4] = 0x20;
      }
      pbVar5 = pbVar5 + 2;
      local_716 = *pbVar5;
    }
    FUN_0067822a(0,1,local_108,0x100,local_708,*(undefined4 *)(param_1 + 4),0);
    ___acrt_LCMapStringA
              (0,*(undefined4 *)(param_1 + 0x21c),0x100,local_108,0x100,local_208,0x100,
               *(undefined4 *)(param_1 + 4),0);
    ___acrt_LCMapStringA
              (0,*(undefined4 *)(param_1 + 0x21c),0x200,local_108,0x100,local_308,0x100,
               *(undefined4 *)(param_1 + 4),0);
    uVar4 = 0;
    do {
      if ((local_708[uVar4] & 1) == 0) {
        if ((local_708[uVar4] & 2) != 0) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = local_308[uVar4];
          goto LAB_00676477;
        }
        param_1[uVar4 + 0x119] = (__crt_multibyte_data)0x0;
      }
      else {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = local_208[uVar4];
LAB_00676477:
        param_1[uVar4 + 0x119] = _Var2;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  int __cdecl setmbcp_internal(int,bool,struct __acrt_ptd * const,struct __crt_multibyte_data * *
// const)
// 
// Library: Visual Studio 2017 Release

int __cdecl
setmbcp_internal(int param_1,bool param_2,__acrt_ptd *param_3,__crt_multibyte_data **param_4)

{
  int *piVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int iVar5;
  undefined4 *puVar6;
  __acrt_ptd **local_18;
  __crt_multibyte_data ***local_14;
  int local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  FUN_00676613(param_3,param_4);
  local_10 = getSystemCP(param_1);
  if (local_10 == *(int *)(*(int *)(param_3 + 0x48) + 4)) {
    return 0;
  }
  puVar3 = (undefined4 *)__malloc_base(0x220);
  if (puVar3 != (undefined4 *)0x0) {
    puVar4 = *(undefined4 **)(param_3 + 0x48);
    puVar6 = puVar3;
    for (iVar5 = 0x88; iVar5 != 0; iVar5 = iVar5 + -1) {
      *puVar6 = *puVar4;
      puVar4 = puVar4 + 1;
      puVar6 = puVar6 + 1;
    }
    *puVar3 = 0;
    iVar5 = FUN_00676701(local_10,puVar3);
    if (iVar5 != -1) {
      if (param_2 == false) {
        ___acrt_set_locale_changed();
      }
      piVar1 = *(int **)(param_3 + 0x48);
      LOCK();
      iVar2 = *piVar1;
      *piVar1 = *piVar1 + -1;
      if ((iVar2 == 1) && (*(int *)(param_3 + 0x48) != 0x10012350)) {
        FID_conflict__free(*(void **)(param_3 + 0x48));
      }
      *puVar3 = 1;
      puVar4 = (undefined4 *)0x0;
      *(undefined4 **)(param_3 + 0x48) = puVar3;
      if ((((byte)param_3[0x350] & 2) == 0) && ((DAT_100126e0 & 1) == 0)) {
        local_18 = &param_3;
        local_14 = &param_4;
        local_10 = 5;
        local_c = 5;
        __crt_seh_guarded_call<void>::
        operator___class__lambda_ceb1ee4838e85a9d631eb091e2fbe199__class__lambda_ae742caa10f662c28703da3d2ea5e57e___class__lambda_cd08b5d6af4937fe54fc07d0c9bf6b37___
                  (&local_5,(_lambda_ceb1ee4838e85a9d631eb091e2fbe199_ *)&local_c,
                   (_lambda_ae742caa10f662c28703da3d2ea5e57e_ *)&local_18,
                   (_lambda_cd08b5d6af4937fe54fc07d0c9bf6b37_ *)&local_10);
        if (param_2 != false) {
          _DAT_1001262c = *param_4;
        }
      }
      goto LAB_0067656f;
    }
    puVar4 = (undefined4 *)FUN_00675142();
    *puVar4 = 0x16;
  }
  iVar5 = -1;
  puVar4 = puVar3;
LAB_0067656f:
  FID_conflict__free(puVar4);
  return iVar5;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int * FUN_00676613(int param_1,int **param_2)

{
  int iVar1;
  int *_Memory;
  
  if ((*(uint *)(param_1 + 0x350) & _DAT_100126e0) == 0) goto LAB_00676645;
  if (*(int *)(param_1 + 0x4c) == 0) goto LAB_00676645;
  _Memory = *(int **)(param_1 + 0x48);
  while (_Memory == (int *)0x0) {
    _abort();
LAB_00676645:
    ___acrt_lock(5);
    _Memory = *(int **)(param_1 + 0x48);
    if (_Memory != *param_2) {
      if (_Memory != (int *)0x0) {
        LOCK();
        iVar1 = *_Memory;
        *_Memory = iVar1 + -1;
        if ((iVar1 + -1 == 0) && (_Memory != (int *)0x10012350)) {
          FID_conflict__free(_Memory);
        }
      }
      _Memory = *param_2;
      *(int **)(param_1 + 0x48) = _Memory;
      LOCK();
      *_Memory = *_Memory + 1;
    }
    FUN_00676695();
  }
  return _Memory;
}



void FUN_00676695(void)

{
  ___acrt_unlock(5);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_initialize_multibyte
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_initialize_multibyte(void)

{
  __acrt_ptd *p_Var1;
  
  if (DAT_10012f74 == '\0') {
    _DAT_10012f6c = 0x10012350;
    _DAT_10012f68 = 0x10012158;
    _DAT_10012f64 = 0x10012050;
    p_Var1 = (__acrt_ptd *)FUN_00675a65();
    setmbcp_internal(-3,true,p_Var1,(__crt_multibyte_data **)&DAT_10012f6c);
    DAT_10012f74 = '\x01';
  }
  return 1;
}



// Library Function - Single Match
//  ___acrt_update_thread_multibyte_data
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_update_thread_multibyte_data(void)

{
  undefined4 uVar1;
  
  uVar1 = FUN_006759b1(&DAT_10012f6c);
  FUN_00676613(uVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00676701(int param_1,__crt_multibyte_data *param_2)

{
  byte bVar1;
  undefined2 uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  byte *pbVar6;
  __crt_multibyte_data *p_Var7;
  wchar_t *pwVar8;
  byte *pbVar9;
  undefined2 *puVar10;
  undefined2 *puVar11;
  uint uVar12;
  int local_20;
  int local_1c;
  byte local_16 [14];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar3 = getSystemCP(param_1);
  if (uVar3 != 0) {
    uVar12 = 0;
    uVar4 = 0;
    local_20 = 0;
LAB_00676742:
    if (*(uint *)(&DAT_10012260 + uVar4) != uVar3) goto code_r0x0067674e;
    _memset(param_2 + 0x18,0,0x101);
    pbVar6 = (byte *)(local_20 * 0x30 + 0x10012270);
    do {
      bVar1 = *pbVar6;
      pbVar9 = pbVar6;
      while ((bVar1 != 0 && (bVar1 = pbVar9[1], bVar1 != 0))) {
        for (uVar4 = (uint)*pbVar9; (uVar4 <= bVar1 && (uVar4 < 0x100)); uVar4 = uVar4 + 1) {
          param_2[uVar4 + 0x19] =
               (__crt_multibyte_data)((byte)param_2[uVar4 + 0x19] | (&DAT_10012258)[uVar12]);
          bVar1 = pbVar9[1];
        }
        pbVar9 = pbVar9 + 2;
        bVar1 = *pbVar9;
      }
      uVar12 = uVar12 + 1;
      pbVar6 = pbVar6 + 8;
    } while (uVar12 < 4);
    *(uint *)(param_2 + 4) = uVar3;
    *(undefined4 *)(param_2 + 8) = 1;
    pwVar8 = CPtoLocaleName(uVar3);
    *(wchar_t **)(param_2 + 0x21c) = pwVar8;
    puVar10 = (undefined2 *)(param_2 + 0xc);
    puVar11 = (undefined2 *)(local_20 * 0x30 + 0x10012264);
    iVar5 = 6;
    do {
      uVar2 = *puVar11;
      puVar11 = puVar11 + 1;
      *puVar10 = uVar2;
      puVar10 = puVar10 + 1;
      iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    goto LAB_006768e1;
  }
  setSBCS(param_2);
LAB_006768eb:
  ___security_check_cookie_4();
  return;
code_r0x0067674e:
  local_20 = local_20 + 1;
  uVar4 = uVar4 + 0x30;
  if (0xef < uVar4) goto code_r0x0067675c;
  goto LAB_00676742;
code_r0x0067675c:
  if ((uVar3 != 65000) &&
     (((uVar3 != 0xfde9 || (iVar5 = (*_DAT_1000c120)(), iVar5 == 0xfde9)) &&
      (iVar5 = (*_DAT_1000c11c)(uVar3 & 0xffff), iVar5 != 0)))) {
    iVar5 = (*_DAT_1000c128)(uVar3,&local_1c);
    if (iVar5 == 0) {
      if (_DAT_10012f70 != 0) {
        setSBCS(param_2);
      }
    }
    else {
      _memset(param_2 + 0x18,0,0x101);
      *(uint *)(param_2 + 4) = uVar3;
      *(undefined4 *)(param_2 + 0x21c) = 0;
      if (local_1c == 2) {
        pbVar6 = local_16;
        while ((local_16[0] != 0 && (bVar1 = pbVar6[1], bVar1 != 0))) {
          for (uVar3 = (uint)*pbVar6; uVar3 <= bVar1; uVar3 = uVar3 + 1) {
            param_2[uVar3 + 0x19] = (__crt_multibyte_data)((byte)param_2[uVar3 + 0x19] | 4);
          }
          pbVar6 = pbVar6 + 2;
          local_16[0] = *pbVar6;
        }
        p_Var7 = param_2 + 0x1a;
        iVar5 = 0xfe;
        do {
          *p_Var7 = (__crt_multibyte_data)((byte)*p_Var7 | 8);
          p_Var7 = p_Var7 + 1;
          iVar5 = iVar5 + -1;
        } while (iVar5 != 0);
        pwVar8 = CPtoLocaleName(*(int *)(param_2 + 4));
        *(wchar_t **)(param_2 + 0x21c) = pwVar8;
        *(undefined4 *)(param_2 + 8) = 1;
      }
      else {
        *(undefined4 *)(param_2 + 8) = 0;
      }
      *(undefined4 *)(param_2 + 0xc) = 0;
      *(undefined4 *)(param_2 + 0x10) = 0;
      *(undefined4 *)(param_2 + 0x14) = 0;
LAB_006768e1:
      setSBUpLow(param_2);
    }
  }
  goto LAB_006768eb;
}



// Library Function - Single Match
//  _memcpy_s
// 
// Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

errno_t __cdecl _memcpy_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)

{
  errno_t eVar1;
  undefined4 *puVar2;
  errno_t *peVar3;
  
  if (_MaxCount == 0) {
    eVar1 = 0;
  }
  else if (_Dst == (void *)0x0) {
    puVar2 = (undefined4 *)FUN_00675142();
    eVar1 = 0x16;
    *puVar2 = 0x16;
    FUN_00675085();
  }
  else if ((_Src == (void *)0x0) || (_DstSize < _MaxCount)) {
    _memset(_Dst,0,_DstSize);
    if (_Src == (void *)0x0) {
      peVar3 = (errno_t *)FUN_00675142();
      eVar1 = 0x16;
    }
    else {
      if (_MaxCount <= _DstSize) {
        return 0x16;
      }
      peVar3 = (errno_t *)FUN_00675142();
      eVar1 = 0x22;
    }
    *peVar3 = eVar1;
    FUN_00675085();
  }
  else {
    FUN_006730bd(_Dst,_Src,_MaxCount);
    eVar1 = 0;
  }
  return eVar1;
}



// Library Function - Single Match
//  int __cdecl x_ismbbtype_l(struct __crt_locale_pointers *,unsigned int,int,int)
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release, Visual Studio 2017 Debug, Visual
// Studio 2017 Release

int __cdecl x_ismbbtype_l(__crt_locale_pointers *param_1,uint param_2,int param_3,int param_4)

{
  uint uVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  char local_8;
  
  FUN_00674cdd(param_1);
  if ((*(byte *)(local_c + 0x19 + (param_2 & 0xff)) & (byte)param_4) == 0) {
    iVar2 = 0;
    if (param_3 == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = (uint)*(ushort *)(*local_10 + (param_2 & 0xff) * 2) & param_3;
    }
    if (uVar1 == 0) goto LAB_006769be;
  }
  iVar2 = 1;
LAB_006769be:
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return iVar2;
}



// Library Function - Single Match
//  __ismbblead
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release, Visual Studio 2017 Debug, Visual
// Studio 2017 Release

int __cdecl __ismbblead(uint _C)

{
  int iVar1;
  
  iVar1 = x_ismbbtype_l((__crt_locale_pointers *)0x0,_C,0,4);
  return iVar1;
}



// Library Function - Single Match
//  wchar_t const * __cdecl find_end_of_double_null_terminated_sequence(wchar_t const * const)
// 
// Library: Visual Studio 2015 Release

wchar_t * __cdecl find_end_of_double_null_terminated_sequence(wchar_t *param_1)

{
  short sVar1;
  short *psVar2;
  
  sVar1 = *(short *)param_1;
  while (sVar1 != 0) {
    psVar2 = (short *)param_1;
    do {
      sVar1 = *psVar2;
      psVar2 = psVar2 + 1;
    } while (sVar1 != 0);
    param_1 = (wchar_t *)((int)param_1 + (((int)psVar2 - (int)((int)param_1 + 2) >> 1) + 1) * 2);
    sVar1 = *(short *)param_1;
  }
  return (wchar_t *)(short *)((int)param_1 + 2);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___dcrt_get_narrow_environment_from_os
// 
// Library: Visual Studio 2015 Release

void * ___dcrt_get_narrow_environment_from_os(void)

{
  wchar_t *pwVar1;
  wchar_t *pwVar2;
  int iVar3;
  void *_Memory;
  int iVar4;
  void *pvVar5;
  
  pwVar1 = (wchar_t *)(*_DAT_1000c134)();
  if (pwVar1 != (wchar_t *)0x0) {
    pwVar2 = find_end_of_double_null_terminated_sequence(pwVar1);
    iVar4 = (int)pwVar2 - (int)pwVar1 >> 1;
    iVar3 = (*_DAT_1000c100)(0,0,pwVar1,iVar4,0,0,0,0);
    if (iVar3 != 0) {
      _Memory = (void *)__malloc_base(iVar3);
      if (_Memory == (void *)0x0) {
LAB_00676a9f:
        pvVar5 = (void *)0x0;
      }
      else {
        iVar3 = (*_DAT_1000c100)(0,0,pwVar1,iVar4,_Memory,iVar3,0,0);
        if (iVar3 == 0) goto LAB_00676a9f;
        pvVar5 = _Memory;
        _Memory = (void *)0x0;
      }
      FID_conflict__free(_Memory);
      goto LAB_00676aac;
    }
  }
  pvVar5 = (void *)0x0;
LAB_00676aac:
  if (pwVar1 != (wchar_t *)0x0) {
    (*_DAT_1000c138)(pwVar1);
  }
  return pvVar5;
}



void FUN_00676ac0(void)

{
  __recalloc_base();
  return;
}



// Library Function - Single Match
//  __recalloc_base
// 
// Library: Visual Studio 2019 Release

int __recalloc_base(int param_1,uint param_2,uint param_3)

{
  undefined4 *puVar1;
  int iVar2;
  uint uVar3;
  
  if ((param_2 == 0) || (param_3 <= 0xffffffe0 / param_2)) {
    if (param_1 == 0) {
      uVar3 = 0;
    }
    else {
      uVar3 = FUN_0067857f(param_1);
    }
    param_2 = param_2 * param_3;
    iVar2 = __realloc_base(param_1,param_2);
    if ((iVar2 != 0) && (uVar3 < param_2)) {
      _memset((void *)(iVar2 + uVar3),0,param_2 - uVar3);
    }
  }
  else {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 0xc;
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  void __cdecl initialize_inherited_file_handles_nolock(void)
// 
// Library: Visual Studio 2017 Release

void __cdecl initialize_inherited_file_handles_nolock(void)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  undefined local_4c [50];
  short local_1a;
  uint *local_18;
  int *local_8;
  
  (*_DAT_1000c0ac)(local_4c);
  if ((local_1a != 0) && (local_18 != (uint *)0x0)) {
    uVar3 = *local_18;
    local_8 = (int *)((int)local_18 + uVar3 + 4);
    if (0x1fff < (int)uVar3) {
      uVar3 = 0x2000;
    }
    ___acrt_lowio_ensure_fh_exists(uVar3);
    if ((int)_DAT_10013198 < (int)uVar3) {
      uVar3 = _DAT_10013198;
    }
    uVar4 = 0;
    if (uVar3 != 0) {
      do {
        iVar2 = *local_8;
        if ((((iVar2 != -1) && (iVar2 != -2)) &&
            (bVar1 = *(byte *)(uVar4 + 4 + (int)local_18), (bVar1 & 1) != 0)) &&
           (((bVar1 & 8) != 0 || (iVar2 = (*_DAT_1000c04c)(iVar2), iVar2 != 0)))) {
          iVar2 = (uVar4 & 0x3f) * 0x30 + *(int *)(&DAT_10012f98 + ((int)uVar4 >> 6) * 4);
          *(int *)(iVar2 + 0x18) = *local_8;
          *(undefined *)(iVar2 + 0x28) = *(undefined *)(uVar4 + 4 + (int)local_18);
        }
        uVar4 = uVar4 + 1;
        local_8 = local_8 + 1;
      } while (uVar4 != uVar3);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_execute_initializers
// 
// Library: Visual Studio 2015 Release

void ___acrt_execute_initializers(code **param_1,code **param_2)

{
  code **ppcVar1;
  code *pcVar2;
  char cVar3;
  uint uVar4;
  code **ppcVar5;
  
  uVar4 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  ppcVar5 = param_1;
  if (param_1 != param_2) {
    do {
      pcVar2 = *ppcVar5;
      if (pcVar2 != (code *)0x0) {
        (*_DAT_1000c174)();
        cVar3 = (*pcVar2)();
        if (cVar3 == '\0') break;
      }
      ppcVar5 = ppcVar5 + 2;
    } while (ppcVar5 != param_2);
    if ((ppcVar5 != param_2) && (ppcVar5 != param_1)) {
      ppcVar5 = ppcVar5 + -1;
      do {
        if ((ppcVar5[-1] != (code *)0x0) && (pcVar2 = *ppcVar5, pcVar2 != (code *)0x0)) {
          (*_DAT_1000c174)(0);
          (*pcVar2)();
        }
        ppcVar1 = ppcVar5 + -1;
        ppcVar5 = ppcVar5 + -2;
      } while (ppcVar1 != param_1);
    }
  }
  ___security_check_cookie_4(uVar4);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00676dc4(int param_1,int param_2)

{
  code *pcVar1;
  uint uVar2;
  
  uVar2 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  if (param_1 != param_2) {
    do {
      pcVar1 = *(code **)(param_2 + -4);
      if (pcVar1 != (code *)0x0) {
        (*_DAT_1000c174)(0);
        (*pcVar1)();
      }
      param_2 = param_2 + -8;
    } while (param_2 != param_1);
  }
  ___security_check_cookie_4(uVar2);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  public: void (__cdecl*__thiscall __crt_seh_guarded_call<void (__cdecl*)(int)>::operator()<class
// <lambda_cbab9ec6f41b0180b23cc171c22676b0>,class <lambda_44731a7d0e6d81c3e6aa82d741081786>&,class
// <lambda_4b292cb8dd18144e164572427af410ab>>(class
// <lambda_cbab9ec6f41b0180b23cc171c22676b0>&&,class
// <lambda_44731a7d0e6d81c3e6aa82d741081786>&,class
// <lambda_4b292cb8dd18144e164572427af410ab>&&))(int)
// 
// Library: Visual Studio 2017 Release

FuncDef284 * __thiscall
__crt_seh_guarded_call<void_(__cdecl*)(int)>::
operator___class__lambda_cbab9ec6f41b0180b23cc171c22676b0__class__lambda_44731a7d0e6d81c3e6aa82d741081786___class__lambda_4b292cb8dd18144e164572427af410ab___
          (__crt_seh_guarded_call_void____cdecl___int__ *this,
          _lambda_cbab9ec6f41b0180b23cc171c22676b0_ *param_1,
          _lambda_44731a7d0e6d81c3e6aa82d741081786_ *param_2,
          _lambda_4b292cb8dd18144e164572427af410ab_ *param_3)

{
  byte bVar1;
  uint uVar2;
  
  ___acrt_lock(*(undefined4 *)param_1);
  bVar1 = (byte)_DAT_10012000 & 0x1f;
  uVar2 = _DAT_10012000 ^ _DAT_100131a4;
  FUN_00676e5a();
  return (FuncDef284 *)(uVar2 >> bVar1 | uVar2 << 0x20 - bVar1);
}



void FUN_00676e5a(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  void (__cdecl** __cdecl get_global_action_nolock(int))(int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void____cdecl____int_ * __cdecl get_global_action_nolock(int param_1)

{
  if (param_1 == 2) {
    return (void____cdecl____int_ *)&DAT_1001319c;
  }
  if (param_1 != 6) {
    if (param_1 == 0xf) {
      return (void____cdecl____int_ *)&DAT_100131a8;
    }
    if (param_1 == 0x15) {
      return (void____cdecl____int_ *)&DAT_100131a0;
    }
    if (param_1 != 0x16) {
      return (void____cdecl____int_ *)0x0;
    }
  }
  return (void____cdecl____int_ *)&DAT_100131a4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  struct __crt_signal_action_t * __cdecl siglookup(int,struct __crt_signal_action_t * const)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

__crt_signal_action_t * __cdecl siglookup(int param_1,__crt_signal_action_t *param_2)

{
  __crt_signal_action_t *p_Var1;
  
  p_Var1 = param_2 + _DAT_1000cb80 * 0xc;
  if (param_2 != p_Var1) {
    do {
      if (*(int *)(param_2 + 4) == param_1) {
        return param_2;
      }
      param_2 = param_2 + 0xc;
    } while (param_2 != p_Var1);
  }
  return (__crt_signal_action_t *)0x0;
}



// Library Function - Single Match
//  ___acrt_get_sigabrt_handler
// 
// Library: Visual Studio 2017 Release

void ___acrt_get_sigabrt_handler(void)

{
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void____cdecl___int__ local_5;
  
  local_c = 3;
  local_10 = 3;
  __crt_seh_guarded_call<void_(__cdecl*)(int)>::
  operator___class__lambda_cbab9ec6f41b0180b23cc171c22676b0__class__lambda_44731a7d0e6d81c3e6aa82d741081786___class__lambda_4b292cb8dd18144e164572427af410ab___
            (&local_5,(_lambda_cbab9ec6f41b0180b23cc171c22676b0_ *)&local_10,
             (_lambda_44731a7d0e6d81c3e6aa82d741081786_ *)&local_5,
             (_lambda_4b292cb8dd18144e164572427af410ab_ *)&local_c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00676ef9(undefined4 param_1)

{
  _DAT_1001319c = param_1;
  _DAT_100131a0 = param_1;
  _DAT_100131a4 = param_1;
  _DAT_100131a8 = param_1;
  return;
}



int FUN_00676f17(void)

{
  int iVar1;
  
  iVar1 = FUN_006759b1();
  return iVar1 + 8;
}



// WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00676f20(int param_1)

{
  code **ppcVar1;
  undefined4 *puVar2;
  __crt_signal_action_t *p_Var3;
  int iVar4;
  char extraout_CL;
  byte bVar5;
  char cVar6;
  __crt_signal_action_t *p_Var7;
  code *pcVar8;
  __crt_signal_action_t **pp_Var9;
  undefined4 local_38;
  __crt_signal_action_t *local_34;
  char local_21;
  
  pp_Var9 = (__crt_signal_action_t **)0x0;
  local_38 = 0;
  local_21 = '\x01';
  if (8 < param_1) {
    if (param_1 == 0xb) goto LAB_00676f7a;
    if ((param_1 == 0xf) || ((0x14 < param_1 && (param_1 < 0x17)))) goto LAB_00676f6f;
LAB_00676f9e:
    puVar2 = (undefined4 *)FUN_00675142();
    *puVar2 = 0x16;
    FUN_00675085();
    goto LAB_00677110;
  }
  if (param_1 == 8) {
LAB_00676f7a:
    pp_Var9 = (__crt_signal_action_t **)FUN_00675aff();
    if (pp_Var9 == (__crt_signal_action_t **)0x0) goto LAB_00677110;
    p_Var3 = siglookup(param_1,*pp_Var9);
    if (p_Var3 == (__crt_signal_action_t *)0x0) goto LAB_00676f9e;
    ppcVar1 = (code **)(p_Var3 + 8);
    cVar6 = '\0';
    local_21 = '\0';
  }
  else {
    if (param_1 != 2) {
      if (param_1 == 4) goto LAB_00676f7a;
      if (param_1 != 6) goto LAB_00676f9e;
    }
LAB_00676f6f:
    ppcVar1 = (code **)get_global_action_nolock(param_1);
    cVar6 = extraout_CL;
  }
  local_34 = (__crt_signal_action_t *)0x0;
  if (cVar6 != '\0') {
    ___acrt_lock(3);
    cVar6 = local_21;
  }
  if (cVar6 == '\0') {
    pcVar8 = *ppcVar1;
  }
  else {
    bVar5 = (byte)_DAT_10012000 & 0x1f;
    pcVar8 = (code *)((_DAT_10012000 ^ (uint)*ppcVar1) >> bVar5 |
                     (_DAT_10012000 ^ (uint)*ppcVar1) << 0x20 - bVar5);
    cVar6 = local_21;
  }
  if (pcVar8 != (code *)0x1) {
    if (pcVar8 == (code *)0x0) {
      if (cVar6 != '\0') {
        ___acrt_unlock(3);
      }
      __exit(3);
    }
    if (((param_1 == 8) || (param_1 == 0xb)) || (param_1 == 4)) {
      local_34 = pp_Var9[1];
      pp_Var9[1] = (__crt_signal_action_t *)0x0;
      if (param_1 == 8) {
        puVar2 = (undefined4 *)FUN_00676f17();
        local_38 = *puVar2;
        puVar2 = (undefined4 *)FUN_00676f17();
        *puVar2 = 0x8c;
        goto LAB_00677055;
      }
    }
    else {
LAB_00677055:
      if (param_1 == 8) {
        p_Var3 = *pp_Var9 + _DAT_1000cb84 * 0xc;
        p_Var7 = p_Var3 + _DAT_1000cb88 * 0xc;
        for (; p_Var3 != p_Var7; p_Var3 = p_Var3 + 0xc) {
          *(undefined4 *)(p_Var3 + 8) = 0;
        }
        goto LAB_00677097;
      }
    }
    bVar5 = 0x20 - ((byte)_DAT_10012000 & 0x1f) & 0x1f;
    *ppcVar1 = (code *)((0U >> bVar5 | 0 << 0x20 - bVar5) ^ _DAT_10012000);
  }
LAB_00677097:
  FUN_006770ce();
  if (pcVar8 != (code *)0x1) {
    if (param_1 == 8) {
      iVar4 = FUN_006759b1();
      (*_DAT_1000c174)(8,*(undefined4 *)(iVar4 + 8));
      (*pcVar8)();
    }
    else {
      (*_DAT_1000c174)(param_1);
      (*pcVar8)();
      if ((param_1 != 0xb) && (param_1 != 4)) goto LAB_00677110;
    }
    pp_Var9[1] = local_34;
    if (param_1 == 8) {
      iVar4 = FUN_006759b1();
      *(undefined4 *)(iVar4 + 8) = local_38;
    }
  }
LAB_00677110:
  FUN_0067b856();
  return;
}



void FUN_006770ce(void)

{
  int unaff_EBP;
  
  if (*(char *)(unaff_EBP + -0x1d) != '\0') {
    ___acrt_unlock(3);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_has_user_matherr
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

uint ___acrt_has_user_matherr(void)

{
  uint uVar1;
  byte bVar2;
  
  bVar2 = (byte)_DAT_10012000 & 0x1f;
  uVar1 = (_DAT_10012000 ^ _DAT_100131ac) >> bVar2 | (_DAT_10012000 ^ _DAT_100131ac) << 0x20 - bVar2
  ;
  return uVar1 & 0xffffff00 | (uint)(uVar1 != 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067712e(undefined4 param_1)

{
  _DAT_100131ac = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_invoke_user_matherr
// 
// Library: Visual Studio 2015 Release

void ___acrt_invoke_user_matherr(undefined4 param_1)

{
  uint uVar1;
  byte bVar2;
  code *pcVar3;
  
  uVar1 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  bVar2 = (byte)_DAT_10012000 & 0x1f;
  pcVar3 = (code *)((_DAT_10012000 ^ _DAT_100131ac) >> bVar2 |
                   (_DAT_10012000 ^ _DAT_100131ac) << 0x20 - bVar2);
  if (pcVar3 != (code *)0x0) {
    (*_DAT_1000c174)(param_1);
    (*pcVar3)();
  }
  ___security_check_cookie_4(uVar1);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_2866be3712abc81a800a822484c830d8>,class <lambda_39ca0ed439415581b5b15c265174cece>&,class
// <lambda_2b24c74d71094a6cd0cb82e44167d71b>>(class
// <lambda_2866be3712abc81a800a822484c830d8>&&,class
// <lambda_39ca0ed439415581b5b15c265174cece>&,class <lambda_2b24c74d71094a6cd0cb82e44167d71b>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_2866be3712abc81a800a822484c830d8__class__lambda_39ca0ed439415581b5b15c265174cece___class__lambda_2b24c74d71094a6cd0cb82e44167d71b___
          (__crt_seh_guarded_call_void_ *this,_lambda_2866be3712abc81a800a822484c830d8_ *param_1,
          _lambda_39ca0ed439415581b5b15c265174cece_ *param_2,
          _lambda_2b24c74d71094a6cd0cb82e44167d71b_ *param_3)

{
  char cVar1;
  int iVar2;
  
  __lock_file(*(FILE **)param_1);
  cVar1 = FUN_006772f8(**(undefined4 **)param_2,*(undefined4 *)(param_2 + 4));
  if ((cVar1 != '\0') &&
     ((**(char **)(param_2 + 8) != '\0' || ((*(uint *)(**(int **)param_2 + 0xc) >> 1 & 1) != 0)))) {
    iVar2 = __fflush_nolock(**(FILE ***)param_2);
    if (iVar2 == -1) {
      **(undefined4 **)(param_2 + 0xc) = 0xffffffff;
    }
    else {
      **(int **)(param_2 + 4) = **(int **)(param_2 + 4) + 1;
    }
  }
  FUN_006771fb();
  return;
}



void FUN_006771fb(void)

{
  int unaff_EBP;
  
  FUN_00677528(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_2cc53f568c5a2bb6f192f930a45d44ea>,class <lambda_ab61a845afdef5b7c387490eaf3616ee>&,class
// <lambda_c2ffc0b7726aa6be21d5f0026187e748>>(class
// <lambda_2cc53f568c5a2bb6f192f930a45d44ea>&&,class
// <lambda_ab61a845afdef5b7c387490eaf3616ee>&,class <lambda_c2ffc0b7726aa6be21d5f0026187e748>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_2cc53f568c5a2bb6f192f930a45d44ea__class__lambda_ab61a845afdef5b7c387490eaf3616ee___class__lambda_c2ffc0b7726aa6be21d5f0026187e748___
          (__crt_seh_guarded_call_void_ *this,_lambda_2cc53f568c5a2bb6f192f930a45d44ea_ *param_1,
          _lambda_ab61a845afdef5b7c387490eaf3616ee_ *param_2,
          _lambda_c2ffc0b7726aa6be21d5f0026187e748_ *param_3)

{
  undefined4 *puVar1;
  char cVar2;
  undefined4 *puVar3;
  undefined4 *local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 *local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  __crt_seh_guarded_call_void_ local_1d [17];
  undefined4 uStack12;
  undefined4 local_8;
  
  local_8 = 0x10011400;
  uStack12 = 0x677213;
  ___acrt_lock(*(undefined4 *)param_1);
  local_8 = 0;
  puVar1 = _DAT_100131b8 + _DAT_100131b4;
  for (puVar3 = _DAT_100131b8; local_30 = puVar3, puVar3 != puVar1; puVar3 = puVar3 + 1) {
    local_24 = *puVar3;
    cVar2 = FUN_006772f8(local_24,*(undefined4 *)param_2);
    if (cVar2 != '\0') {
      local_34 = *(undefined4 *)(param_2 + 8);
      local_38 = *(undefined4 *)(param_2 + 4);
      local_3c = *(undefined4 *)param_2;
      local_40 = &local_24;
      local_28 = local_24;
      local_2c = local_24;
      operator___class__lambda_2866be3712abc81a800a822484c830d8__class__lambda_39ca0ed439415581b5b15c265174cece___class__lambda_2b24c74d71094a6cd0cb82e44167d71b___
                (local_1d,(_lambda_2866be3712abc81a800a822484c830d8_ *)&local_2c,
                 (_lambda_39ca0ed439415581b5b15c265174cece_ *)&local_40,
                 (_lambda_2b24c74d71094a6cd0cb82e44167d71b_ *)&local_28);
    }
  }
  local_8 = 0xfffffffe;
  FUN_0067729d();
  return;
}



void FUN_0067729d(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// Library Function - Single Match
//  int __cdecl common_flush_all(bool)
// 
// Library: Visual Studio 2017 Release

int __cdecl common_flush_all(bool param_1)

{
  int *local_24;
  bool *local_20;
  int *local_1c;
  undefined4 local_18;
  undefined4 local_14;
  int local_10;
  int local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  local_c = 0;
  local_24 = &local_c;
  local_10 = 0;
  local_20 = &param_1;
  local_1c = &local_10;
  local_14 = 8;
  local_18 = 8;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_2cc53f568c5a2bb6f192f930a45d44ea__class__lambda_ab61a845afdef5b7c387490eaf3616ee___class__lambda_c2ffc0b7726aa6be21d5f0026187e748___
            (&local_5,(_lambda_2cc53f568c5a2bb6f192f930a45d44ea_ *)&local_18,
             (_lambda_ab61a845afdef5b7c387490eaf3616ee_ *)&local_24,
             (_lambda_c2ffc0b7726aa6be21d5f0026187e748_ *)&local_14);
  if (param_1 == false) {
    local_c = local_10;
  }
  return local_c;
}



undefined4 FUN_006772f8(int param_1,int *param_2)

{
  char cVar1;
  
  if (param_1 != 0) {
    if ((*(uint *)(param_1 + 0xc) >> 0xd & 1) != 0) {
      cVar1 = FUN_0067732a(*(uint *)(param_1 + 0xc));
      if (cVar1 != '\0') {
        return 1;
      }
      *param_2 = *param_2 + 1;
    }
  }
  return 0;
}



uint FUN_0067732a(uint param_1)

{
  if ((((byte)param_1 & 3) == 2) && ((param_1 & 0xc0) != 0)) {
    return param_1 & 0xffffff00 | 1;
  }
  return param_1 & 0xffffff00 | (uint)((byte)(param_1 >> 0xb) & 1);
}



// Library Function - Single Match
//  ___acrt_stdio_flush_nolock
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_stdio_flush_nolock(FILE *param_1)

{
  int *piVar1;
  int _FileHandle;
  uint uVar2;
  uint uVar3;
  char *_Buf;
  
  piVar1 = &param_1->_flag;
  if ((((byte)*piVar1 & 3) == 2) && ((*piVar1 & 0xc0U) != 0)) {
    _Buf = (char *)param_1->_cnt;
    uVar3 = (int)param_1->_ptr - (int)_Buf;
    param_1->_ptr = _Buf;
    param_1->_base = (char *)0x0;
    if (0 < (int)uVar3) {
      uVar2 = uVar3;
      _FileHandle = __fileno(param_1);
      uVar2 = __write(_FileHandle,_Buf,uVar2);
      if (uVar3 != uVar2) {
        LOCK();
        *piVar1 = *piVar1 | 0x10;
        return 0xffffffff;
      }
      if (((uint)*piVar1 >> 2 & 1) != 0) {
        LOCK();
        *piVar1 = *piVar1 & 0xfffffffd;
      }
    }
  }
  return 0;
}



// Library Function - Single Match
//  __fflush_nolock
// 
// Library: Visual Studio 2015 Release

int __cdecl __fflush_nolock(FILE *_File)

{
  int iVar1;
  
  if (_File == (FILE *)0x0) {
    iVar1 = common_flush_all(false);
    return iVar1;
  }
  iVar1 = ___acrt_stdio_flush_nolock(_File);
  if (iVar1 == 0) {
    if (((uint)_File->_flag >> 0xb & 1) != 0) {
      iVar1 = __fileno(_File);
      iVar1 = __commit(iVar1);
      if (iVar1 != 0) goto LAB_006773d1;
    }
    iVar1 = 0;
  }
  else {
LAB_006773d1:
    iVar1 = -1;
  }
  return iVar1;
}



// Library Function - Single Match
//  __flushall
// 
// Library: Visual Studio 2017 Release

int __cdecl __flushall(void)

{
  int iVar1;
  
  iVar1 = common_flush_all(true);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __lock_file
// 
// Library: Visual Studio 2017 Release

void __cdecl __lock_file(FILE *_File)

{
  (*_DAT_1000c0c8)(_File + 1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00677528(int param_1)

{
  (*_DAT_1000c0cc)(param_1 + 0x20);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0067753c(void)

{
  return _DAT_100131c4;
}



undefined4 FUN_00677542(ushort *param_1,byte *param_2,uint param_3,undefined4 param_4)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  int local_14;
  localeinfo_struct local_10;
  char local_8;
  
  if ((param_2 == (byte *)0x0) || (param_3 == 0)) {
    return 0;
  }
  if (*param_2 == 0) {
    if (param_1 == (ushort *)0x0) {
      return 0;
    }
    *param_1 = 0;
    return 0;
  }
  FUN_00674cdd(param_4);
  if ((local_10.locinfo)->locale_name[2] == (wchar_t *)0x0) {
    if (param_1 != (ushort *)0x0) {
      *param_1 = (ushort)*param_2;
    }
    uVar3 = 1;
    goto LAB_00677628;
  }
  iVar1 = __isleadbyte_l((uint)*param_2,&local_10);
  if (iVar1 == 0) {
    uVar3 = 1;
    iVar1 = FUN_006793c9((local_10.locinfo)->lc_collate_cp,9,param_2,1,param_1,
                         param_1 != (ushort *)0x0);
    if (iVar1 != 0) goto LAB_00677628;
LAB_0067761a:
    puVar2 = (undefined4 *)FUN_00675142();
    uVar3 = 0xffffffff;
    *puVar2 = 0x2a;
  }
  else {
    if ((int)(local_10.locinfo)->lc_codepage < 2) {
LAB_006775e5:
      uVar3 = (local_10.locinfo)->lc_codepage;
LAB_006775e8:
      if ((param_3 < uVar3) || (param_2[1] == 0)) goto LAB_0067761a;
    }
    else {
      uVar3 = (local_10.locinfo)->lc_codepage;
      if ((int)param_3 < (int)(local_10.locinfo)->lc_codepage) goto LAB_006775e8;
      iVar1 = FUN_006793c9((local_10.locinfo)->lc_collate_cp,9,param_2,
                           (local_10.locinfo)->lc_codepage,param_1,param_1 != (ushort *)0x0);
      if (iVar1 == 0) goto LAB_006775e5;
    }
    uVar3 = (local_10.locinfo)->lc_codepage;
  }
LAB_00677628:
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
    return uVar3;
  }
  return uVar3;
}



void FUN_00677640(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_00677542(param_1,param_2,param_3,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_update_locale_info
// 
// Library: Visual Studio 2015 Release

void ___acrt_update_locale_info(int param_1,int *param_2)

{
  int iVar1;
  
  if ((*param_2 != _DAT_100131b0) && ((*(uint *)(param_1 + 0x350) & _DAT_100126e0) == 0)) {
    iVar1 = ___acrt_update_thread_locale_data();
    *param_2 = iVar1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_update_multibyte_info
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_update_multibyte_info(int param_1,int *param_2)

{
  int iVar1;
  
  if ((*param_2 != _DAT_10012f6c) && ((*(uint *)(param_1 + 0x350) & _DAT_100126e0) == 0)) {
    iVar1 = ___acrt_update_thread_multibyte_data();
    *param_2 = iVar1;
  }
  return;
}



// Library Function - Single Match
//  __fileno
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __fileno(FILE *_File)

{
  undefined4 *puVar1;
  
  if (_File == (FILE *)0x0) {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 0x16;
    FUN_00675085();
    return -1;
  }
  return _File->_file;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall __crt_seh_guarded_call<void>::operator()<class
// <lambda_e5124f882df8998aaf41531e079ba474>,class <lambda_3e16ef9562a7dcce91392c22ab16ea36>&,class
// <lambda_e25ca0880e6ef98be67edffd8c599615>>(class
// <lambda_e5124f882df8998aaf41531e079ba474>&&,class
// <lambda_3e16ef9562a7dcce91392c22ab16ea36>&,class <lambda_e25ca0880e6ef98be67edffd8c599615>&&)
// 
// Library: Visual Studio 2017 Release

void __thiscall
__crt_seh_guarded_call<void>::
operator___class__lambda_e5124f882df8998aaf41531e079ba474__class__lambda_3e16ef9562a7dcce91392c22ab16ea36___class__lambda_e25ca0880e6ef98be67edffd8c599615___
          (__crt_seh_guarded_call_void_ *this,_lambda_e5124f882df8998aaf41531e079ba474_ *param_1,
          _lambda_3e16ef9562a7dcce91392c22ab16ea36_ *param_2,
          _lambda_e25ca0880e6ef98be67edffd8c599615_ *param_3)

{
  int iVar1;
  int *piVar2;
  
  ___acrt_lock(*(undefined4 *)param_1);
  for (piVar2 = (int *)&DAT_100131b0; piVar2 != (int *)&DAT_100131b4; piVar2 = piVar2 + 1) {
    if (*piVar2 != 0x10012570) {
      iVar1 = __updatetlocinfoEx_nolock(piVar2,0x10012570);
      *piVar2 = iVar1;
    }
  }
  FUN_00677732();
  return;
}



void FUN_00677732(void)

{
  int unaff_EBP;
  
  ___acrt_unlock(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_set_locale_changed
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_set_locale_changed(void)

{
  undefined4 uVar1;
  
  uVar1 = _DAT_100131c8;
  _DAT_100131c8 = 1;
  return uVar1;
}



// Library Function - Single Match
//  ___acrt_uninitialize_locale
// 
// Library: Visual Studio 2017 Release

void ___acrt_uninitialize_locale(void)

{
  undefined4 local_10;
  undefined4 local_c;
  __crt_seh_guarded_call_void_ local_5;
  
  local_c = 4;
  local_10 = 4;
  __crt_seh_guarded_call<void>::
  operator___class__lambda_e5124f882df8998aaf41531e079ba474__class__lambda_3e16ef9562a7dcce91392c22ab16ea36___class__lambda_e25ca0880e6ef98be67edffd8c599615___
            (&local_5,(_lambda_e5124f882df8998aaf41531e079ba474_ *)&local_10,
             (_lambda_3e16ef9562a7dcce91392c22ab16ea36_ *)&local_5,
             (_lambda_e25ca0880e6ef98be67edffd8c599615_ *)&local_c);
  return;
}



// Library Function - Single Match
//  ___pctype_func
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

ushort * __cdecl ___pctype_func(void)

{
  int iVar1;
  ushort **local_8;
  
  iVar1 = FUN_006759b1();
  local_8 = *(ushort ***)(iVar1 + 0x4c);
  ___acrt_update_locale_info(iVar1,&local_8);
  return *local_8;
}



// Library Function - Single Match
//  int __cdecl GetTableIndexFromLocaleName(wchar_t const *)
// 
// Library: Visual Studio 2017 Release

int __cdecl GetTableIndexFromLocaleName(wchar_t *param_1)

{
  ushort uVar1;
  int iVar2;
  int iVar3;
  ushort uVar4;
  ushort *puVar5;
  int local_10;
  int local_c;
  int local_8;
  
  local_c = 0;
  local_10 = 0xe3;
  while( true ) {
    local_8 = 0x55;
    iVar2 = (local_10 + local_c) / 2;
    puVar5 = *(ushort **)(iVar2 * 8 + 0x1000eed8);
    iVar3 = (int)param_1 - (int)puVar5;
    do {
      uVar4 = *(ushort *)(iVar3 + (int)puVar5);
      if ((ushort)(uVar4 - 0x41) < 0x1a) {
        uVar4 = uVar4 + 0x20;
      }
      uVar1 = *puVar5;
      if ((ushort)(uVar1 - 0x41) < 0x1a) {
        uVar1 = uVar1 + 0x20;
      }
      puVar5 = puVar5 + 1;
      local_8 = local_8 + -1;
    } while (((local_8 != 0) && (uVar4 != 0)) && (uVar4 == uVar1));
    if ((uint)uVar4 == (uint)uVar1) break;
    if ((int)((uint)uVar4 - (uint)uVar1) < 0) {
      local_10 = iVar2 + -1;
    }
    else {
      local_c = iVar2 + 1;
    }
    if (local_10 < local_c) {
      return -1;
    }
  }
  return *(int *)(iVar2 * 8 + 0x1000eedc);
}



// Library Function - Single Match
//  ___acrt_DownlevelLocaleNameToLCID
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_DownlevelLocaleNameToLCID(wchar_t *param_1)

{
  uint uVar1;
  
  if (param_1 != (wchar_t *)0x0) {
    uVar1 = GetTableIndexFromLocaleName(param_1);
    if ((-1 < (int)uVar1) && (uVar1 < 0xe4)) {
      return *(undefined4 *)(uVar1 * 8 + 0x1000ddb0);
    }
  }
  return 0;
}



// Library Function - Single Match
//  ___acrt_add_locale_ref
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_add_locale_ref(int param_1)

{
  int *piVar1;
  int **ppiVar2;
  int iVar3;
  
  LOCK();
  *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + 1;
  piVar1 = *(int **)(param_1 + 0x7c);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x84);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x80);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = *(int **)(param_1 + 0x8c);
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  ppiVar2 = (int **)(param_1 + 0x28);
  iVar3 = 6;
  do {
    if ((ppiVar2[-2] != (int *)0x10012630) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    ppiVar2 = ppiVar2 + 4;
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  ___acrt_locale_add_lc_time_reference(*(undefined4 *)(param_1 + 0x9c));
  return;
}



// Library Function - Single Match
//  ___acrt_free_locale
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_free_locale(void *param_1)

{
  int *piVar1;
  void **ppvVar2;
  int **ppiVar3;
  int local_8;
  
  if ((((*(undefined **)((int)param_1 + 0x88) != (undefined *)0x0) &&
       (*(undefined **)((int)param_1 + 0x88) != &DAT_100126f0)) &&
      (*(int **)((int)param_1 + 0x7c) != (int *)0x0)) && (**(int **)((int)param_1 + 0x7c) == 0)) {
    piVar1 = *(int **)((int)param_1 + 0x84);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      ___acrt_locale_free_monetary(*(undefined4 *)((int)param_1 + 0x88));
    }
    piVar1 = *(int **)((int)param_1 + 0x80);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      ___acrt_locale_free_numeric(*(undefined4 *)((int)param_1 + 0x88));
    }
    FID_conflict__free(*(void **)((int)param_1 + 0x7c));
    FID_conflict__free(*(void **)((int)param_1 + 0x88));
  }
  if ((*(int **)((int)param_1 + 0x8c) != (int *)0x0) && (**(int **)((int)param_1 + 0x8c) == 0)) {
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x90) + -0xfe));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x94) + -0x80));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x98) + -0x80));
    FID_conflict__free(*(void **)((int)param_1 + 0x8c));
  }
  ___acrt_locale_free_lc_time_if_unreferenced(*(undefined4 *)((int)param_1 + 0x9c));
  ppvVar2 = (void **)((int)param_1 + 0xa0);
  local_8 = 6;
  ppiVar3 = (int **)((int)param_1 + 0x28);
  do {
    if (((ppiVar3[-2] != (int *)0x10012630) && (piVar1 = *ppiVar3, piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      FID_conflict__free(*ppvVar2);
    }
    if (((ppiVar3[-3] != (int *)0x0) && (piVar1 = ppiVar3[-1], piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
    }
    ppvVar2 = ppvVar2 + 1;
    ppiVar3 = ppiVar3 + 4;
    local_8 = local_8 + -1;
  } while (local_8 != 0);
  FID_conflict__free(param_1);
  return;
}



// Library Function - Single Match
//  ___acrt_locale_add_lc_time_reference
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int ___acrt_locale_add_lc_time_reference(int param_1)

{
  int *piVar1;
  int iVar2;
  
  if ((param_1 != 0) && (param_1 != 0x1000d648)) {
    LOCK();
    piVar1 = (int *)(param_1 + 0xb0);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + 1;
    return iVar2 + 1;
  }
  return 0x7fffffff;
}



// Library Function - Single Match
//  ___acrt_locale_free_lc_time_if_unreferenced
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_locale_free_lc_time_if_unreferenced(void *param_1)

{
  if (((param_1 != (void *)0x0) && (param_1 != (void *)0x1000d648)) &&
     (*(int *)((int)param_1 + 0xb0) == 0)) {
    ___acrt_locale_free_time(param_1);
    FID_conflict__free(param_1);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_release_lc_time_reference
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int ___acrt_locale_release_lc_time_reference(int param_1)

{
  int *piVar1;
  int iVar2;
  
  if ((param_1 != 0) && (param_1 != 0x1000d648)) {
    LOCK();
    piVar1 = (int *)(param_1 + 0xb0);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + -1;
    return iVar2 + -1;
  }
  return 0x7fffffff;
}



// Library Function - Single Match
//  ___acrt_release_locale_ref
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_release_locale_ref(int param_1)

{
  int *piVar1;
  int **ppiVar2;
  int iVar3;
  
  if (param_1 != 0) {
    LOCK();
    *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + -1;
    piVar1 = *(int **)(param_1 + 0x7c);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x84);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x80);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = *(int **)(param_1 + 0x8c);
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    ppiVar2 = (int **)(param_1 + 0x28);
    iVar3 = 6;
    do {
      if ((ppiVar2[-2] != (int *)0x10012630) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      ppiVar2 = ppiVar2 + 4;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    ___acrt_locale_release_lc_time_reference(*(undefined4 *)(param_1 + 0x9c));
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_update_thread_locale_data
// 
// Library: Visual Studio 2015 Release

int ___acrt_update_thread_locale_data(void)

{
  int iVar1;
  int iVar2;
  
  iVar1 = FUN_006759b1();
  if (((*(uint *)(iVar1 + 0x350) & _DAT_100126e0) == 0) ||
     (iVar2 = *(int *)(iVar1 + 0x4c), iVar2 == 0)) {
    ___acrt_lock(4);
    iVar2 = __updatetlocinfoEx_nolock(iVar1 + 0x4c,_DAT_100131b0);
    FUN_00677ba8();
    if (iVar2 == 0) {
      _abort();
      iVar1 = ___acrt_unlock(4);
      return iVar1;
    }
  }
  return iVar2;
}



void FUN_00677ba8(void)

{
  ___acrt_unlock(4);
  return;
}



// Library Function - Single Match
//  __updatetlocinfoEx_nolock
// 
// Library: Visual Studio 2015 Release

int __updatetlocinfoEx_nolock(int *param_1,int param_2)

{
  int iVar1;
  
  if ((param_2 == 0) || (param_1 == (int *)0x0)) {
    param_2 = 0;
  }
  else {
    iVar1 = *param_1;
    if (iVar1 != param_2) {
      *param_1 = param_2;
      ___acrt_add_locale_ref(param_2);
      if (((iVar1 != 0) && (___acrt_release_locale_ref(iVar1), *(int *)(iVar1 + 0xc) == 0)) &&
         (iVar1 != 0x10012570)) {
        ___acrt_free_locale(iVar1);
      }
    }
  }
  return param_2;
}



// Library Function - Multiple Matches With Different Base Names
//  void __cdecl swap(char *,char *,unsigned int)
//  _swap
//  _swap_c
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void FID_conflict__swap(undefined *param_1,undefined *param_2,int param_3)

{
  undefined *puVar1;
  undefined uVar2;
  undefined *puVar3;
  
  if ((param_1 != param_2) && (puVar3 = param_2, param_3 != 0)) {
    do {
      puVar1 = puVar3 + 1;
      uVar2 = puVar1[(int)(param_1 + (-1 - (int)param_2))];
      puVar1[(int)(param_1 + (-1 - (int)param_2))] = *puVar3;
      *puVar3 = uVar2;
      param_3 = param_3 + -1;
      puVar3 = puVar1;
    } while (param_3 != 0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00677c4d(undefined *param_1,uint param_2,uint param_3,code *param_4)

{
  undefined *puVar1;
  undefined uVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined *puVar5;
  undefined *puVar6;
  uint uVar7;
  undefined *puVar8;
  undefined *puVar9;
  undefined *local_114;
  int local_110;
  undefined *local_108;
  undefined *local_fc;
  undefined4 auStack248 [30];
  undefined4 auStack128 [30];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_108 = param_1;
  if ((((param_1 == (undefined *)0x0) && (param_2 != 0)) || (param_3 == 0)) ||
     (param_4 == (code *)0x0)) {
    puVar3 = (undefined4 *)FUN_00675142();
    *puVar3 = 0x16;
    FUN_00675085();
  }
  else {
    local_110 = 0;
    if (1 < param_2) {
      puVar5 = param_1 + (param_2 - 1) * param_3;
LAB_00677ccf:
      while (uVar7 = (uint)((int)puVar5 - (int)local_108) / param_3 + 1, 8 < uVar7) {
        puVar9 = local_108 + (uVar7 >> 1) * param_3;
        (*_DAT_1000c174)(local_108,puVar9);
        iVar4 = (*param_4)();
        if (0 < iVar4) {
          FID_conflict__swap(local_108,puVar9,param_3);
        }
        (*_DAT_1000c174)(local_108,puVar5);
        iVar4 = (*param_4)();
        if (0 < iVar4) {
          FID_conflict__swap(local_108,puVar5,param_3);
        }
        (*_DAT_1000c174)(puVar9,puVar5);
        iVar4 = (*param_4)();
        local_114 = local_108;
        local_fc = puVar5;
        if (0 < iVar4) {
          FID_conflict__swap(puVar9,puVar5,param_3);
        }
LAB_00677e6d:
        if (local_114 < puVar9) {
          do {
            local_114 = local_114 + param_3;
            if (puVar9 <= local_114) goto LAB_00677eae;
            (*_DAT_1000c174)(local_114,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 < 1);
          puVar8 = local_fc;
          if (puVar9 <= local_114) goto LAB_00677eae;
        }
        else {
LAB_00677eae:
          do {
            local_114 = local_114 + param_3;
            puVar8 = local_fc;
            if (puVar5 < local_114) break;
            (*_DAT_1000c174)(local_114,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 < 1);
        }
        do {
          local_fc = puVar8;
          puVar8 = local_fc + -param_3;
          if (puVar8 <= puVar9) break;
          (*_DAT_1000c174)(puVar8,puVar9);
          iVar4 = (*param_4)();
        } while (0 < iVar4);
        if (local_114 <= puVar8) {
          puVar6 = puVar8;
          uVar7 = param_3;
          if (local_114 != puVar8) {
            do {
              puVar1 = puVar6 + 1;
              uVar2 = puVar1[(int)(local_114 + (-1 - (int)puVar8))];
              puVar1[(int)(local_114 + (-1 - (int)puVar8))] = *puVar6;
              *puVar6 = uVar2;
              uVar7 = uVar7 - 1;
              puVar6 = puVar1;
            } while (uVar7 != 0);
          }
          local_fc = puVar8;
          if (puVar9 == puVar8) {
            puVar9 = local_114;
          }
          goto LAB_00677e6d;
        }
        if (puVar9 < local_fc) {
          do {
            local_fc = local_fc + -param_3;
            if (local_fc <= puVar9) goto LAB_00677fce;
            (*_DAT_1000c174)(local_fc,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 == 0);
          if (local_fc <= puVar9) goto LAB_00677fce;
        }
        else {
LAB_00677fce:
          do {
            local_fc = local_fc + -param_3;
            if (local_fc <= local_108) break;
            (*_DAT_1000c174)(local_fc,puVar9);
            iVar4 = (*param_4)();
          } while (iVar4 == 0);
        }
        if ((int)local_fc - (int)local_108 < (int)puVar5 - (int)local_114) goto LAB_00678054;
        if (local_108 < local_fc) {
          auStack128[local_110] = local_108;
          auStack248[local_110] = local_fc;
          local_110 = local_110 + 1;
        }
        local_108 = local_114;
        if (puVar5 <= local_114) goto LAB_00677d92;
      }
      for (; puVar8 = local_108, puVar9 = local_108, local_108 < puVar5; puVar5 = puVar5 + -param_3)
      {
        while (puVar9 = puVar9 + param_3, puVar9 <= puVar5) {
          (*_DAT_1000c174)(puVar9,puVar8);
          iVar4 = (*param_4)();
          if (0 < iVar4) {
            puVar8 = puVar9;
          }
        }
        if (puVar8 != puVar5) {
          puVar9 = puVar5;
          uVar7 = param_3;
          do {
            uVar2 = puVar9[(int)puVar8 - (int)puVar5];
            (puVar9 + 1)[((int)puVar8 - (int)puVar5) + -1] = *puVar9;
            *puVar9 = uVar2;
            uVar7 = uVar7 - 1;
            puVar9 = puVar9 + 1;
          } while (uVar7 != 0);
        }
      }
      goto LAB_00677d92;
    }
  }
LAB_00677c9b:
  ___security_check_cookie_4();
  return;
LAB_00678054:
  if (local_114 < puVar5) {
    auStack128[local_110] = local_114;
    auStack248[local_110] = puVar5;
    local_110 = local_110 + 1;
  }
  puVar5 = local_fc;
  if (local_fc <= local_108) {
LAB_00677d92:
    local_110 = local_110 + -1;
    if (-1 < local_110) {
      local_108 = (undefined *)auStack128[local_110];
      puVar5 = (undefined *)auStack248[local_110];
      goto LAB_00677ccf;
    }
    goto LAB_00677c9b;
  }
  goto LAB_00677ccf;
}



undefined4 FUN_00678091(char *param_1,int param_2,int param_3,int param_4)

{
  char cVar1;
  undefined4 *puVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  undefined4 uVar6;
  
  if (param_4 == 0) {
    if (param_1 == (char *)0x0) {
      if (param_2 == 0) {
        return 0;
      }
    }
    else {
LAB_006780b3:
      if (param_2 != 0) {
        if (param_4 == 0) {
          *param_1 = '\0';
          return 0;
        }
        if (param_3 != 0) {
          iVar3 = param_4;
          iVar4 = param_2;
          pcVar5 = param_1;
          if (param_4 == -1) {
            do {
              cVar1 = pcVar5[param_3 - (int)param_1];
              *pcVar5 = cVar1;
              pcVar5 = pcVar5 + 1;
              if (cVar1 == '\0') break;
              iVar4 = iVar4 + -1;
            } while (iVar4 != 0);
          }
          else {
            do {
              cVar1 = pcVar5[param_3 - (int)param_1];
              *pcVar5 = cVar1;
              pcVar5 = pcVar5 + 1;
              if ((cVar1 == '\0') || (iVar4 = iVar4 + -1, iVar4 == 0)) break;
              iVar3 = iVar3 + -1;
            } while (iVar3 != 0);
            if (iVar3 == 0) {
              *pcVar5 = '\0';
            }
          }
          if (iVar4 != 0) {
            return 0;
          }
          if (param_4 == -1) {
            param_1[param_2 + -1] = '\0';
            return 0x50;
          }
          *param_1 = '\0';
          puVar2 = (undefined4 *)FUN_00675142();
          uVar6 = 0x22;
          goto LAB_006780d3;
        }
        *param_1 = '\0';
      }
    }
  }
  else if (param_1 != (char *)0x0) goto LAB_006780b3;
  puVar2 = (undefined4 *)FUN_00675142();
  uVar6 = 0x16;
LAB_006780d3:
  *puVar2 = uVar6;
  FUN_00675085();
  return uVar6;
}



void FUN_00678142(void)

{
  FUN_00678091();
  return;
}



// Library Function - Single Match
//  _strpbrk
// 
// Library: Visual Studio

char * __cdecl _strpbrk(char *_Str,char *_Control)

{
  byte bVar1;
  char *pcVar2;
  byte *pbVar3;
  undefined4 uStack40;
  undefined4 uStack36;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  
  uStack12 = 0;
  uStack16 = 0;
  uStack20 = 0;
  uStack24 = 0;
  uStack28 = 0;
  uStack32 = 0;
  uStack36 = 0;
  uStack40 = 0;
  for (; bVar1 = *_Control, bVar1 != 0; _Control = (char *)((byte *)_Control + 1)) {
    pbVar3 = (byte *)((int)&uStack40 + ((int)(uint)bVar1 >> 3));
    *pbVar3 = *pbVar3 | '\x01' << (bVar1 & 7);
  }
  do {
    pbVar3 = (byte *)_Str;
    pcVar2 = (char *)(uint)*pbVar3;
    if (*pbVar3 == 0) {
      return pcVar2;
    }
    _Str = (char *)(pbVar3 + 1);
  } while ((*(byte *)((int)&uStack40 + ((int)pcVar2 >> 3)) >> ((uint)pcVar2 & 7) & 1) == 0);
  return (char *)pbVar3;
}



void FUN_0067818d(undefined4 param_1,undefined4 param_2)

{
  FUN_006781a4(param_1,param_2,0);
  return;
}



byte * FUN_006781a4(byte *param_1,byte *param_2,undefined4 param_3)

{
  undefined4 *puVar1;
  byte *pbVar2;
  int local_14;
  int local_c;
  char local_8;
  
  if ((param_1 == (byte *)0x0) || (param_2 == (byte *)0x0)) {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 0x16;
    FUN_00675085();
  }
  else if (param_1 < param_2) {
    FUN_00674cdd(param_3);
    if (*(int *)(local_c + 8) != 0) {
      pbVar2 = param_2 + -1;
      do {
        pbVar2 = pbVar2 + -1;
        if (pbVar2 < param_1) break;
      } while ((*(byte *)(*pbVar2 + 0x19 + local_c) & 4) != 0);
      param_2 = param_2 + -((int)param_2 - (int)pbVar2 & 1U);
    }
    if (local_8 == '\0') {
      return param_2 + -1;
    }
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
    return param_2 + -1;
  }
  return (byte *)0x0;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067822a(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,int param_6,int param_7)

{
  uint _Size;
  int iVar1;
  uint uVar2;
  int *_Dst;
  int iStack68;
  int iStack64;
  undefined4 uStack60;
  undefined4 uStack56;
  undefined4 uStack52;
  undefined4 uStack48;
  int local_20;
  int local_1c;
  char local_14;
  
  uStack48 = param_1;
  uStack52 = 0x67824a;
  FUN_00674cdd();
  if (param_6 == 0) {
    param_6 = *(int *)(local_1c + 8);
  }
  uStack48 = 0;
  uStack52 = 0;
  uStack56 = param_4;
  uStack60 = param_3;
  iStack64 = (uint)(param_7 != 0) * 8 + 1;
  iStack68 = param_6;
  iVar1 = (*_DAT_1000c0fc)();
  if (iVar1 == 0) goto LAB_00678308;
  _Size = iVar1 * 2;
  uVar2 = -(uint)(_Size < _Size + 8) & _Size + 8;
  if (uVar2 == 0) {
    _Dst = (undefined4 *)0x0;
  }
  else if (uVar2 < 0x401) {
    _Dst = &iStack68;
    if (&stack0x00000000 != (undefined *)0x44) {
      iStack68 = 0xcccc;
      _Dst = &iStack68;
LAB_006782c1:
      _Dst = _Dst + 2;
    }
  }
  else {
    _Dst = (int *)__malloc_base(uVar2);
    if (_Dst != (undefined4 *)0x0) {
      *_Dst = 0xdddd;
      goto LAB_006782c1;
    }
  }
  if (_Dst != (undefined4 *)0x0) {
    _memset(_Dst,0,_Size);
    iVar1 = (*_DAT_1000c0fc)(param_6,1,param_3,param_4,_Dst,iVar1);
    if (iVar1 != 0) {
      (*_DAT_1000c048)(param_2,_Dst,iVar1,param_5);
    }
  }
  FUN_0067832e(_Dst);
LAB_00678308:
  if (local_14 != '\0') {
    *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;
  }
  ___security_check_cookie_4();
  return;
}



void FUN_0067832e(int param_1)

{
  if ((param_1 != 0) && (*(int *)(param_1 + -8) == 0xdddd)) {
    FID_conflict__free((int *)(param_1 + -8));
  }
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067834e(int *param_1,undefined4 param_2,uint param_3,undefined4 param_4,int param_5,
                 undefined4 param_6,int param_7,int param_8,int param_9)

{
  int iVar1;
  uint uVar2;
  int *piVar3;
  int iVar4;
  int *piVar5;
  int iStack48;
  int iStack44;
  undefined4 uStack40;
  int iStack36;
  undefined4 uStack32;
  int iStack28;
  
  iVar4 = param_5;
  if (0 < param_5) {
    iStack28 = param_5;
    uStack32 = param_4;
    iStack36 = 0x678372;
    iVar1 = ___strncnt();
    iVar4 = iVar1 + 1;
    if (param_5 <= iVar1) {
      iVar4 = iVar1;
    }
  }
  if (param_8 == 0) {
    param_8 = *(int *)(*param_1 + 8);
  }
  iStack28 = 0;
  uStack32 = 0;
  uStack40 = param_4;
  iStack44 = (uint)(param_9 != 0) * 8 + 1;
  iStack48 = param_8;
  iStack36 = iVar4;
  iVar1 = (*_DAT_1000c0fc)();
  if (iVar1 == 0) goto LAB_0067850f;
  uVar2 = iVar1 * 2 + 8;
  uVar2 = -(uint)((uint)(iVar1 * 2) < uVar2) & uVar2;
  if (uVar2 == 0) {
    piVar3 = (undefined4 *)0x0;
  }
  else if (uVar2 < 0x401) {
    piVar3 = &iStack48;
    if (&stack0x00000000 != (undefined *)0x30) {
      iStack48 = 0xcccc;
      piVar3 = &iStack48;
LAB_006783f6:
      piVar3 = piVar3 + 2;
    }
  }
  else {
    piVar3 = (int *)__malloc_base(uVar2);
    if (piVar3 != (undefined4 *)0x0) {
      *piVar3 = 0xdddd;
      goto LAB_006783f6;
    }
  }
  if (((piVar3 != (undefined4 *)0x0) &&
      (iVar4 = (*_DAT_1000c0fc)(param_8,1,param_4,iVar4,piVar3,iVar1), iVar4 != 0)) &&
     (iVar4 = ___acrt_CompareStringEx_36(param_2,param_3,piVar3,iVar1,0,0,0,0,0), iVar4 != 0)) {
    if ((param_3 & 0x400) == 0) {
      uVar2 = iVar4 * 2 + 8;
      uVar2 = -(uint)((uint)(iVar4 * 2) < uVar2) & uVar2;
      if (uVar2 == 0) {
        piVar5 = (undefined4 *)0x0;
LAB_006784c1:
        if ((piVar5 != (undefined4 *)0x0) &&
           (iVar1 = ___acrt_CompareStringEx_36(param_2,param_3,piVar3,iVar1,piVar5,iVar4,0,0,0),
           iVar1 != 0)) {
          if (param_7 == 0) {
            param_7 = 0;
            param_6 = 0;
          }
          iVar4 = (*_DAT_1000c100)(param_8,0,piVar5,iVar4,param_6,param_7,0,0);
          if (iVar4 != 0) {
            FUN_0067832e(piVar5);
            goto LAB_00678506;
          }
        }
      }
      else if (uVar2 < 0x401) {
        piVar5 = &iStack48;
        if (&stack0x00000000 != (undefined *)0x30) {
          iStack48 = 0xcccc;
          piVar5 = &iStack48;
LAB_006784ba:
          piVar5 = piVar5 + 2;
          goto LAB_006784c1;
        }
      }
      else {
        piVar5 = (int *)__malloc_base(uVar2);
        if (piVar5 != (undefined4 *)0x0) {
          *piVar5 = 0xdddd;
          goto LAB_006784ba;
        }
      }
      FUN_0067832e(piVar5);
    }
    else if ((param_7 != 0) && (iVar4 <= param_7)) {
      ___acrt_CompareStringEx_36(param_2,param_3,piVar3,iVar1,param_6,param_7,0,0,0);
    }
  }
LAB_00678506:
  FUN_0067832e(piVar3);
LAB_0067850f:
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_LCMapStringA
// 
// Library: Visual Studio 2015 Release

void ___acrt_LCMapStringA
               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
               undefined4 param_9)

{
  int local_14;
  undefined local_10 [8];
  char local_8;
  
  FUN_00674cdd(param_1);
  FUN_0067834e(local_10,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return;
}



void FUN_0067857f(void)

{
  __msize_base();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __msize_base
// 
// Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 __msize_base(int param_1)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  
  if (param_1 == 0) {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 0x16;
    FUN_00675085();
    return 0xffffffff;
  }
  uVar2 = (*_DAT_1000c044)(_DAT_10012f90,0,param_1);
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __realloc_base
// 
// Library: Visual Studio 2015 Release

int __realloc_base(void *param_1,uint param_2)

{
  int iVar1;
  undefined4 *puVar2;
  
  if (param_1 == (void *)0x0) {
    iVar1 = __malloc_base(param_2);
  }
  else {
    if (param_2 == 0) {
      FID_conflict__free(param_1);
    }
    else {
      if (param_2 < 0xffffffe1) {
        do {
          iVar1 = (*_DAT_1000c078)(_DAT_10012f90,0,param_1,param_2);
          if (iVar1 != 0) {
            return iVar1;
          }
          iVar1 = FUN_0067753c();
        } while ((iVar1 != 0) && (iVar1 = __callnewh(param_2), iVar1 != 0));
      }
      puVar2 = (undefined4 *)FUN_00675142();
      *puVar2 = 0xc;
    }
    iVar1 = 0;
  }
  return iVar1;
}



// Library Function - Single Match
//  ___acrt_lowio_create_handle_array
// 
// Library: Visual Studio 2015 Release

undefined4 * ___acrt_lowio_create_handle_array(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  
  puVar2 = (undefined4 *)__calloc_base(0x40,0x30);
  if (puVar2 == (undefined4 *)0x0) {
    puVar2 = (undefined4 *)0x0;
  }
  else if (puVar2 != puVar2 + 0x300) {
    puVar3 = puVar2 + 8;
    do {
      ___acrt_InitializeCriticalSectionEx_12(puVar3 + -8,4000,0);
      puVar3[-2] = 0xffffffff;
      *puVar3 = 0;
      puVar3[1] = 0;
      puVar1 = puVar3 + 4;
      puVar3[2] = 0xa0a0000;
      *(undefined *)(puVar3 + 3) = 10;
      *(byte *)((int)puVar3 + 0xd) = *(byte *)((int)puVar3 + 0xd) & 0xf8;
      *(undefined *)((int)puVar3 + 0xe) = 0;
      puVar3 = puVar3 + 0xc;
    } while (puVar1 != puVar2 + 0x300);
  }
  FID_conflict__free((void *)0x0);
  return puVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lowio_destroy_handle_array
// 
// Library: Visual Studio 2015 Release

void ___acrt_lowio_destroy_handle_array(void *param_1)

{
  void *pvVar1;
  
  if (param_1 != (void *)0x0) {
    pvVar1 = param_1;
    if (param_1 != (void *)((int)param_1 + 0xc00)) {
      do {
        (*_DAT_1000c0d0)(pvVar1);
        pvVar1 = (void *)((int)pvVar1 + 0x30);
      } while (pvVar1 != (void *)((int)param_1 + 0xc00));
    }
    FID_conflict__free(param_1);
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lowio_ensure_fh_exists
// 
// Library: Visual Studio 2017 Release

undefined4 ___acrt_lowio_ensure_fh_exists(uint param_1)

{
  undefined4 *puVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  
  if (param_1 < 0x2000) {
    uVar3 = 0;
    ___acrt_lock(7);
    iVar4 = 0;
    iVar2 = _DAT_10013198;
    while (iVar2 <= (int)param_1) {
      if (*(int *)(&DAT_10012f98 + iVar4 * 4) == 0) {
        iVar2 = ___acrt_lowio_create_handle_array();
        *(int *)(&DAT_10012f98 + iVar4 * 4) = iVar2;
        if (iVar2 == 0) {
          uVar3 = 0xc;
          break;
        }
        iVar2 = _DAT_10013198 + 0x40;
        _DAT_10013198 = iVar2;
      }
      iVar4 = iVar4 + 1;
    }
    FUN_00678760();
  }
  else {
    puVar1 = (undefined4 *)FUN_00675142();
    uVar3 = 9;
    *puVar1 = 9;
    FUN_00675085();
  }
  return uVar3;
}



void FUN_00678760(void)

{
  ___acrt_unlock(7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lowio_lock_fh
// 
// Library: Visual Studio 2017 Release

void ___acrt_lowio_lock_fh(uint param_1)

{
  (*_DAT_1000c0c8)((param_1 & 0x3f) * 0x30 + *(int *)(&DAT_10012f98 + ((int)param_1 >> 6) * 4));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_lowio_unlock_fh
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_lowio_unlock_fh(uint param_1)

{
  (*_DAT_1000c0cc)((param_1 & 0x3f) * 0x30 + *(int *)(&DAT_10012f98 + ((int)param_1 >> 6) * 4));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __free_osfhnd
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __free_osfhnd(int param_1)

{
  int iVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 uVar4;
  
  if ((-1 < param_1) && ((uint)param_1 < _DAT_10013198)) {
    iVar3 = (param_1 & 0x3fU) * 0x30;
    if (((*(byte *)(iVar3 + 0x28 + *(int *)(&DAT_10012f98 + (param_1 >> 6) * 4)) & 1) != 0) &&
       (*(int *)(iVar3 + 0x18 + *(int *)(&DAT_10012f98 + (param_1 >> 6) * 4)) != -1)) {
      iVar1 = FUN_00679687();
      if (iVar1 == 1) {
        if (param_1 == 0) {
          uVar4 = 0xfffffff6;
        }
        else if (param_1 == 1) {
          uVar4 = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_00678815;
          uVar4 = 0xfffffff4;
        }
        (*_DAT_1000c03c)(uVar4,0);
      }
LAB_00678815:
      *(undefined4 *)(iVar3 + 0x18 + *(int *)(&DAT_10012f98 + (param_1 >> 6) * 4)) = 0xffffffff;
      return 0;
    }
  }
  puVar2 = (undefined4 *)FUN_00675142();
  *puVar2 = 9;
  puVar2 = (undefined4 *)FUN_0067512f();
  *puVar2 = 0;
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __get_osfhandle
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

intptr_t __cdecl __get_osfhandle(int _FileHandle)

{
  undefined4 *puVar1;
  int iVar2;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_0067512f();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) {
      iVar2 = (_FileHandle & 0x3fU) * 0x30;
      if ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 + iVar2) & 1) != 0) {
        return *(intptr_t *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x18 + iVar2);
      }
    }
    puVar1 = (undefined4 *)FUN_0067512f();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
    FUN_00675085();
  }
  return -1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_9e9de3de5fa147e2223d7db92bc10aa6>,class <lambda_38ce7e780aa69e748d6df282ebc68efe>&,class
// <lambda_8ca6da459f0f6780f1cff60fdc3d00e5>>(class
// <lambda_9e9de3de5fa147e2223d7db92bc10aa6>&&,class
// <lambda_38ce7e780aa69e748d6df282ebc68efe>&,class <lambda_8ca6da459f0f6780f1cff60fdc3d00e5>&&)
// 
// Library: Visual Studio 2017 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_9e9de3de5fa147e2223d7db92bc10aa6__class__lambda_38ce7e780aa69e748d6df282ebc68efe___class__lambda_8ca6da459f0f6780f1cff60fdc3d00e5___
          (__crt_seh_guarded_call_int_ *this,_lambda_9e9de3de5fa147e2223d7db92bc10aa6_ *param_1,
          _lambda_38ce7e780aa69e748d6df282ebc68efe_ *param_2,
          _lambda_8ca6da459f0f6780f1cff60fdc3d00e5_ *param_3)

{
  uint _FileHandle;
  intptr_t iVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  int iVar5;
  
  iVar5 = 0;
  ___acrt_lowio_lock_fh(*(undefined4 *)param_1);
  _FileHandle = **(uint **)param_2;
  if ((*(byte *)(*(int *)(&DAT_10012f98 + ((int)_FileHandle >> 6) * 4) + 0x28 +
                (_FileHandle & 0x3f) * 0x30) & 1) != 0) {
    iVar1 = __get_osfhandle(_FileHandle);
    iVar2 = (*_DAT_1000c038)(iVar1);
    if (iVar2 != 0) goto LAB_0067891a;
    puVar3 = (undefined4 *)FUN_0067512f();
    uVar4 = (*_DAT_1000c0c0)();
    *puVar3 = uVar4;
  }
  puVar3 = (undefined4 *)FUN_00675142();
  *puVar3 = 9;
  iVar5 = -1;
LAB_0067891a:
  FUN_00678936();
  return iVar5;
}



void FUN_00678936(void)

{
  int unaff_EBP;
  
  ___acrt_lowio_unlock_fh(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __commit
// 
// Library: Visual Studio 2017 Release

int __cdecl __commit(int _FileHandle)

{
  undefined4 *puVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
  }
  else {
    if (((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) &&
       ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 +
                  (_FileHandle & 0x3fU) * 0x30) & 1) != 0)) {
      local_10 = &_FileHandle;
      local_c = _FileHandle;
      local_14 = _FileHandle;
      iVar2 = __crt_seh_guarded_call<int>::
              operator___class__lambda_9e9de3de5fa147e2223d7db92bc10aa6__class__lambda_38ce7e780aa69e748d6df282ebc68efe___class__lambda_8ca6da459f0f6780f1cff60fdc3d00e5___
                        (&local_5,(_lambda_9e9de3de5fa147e2223d7db92bc10aa6_ *)&local_14,
                         (_lambda_38ce7e780aa69e748d6df282ebc68efe_ *)&local_10,
                         (_lambda_8ca6da459f0f6780f1cff60fdc3d00e5_ *)&local_c);
      return iVar2;
    }
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
    FUN_00675085();
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_006789c1(undefined4 *param_1,uint param_2,byte *param_3,int param_4)

{
  byte bVar1;
  byte *pbVar2;
  undefined4 uVar3;
  ushort *puVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  int iVar8;
  int iVar9;
  byte *pbVar10;
  byte *pbVar11;
  undefined4 uVar12;
  uint local_28;
  byte *local_24;
  undefined2 local_20;
  undefined2 local_1c [2];
  undefined local_18 [8];
  byte local_10;
  undefined local_f;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  iVar8 = (int)param_2 >> 6;
  iVar9 = (param_2 & 0x3f) * 0x30;
  uVar7 = *(undefined4 *)(*(int *)(&DAT_10012f98 + iVar8 * 4) + 0x18 + iVar9);
  pbVar2 = param_3 + param_4;
  uVar3 = (*_DAT_1000c034)();
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  if (param_3 < pbVar2) {
    local_24 = param_3 + 1;
    pbVar10 = param_3;
    do {
      local_1c[0] = 0;
      local_20 = local_20 & 0xff | (ushort)*pbVar10 << 8;
      iVar5 = *(int *)(&DAT_10012f98 + iVar8 * 4);
      bVar1 = *(byte *)(iVar5 + 0x2d + iVar9);
      if ((bVar1 & 4) == 0) {
        puVar4 = ___pctype_func();
        if (-1 < (short)puVar4[*pbVar10]) {
          uVar12 = 1;
          pbVar11 = pbVar10;
          goto LAB_00678a9d;
        }
        if (pbVar2 <= local_24) {
          *(byte *)(*(int *)(&DAT_10012f98 + iVar8 * 4) + 0x2e + iVar9) = *pbVar10;
          pbVar2 = (byte *)(*(int *)(&DAT_10012f98 + iVar8 * 4) + 0x2d + iVar9);
          *pbVar2 = *pbVar2 | 4;
          param_1[1] = param_1[1] + 1;
          break;
        }
        iVar5 = FUN_00677640(local_1c,pbVar10,2);
        if (iVar5 == -1) break;
        pbVar10 = pbVar10 + 1;
        local_24 = local_24 + 1;
      }
      else {
        local_10 = *(byte *)(iVar5 + 0x2e + iVar9);
        uVar6 = CONCAT11(*pbVar10,bVar1) & 0xfffffffb;
        uVar12 = 2;
        local_f = (undefined)(uVar6 >> 8);
        *(char *)(iVar5 + 0x2d + iVar9) = (char)uVar6;
        pbVar11 = &local_10;
LAB_00678a9d:
        iVar5 = FUN_00677640(local_1c,pbVar11,uVar12);
        if (iVar5 == -1) break;
      }
      pbVar10 = pbVar10 + 1;
      local_24 = local_24 + 1;
      uVar6 = (*_DAT_1000c100)(uVar3,0,local_1c,1,local_18,5,0,0);
      if (uVar6 == 0) break;
      iVar5 = (*_DAT_1000c064)(uVar7,local_18,uVar6,&local_28,0);
      if (iVar5 == 0) {
LAB_00678b6a:
        uVar7 = (*_DAT_1000c0c0)();
        *param_1 = uVar7;
        break;
      }
      param_1[1] = pbVar10 + (param_1[2] - (int)param_3);
      if (local_28 < uVar6) break;
      if (local_20._1_1_ == '\n') {
        local_20 = 0xd;
        iVar5 = (*_DAT_1000c064)(uVar7,&local_20,1,&local_28,0);
        if (iVar5 == 0) goto LAB_00678b6a;
        if (local_28 == 0) break;
        param_1[2] = param_1[2] + 1;
        param_1[1] = param_1[1] + 1;
      }
    } while (pbVar10 < pbVar2);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  struct `anonymous namespace'::write_result __cdecl write_double_translated_unicode_nolock(char
// const * const,unsigned int)
//  struct `anonymous namespace'::write_result __cdecl write_double_translated_unicode_nolock(char
// const * const,unsigned int)
// 
// Library: Visual Studio 2015 Release

undefined4 * write_double_translated_unicode_nolock(undefined4 *param_1,short *param_2,int param_3)

{
  short sVar1;
  short sVar2;
  short *psVar3;
  undefined4 uVar4;
  
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  psVar3 = (short *)(param_3 + (int)param_2);
  if (param_2 < psVar3) {
    do {
      sVar2 = *param_2;
      sVar1 = FUN_00679726(sVar2);
      if (sVar1 != sVar2) {
LAB_00678be1:
        uVar4 = (*_DAT_1000c0c0)();
        *param_1 = uVar4;
        return param_1;
      }
      param_1[1] = param_1[1] + 2;
      if (sVar2 == 10) {
        sVar2 = FUN_00679726(0xd);
        if (sVar2 != 0xd) goto LAB_00678be1;
        param_1[1] = param_1[1] + 1;
        param_1[2] = param_1[2] + 1;
      }
      param_2 = param_2 + 1;
    } while (param_2 < psVar3);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_00678bf2(uint param_1)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  undefined local_8 [4];
  
  iVar1 = __isatty(param_1);
  if (iVar1 == 0) {
    uVar3 = 0;
  }
  else {
    iVar4 = (int)param_1 >> 6;
    iVar1 = (param_1 & 0x3f) * 0x30;
    uVar3 = *(uint *)(&DAT_10012f98 + iVar4 * 4);
    if ((*(char *)(uVar3 + 0x28 + iVar1) < '\0') &&
       ((iVar2 = FUN_006759b1(), *(int *)(*(int *)(iVar2 + 0x4c) + 0xa8) != 0 ||
        (uVar3 = *(uint *)(&DAT_10012f98 + iVar4 * 4), *(char *)(uVar3 + 0x29 + iVar1) != '\0')))) {
      uVar3 = (*_DAT_1000c030)(*(undefined4 *)(*(int *)(&DAT_10012f98 + iVar4 * 4) + 0x18 + iVar1),
                               local_8);
      uVar3 = uVar3 & 0xffffff00 | (uint)(uVar3 != 0);
    }
    else {
      uVar3 = uVar3 & 0xffffff00;
    }
  }
  return uVar3;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  struct `anonymous namespace'::write_result __cdecl write_text_ansi_nolock(int,char const *
// const,unsigned int)
//  struct `anonymous namespace'::write_result __cdecl write_text_ansi_nolock(int,char const *
// const,unsigned int)
// 
// Library: Visual Studio 2015 Release

void write_text_ansi_nolock(undefined4 *param_1,uint param_2,char *param_3,int param_4)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  char *pcVar4;
  uint local_1410;
  char *local_140c;
  char local_1408 [5120];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar3 = *(undefined4 *)
           (*(int *)(&DAT_10012f98 + ((int)param_2 >> 6) * 4) + 0x18 + (param_2 & 0x3f) * 0x30);
  *param_1 = 0;
  local_140c = param_3 + param_4;
  param_1[1] = 0;
  param_1[2] = 0;
  do {
    if (local_140c <= param_3) break;
    pcVar4 = local_1408;
    do {
      if (local_140c <= param_3) break;
      cVar1 = *param_3;
      param_3 = param_3 + 1;
      if (cVar1 == '\n') {
        param_1[2] = param_1[2] + 1;
        *pcVar4 = '\r';
        pcVar4 = pcVar4 + 1;
      }
      *pcVar4 = cVar1;
      pcVar4 = pcVar4 + 1;
    } while (pcVar4 < local_1408 + 0x13ff);
    iVar2 = (*_DAT_1000c064)(uVar3,local_1408,(int)pcVar4 - (int)local_1408,&local_1410,0);
    if (iVar2 == 0) {
      uVar3 = (*_DAT_1000c0c0)();
      *param_1 = uVar3;
      break;
    }
    param_1[1] = param_1[1] + local_1410;
  } while ((uint)((int)pcVar4 - (int)local_1408) <= local_1410);
  ___security_check_cookie_4();
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00678d47(undefined4 *param_1,uint param_2,short *param_3,int param_4)

{
  short sVar1;
  int iVar2;
  undefined4 uVar3;
  short *psVar4;
  uint local_1410;
  short *local_140c;
  short local_1408 [2560];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  uVar3 = *(undefined4 *)
           (*(int *)(&DAT_10012f98 + ((int)param_2 >> 6) * 4) + 0x18 + (param_2 & 0x3f) * 0x30);
  local_140c = (short *)(param_4 + (int)param_3);
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  do {
    if (local_140c <= param_3) break;
    psVar4 = local_1408;
    do {
      if (local_140c <= param_3) break;
      sVar1 = *param_3;
      param_3 = param_3 + 1;
      if (sVar1 == 10) {
        param_1[2] = param_1[2] + 2;
        *psVar4 = 0xd;
        psVar4 = psVar4 + 1;
      }
      *psVar4 = sVar1;
      psVar4 = psVar4 + 1;
    } while (psVar4 < local_1408 + 0x9ff);
    iVar2 = (*_DAT_1000c064)(uVar3,local_1408,(int)psVar4 - (int)local_1408,&local_1410,0);
    if (iVar2 == 0) {
      uVar3 = (*_DAT_1000c0c0)();
      *param_1 = uVar3;
      break;
    }
    param_1[1] = param_1[1] + local_1410;
  } while ((uint)((int)psVar4 - (int)local_1408) <= local_1410);
  ___security_check_cookie_4();
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Same Base Name
//  struct `anonymous namespace'::write_result __cdecl write_text_utf8_nolock(int,char const *
// const,unsigned int)
//  struct `anonymous namespace'::write_result __cdecl write_text_utf8_nolock(int,char const *
// const,unsigned int)
// 
// Library: Visual Studio 2015 Release

void write_text_utf8_nolock(undefined4 *param_1,uint param_2,short *param_3,int param_4)

{
  short sVar1;
  short *psVar2;
  uint uVar3;
  int iVar4;
  undefined4 uVar5;
  uint uVar6;
  short *psVar7;
  int local_1418;
  undefined4 local_1414;
  short *local_1410;
  undefined local_140c [3416];
  short local_6b4 [854];
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_1414 = *(undefined4 *)
                (*(int *)(&DAT_10012f98 + ((int)param_2 >> 6) * 4) + 0x18 + (param_2 & 0x3f) * 0x30)
  ;
  local_1410 = (short *)(param_4 + (int)param_3);
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  psVar7 = param_3;
  if (param_3 < local_1410) {
    do {
      uVar6 = 0;
      psVar2 = local_6b4;
      do {
        if (local_1410 <= psVar7) break;
        sVar1 = *psVar7;
        psVar7 = psVar7 + 1;
        if (sVar1 == 10) {
          *psVar2 = 0xd;
          psVar2 = psVar2 + 1;
        }
        *psVar2 = sVar1;
        psVar2 = psVar2 + 1;
      } while (psVar2 < local_6b4 + 0x354);
      uVar3 = (*_DAT_1000c100)(0xfde9,0,local_6b4,(int)psVar2 - (int)local_6b4 >> 1,local_140c,0xd55
                               ,0,0);
      if (uVar3 == 0) {
LAB_00678f47:
        uVar5 = (*_DAT_1000c0c0)();
        *param_1 = uVar5;
        break;
      }
      do {
        iVar4 = (*_DAT_1000c064)(local_1414,local_140c + uVar6,uVar3 - uVar6,&local_1418,0);
        if (iVar4 == 0) goto LAB_00678f47;
        uVar6 = uVar6 + local_1418;
      } while (uVar6 < uVar3);
      param_1[1] = (int)psVar7 - (int)param_3;
    } while (psVar7 < local_1410);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __write
// 
// Library: Visual Studio 2017 Release

int __cdecl __write(int _FileHandle,void *_Buf,uint _MaxCharCount)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_0067512f();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) {
      iVar2 = (_FileHandle & 0x3fU) * 0x30;
      if ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 + iVar2) & 1) != 0) {
        ___acrt_lowio_lock_fh(_FileHandle);
        iVar3 = -1;
        if ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 + iVar2) & 1) == 0) {
          puVar1 = (undefined4 *)FUN_00675142();
          *puVar1 = 9;
          puVar1 = (undefined4 *)FUN_0067512f();
          *puVar1 = 0;
        }
        else {
          iVar3 = FUN_0067904a(_FileHandle,_Buf,_MaxCharCount);
        }
        FUN_00679021();
        return iVar3;
      }
    }
    puVar1 = (undefined4 *)FUN_0067512f();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
    FUN_00675085();
  }
  return -1;
}



void FUN_00679021(void)

{
  ___acrt_lowio_unlock_fh();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067904a(uint param_1,char *param_2,uint param_3)

{
  char cVar1;
  char *pcVar2;
  char cVar3;
  undefined4 *puVar4;
  int *piVar5;
  int iVar6;
  int local_30;
  undefined4 local_2c;
  undefined4 uStack40;
  int local_24;
  int local_20;
  int local_1c;
  uint local_18;
  int local_14;
  int local_10;
  char *local_c;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  local_c = param_2;
  local_18 = param_3;
  if (param_3 == 0) goto LAB_0067924d;
  if (param_2 == (char *)0x0) {
    puVar4 = (undefined4 *)FUN_0067512f();
    *puVar4 = 0;
    puVar4 = (undefined4 *)FUN_00675142();
    *puVar4 = 0x16;
    FUN_00675085();
    goto LAB_0067924d;
  }
  local_10 = (int)param_1 >> 6;
  local_14 = (param_1 & 0x3f) * 0x30;
  cVar1 = *(char *)(*(int *)(&DAT_10012f98 + local_10 * 4) + 0x29 + local_14);
  if (((cVar1 == '\x02') || (cVar1 == '\x01')) && ((~param_3 & 1) == 0)) {
    puVar4 = (undefined4 *)FUN_0067512f();
    *puVar4 = 0;
    puVar4 = (undefined4 *)FUN_00675142();
    *puVar4 = 0x16;
    FUN_00675085();
    goto LAB_0067924d;
  }
  if ((*(byte *)(*(int *)(&DAT_10012f98 + local_10 * 4) + 0x28 + local_14) & 0x20) != 0) {
    __lseeki64_nolock(param_1,0,2);
  }
  local_24 = 0;
  local_20 = 0;
  local_1c = 0;
  cVar3 = FUN_00678bf2(param_1);
  pcVar2 = local_c;
  if (cVar3 == '\0') {
    if (*(char *)(*(int *)(&DAT_10012f98 + local_10 * 4) + 0x28 + local_14) < '\0') {
      if (cVar1 == '\0') {
        piVar5 = (int *)write_text_ansi_nolock(&local_30,param_1,local_c,local_18);
      }
      else if (cVar1 == '\x01') {
        piVar5 = (int *)write_text_utf8_nolock(&local_30,param_1,local_c,local_18);
      }
      else {
        if (cVar1 != '\x02') goto LAB_006791e7;
        piVar5 = (int *)FUN_00678d47(&local_30,param_1,local_c,local_18);
      }
    }
    else {
      local_30 = 0;
      local_2c = 0;
      uStack40 = 0;
      iVar6 = (*_DAT_1000c064)(*(undefined4 *)
                                (*(int *)(&DAT_10012f98 + local_10 * 4) + 0x18 + local_14),local_c,
                               local_18,&local_2c,0);
      if (iVar6 == 0) {
        local_30 = (*_DAT_1000c0c0)();
      }
      piVar5 = &local_30;
    }
LAB_006791db:
    local_24 = *piVar5;
    local_20 = piVar5[1];
    local_1c = piVar5[2];
  }
  else {
    if (cVar1 == '\0') {
      piVar5 = (int *)FUN_006789c1(&local_30,param_1,local_c,local_18);
      goto LAB_006791db;
    }
    if ((byte)(cVar1 - 1U) < 2) {
      piVar5 = (int *)write_double_translated_unicode_nolock(&local_30,local_c,local_18);
      goto LAB_006791db;
    }
  }
LAB_006791e7:
  if (local_20 == 0) {
    if (local_24 == 0) {
      if (((*(byte *)(*(int *)(&DAT_10012f98 + local_10 * 4) + 0x28 + local_14) & 0x40) == 0) ||
         (*pcVar2 != '\x1a')) {
        puVar4 = (undefined4 *)FUN_00675142();
        *puVar4 = 0x1c;
        puVar4 = (undefined4 *)FUN_0067512f();
        *puVar4 = 0;
      }
    }
    else if (local_24 == 5) {
      puVar4 = (undefined4 *)FUN_00675142();
      *puVar4 = 9;
      puVar4 = (undefined4 *)FUN_0067512f();
      *puVar4 = 5;
    }
    else {
      ___acrt_errno_map_os_error(local_24);
    }
  }
LAB_0067924d:
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  ___acrt_stdio_free_buffer_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_stdio_free_buffer_nolock(undefined4 *param_1)

{
  uint *puVar1;
  
  puVar1 = param_1 + 3;
  if (((*puVar1 >> 0xd & 1) != 0) && ((*puVar1 >> 6 & 1) != 0)) {
    FID_conflict__free((void *)param_1[1]);
    LOCK();
    *puVar1 = *puVar1 & 0xfffffebf;
    param_1[1] = 0;
    *param_1 = 0;
    param_1[2] = 0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __isatty
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __isatty(int _FileHandle)

{
  undefined4 *puVar1;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) {
      return *(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 +
                      (_FileHandle & 0x3fU) * 0x30) & 0x40;
    }
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
    FUN_00675085();
  }
  return 0;
}



// Library Function - Single Match
//  __isleadbyte_l
// 
// Library: Visual Studio 2015 Release

int __cdecl __isleadbyte_l(int _C,_locale_t _Locale)

{
  ushort uVar1;
  int local_14;
  int *local_10;
  char local_8;
  
  FUN_00674cdd(_Locale);
  uVar1 = *(ushort *)(*local_10 + (_C & 0xffU) * 2);
  if (local_8 != '\0') {
    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;
  }
  return uVar1 & 0x8000;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_006793c9(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,undefined4 param_6)

{
  (*_DAT_1000c0fc)(param_1,param_2,param_3,param_4,param_5,param_6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_locale_free_monetary
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_locale_free_monetary(int param_1)

{
  if (param_1 != 0) {
    if (*(void **)(param_1 + 0xc) != _DAT_100126fc) {
      FID_conflict__free(*(void **)(param_1 + 0xc));
    }
    if (*(void **)(param_1 + 0x10) != _DAT_10012700) {
      FID_conflict__free(*(void **)(param_1 + 0x10));
    }
    if (*(void **)(param_1 + 0x14) != _DAT_10012704) {
      FID_conflict__free(*(void **)(param_1 + 0x14));
    }
    if (*(void **)(param_1 + 0x18) != _DAT_10012708) {
      FID_conflict__free(*(void **)(param_1 + 0x18));
    }
    if (*(void **)(param_1 + 0x1c) != _DAT_1001270c) {
      FID_conflict__free(*(void **)(param_1 + 0x1c));
    }
    if (*(void **)(param_1 + 0x20) != _DAT_10012710) {
      FID_conflict__free(*(void **)(param_1 + 0x20));
    }
    if (*(void **)(param_1 + 0x24) != _DAT_10012714) {
      FID_conflict__free(*(void **)(param_1 + 0x24));
    }
    if (*(void **)(param_1 + 0x38) != _DAT_10012728) {
      FID_conflict__free(*(void **)(param_1 + 0x38));
    }
    if (*(void **)(param_1 + 0x3c) != _DAT_1001272c) {
      FID_conflict__free(*(void **)(param_1 + 0x3c));
    }
    if (*(void **)(param_1 + 0x40) != _DAT_10012730) {
      FID_conflict__free(*(void **)(param_1 + 0x40));
    }
    if (*(void **)(param_1 + 0x44) != _DAT_10012734) {
      FID_conflict__free(*(void **)(param_1 + 0x44));
    }
    if (*(void **)(param_1 + 0x48) != _DAT_10012738) {
      FID_conflict__free(*(void **)(param_1 + 0x48));
    }
    if (*(void **)(param_1 + 0x4c) != _DAT_1001273c) {
      FID_conflict__free(*(void **)(param_1 + 0x4c));
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___acrt_locale_free_numeric
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

void ___acrt_locale_free_numeric(void **param_1)

{
  if (param_1 != (void **)0x0) {
    if (*param_1 != _DAT_100126f0) {
      FID_conflict__free(*param_1);
    }
    if (param_1[1] != _DAT_100126f4) {
      FID_conflict__free(param_1[1]);
    }
    if (param_1[2] != _DAT_100126f8) {
      FID_conflict__free(param_1[2]);
    }
    if (param_1[0xc] != _DAT_10012720) {
      FID_conflict__free(param_1[0xc]);
    }
    if (param_1[0xd] != _DAT_10012724) {
      FID_conflict__free(param_1[0xd]);
    }
  }
  return;
}



void FUN_0067954f(void **param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  
  uVar2 = 0;
  uVar1 = ~-(uint)(param_1 + param_2 < param_1) & param_2 & 0x3fffffff;
  if (uVar1 != 0) {
    do {
      FID_conflict__free(*param_1);
      uVar2 = uVar2 + 1;
      param_1 = param_1 + 1;
    } while (uVar2 != uVar1);
  }
  return;
}



// Library Function - Single Match
//  ___acrt_locale_free_time
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___acrt_locale_free_time(int param_1)

{
  if (param_1 != 0) {
    FUN_0067954f(param_1,7);
    FUN_0067954f(param_1 + 0x1c,7);
    FUN_0067954f(param_1 + 0x38,0xc);
    FUN_0067954f(param_1 + 0x68,0xc);
    FUN_0067954f(param_1 + 0x98,2);
    FID_conflict__free(*(void **)(param_1 + 0xa0));
    FID_conflict__free(*(void **)(param_1 + 0xa4));
    FID_conflict__free(*(void **)(param_1 + 0xa8));
    FUN_0067954f(param_1 + 0xb4,7);
    FUN_0067954f(param_1 + 0xd0,7);
    FUN_0067954f(param_1 + 0xec,0xc);
    FUN_0067954f(param_1 + 0x11c,0xc);
    FUN_0067954f(param_1 + 0x14c,2);
    FID_conflict__free(*(void **)(param_1 + 0x154));
    FID_conflict__free(*(void **)(param_1 + 0x158));
    FID_conflict__free(*(void **)(param_1 + 0x15c));
    FID_conflict__free(*(void **)(param_1 + 0x160));
  }
  return;
}



// Library Function - Single Match
//  ___strncnt
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void ___strncnt(char *param_1,int param_2)

{
  char cVar1;
  int iVar2;
  
  iVar2 = 0;
  cVar1 = *param_1;
  while ((cVar1 != '\0' && (iVar2 != param_2))) {
    iVar2 = iVar2 + 1;
    cVar1 = param_1[iVar2];
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00679687(void)

{
  return _DAT_100131d4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __int64 __cdecl common_lseek_nolock<__int64>(int,__int64,int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

__int64 __cdecl common_lseek_nolock___int64_(int param_1,__int64 param_2,int param_3)

{
  byte *pbVar1;
  intptr_t iVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined4 uVar5;
  uint local_c;
  uint local_8;
  
  iVar2 = __get_osfhandle(param_1);
  if (iVar2 == -1) {
    puVar3 = (undefined4 *)FUN_00675142();
    *puVar3 = 9;
  }
  else {
    iVar4 = (*_DAT_1000c040)(iVar2,param_2,&local_c,param_3);
    if (iVar4 == 0) {
      uVar5 = (*_DAT_1000c0c0)();
      ___acrt_errno_map_os_error(uVar5);
    }
    else if ((local_c & local_8) != 0xffffffff) {
      pbVar1 = (byte *)(*(int *)(&DAT_10012f98 + (param_1 >> 6) * 4) + 0x28 +
                       (param_1 & 0x3fU) * 0x30);
      *pbVar1 = *pbVar1 & 0xfd;
      goto LAB_00679705;
    }
  }
  local_c = 0xffffffff;
  local_8 = 0xffffffff;
LAB_00679705:
  return CONCAT44(local_8,local_c);
}



// Library Function - Single Match
//  __lseeki64_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

longlong __cdecl __lseeki64_nolock(int _FileHandle,longlong _Offset,int _Origin)

{
  __int64 _Var1;
  
  _Var1 = common_lseek_nolock___int64_(_FileHandle,_Offset,_Origin);
  return _Var1;
}



uint FUN_00679726(ushort param_1)

{
  int iVar1;
  uint uVar2;
  undefined local_8 [4];
  
  iVar1 = FUN_00679afd();
  if ((iVar1 != 0) && (uVar2 = FID_conflict____dcrt_read_console(&param_1,1,local_8), uVar2 != 0)) {
    return uVar2 & 0xffff0000 | (uint)param_1;
  }
  return 0xffff;
}



// Library Function - Single Match
//  __fclose_nolock
// 
// Library: Visual Studio 2017 Release

int __cdecl __fclose_nolock(FILE *_File)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  
  if (_File == (FILE *)0x0) {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 0x16;
    FUN_00675085();
    iVar2 = -1;
  }
  else {
    iVar2 = -1;
    if (((uint)_File->_flag >> 0xd & 1) != 0) {
      iVar2 = ___acrt_stdio_flush_nolock(_File);
      ___acrt_stdio_free_buffer_nolock(_File);
      iVar3 = __fileno(_File);
      iVar3 = __close(iVar3);
      if (iVar3 < 0) {
        iVar2 = -1;
      }
      else if (_File->_tmpfname != (char *)0x0) {
        FID_conflict__free(_File->_tmpfname);
        _File->_tmpfname = (char *)0x0;
      }
    }
    __acrt_stdio_free_stream(SUB41(_File,0));
  }
  return iVar2;
}



// Library Function - Single Match
//  ___ascii_strnicmp
// 
// Library: Visual Studio

int __cdecl ___ascii_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  
  if (_MaxCount != 0) {
    do {
      bVar2 = *_Str1;
      bVar1 = *_Str2;
      if ((bVar2 == 0) || (bVar1 == 0)) break;
      _Str1 = (char *)((byte *)_Str1 + 1);
      _Str2 = (char *)((byte *)_Str2 + 1);
      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
        bVar2 = bVar2 + 0x20;
      }
      if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
        bVar1 = bVar1 + 0x20;
      }
      bVar3 = bVar2 < bVar1;
      if (bVar2 != bVar1) goto LAB_00679ace;
      _MaxCount = _MaxCount - 1;
    } while (_MaxCount != 0);
    _MaxCount = 0;
    bVar3 = bVar2 < bVar1;
    if (bVar2 != bVar1) {
LAB_00679ace:
      _MaxCount = 0xffffffff;
      if (!bVar3) {
        _MaxCount = 1;
      }
    }
  }
  return _MaxCount;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  void __cdecl __dcrt_lowio_initialize_console_input(void)
//  void __cdecl __dcrt_lowio_initialize_console_output(void)
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void FID_conflict___dcrt_lowio_initialize_console_input(void)

{
  _DAT_10012740 = (*_DAT_1000c070)(0x1000fe88,0x40000000,3,0,3,0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool FUN_00679afd(void)

{
  if (_DAT_10012740 == -2) {
    FID_conflict___dcrt_lowio_initialize_console_input();
  }
  return _DAT_10012740 != -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  ___dcrt_terminate_console_input
//  ___dcrt_terminate_console_output
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void FID_conflict____dcrt_terminate_console_output(void)

{
  if ((_DAT_10012740 != -1) && (_DAT_10012740 != -2)) {
    (*_DAT_1000c060)(_DAT_10012740);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Multiple Matches With Different Base Names
//  ___dcrt_read_console
//  ___dcrt_write_console
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

int FID_conflict____dcrt_read_console(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  
  iVar1 = (*_DAT_1000c074)(_DAT_10012740,param_1,param_2,param_3,0);
  if (iVar1 == 0) {
    iVar2 = (*_DAT_1000c0c0)();
    if (iVar2 == 6) {
      FID_conflict____dcrt_terminate_console_output();
      FID_conflict___dcrt_lowio_initialize_console_input();
      iVar1 = (*_DAT_1000c074)(_DAT_10012740,param_1,param_2,param_3,0);
    }
  }
  return iVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall __crt_seh_guarded_call<int>::operator()<class
// <lambda_218ce3db14220d0be481dae8ef3383b6>,class <lambda_628dfdc04ba53c8bfc02c9951375f3f5>&,class
// <lambda_57dc472bd5c9d5f3b2cbca59b8a843ae>>(class
// <lambda_218ce3db14220d0be481dae8ef3383b6>&&,class
// <lambda_628dfdc04ba53c8bfc02c9951375f3f5>&,class <lambda_57dc472bd5c9d5f3b2cbca59b8a843ae>&&)
// 
// Library: Visual Studio 2017 Release

int __thiscall
__crt_seh_guarded_call<int>::
operator___class__lambda_218ce3db14220d0be481dae8ef3383b6__class__lambda_628dfdc04ba53c8bfc02c9951375f3f5___class__lambda_57dc472bd5c9d5f3b2cbca59b8a843ae___
          (__crt_seh_guarded_call_int_ *this,_lambda_218ce3db14220d0be481dae8ef3383b6_ *param_1,
          _lambda_628dfdc04ba53c8bfc02c9951375f3f5_ *param_2,
          _lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_ *param_3)

{
  uint _FileHandle;
  int iVar1;
  undefined4 *puVar2;
  
  ___acrt_lowio_lock_fh(*(undefined4 *)param_1);
  _FileHandle = **(uint **)param_2;
  if ((*(byte *)(*(int *)(&DAT_10012f98 + ((int)_FileHandle >> 6) * 4) + 0x28 +
                (_FileHandle & 0x3f) * 0x30) & 1) == 0) {
    puVar2 = (undefined4 *)FUN_00675142();
    *puVar2 = 9;
    iVar1 = -1;
  }
  else {
    iVar1 = __close_nolock(_FileHandle);
  }
  FUN_00679bfe();
  return iVar1;
}



void FUN_00679bfe(void)

{
  int unaff_EBP;
  
  ___acrt_lowio_unlock_fh(**(undefined4 **)(unaff_EBP + 0x10));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __close
// 
// Library: Visual Studio 2017 Release

int __cdecl __close(int _FileHandle)

{
  undefined4 *puVar1;
  int iVar2;
  int local_14;
  int *local_10;
  int local_c;
  __crt_seh_guarded_call_int_ local_5;
  
  if (_FileHandle == -2) {
    puVar1 = (undefined4 *)FUN_0067512f();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
  }
  else {
    if (((-1 < _FileHandle) && ((uint)_FileHandle < _DAT_10013198)) &&
       ((*(byte *)(*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 +
                  (_FileHandle & 0x3fU) * 0x30) & 1) != 0)) {
      local_10 = &_FileHandle;
      local_c = _FileHandle;
      local_14 = _FileHandle;
      iVar2 = __crt_seh_guarded_call<int>::
              operator___class__lambda_218ce3db14220d0be481dae8ef3383b6__class__lambda_628dfdc04ba53c8bfc02c9951375f3f5___class__lambda_57dc472bd5c9d5f3b2cbca59b8a843ae___
                        (&local_5,(_lambda_218ce3db14220d0be481dae8ef3383b6_ *)&local_14,
                         (_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ *)&local_10,
                         (_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_ *)&local_c);
      return iVar2;
    }
    puVar1 = (undefined4 *)FUN_0067512f();
    *puVar1 = 0;
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 9;
    FUN_00675085();
  }
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __close_nolock
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int __cdecl __close_nolock(int _FileHandle)

{
  intptr_t iVar1;
  intptr_t iVar2;
  int iVar3;
  
  iVar1 = __get_osfhandle(_FileHandle);
  if (iVar1 != -1) {
    if (((_FileHandle == 1) && ((*(byte *)(_DAT_10012f98 + 0x88) & 1) != 0)) ||
       ((_FileHandle == 2 && ((*(byte *)(_DAT_10012f98 + 0x58) & 1) != 0)))) {
      iVar1 = __get_osfhandle(2);
      iVar2 = __get_osfhandle(1);
      if (iVar2 == iVar1) goto LAB_00679caf;
    }
    iVar1 = __get_osfhandle(_FileHandle);
    iVar3 = (*_DAT_1000c060)(iVar1);
    if (iVar3 == 0) {
      iVar3 = (*_DAT_1000c0c0)();
      goto LAB_00679d01;
    }
  }
LAB_00679caf:
  iVar3 = 0;
LAB_00679d01:
  __free_osfhnd(_FileHandle);
  *(undefined *)
   (*(int *)(&DAT_10012f98 + (_FileHandle >> 6) * 4) + 0x28 + (_FileHandle & 0x3fU) * 0x30) = 0;
  if (iVar3 == 0) {
    iVar3 = 0;
  }
  else {
    ___acrt_errno_map_os_error(iVar3);
    iVar3 = -1;
  }
  return iVar3;
}



// Library Function - Single Match
//  void __cdecl __acrt_stdio_free_stream(class __crt_stdio_stream)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

void __cdecl __acrt_stdio_free_stream(__crt_stdio_stream param_1)

{
  undefined3 in_stack_00000005;
  
  *_param_1 = 0;
  _param_1[1] = 0;
  _param_1[2] = 0;
  _param_1[4] = 0xffffffff;
  _param_1[5] = 0;
  _param_1[6] = 0;
  _param_1[7] = 0;
  _param_1[3] = 0;
  return;
}



// Library Function - Single Match
//  __CIlog10_pentium4
// 
// Library: Visual Studio

void __CIlog10_pentium4(void)

{
  float10 in_ST0;
  
  start((double)in_ST0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  start
// 
// Library: Visual Studio 2015 Release

float10 start(double param_1)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  double dVar7;
  double dVar8;
  undefined in_XMM0 [16];
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  double local_c;
  
  iVar4 = 0;
  while( true ) {
    uVar2 = (uint)(ushort)(SUB162(in_XMM0 >> 0x30,0) >> 4);
    dVar7 = (double)(SUB168(in_XMM0,0) & (ulonglong)_DAT_1000fea0 | (ulonglong)_DAT_1000ff10);
    dVar8 = (double)(SUB168(in_XMM0,0) & uRam1000fea8 | uRam1000ff18);
    uVar1 = SUB82(_DAT_1000fec0 + dVar7,0) & 0x7f0;
    dVar12 = (double)(uRam1000fed8 & (ulonglong)dVar8);
    dVar10 = (double)(_DAT_1000fed0 & (ulonglong)dVar7) * *(double *)(uVar1 + 0x100104e0) -
             _DAT_1000feb0;
    dVar7 = (dVar7 - (double)(_DAT_1000fed0 & (ulonglong)dVar7)) * *(double *)(uVar1 + 0x100104e0);
    dVar9 = (dVar8 - dVar12) * *(double *)(uVar1 + 0x100104e8);
    dVar8 = dVar7 + dVar10;
    dVar12 = dVar9 + (dVar12 * *(double *)(uVar1 + 0x100104e8) - dRam1000feb8);
    uVar3 = uVar2 - 1;
    if (uVar3 < 0x7fe) {
      iVar4 = (uVar2 - 0x3ff) + iVar4;
      dVar11 = (double)iVar4;
      iVar5 = 0;
      if (uVar1 + iVar4 * 0x400 == 0) {
        iVar5 = 0x10;
      }
      return (float10)(((dRam1000ff68 * dVar12 + dRam1000ff78) * dVar12 + dRam1000ff88) *
                       dVar12 * dVar12 +
                       ((_DAT_1000ff60 * dVar8 + _DAT_1000ff70) * dVar8 + _DAT_1000ff80) *
                       dVar8 * dVar8 * dVar8 * dVar8 * dVar8 + _DAT_1000ff90 * dVar8 +
                       *(double *)(uVar1 + 0x100100d8) + dVar11 * dRam1000fee8 +
                       (double)((ulonglong)dVar9 & *(ulonglong *)(iVar5 + 0x1000fef8)) +
                      *(double *)(uVar1 + 0x100100d0) + dVar10 + dVar11 * _DAT_1000fee0 +
                      (double)((ulonglong)dVar7 & *(ulonglong *)(iVar5 + 0x1000fef0)));
    }
    local_c = (double)-(ulonglong)(_DAT_1000ff20 == param_1);
    if (SUB82(local_c,0) != 0) break;
    if (uVar3 != 0xffffffff) {
      if (uVar3 < 0x7ff) {
        if (_DAT_1000ff10 ==
            (double)((ulonglong)param_1 & (ulonglong)_DAT_1000fea0 | (ulonglong)_DAT_1000ff10)) {
          return (float10)_DAT_1000ff48;
        }
        uVar6 = 0x3e9;
        local_c = _DAT_1000fea0;
      }
      else if (((uVar2 & 0x7ff) < 0x7ff) ||
              ((SUB84(param_1,0) | (uint)((ulonglong)param_1 >> 0x20) & 0xfffff) == 0)) {
        local_c = -NAN;
        uVar6 = 9;
      }
      else {
        uVar6 = 0x3e9;
      }
      goto LAB_00679fd7;
    }
    in_XMM0 = CONCAT88(dVar12,param_1 * _DAT_1000ff30);
    iVar4 = -0x34;
  }
  uVar6 = 8;
  local_c = _DAT_1000ff40;
LAB_00679fd7:
  ___libm_error_support(&param_1,&param_1,&local_c,uVar6);
  return (float10)local_c;
}



float10 __fastcall
FUN_0067a5cd(undefined4 param_1_00,undefined4 param_2_00,undefined2 param_1,undefined4 param_2,
            undefined4 param_3,undefined4 param_4,undefined4 param_5,undefined4 param_6)

{
  float10 in_ST0;
  undefined local_24 [8];
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  double local_c;
  
  local_14 = param_5;
  local_10 = param_6;
  local_c = (double)in_ST0;
  local_1c = param_3;
  local_18 = param_4;
  __87except(param_2_00,local_24,&param_1);
  return (float10)local_c;
}



float10 __fastcall
FUN_0067a5e4(undefined4 param_1,undefined4 param_2,undefined2 param_3,undefined4 param_4,
            undefined4 param_5,undefined4 param_6)

{
  float10 in_ST0;
  undefined local_24 [8];
  undefined4 uStack28;
  undefined4 uStack24;
  double dStack12;
  
  dStack12 = (double)in_ST0;
  uStack28 = param_5;
  uStack24 = param_6;
  __87except(param_2,local_24,&param_3);
  return (float10)dStack12;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___libm_error_support
// 
// Library: Visual Studio 2015 Release

void ___libm_error_support(undefined8 *param_1,undefined8 *param_2,undefined8 *param_3,int param_4)

{
  undefined8 uVar1;
  code *pcVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 local_28;
  undefined4 local_24;
  undefined8 local_20;
  undefined8 local_18;
  undefined8 local_10;
  uint local_8;
  
  local_8 = _DAT_10012000 ^ (uint)&stack0xfffffffc;
  if (_DAT_100131dc == 0) {
    pcVar2 = (code *)0x100071d0;
  }
  else {
    pcVar2 = (code *)(*_DAT_1000c0d4)(_DAT_100131ec);
  }
  if (0x1a < param_4) {
    if (param_4 != 0x1b) {
      if (param_4 == 0x1c) {
        local_24 = 0x10010094;
      }
      else if (param_4 == 0x31) {
        local_24 = 0x100100a8;
      }
      else if (param_4 == 0x3a) {
        local_24 = 0x100100a0;
      }
      else {
        if (param_4 != 0x3d) {
          if ((param_4 != 1000) && (param_4 != 0x3e9)) goto LAB_0067a828;
          uVar1 = *param_1;
          goto LAB_0067a775;
        }
        local_24 = 0x10010098;
      }
      goto LAB_0067a694;
    }
    local_28 = 2;
LAB_0067a7e6:
    local_24 = 0x10010094;
    goto LAB_0067a7ed;
  }
  if (param_4 == 0x1a) {
    uVar1 = 0x3ff0000000000000;
LAB_0067a775:
    *param_3 = uVar1;
    goto LAB_0067a828;
  }
  if (param_4 < 0xf) {
    if (param_4 == 0xe) {
      local_28 = 3;
      local_24 = 0x10010090;
    }
    else {
      if (param_4 != 2) {
        if (param_4 == 3) {
          local_24 = 0x10010084;
        }
        else {
          if (param_4 == 8) {
            local_28 = 2;
            local_24 = 0x10010088;
            goto LAB_0067a7ed;
          }
          if (param_4 != 9) goto LAB_0067a828;
          local_24 = 0x10010088;
        }
LAB_0067a694:
        local_28 = 1;
        local_20 = *param_1;
        local_18 = *param_2;
        local_10 = *param_3;
        (*_DAT_1000c174)(&local_28);
        iVar3 = (*pcVar2)();
        if (iVar3 == 0) {
          puVar4 = (undefined4 *)FUN_00675142();
          *puVar4 = 0x21;
        }
        goto LAB_0067a823;
      }
      local_28 = 2;
      local_24 = 0x10010084;
    }
LAB_0067a7ed:
    local_20 = *param_1;
    local_18 = *param_2;
    local_10 = *param_3;
    (*_DAT_1000c174)(&local_28);
    iVar3 = (*pcVar2)();
    if (iVar3 == 0) {
      puVar4 = (undefined4 *)FUN_00675142();
      *puVar4 = 0x22;
    }
  }
  else {
    if (param_4 == 0xf) {
      local_24 = 0x10010090;
    }
    else {
      if (param_4 == 0x18) {
        local_28 = 3;
        goto LAB_0067a7e6;
      }
      if (param_4 != 0x19) goto LAB_0067a828;
      local_24 = 0x10010094;
    }
    local_28 = 4;
    local_20 = *param_1;
    local_18 = *param_2;
    local_10 = *param_3;
    (*_DAT_1000c174)(&local_28);
    (*pcVar2)();
  }
LAB_0067a823:
  *param_3 = local_10;
LAB_0067a828:
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __ceil_default
// 
// Library: Visual Studio 2015 Release

float10 __ceil_default(double param_1)

{
  uint uVar1;
  int iVar2;
  float10 fVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  
  uVar1 = __ctrlfp(0x1b3f,0xffff);
  if ((param_1._6_2_ & 0x7ff0) == 0x7ff0) {
    iVar2 = __sptype();
    if (iVar2 - 1U < 3) {
      __ctrlfp(uVar1,0xffff);
      return (float10)param_1;
    }
    uVar5 = SUB84(_DAT_100100b0 + param_1,0);
    uVar6 = (undefined4)((ulonglong)(_DAT_100100b0 + param_1) >> 0x20);
    uVar4 = 8;
  }
  else {
    fVar3 = (float10)__frnd(SUB84(param_1,0),(int)((ulonglong)param_1 >> 0x20));
    if (((float10)param_1 == fVar3) || ((uVar1 & 0x20) != 0)) {
      __ctrlfp(uVar1,0xffff);
      return (float10)(double)fVar3;
    }
    uVar5 = SUB84((double)fVar3,0);
    uVar6 = (undefined4)((ulonglong)(double)fVar3 >> 0x20);
    uVar4 = 0x10;
  }
  fVar3 = (float10)__except1(uVar4,0xc,param_1,uVar5,uVar6,uVar1);
  return fVar3;
}



// Library Function - Single Match
//  __clrfp
// 
// Library: Visual Studio 2015 Release

int __clrfp(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// Library Function - Single Match
//  __ctrlfp
// 
// Library: Visual Studio 2015 Release

int __ctrlfp(void)

{
  short in_FPUControlWord;
  
  return (int)in_FPUControlWord;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __set_statfp
// 
// Library: Visual Studio 2017 Release

void __set_statfp(void)

{
  return;
}



// Library Function - Single Match
//  __statfp
// 
// Library: Visual Studio 2015 Release

int __statfp(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __d_inttype
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 __d_inttype(double param_1)

{
  uint uVar1;
  float10 fVar2;
  undefined8 extraout_var;
  double dVar3;
  
  uVar1 = __fpclass(param_1);
  if ((uVar1 & 0x90) == 0) {
    fVar2 = (float10)__frnd(param_1,extraout_var);
    if ((float10)param_1 == fVar2) {
      dVar3 = (double)((float10)param_1 * (float10)_DAT_100108f0);
      fVar2 = (float10)__frnd();
      if ((float10)dVar3 == fVar2) {
        return 2;
      }
      return 1;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __powhlp
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

undefined4 __powhlp(int param_1,int param_2_00,int param_2,int param_4,double *param_3)

{
  double dVar1;
  double dVar2;
  int iVar3;
  
  dVar1 = ABS((double)CONCAT44(param_2_00,param_1));
  dVar2 = _DAT_10010a80;
  if (param_4 == 0x7ff00000) {
    if (param_2 == 0) {
      if ((dVar1 <= 1.0) &&
         (dVar2 = 1.0, (ushort)((ushort)(1.0 < dVar1) << 8 | (ushort)(dVar1 == 1.0) << 0xe) == 0)) {
        dVar2 = 0.0;
      }
      goto LAB_0067ab2c;
    }
  }
  else if ((param_4 == -0x100000) && (param_2 == 0)) {
    if (dVar1 <= 1.0) {
      dVar2 = 1.0;
      if ((ushort)((ushort)(1.0 < dVar1) << 8 | (ushort)(dVar1 == 1.0) << 0xe) == 0) {
        dVar2 = _DAT_10010a80;
      }
    }
    else {
      dVar2 = 0.0;
    }
    goto LAB_0067ab2c;
  }
  if (param_2_00 == 0x7ff00000) {
    if (param_1 != 0) {
      return 0;
    }
    dVar1 = (double)CONCAT44(param_4,param_2);
    if (((ushort)((ushort)(dVar1 < 0.0) << 8 | (ushort)(dVar1 == 0.0) << 0xe) != 0) &&
       (dVar2 = 0.0, 0.0 <= dVar1)) {
      dVar2 = 1.0;
    }
  }
  else {
    if (param_2_00 != -0x100000) {
      return 0;
    }
    if (param_1 != 0) {
      return 0;
    }
    iVar3 = __d_inttype(CONCAT44(param_4,param_2));
    dVar1 = (double)CONCAT44(param_4,param_2);
    if ((ushort)((ushort)(dVar1 < 0.0) << 8 | (ushort)(dVar1 == 0.0) << 0xe) == 0) {
      dVar2 = _DAT_10010a80;
      if (iVar3 == 1) {
        dVar2 = -_DAT_10010a80;
      }
    }
    else if (0.0 <= dVar1) {
      dVar2 = 1.0;
    }
    else {
      dVar2 = 0.0;
      if (iVar3 == 1) {
        dVar2 = _DAT_10010a90;
      }
    }
  }
LAB_0067ab2c:
  *param_3 = dVar2;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __87except
// 
// Library: Visual Studio 2015 Release

void __87except(int param_1,int *param_2,ushort *param_3)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  uint local_94;
  undefined local_90 [48];
  undefined8 local_60;
  uint local_50;
  uint local_14;
  
  local_14 = _DAT_10012000 ^ (uint)&stack0xfffffff0;
  local_94 = (uint)*param_3;
  iVar2 = *param_2;
  if (iVar2 == 1) {
LAB_0067ab9a:
    uVar3 = 8;
  }
  else if (iVar2 == 2) {
    uVar3 = 4;
  }
  else if (iVar2 == 3) {
    uVar3 = 0x11;
  }
  else if (iVar2 == 4) {
    uVar3 = 0x12;
  }
  else {
    if (iVar2 == 5) goto LAB_0067ab9a;
    if (iVar2 != 8) goto LAB_0067abfc;
    uVar3 = 0x10;
  }
  iVar2 = __handle_exc(uVar3,param_2 + 6,local_94);
  if (iVar2 == 0) {
    if (((param_1 == 0x10) || (param_1 == 0x16)) || (param_1 == 0x1d)) {
      local_60 = *(undefined8 *)(param_2 + 4);
      local_50 = local_50 & 0xffffffe3 | 3;
    }
    else {
      local_50 = local_50 & 0xfffffffe;
    }
    __raise_exc(local_90,&local_94,uVar3,param_1,param_2 + 2,param_2 + 6);
  }
LAB_0067abfc:
  __ctrlfp(local_94,0xffff);
  if (((*param_2 == 8) || (cVar1 = ___acrt_has_user_matherr(), cVar1 == '\0')) ||
     (iVar2 = ___acrt_invoke_user_matherr(param_2), iVar2 == 0)) {
    __set_errno_from_matherr(*param_2);
  }
  ___security_check_cookie_4();
  return;
}



// Library Function - Single Match
//  __frnd
// 
// Library: Visual Studio 2015 Release

float10 __frnd(double param_1)

{
  return (float10)ROUND(param_1);
}



// Library Function - Single Match
//  __errcode
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __errcode(uint param_1)

{
  int iStack8;
  
  if ((param_1 & 0x20) == 0) {
    if ((param_1 & 8) != 0) {
      return 1;
    }
    if ((param_1 & 4) == 0) {
      if ((param_1 & 1) == 0) {
        return (param_1 & 2) * 2;
      }
      iStack8 = 3;
    }
    else {
      iStack8 = 2;
    }
  }
  else {
    iStack8 = 5;
  }
  return iStack8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __except1
// 
// Library: Visual Studio 2015 Release

void __except1(undefined4 param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,
              undefined4 param_5)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  undefined local_90 [64];
  uint local_50;
  uint local_14;
  
  uVar3 = param_5;
  local_14 = _DAT_10012000 ^ (uint)&stack0xfffffff0;
  iVar2 = __handle_exc(param_1,&param_4,param_5);
  if (iVar2 == 0) {
    local_50 = local_50 & 0xfffffffe;
    __raise_exc_ex(local_90,&param_5,param_1,param_2,&param_3,&param_4,0);
    uVar3 = param_5;
  }
  iVar2 = __errcode(param_1);
  cVar1 = ___acrt_has_user_matherr();
  if ((cVar1 == '\0') || (iVar2 == 0)) {
    __set_errno_from_matherr(iVar2);
    __ctrlfp();
  }
  else {
    __umatherr(iVar2,param_2,param_3,0,param_4,uVar3);
  }
  ___security_check_cookie_4();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __handle_exc
// 
// Library: Visual Studio 2017 Release

bool __handle_exc(uint param_1,double *param_2,uint param_3)

{
  double dVar1;
  double dVar2;
  double dVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  float10 fVar8;
  float10 fVar9;
  uint local_14;
  byte bStack16;
  undefined uStack15;
  ushort uStack14;
  uint local_8;
  
  uVar7 = param_1 & 0x1f;
  if (((param_1 & 8) != 0) && ((param_3 & 1) != 0)) {
    __set_statfp(1);
    uVar7 = param_1 & 0x17;
    goto LAB_0067af1f;
  }
  if ((param_1 & param_3 & 4) != 0) {
    __set_statfp(4);
    uVar7 = param_1 & 0x1b;
    goto LAB_0067af1f;
  }
  if (((param_1 & 1) == 0) || ((param_3 & 8) == 0)) {
    if (((param_1 & 2) != 0) && ((param_3 & 0x10) != 0)) {
      uVar7 = param_1 >> 4 & 1;
      if (*param_2 == 0.0) {
        uVar7 = 1;
      }
      else {
        fVar8 = (float10)__decomp(*param_2,&local_8);
        iVar4 = local_8 - 0x600;
        dVar2 = (double)fVar8;
        local_14 = SUB84(dVar2,0);
        bStack16 = (byte)((ulonglong)dVar2 >> 0x20);
        uStack15 = (undefined)((ulonglong)dVar2 >> 0x28);
        uStack14 = (ushort)((ulonglong)dVar2 >> 0x30);
        fVar9 = (float10)0;
        if (iVar4 < -0x432) {
          fVar9 = fVar9 * fVar8;
          uVar7 = 1;
        }
        else {
          local_8 = (uint)((ushort)((ushort)(fVar9 < fVar8) << 8 | (ushort)(fVar9 == fVar8) << 0xe)
                          == 0);
          uStack14 = uStack14 & 0xf | 0x10;
          if (iVar4 < -0x3fd) {
            iVar4 = -0x3fd - iVar4;
            uVar5 = (uint)((ulonglong)dVar2 >> 0x20) & 0xfffff | 0x100000;
            do {
              if (((local_14 & 1) != 0) && (uVar7 == 0)) {
                uVar7 = 1;
              }
              local_14 = local_14 >> 1;
              if ((bStack16 & 1) != 0) {
                local_14 = local_14 | 0x80000000;
              }
              uVar6 = uVar5 >> 1;
              bStack16 = (byte)uVar6;
              uStack15 = (undefined)(uVar6 >> 8);
              uStack14 = (ushort)(uVar5 >> 0x11);
              iVar4 = iVar4 + -1;
              uVar5 = uVar6;
            } while (iVar4 != 0);
          }
          fVar9 = (float10)(double)CONCAT26(uStack14,CONCAT15(uStack15,CONCAT14(bStack16,local_14)))
          ;
          if (local_8 != 0) {
            fVar9 = -fVar9;
          }
        }
        *param_2 = (double)fVar9;
      }
      if (uVar7 != 0) {
        __set_statfp(0x10);
      }
      uVar7 = param_1 & 0x1d;
    }
    goto LAB_0067af1f;
  }
  __set_statfp(8);
  uVar7 = param_3 & 0xc00;
  dVar2 = _DAT_10010a80;
  dVar3 = _DAT_10010a80;
  if (uVar7 == 0) {
    dVar1 = *param_2;
joined_r0x0067adf6:
    if (dVar1 <= 0.0) {
      dVar2 = -dVar3;
    }
    *param_2 = dVar2;
  }
  else {
    if (uVar7 == 0x400) {
      dVar1 = *param_2;
      dVar2 = _DAT_10010a88;
      goto joined_r0x0067adf6;
    }
    dVar3 = _DAT_10010a88;
    if (uVar7 == 0x800) {
      dVar1 = *param_2;
      goto joined_r0x0067adf6;
    }
    if (uVar7 == 0xc00) {
      dVar1 = *param_2;
      dVar2 = _DAT_10010a88;
      goto joined_r0x0067adf6;
    }
  }
  uVar7 = param_1 & 0x1e;
LAB_0067af1f:
  if (((param_1 & 0x10) != 0) && ((param_3 & 0x20) != 0)) {
    __set_statfp(0x20);
    uVar7 = uVar7 & 0xffffffef;
  }
  return uVar7 == 0;
}



// Library Function - Single Match
//  __raise_exc
// 
// Library: Visual Studio 2015 Release

void __raise_exc(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                undefined4 param_5,undefined4 param_6)

{
  __raise_exc_ex(param_1,param_2,param_3,param_4,param_5,param_6,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __raise_exc_ex
// 
// Library: Visual Studio 2015 Release

void __raise_exc_ex(uint *param_1,uint *param_2,uint param_3,int param_4,undefined8 *param_5,
                   undefined8 *param_6,int param_7)

{
  uint *puVar1;
  undefined8 *puVar2;
  uint uVar3;
  undefined4 uVar4;
  
  puVar1 = param_2;
  param_1[1] = 0;
  uVar4 = 0xc000000d;
  param_1[2] = 0;
  param_1[3] = 0;
  if ((param_3 & 0x10) != 0) {
    uVar4 = 0xc000008f;
    param_1[1] = param_1[1] | 1;
  }
  if ((param_3 & 2) != 0) {
    uVar4 = 0xc0000093;
    param_1[1] = param_1[1] | 2;
  }
  if ((param_3 & 1) != 0) {
    uVar4 = 0xc0000091;
    param_1[1] = param_1[1] | 4;
  }
  if ((param_3 & 4) != 0) {
    uVar4 = 0xc000008e;
    param_1[1] = param_1[1] | 8;
  }
  if ((param_3 & 8) != 0) {
    uVar4 = 0xc0000090;
    param_1[1] = param_1[1] | 0x10;
  }
  param_1[2] = param_1[2] ^ (~(*param_2 << 4) ^ param_1[2]) & 0x10;
  param_1[2] = param_1[2] ^ (~(*param_2 * 2) ^ param_1[2]) & 8;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 1) ^ param_1[2]) & 4;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 3) ^ param_1[2]) & 2;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 5) ^ param_1[2]) & 1;
  uVar3 = __statfp();
  puVar2 = param_6;
  if ((uVar3 & 1) != 0) {
    param_1[3] = param_1[3] | 0x10;
  }
  if ((uVar3 & 4) != 0) {
    param_1[3] = param_1[3] | 8;
  }
  if ((uVar3 & 8) != 0) {
    param_1[3] = param_1[3] | 4;
  }
  if ((uVar3 & 0x10) != 0) {
    param_1[3] = param_1[3] | 2;
  }
  if ((uVar3 & 0x20) != 0) {
    param_1[3] = param_1[3] | 1;
  }
  uVar3 = *puVar1 & 0xc00;
  if (uVar3 == 0) {
    *param_1 = *param_1 & 0xfffffffc;
  }
  else {
    if (uVar3 == 0x400) {
      uVar3 = *param_1 & 0xfffffffd | 1;
    }
    else {
      if (uVar3 != 0x800) {
        if (uVar3 == 0xc00) {
          *param_1 = *param_1 | 3;
        }
        goto LAB_0067b0c7;
      }
      uVar3 = *param_1 & 0xfffffffe | 2;
    }
    *param_1 = uVar3;
  }
LAB_0067b0c7:
  uVar3 = *puVar1 & 0x300;
  if (uVar3 == 0) {
    uVar3 = *param_1 & 0xffffffeb | 8;
LAB_0067b0fd:
    *param_1 = uVar3;
  }
  else {
    if (uVar3 == 0x200) {
      uVar3 = *param_1 & 0xffffffe7 | 4;
      goto LAB_0067b0fd;
    }
    if (uVar3 == 0x300) {
      *param_1 = *param_1 & 0xffffffe3;
    }
  }
  *param_1 = *param_1 ^ (param_4 << 5 ^ *param_1) & 0x1ffe0;
  param_1[8] = param_1[8] | 1;
  if (param_7 == 0) {
    param_1[8] = param_1[8] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 4) = *param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 0x14) = *param_6;
  }
  else {
    param_1[8] = param_1[8] & 0xffffffe1;
    param_1[4] = *(uint *)param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe1;
    param_1[0x14] = *(uint *)param_6;
  }
  __clrfp();
  (*_DAT_1000c0b8)(uVar4,0,1,&param_1);
  if ((*(byte *)(param_1 + 2) & 0x10) != 0) {
    *puVar1 = *puVar1 & 0xfffffffe;
  }
  if ((*(byte *)(param_1 + 2) & 8) != 0) {
    *puVar1 = *puVar1 & 0xfffffffb;
  }
  if ((*(byte *)(param_1 + 2) & 4) != 0) {
    *puVar1 = *puVar1 & 0xfffffff7;
  }
  if ((*(byte *)(param_1 + 2) & 2) != 0) {
    *puVar1 = *puVar1 & 0xffffffef;
  }
  if ((*(byte *)(param_1 + 2) & 1) != 0) {
    *puVar1 = *puVar1 & 0xffffffdf;
  }
  uVar3 = *param_1 & 3;
  if (uVar3 == 0) {
    *puVar1 = *puVar1 & 0xfffff3ff;
  }
  else {
    if (uVar3 == 1) {
      uVar3 = *puVar1 & 0xfffff7ff | 0x400;
    }
    else {
      if (uVar3 != 2) {
        if (uVar3 == 3) {
          *puVar1 = *puVar1 | 0xc00;
        }
        goto LAB_0067b20e;
      }
      uVar3 = *puVar1 & 0xfffffbff | 0x800;
    }
    *puVar1 = uVar3;
  }
LAB_0067b20e:
  uVar3 = *param_1 >> 2 & 7;
  if (uVar3 == 0) {
    uVar3 = *puVar1 & 0xfffff3ff | 0x300;
  }
  else {
    if (uVar3 != 1) {
      if (uVar3 == 2) {
        *puVar1 = *puVar1 & 0xfffff3ff;
      }
      goto LAB_0067b23f;
    }
    uVar3 = *puVar1 & 0xfffff3ff | 0x200;
  }
  *puVar1 = uVar3;
LAB_0067b23f:
  if (param_7 == 0) {
    *puVar2 = *(undefined8 *)(param_1 + 0x14);
  }
  else {
    *(uint *)puVar2 = param_1[0x14];
  }
  return;
}



// Library Function - Single Match
//  __set_errno_from_matherr
// 
// Library: Visual Studio 2015 Release

void __set_errno_from_matherr(int param_1)

{
  undefined4 *puVar1;
  
  if (param_1 == 1) {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 0x21;
  }
  else if (param_1 - 2U < 2) {
    puVar1 = (undefined4 *)FUN_00675142();
    *puVar1 = 0x22;
    return;
  }
  return;
}



// Library Function - Single Match
//  __umatherr
// 
// Library: Visual Studio 2015 Release

float10 __umatherr(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4,
                  undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8_00,
                  undefined4 param_8)

{
  double dVar1;
  int iVar2;
  undefined4 local_24;
  int local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 uStack8;
  
  local_20 = 0;
  iVar2 = 0;
  do {
    if (*(int *)(&DAT_100108f8 + iVar2 * 8) == param_2) {
      local_20 = *(int *)(&DAT_100108fc + iVar2 * 8);
      break;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 < 0x1d);
  if (local_20 == 0) {
    __ctrlfp(param_8,0xffff);
    __set_errno_from_matherr(param_1);
    dVar1 = (double)CONCAT44(param_8_00,param_7);
  }
  else {
    local_1c = param_3;
    local_18 = param_4;
    local_14 = param_5;
    local_10 = param_6;
    local_c = param_7;
    local_24 = param_1;
    uStack8 = param_8_00;
    __ctrlfp(param_8,0xffff);
    iVar2 = ___acrt_invoke_user_matherr(&local_24);
    if (iVar2 == 0) {
      __set_errno_from_matherr(param_1);
    }
    dVar1 = (double)CONCAT44(uStack8,local_c);
  }
  return (float10)dVar1;
}



// Library Function - Single Match
//  __decomp
// 
// Library: Visual Studio 2015 Release

void __decomp(int param_1,uint param_2_00,int *param_2)

{
  uint uVar1;
  double dVar2;
  ushort uVar3;
  int iVar4;
  
  dVar2 = (double)CONCAT17(param_2_00._3_1_,
                           CONCAT16(param_2_00._2_1_,CONCAT24((undefined2)param_2_00,param_1)));
  if (dVar2 == 0.0) {
    iVar4 = 0;
  }
  else {
    uVar3 = (ushort)(param_2_00 >> 0x10);
    if (((param_2_00 & 0x7ff00000) == 0) && (((param_2_00 & 0xfffff) != 0 || (param_1 != 0)))) {
      iVar4 = -0x3fd;
      if ((param_2_00 & 0x100000) == 0) {
        do {
          uVar1 = param_2_00 * 2;
          param_2_00._0_2_ = (undefined2)uVar1;
          param_2_00 = uVar1;
          if (param_1 < 0) {
            param_2_00 = uVar1 | 1;
          }
          param_1 = param_1 * 2;
          iVar4 = iVar4 + -1;
        } while ((uVar1 & 0x100000) == 0);
        uVar3 = (ushort)(uVar1 >> 0x10);
      }
      param_2_00._2_1_ = (undefined)(uVar3 & 0xffef);
      param_2_00._3_1_ = (byte)((uVar3 & 0xffef) >> 8);
      if ((ushort)((ushort)(0.0 < dVar2) << 8 | (ushort)(dVar2 == 0.0) << 0xe) == 0) {
        param_2_00._3_1_ = param_2_00._3_1_ | 0x80;
      }
      __set_exp(CONCAT17(param_2_00._3_1_,
                         CONCAT16(param_2_00._2_1_,CONCAT24((undefined2)param_2_00,param_1))),0);
    }
    else {
      __set_exp(dVar2,0);
      iVar4 = (uVar3 >> 4 & 0x7ff) - 0x3fe;
    }
  }
  *param_2 = iVar4;
  return;
}



// Library Function - Single Match
//  __set_exp
// 
// Library: Visual Studio 2015 Release

float10 __set_exp(ulonglong param_1,short param_2)

{
  double local_c;
  
  local_c = (double)(param_1 & 0xffffffffffff |
                    (ulonglong)(ushort)((param_2 + 0x3fe) * 0x10 | param_1._6_2_ & 0x800f) << 0x30);
  return (float10)local_c;
}



// Library Function - Single Match
//  __sptype
// 
// Library: Visual Studio 2015 Release

undefined4 __sptype(int param_1,uint param_2)

{
  undefined4 uStack8;
  
  if (param_2 == 0x7ff00000) {
    if (param_1 == 0) {
      return 1;
    }
  }
  else if ((param_2 == 0xfff00000) && (param_1 == 0)) {
    return 2;
  }
  if ((param_2._2_2_ & 0x7ff8) == 0x7ff8) {
    uStack8 = 3;
  }
  else {
    if (((param_2._2_2_ & 0x7ff8) != 0x7ff0) || (((param_2 & 0x7ffff) == 0 && (param_1 == 0)))) {
      return 0;
    }
    uStack8 = 4;
  }
  return uStack8;
}



// Library Function - Single Match
//  __fpclass
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __fpclass(double _X)

{
  int iVar1;
  int iStack8;
  
  if ((_X._6_2_ & 0x7ff0) == 0x7ff0) {
    iVar1 = __sptype();
    if (iVar1 == 1) {
      return 0x200;
    }
    if (iVar1 == 2) {
      iStack8 = 4;
    }
    else {
      if (iVar1 != 3) {
        return 1;
      }
      iStack8 = 2;
    }
    return iStack8;
  }
  if ((((ulonglong)_X & 0x7ff0000000000000) == 0) &&
     ((((ulonglong)_X & 0xfffff00000000) != 0 || (_X._0_4_ != 0)))) {
    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff90) + 0x80;
  }
  if (_X == 0.0) {
    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffffe0) + 0x40;
  }
  return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff08) + 0x100;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_0067b52c(void)

{
                    // WARNING: Could not recover jumptable at 0x0067b52c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_1000c090)();
  return;
}



// Library Function - Single Match
//  __FindPESection
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase,DWORD_PTR rva)

{
  int iVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  uint uVar3;
  
  uVar3 = 0;
  iVar1 = *(int *)(pImageBase + 0x3c);
  p_Var2 = (PIMAGE_SECTION_HEADER)
           (pImageBase + *(ushort *)(pImageBase + iVar1 + 0x14) + 0x18 + iVar1);
  if (*(ushort *)(pImageBase + iVar1 + 6) != 0) {
    do {
      if ((p_Var2->VirtualAddress <= rva) && (rva < p_Var2->Misc + p_Var2->VirtualAddress)) {
        return p_Var2;
      }
      uVar3 = uVar3 + 1;
      p_Var2 = p_Var2 + 1;
    } while (uVar3 < *(ushort *)(pImageBase + iVar1 + 6));
  }
  return (PIMAGE_SECTION_HEADER)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __IsNonwritableInCurrentImage
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2019 Release

BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)

{
  uint uVar1;
  BOOL BVar2;
  PIMAGE_SECTION_HEADER p_Var3;
  int **in_FS_OFFSET;
  int *local_14;
  undefined4 uStack16;
  uint local_c;
  undefined4 local_8;
  
  uStack16 = 0x10002520;
  local_14 = *in_FS_OFFSET;
  local_c = _DAT_10012000 ^ 0x10011520;
  *in_FS_OFFSET = (int *)&local_14;
  local_8 = 0;
  BVar2 = __ValidateImageBase(&DAT_10000000);
  if (BVar2 != 0) {
    p_Var3 = __FindPESection(&DAT_10000000,(DWORD_PTR)(pTarget + -0x10000000));
    if (p_Var3 != (PIMAGE_SECTION_HEADER)0x0) {
      uVar1 = p_Var3->Characteristics;
      *in_FS_OFFSET = local_14;
      return ~(uVar1 >> 0x1f) & 1;
    }
  }
  *in_FS_OFFSET = local_14;
  return 0;
}



// Library Function - Single Match
//  __ValidateImageBase
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release

BOOL __cdecl __ValidateImageBase(PBYTE pImageBase)

{
  uint uVar1;
  
  if (*(short *)pImageBase != 0x5a4d) {
    return 0;
  }
  uVar1 = 0;
  if (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550) {
    uVar1 = (uint)(*(short *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b);
  }
  return uVar1;
}



// Library Function - Single Match
//  __alldvrm
// 
// Library: Visual Studio

undefined8 __alldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT44(uVar3,iVar4);
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __SEH_prolog4_GS
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __SEH_prolog4_GS(undefined4 param_1,int param_2)

{
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  param_2 = -param_2;
  *(undefined4 *)((int)auStack28 + param_2 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + param_2 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + param_2 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + param_2 + 4) = _DAT_10012000 ^ (uint)&stack0x00000008;
  *(undefined4 *)((int)auStack28 + param_2) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

void FUN_0067b856(void)

{
  ___security_check_cookie_4();
  return;
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

uint __alloca_probe_16(void)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 0xf;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

uint __alloca_probe_8(void)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 7;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __alloca_probe
// 
// Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

void __alloca_probe(void)

{
  undefined *in_EAX;
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 unaff_retaddr;
  undefined auStack4 [4];
  
  puVar2 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX))
  ;
  for (puVar1 = (undefined4 *)((uint)auStack4 & 0xfffff000); puVar2 < puVar1;
      puVar1 = puVar1 + -0x400) {
  }
  *puVar2 = unaff_retaddr;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _strrchr
// 
// Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

char * __cdecl _strrchr(char *_Str,int _Ch)

{
  uint uVar1;
  undefined (*pauVar2) [16];
  uint uVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  undefined (*pauVar7) [16];
  undefined auVar8 [16];
  undefined auVar10 [16];
  char cVar13;
  char cVar14;
  char cVar15;
  char cVar16;
  char cVar17;
  char cVar18;
  char cVar19;
  undefined auVar12 [16];
  byte bVar9;
  byte bVar11;
  
  if (_DAT_10012b40 != 0) {
    if (_DAT_10012b40 < 2) {
      auVar12 = pshuflw(ZEXT216(CONCAT11((char)_Ch,(char)_Ch)),
                        ZEXT216(CONCAT11((char)_Ch,(char)_Ch)),0);
      uVar1 = -1 << (sbyte)((uint)_Str & 0xf);
      pcVar6 = _Str + -((uint)_Str & 0xf);
      pcVar5 = (char *)0x0;
      while( true ) {
        bVar11 = -(pcVar6[0xf] == '\0');
        auVar10 = CONCAT115(bVar11,CONCAT114(-(pcVar6[0xe] == '\0'),
                                             CONCAT113(-(pcVar6[0xd] == '\0'),
                                                       CONCAT112(-(pcVar6[0xc] == '\0'),
                                                                 CONCAT111(-(pcVar6[0xb] == '\0'),
                                                                           CONCAT110(-(pcVar6[10] ==
                                                                                      '\0'),CONCAT19
                                                  (-(pcVar6[9] == '\0'),
                                                   CONCAT18(-(pcVar6[8] == '\0'),
                                                            CONCAT17(-(pcVar6[7] == '\0'),
                                                                     CONCAT16(-(pcVar6[6] == '\0'),
                                                                              CONCAT15(-(pcVar6[5]
                                                                                        == '\0'),
                                                                                       CONCAT14(-(
                                                  pcVar6[4] == '\0'),
                                                  CONCAT13(-(pcVar6[3] == '\0'),
                                                           CONCAT12(-(pcVar6[2] == '\0'),
                                                                    CONCAT11(-(pcVar6[1] == '\0'),
                                                                             -(*pcVar6 == '\0'))))))
                                                  ))))))))));
        cVar13 = SUB161(auVar12 >> 8,0);
        cVar14 = SUB161(auVar12 >> 0x10,0);
        cVar15 = SUB161(auVar12 >> 0x18,0);
        cVar16 = SUB161(auVar12 >> 0x20,0);
        cVar17 = SUB161(auVar12 >> 0x28,0);
        cVar18 = SUB161(auVar12 >> 0x30,0);
        cVar19 = SUB161(auVar12 >> 0x38,0);
        bVar9 = -(pcVar6[0xf] == cVar19);
        auVar8 = CONCAT115(bVar9,CONCAT114(-(pcVar6[0xe] == cVar18),
                                           CONCAT113(-(pcVar6[0xd] == cVar17),
                                                     CONCAT112(-(pcVar6[0xc] == cVar16),
                                                               CONCAT111(-(pcVar6[0xb] == cVar15),
                                                                         CONCAT110(-(pcVar6[10] ==
                                                                                    cVar14),CONCAT19
                                                  (-(pcVar6[9] == cVar13),
                                                   CONCAT18(-(pcVar6[8] == SUB161(auVar12,0)),
                                                            CONCAT17(-(pcVar6[7] == cVar19),
                                                                     CONCAT16(-(pcVar6[6] == cVar18)
                                                                              ,CONCAT15(-(pcVar6[5]
                                                                                         == cVar17),
                                                                                        CONCAT14(-(
                                                  pcVar6[4] == cVar16),
                                                  CONCAT13(-(pcVar6[3] == cVar15),
                                                           CONCAT12(-(pcVar6[2] == cVar14),
                                                                    CONCAT11(-(pcVar6[1] == cVar13),
                                                                             -(*pcVar6 ==
                                                                              SUB161(auVar12,0))))))
                                                  )))))))))));
        uVar3 = (ushort)((ushort)(SUB161(auVar10 >> 7,0) & 1) |
                         (ushort)(SUB161(auVar10 >> 0xf,0) & 1) << 1 |
                         (ushort)(SUB161(auVar10 >> 0x17,0) & 1) << 2 |
                         (ushort)(SUB161(auVar10 >> 0x1f,0) & 1) << 3 |
                         (ushort)(SUB161(auVar10 >> 0x27,0) & 1) << 4 |
                         (ushort)(SUB161(auVar10 >> 0x2f,0) & 1) << 5 |
                         (ushort)(SUB161(auVar10 >> 0x37,0) & 1) << 6 |
                         (ushort)(SUB161(auVar10 >> 0x3f,0) & 1) << 7 |
                         (ushort)(SUB161(auVar10 >> 0x47,0) & 1) << 8 |
                         (ushort)(SUB161(auVar10 >> 0x4f,0) & 1) << 9 |
                         (ushort)(SUB161(auVar10 >> 0x57,0) & 1) << 10 |
                         (ushort)(SUB161(auVar10 >> 0x5f,0) & 1) << 0xb |
                         (ushort)(SUB161(auVar10 >> 0x67,0) & 1) << 0xc |
                         (ushort)(SUB161(auVar10 >> 0x6f,0) & 1) << 0xd |
                         (ushort)(SUB161(auVar10 >> 0x77,0) & 1) << 0xe |
                        (ushort)(bVar11 >> 7) << 0xf) & uVar1;
        if (uVar3 != 0) break;
        uVar1 = (ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                         (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                         (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                         (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                         (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                         (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                         (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                         (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                         (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                         (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                         (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                         (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                         (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                         (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                         (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe | (ushort)(bVar9 >> 7) << 0xf
                        ) & uVar1;
        iVar4 = 0x1f;
        if (uVar1 != 0) {
          for (; uVar1 >> iVar4 == 0; iVar4 = iVar4 + -1) {
          }
        }
        if (uVar1 != 0) {
          pcVar5 = pcVar6 + iVar4;
        }
        uVar1 = 0xffffffff;
        pcVar6 = pcVar6 + 0x10;
      }
      uVar1 = (uVar3 * 2 & uVar3 * -2) - 1 &
              (ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                       (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                       (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                       (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                       (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                       (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                       (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                       (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                       (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                       (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                       (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                       (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                       (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                       (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                       (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe | (ushort)(bVar9 >> 7) << 0xf)
              & uVar1;
      iVar4 = 0x1f;
      if (uVar1 != 0) {
        for (; uVar1 >> iVar4 == 0; iVar4 = iVar4 + -1) {
        }
      }
      pcVar6 = pcVar6 + iVar4;
      if (uVar1 == 0) {
        pcVar6 = pcVar5;
      }
      return pcVar6;
    }
    uVar1 = _Ch & 0xff;
    if (uVar1 == 0) {
      pcVar5 = (char *)((uint)_Str & 0xfffffff0);
      auVar12 = CONCAT115(-(pcVar5[0xf] == '\0'),
                          CONCAT114(-(pcVar5[0xe] == '\0'),
                                    CONCAT113(-(pcVar5[0xd] == '\0'),
                                              CONCAT112(-(pcVar5[0xc] == '\0'),
                                                        CONCAT111(-(pcVar5[0xb] == '\0'),
                                                                  CONCAT110(-(pcVar5[10] == '\0'),
                                                                            CONCAT19(-(pcVar5[9] ==
                                                                                      '\0'),CONCAT18
                                                  (-(pcVar5[8] == '\0'),
                                                   CONCAT17(-(pcVar5[7] == '\0'),
                                                            CONCAT16(-(pcVar5[6] == '\0'),
                                                                     CONCAT15(-(pcVar5[5] == '\0'),
                                                                              CONCAT14(-(pcVar5[4]
                                                                                        == '\0'),
                                                                                       CONCAT13(-(
                                                  pcVar5[3] == '\0'),
                                                  CONCAT12(-(pcVar5[2] == '\0'),
                                                           CONCAT11(-(pcVar5[1] == '\0'),
                                                                    -(*pcVar5 == '\0')))))))))))))))
                         );
      uVar1 = (uint)(ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |
                             (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |
                             (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |
                             (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |
                             (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |
                             (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |
                             (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |
                             (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |
                             (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |
                             (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |
                             (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |
                             (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |
                             (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |
                             (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |
                             (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |
                            (ushort)((byte)-(pcVar5[0xf] == '\0') >> 7) << 0xf) &
              -1 << ((byte)_Str & 0xf);
      while (uVar1 == 0) {
        pcVar6 = pcVar5 + 0x1f;
        auVar12 = CONCAT115(-(*pcVar6 == '\0'),
                            CONCAT114(-(pcVar5[0x1e] == '\0'),
                                      CONCAT113(-(pcVar5[0x1d] == '\0'),
                                                CONCAT112(-(pcVar5[0x1c] == '\0'),
                                                          CONCAT111(-(pcVar5[0x1b] == '\0'),
                                                                    CONCAT110(-(pcVar5[0x1a] == '\0'
                                                                               ),CONCAT19(-(pcVar5[
                                                  0x19] == '\0'),
                                                  CONCAT18(-(pcVar5[0x18] == '\0'),
                                                           CONCAT17(-(pcVar5[0x17] == '\0'),
                                                                    CONCAT16(-(pcVar5[0x16] == '\0')
                                                                             ,CONCAT15(-(pcVar5[0x15
                                                  ] == '\0'),
                                                  CONCAT14(-(pcVar5[0x14] == '\0'),
                                                           CONCAT13(-(pcVar5[0x13] == '\0'),
                                                                    CONCAT12(-(pcVar5[0x12] == '\0')
                                                                             ,CONCAT11(-(pcVar5[0x11
                                                  ] == '\0'),-(pcVar5[0x10] == '\0'))))))))))))))));
        pcVar5 = pcVar5 + 0x10;
        uVar1 = (uint)(ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |
                               (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |
                               (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |
                               (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |
                               (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |
                               (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |
                               (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |
                               (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |
                               (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |
                               (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |
                               (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |
                               (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |
                               (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |
                               (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |
                               (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |
                              (ushort)((byte)-(*pcVar6 == '\0') >> 7) << 0xf);
      }
      iVar4 = 0;
      if (uVar1 != 0) {
        for (; (uVar1 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
        }
      }
      pauVar2 = (undefined (*) [16])(pcVar5 + iVar4);
    }
    else {
      pauVar2 = (undefined (*) [16])0x0;
      uVar3 = (uint)_Str & 0xf;
      while (uVar3 != 0) {
        if ((byte)*_Str == uVar1) {
          pauVar2 = (undefined (*) [16])_Str;
        }
        if ((byte)*_Str == 0) {
          return (char *)pauVar2;
        }
        _Str = _Str + 1;
        uVar3 = (uint)_Str & 0xf;
      }
      do {
        pauVar7 = (undefined (*) [16])((int)_Str + 0x10);
        iVar4 = pcmpistri(ZEXT416(uVar1),*(undefined (*) [16])_Str,0x40);
        if ((undefined (*) [16])0xffffffef < _Str) {
          pauVar2 = (undefined (*) [16])(pauVar7[-1] + iVar4);
        }
        _Str = (char *)pauVar7;
      } while (pauVar7 != (undefined (*) [16])0x0);
    }
    return (char *)pauVar2;
  }
  iVar4 = -1;
  do {
    pcVar5 = _Str;
    if (iVar4 == 0) break;
    iVar4 = iVar4 + -1;
    pcVar5 = _Str + 1;
    cVar13 = *_Str;
    _Str = pcVar5;
  } while (cVar13 != '\0');
  iVar4 = -(iVar4 + 1);
  pcVar5 = pcVar5 + -1;
  do {
    pcVar6 = pcVar5;
    if (iVar4 == 0) break;
    iVar4 = iVar4 + -1;
    pcVar6 = pcVar5 + -1;
    cVar13 = *pcVar5;
    pcVar5 = pcVar6;
  } while ((char)_Ch != cVar13);
  pcVar6 = pcVar6 + 1;
  if (*pcVar6 != (char)_Ch) {
    pcVar6 = (char *)0x0;
  }
  return pcVar6;
}



void entry(void)

{
                    // WARNING: Could not recover jumptable at 0x006b274e. Too many branches
                    // WARNING: Treating indirect jump as call
  _CorExeMain();
  return;
}


