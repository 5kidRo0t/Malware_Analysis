typedef unsigned char   undefined;

typedef unsigned int    ImageBaseOffset32;
typedef unsigned char    byte;
typedef unsigned int    dword;
typedef unsigned int    uint;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion;

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct {
    dword OffsetToDirectory;
    dword DataIsDirectory;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion {
    dword OffsetToData;
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;
};

typedef struct HWND__ HWND__, *PHWND__;

struct HWND__ {
    int unused;
};

typedef ushort WORD;

typedef uint UINT;

typedef struct HWND__ * HWND;

typedef struct IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

struct IMAGE_DATA_DIRECTORY {
    ImageBaseOffset32 VirtualAddress;
    dword Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
    word Magic;
    byte MajorLinkerVersion;
    byte MinorLinkerVersion;
    dword SizeOfCode;
    dword SizeOfInitializedData;
    dword SizeOfUninitializedData;
    ImageBaseOffset32 AddressOfEntryPoint;
    ImageBaseOffset32 BaseOfCode;
    ImageBaseOffset32 BaseOfData;
    pointer32 ImageBase;
    dword SectionAlignment;
    dword FileAlignment;
    word MajorOperatingSystemVersion;
    word MinorOperatingSystemVersion;
    word MajorImageVersion;
    word MinorImageVersion;
    word MajorSubsystemVersion;
    word MinorSubsystemVersion;
    dword Win32VersionValue;
    dword SizeOfImage;
    dword SizeOfHeaders;
    dword CheckSum;
    word Subsystem;
    word DllCharacteristics;
    dword SizeOfStackReserve;
    dword SizeOfStackCommit;
    dword SizeOfHeapReserve;
    dword SizeOfHeapCommit;
    dword LoaderFlags;
    dword NumberOfRvaAndSizes;
    struct IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct {
    dword NameOffset;
    dword NameIsString;
};

typedef struct IMAGE_BOUND_IMPORT_DESCRIPTOR_0 IMAGE_BOUND_IMPORT_DESCRIPTOR_0, *PIMAGE_BOUND_IMPORT_DESCRIPTOR_0;

struct IMAGE_BOUND_IMPORT_DESCRIPTOR_0 {
    dword TimeDateStamp;
    word OffsetModuleName;
    word NumberOfModuleForwarderRefs;
};

typedef struct IMAGE_DEBUG_DIRECTORY IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

struct IMAGE_DEBUG_DIRECTORY {
    dword Characteristics;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    dword Type;
    dword SizeOfData;
    dword AddressOfRawData;
    dword PointerToRawData;
};

typedef struct IMAGE_FILE_HEADER IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

struct IMAGE_FILE_HEADER {
    word Machine; // 332
    word NumberOfSections;
    dword TimeDateStamp;
    dword PointerToSymbolTable;
    dword NumberOfSymbols;
    word SizeOfOptionalHeader;
    word Characteristics;
};

typedef struct IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

struct IMAGE_NT_HEADERS32 {
    char Signature[4];
    struct IMAGE_FILE_HEADER FileHeader;
    struct IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion;

union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion {
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;
    dword Name;
    word Id;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion NameUnion;
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion DirectoryUnion;
};

typedef struct IMAGE_SECTION_HEADER IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef union Misc Misc, *PMisc;

typedef enum SectionFlags {
    IMAGE_SCN_TYPE_NO_PAD=8,
    IMAGE_SCN_RESERVED_0001=16,
    IMAGE_SCN_CNT_CODE=32,
    IMAGE_SCN_CNT_INITIALIZED_DATA=64,
    IMAGE_SCN_CNT_UNINITIALIZED_DATA=128,
    IMAGE_SCN_LNK_OTHER=256,
    IMAGE_SCN_LNK_INFO=512,
    IMAGE_SCN_RESERVED_0040=1024,
    IMAGE_SCN_LNK_REMOVE=2048,
    IMAGE_SCN_LNK_COMDAT=4096,
    IMAGE_SCN_GPREL=32768,
    IMAGE_SCN_MEM_16BIT=131072,
    IMAGE_SCN_MEM_PURGEABLE=131072,
    IMAGE_SCN_MEM_LOCKED=262144,
    IMAGE_SCN_MEM_PRELOAD=524288,
    IMAGE_SCN_ALIGN_1BYTES=1048576,
    IMAGE_SCN_ALIGN_2BYTES=2097152,
    IMAGE_SCN_ALIGN_4BYTES=3145728,
    IMAGE_SCN_ALIGN_8BYTES=4194304,
    IMAGE_SCN_ALIGN_16BYTES=5242880,
    IMAGE_SCN_ALIGN_32BYTES=6291456,
    IMAGE_SCN_ALIGN_64BYTES=7340032,
    IMAGE_SCN_ALIGN_128BYTES=8388608,
    IMAGE_SCN_ALIGN_256BYTES=9437184,
    IMAGE_SCN_ALIGN_512BYTES=10485760,
    IMAGE_SCN_ALIGN_1024BYTES=11534336,
    IMAGE_SCN_ALIGN_2048BYTES=12582912,
    IMAGE_SCN_ALIGN_4096BYTES=13631488,
    IMAGE_SCN_ALIGN_8192BYTES=14680064,
    IMAGE_SCN_LNK_NRELOC_OVFL=16777216,
    IMAGE_SCN_MEM_DISCARDABLE=33554432,
    IMAGE_SCN_MEM_NOT_CACHED=67108864,
    IMAGE_SCN_MEM_NOT_PAGED=134217728,
    IMAGE_SCN_MEM_SHARED=268435456,
    IMAGE_SCN_MEM_EXECUTE=536870912,
    IMAGE_SCN_MEM_READ=1073741824,
    IMAGE_SCN_MEM_WRITE=2147483648
} SectionFlags;

union Misc {
    dword PhysicalAddress;
    dword VirtualSize;
};

struct IMAGE_SECTION_HEADER {
    char Name[8];
    union Misc Misc;
    ImageBaseOffset32 VirtualAddress;
    dword SizeOfRawData;
    dword PointerToRawData;
    dword PointerToRelocations;
    dword PointerToLinenumbers;
    word NumberOfRelocations;
    word NumberOfLinenumbers;
    enum SectionFlags Characteristics;
};

typedef struct IMAGE_RESOURCE_DATA_ENTRY IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

struct IMAGE_RESOURCE_DATA_ENTRY {
    dword OffsetToData;
    dword Size;
    dword CodePage;
    dword Reserved;
};

typedef struct IMAGE_RESOURCE_DIRECTORY IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

struct IMAGE_RESOURCE_DIRECTORY {
    dword Characteristics;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    word NumberOfNamedEntries;
    word NumberOfIdEntries;
};

typedef struct _SYSTEMTIME _SYSTEMTIME, *P_SYSTEMTIME;

struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
};

typedef struct _SYSTEMTIME * LPSYSTEMTIME;

typedef char CHAR;

typedef CHAR * LPCSTR;

typedef char * va_list;

typedef struct IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

struct IMAGE_DOS_HEADER {
    char e_magic[2]; // Magic number
    word e_cblp; // Bytes of last page
    word e_cp; // Pages in file
    word e_crlc; // Relocations
    word e_cparhdr; // Size of header in paragraphs
    word e_minalloc; // Minimum extra paragraphs needed
    word e_maxalloc; // Maximum extra paragraphs needed
    word e_ss; // Initial (relative) SS value
    word e_sp; // Initial SP value
    word e_csum; // Checksum
    word e_ip; // Initial IP value
    word e_cs; // Initial (relative) CS value
    word e_lfarlc; // File address of relocation table
    word e_ovno; // Overlay number
    word e_res[4][4]; // Reserved words
    word e_oemid; // OEM identifier (for e_oeminfo)
    word e_oeminfo; // OEM information; e_oemid specific
    word e_res2[10][10]; // Reserved words
    dword e_lfanew; // File address of new exe header
    byte e_program[64]; // Actual DOS program
};

typedef uint size_t;




uint FUN_00401280(void)

{
  uint uVar1;
  byte in_VIP;
  byte in_ID;
  
  uVar1 = (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000;
  return ((uint)(((uVar1 ^ 0x200000) & 0x200000) != 0) * 0x200000 ^ uVar1) >> 0x15;
}



void FUN_004012a0(void)

{
  char *in_EAX;
  
  strchr(in_EAX,0x2e);
  return;
}



undefined4 FUN_004012b0(void)

{
  int in_FS_OFFSET;
  
  return *(undefined4 *)(in_FS_OFFSET + 0x18);
}



int FUN_004012c0(void)

{
  uint in_EAX;
  
  return (in_EAX ^ (int)in_EAX >> 0x1f) - ((int)in_EAX >> 0x1f);
}



void __cdecl FUN_004012d0(char *param_1)

{
  char local_404 [1024];
  
  vsprintf(local_404,param_1,&stack0x00000008);
  OutputDebugStringA(local_404);
  return;
}



void FUN_00401310(void)

{
  glClear(0x4100);
  glPointSize(0x40000000);
  glBegin(0);
  glColor3d(0x3ff0000000000000,0,0);
  glVertex3d(0xc012000000000000,0x4010000000000000,0);
  glColor3d(0,0x3ff0000000000000,0);
  glVertex3d(0xc010000000000000,0x4010000000000000,0);
  glColor3d(0,0,0x3ff0000000000000);
  glVertex3d(0xc00c000000000000,0x4010000000000000,0);
  glEnd();
  glPointSize(0x40a00000);
  glBegin(0);
  glColor3d(0x3ff0000000000000,0,0);
  glVertex3d(0xc000000000000000,0x4010000000000000,0);
  glColor3d(0,0x3ff0000000000000,0);
  glVertex3d(0xbff0000000000000,0x4010000000000000,0);
  glColor3d(0,0,0x3ff0000000000000);
  glVertex3d(0,0x4010000000000000,0);
  glEnd();
  glPointSize(0x41200000);
  glEnable(0xb10);
  glBegin(0);
  glColor3d(0x3ff0000000000000,0,0);
  glVertex3d(0x4000000000000000,0x4010000000000000,0);
  glColor3d(0,0x3ff0000000000000,0);
  glVertex3d(0x4008000000000000,0x4010000000000000,0);
  glColor3d(0,0,0x3ff0000000000000);
  glVertex3d(0x4010000000000000,0x4010000000000000,0);
  glEnd();
  glDisable(0xb10);
  glLineWidth(0x3f800000);
  glBegin(1);
  glColor3d(0x3ff0000000000000,0,0);
  glVertex3d(0xc012000000000000,0x4008000000000000,0);
  glVertex3d(0xc008000000000000,0x4008000000000000,0);
  glColor3d(0,0x3ff0000000000000,0);
  glVertex3d(0xc008000000000000,0x400a666666666666,0);
  glVertex3d(0xc010000000000000,0x400b333333333333,0);
  glEnd();
  glLineWidth(0x40400000);
  glBegin(3);
  glColor3d(0x3ff0000000000000,0,0);
  glVertex3d(0xc00599999999999a,0x4008000000000000,0);
  glVertex3d(0xbff0000000000000,0x4008000000000000,0);
  glColor3d(0,0x3ff0000000000000,0);
  glVertex3d(0xbff8000000000000,0x400a666666666666,0);
  glColor3d(0,0,0x3ff0000000000000);
  glVertex3d(0xbff0000000000000,0x400c000000000000,0);
  glEnd();
  glLineWidth(0x40a00000);
  glEnable(0xb20);
  glEnable(0xb24);
  glLineStipple(2,0xe3f8);
  glBegin(2);
  glColor3d(0x3ff0000000000000,0,0);
  glVertex3d(0x3ff0000000000000,0x4008000000000000,0);
  glVertex3d(0x4010000000000000,0x4008000000000000,0);
  glColor3d(0,0x3ff0000000000000,0);
  glVertex3d(0x4008000000000000,0x400599999999999a,0);
  glColor3d(0,0,0x3ff0000000000000);
  glVertex3d(0x4004000000000000,0x400d99999999999a,0);
  glEnd();
  glDisable(0xb20);
  glDisable(0xb24);
  glPolygonMode(0x408,0x1b02);
  glBegin(4);
  glColor3d(0x3ff0000000000000,0,0);
  glVertex3d(0xc010000000000000,0x4000000000000000,0);
  glVertex3d(0xc008000000000000,0x4007333333333333,0);
  glVertex3d(0xc000000000000000,0x4000000000000000,0);
  glEnd();
  glLineWidth(0x40000000);
  glPolygonMode(0x408,0x1b01);
  glBegin(5);
  glColor3d(0,0x3ff0000000000000,0);
  glVertex3d(0x3ff0000000000000,0x4000000000000000,0);
  glVertex3d(0,0x4007333333333333,0);
  glVertex3d(0xbff0000000000000,0x4000000000000000,0);
  glVertex3d(0,0x3ff199999999999a,0);
  glEnd();
  glEnable(0xb24);
  glPolygonMode(0x408,0x1b01);
  glBegin(6);
  glColor3d(0,0,0x3ff0000000000000);
  glVertex3d(0x4010000000000000,0x4000000000000000,0);
  glVertex3d(0x4004cccccccccccd,0x4006666666666666,0);
  glVertex3d(0x4000000000000000,0x4000000000000000,0);
  glVertex3d(0x4008000000000000,0x3ff199999999999a,0);
  glEnd();
  glDisable(0xb24);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void * __cdecl memset(void *_Dst,int _Val,size_t _Size)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x00401c3e. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)memset();
  return pvVar1;
}



// WARNING: Removing unreachable block (ram,0x00401cb2)
// WARNING: Removing unreachable block (ram,0x00401caf)
// WARNING: Removing unreachable block (ram,0x00401da1)
// WARNING: Removing unreachable block (ram,0x00401da3)

undefined4 __fastcall FUN_00401c50(void **param_1)

{
  void *pvVar1;
  void *pvVar2;
  void *pvVar3;
  
  pvVar3 = param_1[1];
  pvVar1 = *param_1;
  pvVar2 = (void *)0x0;
  do {
    *(byte *)((int)pvVar1 + (int)pvVar2) =
         *(byte *)((int)pvVar1 + (int)pvVar2) ^
         *(char *)(DAT_0040d664 + 0x19) + *(char *)(DAT_0040d41c + 2);
    pvVar2 = (void *)((int)pvVar2 + 1);
  } while (pvVar2 <= pvVar3);
  pvVar3 = (void *)FUN_00402d70((uint)pvVar3,(uint *)param_1[3]);
                    // WARNING: Load size is inaccurate
  memmove(*param_1,pvVar3,*param_1[3]);
  return 0;
}



// WARNING: Removing unreachable block (ram,0x00401fb1)
// WARNING: Removing unreachable block (ram,0x00401ef3)
// WARNING: Removing unreachable block (ram,0x00401ef5)
// WARNING: Removing unreachable block (ram,0x00401ee4)
// WARNING: Removing unreachable block (ram,0x00401ee6)
// WARNING: Removing unreachable block (ram,0x00401ebf)
// WARNING: Removing unreachable block (ram,0x00401f10)
// WARNING: Removing unreachable block (ram,0x00401fbb)
// WARNING: Removing unreachable block (ram,0x00401ec4)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: stack

void FUN_00401e60(void)

{
  uint local_8;
  
  FUN_004012d0("%s");
  DAT_0040d594 = 0;
  if (DAT_0040d41c == 0) {
    local_8 = 0;
    do {
      local_8 = local_8 + 1;
    } while (local_8 < 0xfaa7c);
    _DAT_0040d668 = FUN_004012b0();
    if (_DAT_0040d668 != 0) {
      DAT_0040d41c = *(int *)(_DAT_0040d668 + 0x30);
      local_8 = 0;
      do {
        local_8 = local_8 + 1;
      } while ((int)local_8 < 0x1bdbd);
      if (DAT_0040d41c != 0) {
        FUN_00402520();
        return;
      }
      func_0x0040103c();
    }
  }
  return;
}



void FUN_00402010(void)

{
  int iVar1;
  
  iVar1 = 0;
  do {
    (&DAT_0040d6a8)[(byte)(&DAT_0040d448)[iVar1]] = (char)iVar1;
    iVar1 = iVar1 + 1;
  } while (iVar1 < 0x40);
  return;
}



// WARNING: Removing unreachable block (ram,0x00402112)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: stack

undefined4 FUN_00402030(undefined4 *param_1)

{
  int *piVar1;
  byte bVar2;
  char cVar3;
  int iVar4;
  undefined3 extraout_var;
  uint uVar5;
  int iVar6;
  code *pcVar7;
  uint uVar8;
  undefined *puVar9;
  undefined local_b40 [2048];
  undefined4 local_340;
  undefined local_33c [172];
  int iStack656;
  undefined4 local_74;
  undefined local_70 [64];
  undefined4 uStack48;
  int iStack44;
  undefined4 uStack40;
  undefined4 uStack36;
  code *pcStack32;
  undefined auStack28 [4];
  int iStack24;
  int iStack20;
  undefined auStack16 [4];
  int iStack12;
  int iStack8;
  
  memset(local_33c,0,0x2c8);
  local_340 = 0x10007;
  memset(local_70,0,0x40);
  local_74 = 0x44;
  FUN_00402c20(&DAT_0040d1a0);
  DAT_0040d590 = (code *)FUN_00402bf0();
  if (DAT_0040d7b8 == (code *)0x0) {
    FUN_00402c20(&DAT_0040d28c);
    DAT_0040d7b8 = (code *)FUN_00402bf0();
  }
  (*DAT_0040d6a0)(0,local_b40,0x400);
  iVar4 = (*DAT_0040d7b8)(0,local_b40,*(undefined4 *)(*(int *)(DAT_0040d41c + 0x10) + 0x44),0,0,0,4,
                          0,*(undefined4 *)(*(int *)(DAT_0040d41c + 0x10) + 0x28),&local_74,
                          &DAT_0040d7a8,0);
  if (iVar4 != 0) {
    uVar8 = 0;
    iStack20 = *(int *)(DAT_0040d664 + 0x15) * 2;
    (*DAT_0040d590)(0xffffffff,&DAT_0040d818,0,&iStack20,0x1000,4);
    DAT_0040d6a4 = (code *)FUN_00402bf0();
    (*DAT_0040d6a4)(DAT_0040d7ac,&local_340);
    DAT_0040d684 = *(int *)(DAT_0040d664 + 5);
    FUN_00402c20(&DAT_00404000);
    _DAT_0040d220 = (code *)FUN_00402bf0();
    iStack12 = *(int *)(DAT_0040d664 + 5);
    (*_DAT_0040d220)(DAT_0040d7a8,iStack12);
    _DAT_0040d680 = DAT_0040d7a8;
    _DAT_0040d688 = *(undefined4 *)(DAT_0040d664 + 0x1b);
    iVar4 = FUN_00402440();
    while (iVar4 < 0) {
      if (0x6c < uVar8) {
        iVar4 = FUN_00402440();
        if (iVar4 < 0) {
          DAT_0040d684 = 0;
          FUN_00402440();
        }
        break;
      }
      _DAT_0040d688 = *(undefined4 *)(DAT_0040d664 + 0x1b);
      uVar8 = uVar8 + 1;
      iVar4 = FUN_00402440();
    }
    iStack24 = DAT_0040d684;
    bVar2 = *(byte *)(DAT_0040d41c + 2);
    uStack48 = DAT_0040d228;
    if (_DAT_0040d62c == 0) {
      uStack48 = *param_1;
    }
    cVar3 = FUN_00402470();
    DAT_0040d594 = CONCAT31(extraout_var,cVar3);
    if ((DAT_0040d594 != 0) && ((*(uint *)(DAT_0040d41c + 0xa4) < 6 || (DAT_0040d594 < 3)))) {
      DAT_0040d594 = 0;
    }
    DAT_0040d7d8 = (code *)FUN_00402b10('\x01',0);
    (*DAT_0040d7d8)(DAT_0040d7a8,bVar2 + 8 + (int)param_1,&iStack24,4,auStack16);
    uStack40 = *(undefined4 *)(DAT_0040d664 + 0x11);
    uStack36 = *(undefined4 *)(DAT_0040d664 + 0x15);
    iStack44 = DAT_0040d818;
    uVar8 = FUN_00402ca0();
    FUN_00402b10('\x02',uVar8);
    piVar1 = (int *)(DAT_0040d818 + 0x3c);
    iVar4 = *(int *)(DAT_0040d818 + 0x3c) + DAT_0040d818;
    FUN_00402c20(&DAT_0040d420);
    pcStack32 = (code *)FUN_00402bf0();
    (*DAT_0040d7d8)(DAT_0040d7a8,DAT_0040d684,DAT_0040d818,*(undefined4 *)(iVar4 + 0x54),auStack16);
    FUN_00402c20(&DAT_0040d5cc);
    DAT_0040d7d4 = (code *)FUN_00402bf0();
    uVar8 = 0;
    while( true ) {
      iVar6 = *piVar1 + uVar8 * 0x28;
      iStack8 = *(int *)(iVar6 + 0x100 + DAT_0040d818);
      iVar6 = iVar6 + 0xf8 + DAT_0040d818;
      if (iStack8 == 0) break;
      iStack12 = *(int *)(iVar6 + 0xc) + DAT_0040d684;
      (*DAT_0040d7d8)(DAT_0040d7a8,iStack12,*(int *)(iVar6 + 0x14) + DAT_0040d818,
                      *(undefined4 *)(iVar6 + 0x10),auStack16);
      puVar9 = auStack28;
      uVar5 = FUN_00402570(*(uint *)(iVar6 + 0x24));
      (*pcStack32)(DAT_0040d7a8,&iStack12,&iStack8,uVar5,puVar9);
      iVar6 = FUN_00402840((int)"qfntvthb"[uVar8]);
      uVar8 = uVar8 + 1 + iVar6 * DAT_0040d594;
      if ((uVar8 == *(ushort *)(iVar4 + 6)) || (iStack8 == 0)) break;
    }
    iStack656 = *(int *)(iVar4 + 0x28) + DAT_0040d594 + DAT_0040d684;
    FUN_00402c20(&DAT_0040d5fc);
    pcVar7 = (code *)FUN_00402bf0();
    (*DAT_0040d7d0)(DAT_0040d7ac,&local_340);
    (*DAT_0040d7d4)(DAT_0040d7a8,DAT_0040d684,*(undefined4 *)(iVar4 + 0x50));
    (*pcVar7)(DAT_0040d7a8);
  }
  return 0;
}



void FUN_00402440(void)

{
  undefined4 *in_EAX;
  
  (*DAT_0040d590)(*in_EAX,in_EAX + 1,*(undefined *)(DAT_0040d41c + 2),in_EAX + 2,0x3000,0x40);
  return;
}



char FUN_00402470(void)

{
  int iVar1;
  char cVar2;
  undefined4 uStack720;
  int iStack716;
  int iStack712;
  int iStack708;
  int iStack704;
  
  uStack720 = 0x10010;
  iVar1 = (*DAT_0040d6a4)(0xffffffff,&uStack720);
  if (iVar1 == 0) {
    return '\0';
  }
  cVar2 = iStack716 != 0;
  if (iStack712 != 0) {
    cVar2 = cVar2 + '\x01';
  }
  if (iStack708 != 0) {
    cVar2 = cVar2 + '\x01';
  }
  if (iStack704 != 0) {
    cVar2 = cVar2 + '\x01';
  }
  return cVar2;
}



undefined4 entry(void)

{
  FUN_00402610();
  return 0x5de7afeb;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_00402520(void)

{
  FUN_004012d0("%s");
  if ((5 < *(uint *)(DAT_0040d41c + 0xa4)) ||
     (_DAT_0040d62c = 1, *(int *)(DAT_0040d41c + 0xa8) == 2)) {
    _DAT_0040d62c = 0;
  }
  FUN_00402890();
  return 0;
}



uint __fastcall FUN_00402570(uint param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  if ((param_1 & 0x4000000) != 0) {
    uVar1 = 0x200;
  }
  if ((param_1 & 0x20000000) == 0) {
    if ((param_1 & 0x40000000) == 0) {
      if ((int)param_1 < 0) {
        return uVar1 | 8;
      }
      return uVar1 | 1;
    }
    if ((int)param_1 < 0) {
      return uVar1 | 4;
    }
    return uVar1 | 2;
  }
  if ((param_1 & 0x40000000) == 0) {
    if ((int)param_1 < 0) {
      return uVar1 | 0x80;
    }
    return uVar1 | 0x10;
  }
  if ((int)param_1 < 0) {
    return uVar1 | 0x40;
  }
  return uVar1 | 0x20;
}



undefined4 FUN_004025d0(void)

{
  undefined4 local_c;
  undefined4 local_8;
  
  local_c = DAT_0040d228;
  local_8 = 0x6c81;
  FUN_004012d0("%s-TryExcept");
  FUN_00402030(&local_c);
  return 1;
}



// WARNING: Removing unreachable block (ram,0x00402693)
// WARNING: Removing unreachable block (ram,0x004026a9)
// WARNING: Removing unreachable block (ram,0x00402767)
// WARNING: Removing unreachable block (ram,0x004026ca)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00402610(void)

{
  code *pcVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  _SYSTEMTIME local_18;
  
  FUN_004012d0("%s");
  uVar2 = FUN_00401280();
  if (uVar2 != 0) {
    GetLocalTime(&local_18);
    DAT_0040d594 = (uint)local_18.wHour;
  }
  FUN_004012d0("%s-2");
  FUN_00401310();
  FUN_00402840(0x72);
  iVar3 = 0x6f9eb38;
  do {
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  FUN_004012d0("%s-3");
  FUN_00401e60();
  DAT_0040d228 = &DAT_004040f0;
  iVar3 = 0xeafd440;
  do {
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  FUN_004012d0("%s-4");
  iVar3 = FUN_00402840(0x72);
  iVar4 = FUN_00402840(iVar3 + 0x78);
  FUN_00402840(iVar3 + iVar4 + 0x78);
  FUN_00402c20(&DAT_0040d518);
  _DAT_0040d7bc = FUN_00402bf0();
  FUN_004012d0("%s-TryExcept");
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



int FUN_00402840(int param_1)

{
  int iVar1;
  
  DAT_0040d274 = param_1;
  if (param_1 < 0) {
    return 0;
  }
  if (param_1 == 0) {
    return 1;
  }
  NtYieldExecution();
  iVar1 = FUN_00402840(DAT_0040d274 + -1);
  return iVar1 * DAT_0040d274;
}



undefined4 __fastcall FUN_00402880(undefined4 param_1)

{
  return param_1;
}



// WARNING: Removing unreachable block (ram,0x00402efc)
// WARNING: Removing unreachable block (ram,0x00402f0f)
// WARNING: Removing unreachable block (ram,0x00402f16)
// WARNING: Removing unreachable block (ram,0x00402f26)
// WARNING: Removing unreachable block (ram,0x00402f28)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00402890(void)

{
  int iVar1;
  int **unaff_ESI;
  undefined *local_14;
  undefined4 local_10;
  undefined4 uStack12;
  
  uStack12 = 0x40289f;
  FUN_004012d0("%s");
  uStack12 = 0x4028fd;
  FUN_004012d0("%s-2");
  _DAT_0040d68c = unaff_ESI[6];
  _DAT_0040d660 = _DAT_0040d68c + _DAT_0040d68c[0xf] + 4;
  DAT_0040d664 = &DAT_004040c8;
  DAT_0040d690 = (*unaff_ESI)[6];
  iVar1 = **unaff_ESI;
  _DAT_0040d69c = _DAT_0040d68c;
  FUN_004012d0("%s");
  DAT_0040d694 = *(undefined4 *)(iVar1 + 0x18);
  FUN_00402c20(&DAT_0040402c);
  _DAT_0040d698 = (code *)FUN_00402bf0();
  (*_DAT_0040d698)(FUN_004025d0);
  _DAT_0040d4a8 = _DAT_0040d4a8 | 0x2000;
  local_10 = 0x90ac;
  local_14 = &DAT_004040f0;
  FUN_00402c20(&DAT_0040d540);
  DAT_0040d6a0 = FUN_00402bf0();
  FUN_00401c50(&local_14);
  FUN_004012d0("%s");
  return;
}



int FUN_00402940(short *param_1,char *param_2,undefined *param_3)

{
  undefined4 *puVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  undefined4 *puVar6;
  short *psVar7;
  char *_Source;
  char local_11c [4];
  undefined local_118 [252];
  uint local_1c;
  ushort *local_18;
  ushort *local_14;
  int local_10;
  uint local_c;
  int local_8;
  
  local_8 = 0;
  if ((*param_1 == 0x5a4d) &&
     (piVar2 = (int *)(*(int *)(param_1 + 0x1e) + (int)param_1), *piVar2 == 0x4550)) {
    local_1c = piVar2[0x1f];
    uVar4 = piVar2[0x1e];
    if ((uVar4 != 0) && (uVar4 < (uint)piVar2[0x14])) {
      local_18 = (ushort *)(*(int *)(uVar4 + 0xc + (int)param_1) + (int)param_1);
      local_14 = (ushort *)(*(int *)(uVar4 + 0x24 + (int)param_1) + (int)param_1);
      piVar2 = (int *)(*(int *)(uVar4 + 0x20 + (int)param_1) + (int)param_1);
      local_c = 0;
      if (*(int *)(uVar4 + 0x14 + (int)param_1) != 0) {
        while (local_14 != local_18) {
          local_10 = *(int *)(*(int *)(uVar4 + 0x1c + (int)param_1) + (uint)*local_14 * 4 +
                             (int)param_1);
          if (param_2 == (char *)((uint)param_2 & 0xffff)) {
            if ((uint)*local_14 + (uint)*(ushort *)(uVar4 + 0x10 + (int)param_1) ==
                ((uint)param_2 & 0xffff)) {
              return local_10 + (int)param_1;
            }
          }
          else if (((piVar2 != (int *)0x0) && (local_c < *(uint *)(uVar4 + 0x18 + (int)param_1))) &&
                  (iVar3 = _stricmp(param_2,(char *)(*piVar2 + (int)param_1)), iVar5 = local_10,
                  iVar3 == 0)) {
            uVar4 = FUN_004012c0();
            if (local_1c < uVar4) {
              return iVar5 + (int)param_1;
            }
            _Source = (char *)((int)param_1 + iVar5);
            iVar5 = FUN_004012a0();
            if (iVar5 == 0) {
              return local_8;
            }
            memset(local_11c,0,0x100);
            strncpy(local_11c,_Source,iVar5 - (int)_Source);
            puVar1 = (undefined4 *)&stack0xfffffee3;
            do {
              puVar6 = puVar1;
              puVar1 = (undefined4 *)((int)puVar6 + 1);
            } while (*(char *)((int)puVar6 + 1) != '\0');
            *(undefined4 *)((int)puVar6 + 1) = 0x6c6c642e;
            *(undefined *)((int)puVar6 + 5) = 0;
            psVar7 = (short *)(*(code *)param_3)(local_11c);
            if (psVar7 == (short *)0x0) {
              return local_8;
            }
            iVar5 = FUN_00402940(psVar7,(char *)(iVar5 + 1),param_3);
            return iVar5;
          }
          local_c = local_c + 1;
          local_14 = local_14 + 1;
          piVar2 = piVar2 + 1;
          if (*(uint *)(uVar4 + 0x14 + (int)param_1) <= local_c) {
            return local_8;
          }
        }
      }
    }
  }
  return local_8;
}



// WARNING: Removing unreachable block (ram,0x00402b77)
// WARNING: Removing unreachable block (ram,0x00402b79)
// WARNING: Restarted to delay deadcode elimination for space: stack

uint FUN_00402b10(char param_1,uint param_2)

{
  uint uVar1;
  int iVar2;
  byte bVar3;
  uint uVar4;
  int unaff_EDI;
  
  uVar4 = param_2;
  if (param_1 == '\x01') {
    FUN_00402c20(&DAT_004040a4);
    param_2 = FUN_00402bf0();
  }
  if (uVar4 == 0) {
    uVar4 = *(byte *)(DAT_0040d41c + 2) + 0x90ac;
  }
  uVar1 = 0;
  iVar2 = DAT_0040d664;
  do {
    if (param_1 == '\x01') {
      bVar3 = *(char *)(iVar2 + 4) + *(char *)(DAT_0040d41c + 2);
    }
    else {
      bVar3 = *(char *)(DAT_0040d664 + 0x1a) - *(char *)(DAT_0040d41c + 2);
      iVar2 = DAT_0040d664;
    }
    *(byte *)(uVar1 + unaff_EDI) = *(byte *)(uVar1 + unaff_EDI) ^ bVar3;
    uVar1 = uVar1 + 1;
  } while (uVar1 <= uVar4);
  if (param_1 == '\x01') {
    FUN_00402c20(&DAT_0040d1fc);
    DAT_0040d7d0 = FUN_00402bf0();
  }
  return param_2;
}



void FUN_00402bf0(void)

{
  int iVar1;
  char *unaff_ESI;
  
  iVar1 = FUN_00402940(DAT_0040d690,unaff_ESI,(undefined *)0x0);
  if (iVar1 == 0) {
    FUN_00402940(DAT_0040d694,unaff_ESI,(undefined *)0x0);
  }
  return;
}



void FUN_00402c20(byte *param_1)

{
  byte bVar1;
  uint uVar2;
  byte *pbVar3;
  int iVar4;
  byte local_88 [131];
  byte local_5;
  
  local_5 = *param_1;
  bVar1 = param_1[1];
  uVar2 = 0;
  if (bVar1 != 0) {
    pbVar3 = param_1 + 5;
    iVar4 = -(int)pbVar3;
    do {
      if (*pbVar3 == 0) {
        *param_1 = 0;
        break;
      }
      pbVar3[(int)(local_88 + iVar4)] = ((*pbVar3 ^ local_5) - (char)uVar2) - 1;
      uVar2 = uVar2 + 1;
      pbVar3 = pbVar3 + 1;
    } while (uVar2 < bVar1);
  }
  pbVar3 = local_88;
  local_88[bVar1] = 0;
  iVar4 = (int)param_1 - (int)pbVar3;
  do {
    bVar1 = *pbVar3;
    pbVar3[iVar4] = bVar1;
    pbVar3 = pbVar3 + 1;
  } while (bVar1 != 0);
  return;
}



// WARNING: Removing unreachable block (ram,0x00402cfb)
// WARNING: Removing unreachable block (ram,0x00402d04)
// WARNING: Removing unreachable block (ram,0x00402d06)

undefined4 FUN_00402ca0(void)

{
  FUN_00402c20(&DAT_0040d36c);
  DAT_0040d66c = (code *)FUN_00402bf0();
  (*DAT_0040d66c)();
  return 0;
}



int FUN_00402d70(uint param_1,uint *param_2)

{
  char cVar1;
  int iVar2;
  uint uVar3;
  uint extraout_EDX;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int unaff_EDI;
  int local_8;
  
  FUN_00402010();
  if ((extraout_EDX & 3) == 0) {
    uVar6 = (extraout_EDX >> 2) * 3;
    *param_2 = uVar6;
    if (*(char *)(unaff_EDI + -1 + extraout_EDX) == '=') {
      *param_2 = uVar6 - 1;
    }
    if (*(char *)(unaff_EDI + -2 + extraout_EDX) == '=') {
      *param_2 = *param_2 - 1;
    }
    if (unaff_EDI != 0) {
      uVar3 = 0;
      uVar6 = 0;
      if (extraout_EDX != 0) {
        do {
          if (*(char *)(uVar3 + unaff_EDI) == '=') {
            iVar2 = 0;
          }
          else {
            iVar2 = (int)(char)(&DAT_0040d6a8)[*(char *)(uVar3 + unaff_EDI)];
          }
          cVar1 = *(char *)(uVar3 + 1 + unaff_EDI);
          if (cVar1 == '=') {
            iVar5 = 0;
          }
          else {
            iVar5 = (int)(char)(&DAT_0040d6a8)[cVar1];
          }
          cVar1 = *(char *)(uVar3 + 2 + unaff_EDI);
          if (cVar1 == '=') {
            local_8 = 0;
          }
          else {
            local_8 = (int)(char)(&DAT_0040d6a8)[cVar1];
          }
          cVar1 = *(char *)(uVar3 + 3 + unaff_EDI);
          if (cVar1 == '=') {
            iVar4 = 0;
          }
          else {
            iVar4 = (int)(char)(&DAT_0040d6a8)[cVar1];
          }
          uVar3 = uVar3 + 4;
          iVar4 = ((iVar2 * 0x40 + iVar5) * 0x40 + local_8) * 0x40 + iVar4;
          uVar7 = uVar6;
          if (uVar6 < *param_2) {
            *(char *)(uVar6 + unaff_EDI) = (char)((uint)iVar4 >> 0x10);
            uVar7 = uVar6 + 1;
            if (uVar7 < *param_2) {
              *(char *)(uVar7 + unaff_EDI) = (char)((uint)iVar4 >> 8);
              uVar7 = uVar6 + 2;
              if (uVar7 < *param_2) {
                *(char *)(uVar7 + unaff_EDI) = (char)iVar4;
                uVar7 = uVar6 + 3;
              }
            }
          }
          uVar6 = uVar7;
        } while (uVar3 < param_1);
      }
      return unaff_EDI;
    }
  }
  return 0;
}


